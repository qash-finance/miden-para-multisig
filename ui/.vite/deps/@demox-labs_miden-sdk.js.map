{
  "version": 3,
  "sources": ["../../node_modules/.pnpm/@demox-labs+miden-sdk@0.12.5_rollup@4.53.3_tslib@2.8.1_typescript@5.9.3/node_modules/@demox-labs/miden-sdk/js/wasm.js", "../../node_modules/.pnpm/@demox-labs+miden-sdk@0.12.5_rollup@4.53.3_tslib@2.8.1_typescript@5.9.3/node_modules/@demox-labs/miden-sdk/js/constants.js", "../../node_modules/.pnpm/@demox-labs+miden-sdk@0.12.5_rollup@4.53.3_tslib@2.8.1_typescript@5.9.3/node_modules/@demox-labs/miden-sdk/js/index.js"],
  "sourcesContent": ["// This is a documented workaround that should avoid issues with Vite projects\n// https://github.com/wasm-tool/rollup-plugin-rust?tab=readme-ov-file#usage-with-vite\n// Also, this effectively disables SSR.\nasync function loadWasm() {\n  let wasmModule;\n  if (!import.meta.env || (import.meta.env && !import.meta.env.SSR)) {\n    wasmModule = await import(\"../Cargo.toml\");\n  }\n  return wasmModule;\n}\nexport default loadWasm;\n", "export const WorkerAction = Object.freeze({\n  INIT: \"init\",\n  CALL_METHOD: \"callMethod\",\n});\n\nexport const MethodName = Object.freeze({\n  CREATE_CLIENT: \"createClient\",\n  NEW_WALLET: \"newWallet\",\n  NEW_FAUCET: \"newFaucet\",\n  EXECUTE_TRANSACTION: \"executeTransaction\",\n  PROVE_TRANSACTION: \"proveTransaction\",\n  SUBMIT_NEW_TRANSACTION: \"submitNewTransaction\",\n  SUBMIT_NEW_TRANSACTION_MOCK: \"submitNewTransactionMock\",\n  SYNC_STATE: \"syncState\",\n  SYNC_STATE_MOCK: \"syncStateMock\",\n});\n", "import loadWasm from \"./wasm.js\";\nimport { MethodName, WorkerAction } from \"./constants.js\";\nexport * from \"../Cargo.toml\";\n\nconst buildTypedArraysExport = (exportObject) => {\n  return Object.entries(exportObject).reduce(\n    (exports, [exportName, _export]) => {\n      if (exportName.endsWith(\"Array\")) {\n        exports[exportName] = _export;\n      }\n      return exports;\n    },\n    {}\n  );\n};\n\nexport const MidenArrays = {};\n\nlet wasmModule = null;\nlet wasmLoadPromise = null;\nlet webClientStaticsCopied = false;\n\nconst ensureWasm = async () => {\n  if (wasmModule) {\n    return wasmModule;\n  }\n  if (!wasmLoadPromise) {\n    wasmLoadPromise = loadWasm().then((module) => {\n      wasmModule = module;\n      if (module) {\n        Object.assign(MidenArrays, buildTypedArraysExport(module));\n        if (!webClientStaticsCopied && module.WebClient) {\n          copyWebClientStatics(module.WebClient);\n          webClientStaticsCopied = true;\n        }\n      }\n      return module;\n    });\n  }\n  return wasmLoadPromise;\n};\n\nconst getWasmOrThrow = async () => {\n  const module = await ensureWasm();\n  if (!module) {\n    throw new Error(\n      \"Miden WASM bindings are unavailable in this environment (SSR is disabled).\"\n    );\n  }\n  return module;\n};\n/**\n * WebClient is a wrapper around the underlying WASM WebClient object.\n *\n * This wrapper serves several purposes:\n *\n * 1. It creates a dedicated web worker to offload computationally heavy tasks\n *    (such as creating accounts, executing transactions, submitting transactions, etc.)\n *    from the main thread, helping to prevent UI freezes in the browser.\n *\n * 2. It defines methods that mirror the API of the underlying WASM WebClient,\n *    with the intention of executing these functions via the web worker. This allows us\n *    to maintain the same API and parameters while benefiting from asynchronous, worker-based computation.\n *\n * 3. It employs a Proxy to forward any calls not designated for web worker computation\n *    directly to the underlying WASM WebClient instance.\n *\n * Additionally, the wrapper provides a static createClient function. This static method\n * instantiates the WebClient object and ensures that the necessary createClient calls are\n * performed both in the main thread and within the worker thread. This dual initialization\n * correctly passes user parameters (RPC URL and seed) to both the main-thread\n * WASM WebClient and the worker-side instance.\n *\n * Because of this implementation, the only breaking change for end users is in the way the\n * web client is instantiated. Users should now use the WebClient.createClient static call.\n */\nexport class WebClient {\n  /**\n   * Create a WebClient wrapper.\n   *\n   * @param {string | undefined} rpcUrl - RPC endpoint URL used by the client.\n   * @param {Uint8Array | undefined} seed - Optional seed for account initialization.\n   * @param {(pubKey: Uint8Array) => Promise<Uint8Array | null | undefined> | Uint8Array | null | undefined} [getKeyCb]\n   *   - Callback to retrieve the secret key bytes for a given public key. The `pubKey`\n   *   parameter is the serialized public key (from `PublicKey.serialize()`). Return the\n   *   corresponding secret key as a `Uint8Array`, or `null`/`undefined` if not found. The\n   *   return value may be provided synchronously or via a `Promise`.\n   * @param {(pubKey: Uint8Array, secretKey: Uint8Array) => Promise<void> | void} [insertKeyCb]\n   *   - Callback to persist a secret key. `pubKey` is the serialized public key, and\n   *   `secretKey` is the serialized secret key (from `SecretKey.serialize()`). May return\n   *   `void` or a `Promise<void>`.\n   * @param {(pubKey: Uint8Array, signingInputs: Uint8Array) => Promise<Array<number | string>> | Array<number | string>} [signCb]\n   *   - Callback to produce signature elements for the provided inputs. `pubKey` is the\n   *   serialized public key, and `signingInputs` is a `Uint8Array` produced by\n   *   `SigningInputs.serialize()`. Must return an array of numeric values (numbers or numeric\n   *   strings) representing the signature elements, either directly or wrapped in a `Promise`.\n   */\n  constructor(rpcUrl, noteTransportUrl, seed, getKeyCb, insertKeyCb, signCb) {\n    this.rpcUrl = rpcUrl;\n    this.noteTransportUrl = noteTransportUrl;\n    this.seed = seed;\n    this.getKeyCb = getKeyCb;\n    this.insertKeyCb = insertKeyCb;\n    this.signCb = signCb;\n\n    // Check if Web Workers are available.\n    if (\n      typeof Worker !== \"undefined\" &&\n      !this.getKeyCb &&\n      !this.insertKeyCb &&\n      !this.signCb\n    ) {\n      console.log(\"WebClient: Web Workers are available.\");\n      // Create the worker.\n      this.worker = new Worker(\n        new URL(\"./workers/web-client-methods-worker.js\", import.meta.url),\n        { type: \"module\" }\n      );\n\n      // Map to track pending worker requests.\n      this.pendingRequests = new Map();\n\n      // Promises to track when the worker script is loaded and ready.\n      this.loaded = new Promise((resolve) => {\n        this.loadedResolver = resolve;\n      });\n\n      // Create a promise that resolves when the worker signals that it is fully initialized.\n      this.ready = new Promise((resolve) => {\n        this.readyResolver = resolve;\n      });\n\n      // Listen for messages from the worker.\n      this.worker.addEventListener(\"message\", (event) => {\n        const data = event.data;\n\n        // Worker script loaded.\n        if (data.loaded) {\n          this.loadedResolver();\n          return;\n        }\n\n        // Worker ready.\n        if (data.ready) {\n          this.readyResolver();\n          return;\n        }\n\n        // Handle responses for method calls.\n        const { requestId, error, result, methodName } = data;\n        if (requestId && this.pendingRequests.has(requestId)) {\n          const { resolve, reject } = this.pendingRequests.get(requestId);\n          this.pendingRequests.delete(requestId);\n          if (error) {\n            console.error(\n              `WebClient: Error from worker in ${methodName}:`,\n              error\n            );\n            reject(new Error(error));\n          } else {\n            resolve(result);\n          }\n        }\n      });\n\n      // Once the worker script has loaded, initialize the worker.\n      this.loaded.then(() => {\n        this.worker.postMessage({\n          action: WorkerAction.INIT,\n          args: [\n            this.rpcUrl,\n            this.noteTransportUrl,\n            this.seed,\n            this.getKeyCb,\n            this.insertKeyCb,\n            this.signCb,\n          ],\n        });\n      });\n    } else {\n      console.log(\"WebClient: Web Workers are not available.\");\n      // Worker not available; set up fallback values.\n      this.worker = null;\n      this.pendingRequests = null;\n      this.loaded = Promise.resolve();\n      this.ready = Promise.resolve();\n    }\n\n    // Lazy initialize the underlying WASM WebClient when first requested.\n    this.wasmWebClient = null;\n    this.wasmWebClientPromise = null;\n  }\n\n  async getWasmWebClient() {\n    if (this.wasmWebClient) {\n      return this.wasmWebClient;\n    }\n    if (!this.wasmWebClientPromise) {\n      this.wasmWebClientPromise = (async () => {\n        const wasm = await getWasmOrThrow();\n        const client = new wasm.WebClient();\n        this.wasmWebClient = client;\n        return client;\n      })();\n    }\n    return this.wasmWebClientPromise;\n  }\n\n  /**\n   * Factory method to create and initialize a WebClient instance.\n   * This method is async so you can await the asynchronous call to createClient().\n   *\n   * @param {string} rpcUrl - The RPC URL.\n   * @param {string} noteTransportUrl - The note transport URL (optional).\n   * @param {string} seed - The seed for the account.\n   * @returns {Promise<WebClient>} The fully initialized WebClient.\n   */\n  static async createClient(rpcUrl, noteTransportUrl, seed) {\n    // Construct the instance (synchronously).\n    const instance = new WebClient(rpcUrl, noteTransportUrl, seed);\n\n    // Wait for the underlying wasmWebClient to be initialized.\n    const wasmWebClient = await instance.getWasmWebClient();\n    await wasmWebClient.createClient(rpcUrl, noteTransportUrl, seed);\n\n    // Wait for the worker to be ready\n    await instance.ready;\n\n    // Return a proxy that forwards missing properties to wasmWebClient.\n    return new Proxy(instance, {\n      get(target, prop, receiver) {\n        // If the property exists on the wrapper, return it.\n        if (prop in target) {\n          return Reflect.get(target, prop, receiver);\n        }\n        // Otherwise, if the wasmWebClient has it, return that.\n        if (target.wasmWebClient && prop in target.wasmWebClient) {\n          const value = target.wasmWebClient[prop];\n          if (typeof value === \"function\") {\n            return value.bind(target.wasmWebClient);\n          }\n          return value;\n        }\n        return undefined;\n      },\n    });\n  }\n\n  /**\n   * Factory method to create and initialize a WebClient instance with a remote keystore.\n   * This method is async so you can await the asynchronous call to createClientWithExternalKeystore().\n   *\n   * @param {string} rpcUrl - The RPC URL.\n   * @param {string | undefined} noteTransportUrl - The note transport URL (optional).\n   * @param {string | undefined} seed - The seed for the account.\n   * @param {Function | undefined} getKeyCb - The get key callback.\n   * @param {Function | undefined} insertKeyCb - The insert key callback.\n   * @param {Function | undefined} signCb - The sign callback.\n   * @returns {Promise<WebClient>} The fully initialized WebClient.\n   */\n  static async createClientWithExternalKeystore(\n    rpcUrl,\n    noteTransportUrl,\n    seed,\n    getKeyCb,\n    insertKeyCb,\n    signCb\n  ) {\n    // Construct the instance (synchronously).\n    const instance = new WebClient(\n      rpcUrl,\n      noteTransportUrl,\n      seed,\n      getKeyCb,\n      insertKeyCb,\n      signCb\n    );\n    const wasmWebClient = await instance.getWasmWebClient();\n    await wasmWebClient.createClientWithExternalKeystore(\n      rpcUrl,\n      noteTransportUrl,\n      seed,\n      getKeyCb,\n      insertKeyCb,\n      signCb\n    );\n    await instance.ready;\n    // Return a proxy that forwards missing properties to wasmWebClient.\n    return new Proxy(instance, {\n      get(target, prop, receiver) {\n        // If the property exists on the wrapper, return it.\n        if (prop in target) {\n          return Reflect.get(target, prop, receiver);\n        }\n        // Otherwise, if the wasmWebClient has it, return that.\n        if (target.wasmWebClient && prop in target.wasmWebClient) {\n          const value = target.wasmWebClient[prop];\n          if (typeof value === \"function\") {\n            return value.bind(target.wasmWebClient);\n          }\n          return value;\n        }\n        return undefined;\n      },\n    });\n  }\n\n  /**\n   * Call a method via the worker.\n   * @param {string} methodName - Name of the method to call.\n   * @param  {...any} args - Arguments for the method.\n   * @returns {Promise<any>}\n   */\n  async callMethodWithWorker(methodName, ...args) {\n    await this.ready;\n    // Create a unique request ID.\n    const requestId = `${methodName}-${Date.now()}-${Math.random()}`;\n    return new Promise((resolve, reject) => {\n      // Save the resolve and reject callbacks in the pendingRequests map.\n      this.pendingRequests.set(requestId, { resolve, reject });\n      // Send the method call request to the worker.\n      this.worker.postMessage({\n        action: WorkerAction.CALL_METHOD,\n        methodName,\n        args,\n        requestId,\n      });\n    });\n  }\n\n  // ----- Explicitly Wrapped Methods (Worker-Forwarded) -----\n\n  async newWallet(storageMode, mutable, authSchemeId, seed) {\n    try {\n      if (!this.worker) {\n        const wasmWebClient = await this.getWasmWebClient();\n        return await wasmWebClient.newWallet(\n          storageMode,\n          mutable,\n          authSchemeId,\n          seed\n        );\n      }\n      const wasm = await getWasmOrThrow();\n      const serializedStorageMode = storageMode.asStr();\n      const serializedAccountBytes = await this.callMethodWithWorker(\n        MethodName.NEW_WALLET,\n        serializedStorageMode,\n        mutable,\n        authSchemeId,\n        seed\n      );\n      return wasm.Account.deserialize(new Uint8Array(serializedAccountBytes));\n    } catch (error) {\n      console.error(\"INDEX.JS: Error in newWallet:\", error.toString());\n      throw error;\n    }\n  }\n\n  async newFaucet(\n    storageMode,\n    nonFungible,\n    tokenSymbol,\n    decimals,\n    maxSupply,\n    authSchemeId\n  ) {\n    try {\n      if (!this.worker) {\n        const wasmWebClient = await this.getWasmWebClient();\n        return await wasmWebClient.newFaucet(\n          storageMode,\n          nonFungible,\n          tokenSymbol,\n          decimals,\n          maxSupply,\n          authSchemeId\n        );\n      }\n      const wasm = await getWasmOrThrow();\n      const serializedStorageMode = storageMode.asStr();\n      const serializedMaxSupply = maxSupply.toString();\n      const serializedAccountBytes = await this.callMethodWithWorker(\n        MethodName.NEW_FAUCET,\n        serializedStorageMode,\n        nonFungible,\n        tokenSymbol,\n        decimals,\n        serializedMaxSupply,\n        authSchemeId\n      );\n\n      return wasm.Account.deserialize(new Uint8Array(serializedAccountBytes));\n    } catch (error) {\n      console.error(\"INDEX.JS: Error in newFaucet:\", error.toString());\n      throw error;\n    }\n  }\n\n  async submitNewTransaction(accountId, transactionRequest) {\n    try {\n      if (!this.worker) {\n        const wasmWebClient = await this.getWasmWebClient();\n        return await wasmWebClient.submitNewTransaction(\n          accountId,\n          transactionRequest\n        );\n      }\n\n      const wasm = await getWasmOrThrow();\n      const serializedTransactionRequest = transactionRequest.serialize();\n      const result = await this.callMethodWithWorker(\n        MethodName.SUBMIT_NEW_TRANSACTION,\n        accountId.toString(),\n        serializedTransactionRequest\n      );\n\n      const transactionResult = wasm.TransactionResult.deserialize(\n        new Uint8Array(result.serializedTransactionResult)\n      );\n\n      return transactionResult.id();\n    } catch (error) {\n      console.error(\n        \"INDEX.JS: Error in submitNewTransaction:\",\n        error.toString()\n      );\n      throw error;\n    }\n  }\n\n  async executeTransaction(accountId, transactionRequest) {\n    try {\n      if (!this.worker) {\n        const wasmWebClient = await this.getWasmWebClient();\n        return await wasmWebClient.executeTransaction(\n          accountId,\n          transactionRequest\n        );\n      }\n\n      const wasm = await getWasmOrThrow();\n      const serializedTransactionRequest = transactionRequest.serialize();\n      const serializedResultBytes = await this.callMethodWithWorker(\n        MethodName.EXECUTE_TRANSACTION,\n        accountId.toString(),\n        serializedTransactionRequest\n      );\n\n      return wasm.TransactionResult.deserialize(\n        new Uint8Array(serializedResultBytes)\n      );\n    } catch (error) {\n      console.error(\"INDEX.JS: Error in executeTransaction:\", error.toString());\n      throw error;\n    }\n  }\n\n  async submitTransaction(transactionResult, prover) {\n    try {\n      if (!this.worker) {\n        const wasmWebClient = await this.getWasmWebClient();\n        const proven = await wasmWebClient.proveTransaction(\n          transactionResult,\n          prover\n        );\n        const submissionHeight = await wasmWebClient.submitProvenTransaction(\n          proven,\n          transactionResult\n        );\n        return await wasmWebClient.applyTransaction(\n          transactionResult,\n          submissionHeight\n        );\n      }\n\n      const wasm = await getWasmOrThrow();\n      const serializedTransactionResult = transactionResult.serialize();\n      const proverPayload = prover ? prover.serialize() : null;\n\n      const { submissionHeight, serializedTransactionUpdate } =\n        await this.callMethodWithWorker(\n          MethodName.SUBMIT_TRANSACTION,\n          serializedTransactionResult,\n          proverPayload\n        );\n\n      if (this instanceof MockWebClient) {\n        return wasm.TransactionStoreUpdate.deserialize(\n          new Uint8Array(serializedTransactionUpdate)\n        );\n      }\n\n      const wasmWebClient = await this.getWasmWebClient();\n      return await wasmWebClient.applyTransaction(\n        transactionResult,\n        submissionHeight\n      );\n    } catch (error) {\n      console.error(\"INDEX.JS: Error in submitTransaction:\", error.toString());\n      throw error;\n    }\n  }\n\n  async proveTransaction(transactionResult, prover) {\n    try {\n      if (!this.worker) {\n        const wasmWebClient = await this.getWasmWebClient();\n        return await wasmWebClient.proveTransaction(transactionResult, prover);\n      }\n\n      const wasm = await getWasmOrThrow();\n      const serializedTransactionResult = transactionResult.serialize();\n      const proverPayload = prover ? prover.serialize() : null;\n\n      const serializedProvenBytes = await this.callMethodWithWorker(\n        MethodName.PROVE_TRANSACTION,\n        serializedTransactionResult,\n        proverPayload\n      );\n\n      return wasm.ProvenTransaction.deserialize(\n        new Uint8Array(serializedProvenBytes)\n      );\n    } catch (error) {\n      console.error(\"INDEX.JS: Error in proveTransaction:\", error.toString());\n      throw error;\n    }\n  }\n\n  async syncState() {\n    try {\n      if (!this.worker) {\n        const wasmWebClient = await this.getWasmWebClient();\n        return await wasmWebClient.syncState();\n      }\n\n      const wasm = await getWasmOrThrow();\n      const serializedSyncSummaryBytes = await this.callMethodWithWorker(\n        MethodName.SYNC_STATE\n      );\n\n      return wasm.SyncSummary.deserialize(\n        new Uint8Array(serializedSyncSummaryBytes)\n      );\n    } catch (error) {\n      console.error(\"INDEX.JS: Error in syncState:\", error.toString());\n      throw error;\n    }\n  }\n\n  terminate() {\n    if (this.worker) {\n      this.worker.terminate();\n    }\n  }\n}\n\nexport class MockWebClient extends WebClient {\n  constructor(seed) {\n    super(null, seed);\n  }\n\n  /**\n   * Factory method to create a WebClient with a mock chain for testing purposes.\n   *\n   * @param serializedMockChain - Serialized mock chain data (optional). Will use an empty chain if not provided.\n   * @param serializedMockNoteTransportNode - Serialized mock note transport node data (optional). Will use a new instance if not provided.\n   * @param seed - The seed for the account (optional).\n   * @returns A promise that resolves to a MockWebClient.\n   */\n  static async createClient(\n    serializedMockChain,\n    serializedMockNoteTransportNode,\n    seed\n  ) {\n    // Construct the instance (synchronously).\n    const instance = new MockWebClient(seed);\n\n    // Wait for the underlying wasmWebClient to be initialized.\n    const wasmWebClient = await instance.getWasmWebClient();\n    await wasmWebClient.createMockClient(\n      seed,\n      serializedMockChain,\n      serializedMockNoteTransportNode\n    );\n\n    // Wait for the worker to be ready\n    await instance.ready;\n\n    // Return a proxy that forwards missing properties to wasmWebClient.\n    return new Proxy(instance, {\n      get(target, prop, receiver) {\n        // If the property exists on the wrapper, return it.\n        if (prop in target) {\n          return Reflect.get(target, prop, receiver);\n        }\n        // Otherwise, if the wasmWebClient has it, return that.\n        if (target.wasmWebClient && prop in target.wasmWebClient) {\n          const value = target.wasmWebClient[prop];\n          if (typeof value === \"function\") {\n            return value.bind(target.wasmWebClient);\n          }\n          return value;\n        }\n        return undefined;\n      },\n    });\n  }\n\n  async syncState() {\n    try {\n      const wasmWebClient = await this.getWasmWebClient();\n      if (!this.worker) {\n        return await wasmWebClient.syncState();\n      }\n\n      let serializedMockChain = wasmWebClient.serializeMockChain().buffer;\n      let serializedMockNoteTransportNode =\n        wasmWebClient.serializeMockNoteTransportNode().buffer;\n\n      const wasm = await getWasmOrThrow();\n\n      const serializedSyncSummaryBytes = await this.callMethodWithWorker(\n        MethodName.SYNC_STATE_MOCK,\n        serializedMockChain,\n        serializedMockNoteTransportNode\n      );\n\n      return wasm.SyncSummary.deserialize(\n        new Uint8Array(serializedSyncSummaryBytes)\n      );\n    } catch (error) {\n      console.error(\"INDEX.JS: Error in syncState:\", error.toString());\n      throw error;\n    }\n  }\n\n  async submitTransaction(transactionResult, prover) {\n    try {\n      if (!this.worker) {\n        return await super.submitTransaction(transactionResult, prover);\n      }\n\n      const wasmWebClient = await this.getWasmWebClient();\n      const wasm = await getWasmOrThrow();\n      const serializedTransactionResult = transactionResult.serialize();\n      const proverPayload = prover ? prover.serialize() : null;\n      const serializedMockChain = wasmWebClient.serializeMockChain().buffer;\n      const serializedMockNoteTransportNode =\n        wasmWebClient.serializeMockNoteTransportNode().buffer;\n\n      const result = await this.callMethodWithWorker(\n        MethodName.SUBMIT_TRANSACTION_MOCK,\n        serializedTransactionResult,\n        proverPayload,\n        serializedMockChain,\n        serializedMockNoteTransportNode\n      );\n      const newMockChain = new Uint8Array(result.serializedMockChain);\n      const newMockNoteTransportNode = result.serializedMockNoteTransportNode\n        ? new Uint8Array(result.serializedMockNoteTransportNode)\n        : undefined;\n\n      if (!(this instanceof MockWebClient)) {\n        return await wasmWebClient.applyTransaction(\n          transactionResult,\n          result.submissionHeight\n        );\n      }\n\n      this.wasmWebClient = new wasm.WebClient();\n      this.wasmWebClientPromise = Promise.resolve(this.wasmWebClient);\n      await this.wasmWebClient.createMockClient(\n        this.seed,\n        newMockChain,\n        newMockNoteTransportNode\n      );\n\n      return wasm.TransactionStoreUpdate.deserialize(\n        new Uint8Array(result.serializedTransactionUpdate)\n      );\n    } catch (error) {\n      console.error(\"INDEX.JS: Error in submitTransaction:\", error.toString());\n      throw error;\n    }\n  }\n\n  async submitNewTransaction(accountId, transactionRequest) {\n    try {\n      if (!this.worker) {\n        return await super.submitNewTransaction(accountId, transactionRequest);\n      }\n\n      const wasmWebClient = await this.getWasmWebClient();\n      const wasm = await getWasmOrThrow();\n      const serializedTransactionRequest = transactionRequest.serialize();\n      const serializedMockChain = wasmWebClient.serializeMockChain().buffer;\n      const serializedMockNoteTransportNode =\n        wasmWebClient.serializeMockNoteTransportNode().buffer;\n\n      const result = await this.callMethodWithWorker(\n        MethodName.SUBMIT_NEW_TRANSACTION_MOCK,\n        accountId.toString(),\n        serializedTransactionRequest,\n        serializedMockChain,\n        serializedMockNoteTransportNode\n      );\n\n      const newMockChain = new Uint8Array(result.serializedMockChain);\n      const newMockNoteTransportNode = result.serializedMockNoteTransportNode\n        ? new Uint8Array(result.serializedMockNoteTransportNode)\n        : undefined;\n\n      const transactionResult = wasm.TransactionResult.deserialize(\n        new Uint8Array(result.serializedTransactionResult)\n      );\n\n      if (!(this instanceof MockWebClient)) {\n        return transactionResult.id();\n      }\n\n      this.wasmWebClient = new wasm.WebClient();\n      this.wasmWebClientPromise = Promise.resolve(this.wasmWebClient);\n      await this.wasmWebClient.createMockClient(\n        this.seed,\n        newMockChain,\n        newMockNoteTransportNode\n      );\n\n      return transactionResult.id();\n    } catch (error) {\n      console.error(\n        \"INDEX.JS: Error in submitNewTransaction:\",\n        error.toString()\n      );\n      throw error;\n    }\n  }\n}\n\nfunction copyWebClientStatics(WasmWebClient) {\n  if (!WasmWebClient) {\n    return;\n  }\n  Object.getOwnPropertyNames(WasmWebClient).forEach((prop) => {\n    if (\n      typeof WasmWebClient[prop] === \"function\" &&\n      prop !== \"constructor\" &&\n      prop !== \"prototype\"\n    ) {\n      WebClient[prop] = WasmWebClient[prop];\n    }\n  });\n}\n"],
  "mappings": "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",
  "names": ["wasmModule", "wasmWebClient", "submissionHeight"]
}
