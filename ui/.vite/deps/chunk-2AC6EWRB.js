import {
  ConstantsUtil as ConstantsUtil2,
  baseSepoliaUSDC,
  baseUSDC
} from "./chunk-O3ZFJ47R.js";
import {
  ApiController,
  ChainController,
  ConnectionController,
  ConnectorController,
  ConstantsUtil,
  CoreHelperUtil,
  OptionsController,
  OptionsUtil,
  StorageUtil,
  isSafe
} from "./chunk-PVA264XD.js";
import {
  D,
  Y
} from "./chunk-252BUJIX.js";
import {
  fallback,
  http
} from "./chunk-RELLE3JG.js";

// node_modules/.pnpm/@reown+appkit-utils@1.8.11_@react-native-async-storage+async-storage@1.24.0_react-nativ_faf548e845ee58e4afd1861473f5d503/node_modules/@reown/appkit-utils/dist/esm/src/ConstantsUtil.js
var ConstantsUtil3 = {
  /* Connector names */
  METMASK_CONNECTOR_NAME: "MetaMask",
  TRUST_CONNECTOR_NAME: "Trust Wallet",
  SOLFLARE_CONNECTOR_NAME: "Solflare",
  PHANTOM_CONNECTOR_NAME: "Phantom",
  COIN98_CONNECTOR_NAME: "Coin98",
  MAGIC_EDEN_CONNECTOR_NAME: "Magic Eden",
  BACKPACK_CONNECTOR_NAME: "Backpack",
  BITGET_CONNECTOR_NAME: "Bitget Wallet",
  FRONTIER_CONNECTOR_NAME: "Frontier",
  XVERSE_CONNECTOR_NAME: "Xverse Wallet",
  LEATHER_CONNECTOR_NAME: "Leather",
  OKX_CONNECTOR_NAME: "OKX Wallet",
  EIP155: ConstantsUtil.CHAIN.EVM,
  ADD_CHAIN_METHOD: "wallet_addEthereumChain",
  EIP6963_ANNOUNCE_EVENT: "eip6963:announceProvider",
  EIP6963_REQUEST_EVENT: "eip6963:requestProvider",
  CONNECTOR_RDNS_MAP: {
    coinbaseWallet: "com.coinbase.wallet",
    coinbaseWalletSDK: "com.coinbase.wallet"
  },
  CONNECTOR_TYPE_EXTERNAL: "EXTERNAL",
  CONNECTOR_TYPE_WALLET_CONNECT: "WALLET_CONNECT",
  CONNECTOR_TYPE_INJECTED: "INJECTED",
  CONNECTOR_TYPE_ANNOUNCED: "ANNOUNCED",
  CONNECTOR_TYPE_AUTH: "AUTH",
  CONNECTOR_TYPE_MULTI_CHAIN: "MULTI_CHAIN",
  CONNECTOR_TYPE_W3M_AUTH: "AUTH",
  getSDKVersionWarningMessage(currentVersion, latestVersion) {
    return `
     @@@@@@@           @@@@@@@@@@@@@@@@@@      
   @@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@   
  @@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@  
 @@@@@@@@@@@@@@@  @@@@@@@@@@@@@@@@@@@@@@@@@@@  
 @@@@@@@@@@@@@@@  @@@@@@@@@@@@@@   @@@@@@@@@@@ 
 @@@@@@@@@@@@@@@  @@@@@@@@@@@@@   @@@@@@@@@@@@ 
 @@@@@@@@@@@@@@@  @@@@@@@@@@@@@  @@@@@@@@@@@@@
 @@@@@@@@@@@@@@@  @@@@@@@@@@@@   @@@@@@@@@@@@@    
 @@@@@@   @@@@@@  @@@@@@@@@@@   @@@@@@@@@@@@@@    
 @@@@@@   @@@@@@  @@@@@@@@@@@  @@@@@@@@@@@@@@@ 
 @@@@@@@@@@@@@@@  @@@@@@@@@@   @@@@@@@@@@@@@@@ 
 @@@@@@@@@@@@@@@  @@@@@@@@@@@@@@@@@@@@@@@@@@@  
  @@@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@@@@@@@  
   @@@@@@@@@@@      @@@@@@@@@@@@@@@@@@@@@@@@   
      @@@@@            @@@@@@@@@@@@@@@@@@  
      
AppKit SDK version ${currentVersion} is outdated. Latest version is ${latestVersion}. Please update to the latest version for bug fixes and new features.
            
Changelog: https://github.com/reown-com/appkit/releases
NPM Registry: https://www.npmjs.com/package/@reown/appkit`;
  }
};

// node_modules/.pnpm/@reown+appkit-utils@1.8.11_@react-native-async-storage+async-storage@1.24.0_react-nativ_faf548e845ee58e4afd1861473f5d503/node_modules/@reown/appkit-utils/dist/esm/src/HelpersUtil.js
var HelpersUtil = {
  getCaipTokens(tokens) {
    if (!tokens) {
      return void 0;
    }
    const caipTokens = {};
    Object.entries(tokens).forEach(([id, token]) => {
      caipTokens[`${ConstantsUtil3.EIP155}:${id}`] = token;
    });
    return caipTokens;
  },
  isLowerCaseMatch(str1, str2) {
    return str1?.toLowerCase() === str2?.toLowerCase();
  },
  /**
   * Iterates the Auth connector supported chains and returns the namespace that is last connected to the active chain.
   * @returns ChainNamespace | undefined
   */
  getActiveNamespaceConnectedToAuth() {
    const activeChain = ChainController.state.activeChain;
    return ConstantsUtil.AUTH_CONNECTOR_SUPPORTED_CHAINS.find((chain) => ConnectorController.getConnectorId(chain) === ConstantsUtil.CONNECTOR_ID.AUTH && chain === activeChain);
  },
  /**
   * Runs a condition function again and again until it returns true or the max number of tries is reached.
   *
   * @param conditionFn - A function (can be async) that returns true when the condition is met.
   * @param intervalMs - Time to wait between tries, in milliseconds.
   * @param maxRetries - Maximum number of times to try before stopping.
   * @returns A Promise that resolves to true if the condition becomes true in time, or false if it doesn't.
   */
  withRetry({ conditionFn, intervalMs, maxRetries }) {
    let attempts = 0;
    return new Promise((resolve) => {
      async function tryCheck() {
        attempts += 1;
        const result = await conditionFn();
        if (result) {
          return resolve(true);
        }
        if (attempts >= maxRetries) {
          return resolve(false);
        }
        setTimeout(tryCheck, intervalMs);
        return null;
      }
      tryCheck();
    });
  },
  /**
   * Returns the chain namespace from user's chainId which is returned from Auth provider.
   * @param chainId - The chainId to parse.
   * @returns The chain namespace.
   */
  userChainIdToChainNamespace(chainId) {
    if (typeof chainId === "number") {
      return ConstantsUtil.CHAIN.EVM;
    }
    const [namespace] = chainId.split(":");
    return namespace;
  },
  /**
   * Get all auth namespaces except the active one
   * @param activeNamespace - The active namespace
   * @returns All auth namespaces except the active one
   */
  getOtherAuthNamespaces(activeNamespace) {
    if (!activeNamespace) {
      return [];
    }
    const authNamespaces = ConstantsUtil.AUTH_CONNECTOR_SUPPORTED_CHAINS;
    const otherAuthNamespaces = authNamespaces.filter((ns) => ns !== activeNamespace);
    return otherAuthNamespaces;
  },
  /**
   * Gets the storage info for a connector
   * @param connectorId - The ID of the connector
   * @param namespace - The namespace of the connector
   * @returns
   */
  getConnectorStorageInfo(connectorId, namespace) {
    const storageConnectionsByNamespace = StorageUtil.getConnections();
    const storageConnections = storageConnectionsByNamespace[namespace] ?? [];
    return {
      hasDisconnected: StorageUtil.isConnectorDisconnected(connectorId, namespace),
      hasConnected: storageConnections.some((c) => HelpersUtil.isLowerCaseMatch(c.connectorId, connectorId))
    };
  }
};

// node_modules/.pnpm/@reown+appkit-utils@1.8.11_@react-native-async-storage+async-storage@1.24.0_react-nativ_faf548e845ee58e4afd1861473f5d503/node_modules/@reown/appkit-utils/dist/esm/src/ErrorUtil.js
var abortController = new AbortController();
var ErrorUtil = {
  EmbeddedWalletAbortController: abortController,
  /**
   * Universal Provider errors. Make sure the `message` is matching with the errors thrown by the Universal Provider.
   * We use the `alertErrorKey` to map the error to the correct AppKit alert error.
   */
  UniversalProviderErrors: {
    UNAUTHORIZED_DOMAIN_NOT_ALLOWED: {
      message: "Unauthorized: origin not allowed",
      alertErrorKey: "ORIGIN_NOT_ALLOWED"
    },
    JWT_VALIDATION_ERROR: {
      message: "JWT validation error: JWT Token is not yet valid",
      alertErrorKey: "JWT_TOKEN_NOT_VALID"
    },
    INVALID_KEY: {
      message: "Unauthorized: invalid key",
      alertErrorKey: "INVALID_PROJECT_ID"
    }
  },
  ALERT_ERRORS: {
    SWITCH_NETWORK_NOT_FOUND: {
      code: "APKT001",
      displayMessage: "Network Not Found",
      debugMessage: "The specified network is not recognized. Please ensure it is included in the `networks` array of your `createAppKit` configuration."
    },
    ORIGIN_NOT_ALLOWED: {
      code: "APKT002",
      displayMessage: "Invalid App Configuration",
      debugMessage: () => `The origin ${isSafe() ? window.origin : "unknown"} is not in your allow list. Please update your allowed domains at https://dashboard.reown.com. [PID: ${OptionsController.state.projectId}]`
    },
    IFRAME_LOAD_FAILED: {
      code: "APKT003",
      displayMessage: "Network Error: Wallet Load Failed",
      debugMessage: () => "Failed to load the embedded wallet. This may be due to network issues or server downtime. Please check your network connection and try again shortly. Contact support if the issue persists."
    },
    IFRAME_REQUEST_TIMEOUT: {
      code: "APKT004",
      displayMessage: "Wallet Request Timeout",
      debugMessage: () => "The request to the embedded wallet timed out. Please check your network connection and try again shortly. Contact support if the issue persists."
    },
    UNVERIFIED_DOMAIN: {
      code: "APKT005",
      displayMessage: "Unverified Domain",
      debugMessage: () => "Embedded wallet load failed. Ensure your domain is verified in https://dashboard.reown.com."
    },
    JWT_TOKEN_NOT_VALID: {
      code: "APKT006",
      displayMessage: "Session Expired",
      debugMessage: "Your session is invalid or expired. Please check your systemâ€™s date and time settings, then reconnect."
    },
    INVALID_PROJECT_ID: {
      code: "APKT007",
      displayMessage: "Invalid Project ID",
      debugMessage: "The specified project ID is invalid. Please visit https://dashboard.reown.com to obtain a valid project ID."
    },
    PROJECT_ID_NOT_CONFIGURED: {
      code: "APKT008",
      displayMessage: "Project ID Missing",
      debugMessage: "No project ID is configured. You can create and configure a project ID at https://dashboard.reown.com."
    },
    SERVER_ERROR_APP_CONFIGURATION: {
      code: "APKT009",
      displayMessage: "Server Error",
      debugMessage: (errorMessage) => `Unable to fetch App Configuration. ${errorMessage}. Please check your network connection and try again shortly. Contact support if the issue persists.`
    },
    RATE_LIMITED_APP_CONFIGURATION: {
      code: "APKT010",
      displayMessage: "Rate Limited",
      debugMessage: "You have been rate limited while retrieving App Configuration. Please wait a few minutes and try again. Contact support if the issue persists."
    }
  },
  ALERT_WARNINGS: {
    LOCAL_CONFIGURATION_IGNORED: {
      debugMessage: (warningMessage) => `[Reown Config Notice] ${warningMessage}`
    },
    INACTIVE_NAMESPACE_NOT_CONNECTED: {
      code: "APKTW001",
      displayMessage: "Inactive Namespace Not Connected",
      debugMessage: (namespace, errorMessage) => `An error occurred while connecting an inactive namespace ${namespace}: "${errorMessage}"`
    },
    INVALID_EMAIL: {
      code: "APKTW002",
      displayMessage: "Invalid Email Address",
      debugMessage: "Please enter a valid email address"
    }
  }
};

// node_modules/.pnpm/@reown+appkit-utils@1.8.11_@react-native-async-storage+async-storage@1.24.0_react-nativ_faf548e845ee58e4afd1861473f5d503/node_modules/@reown/appkit-utils/dist/esm/src/TokenUtil.js
var TokenUtil = {
  TOKEN_ADDRESSES_BY_SYMBOL: {
    USDC: {
      8453: baseUSDC.asset,
      84532: baseSepoliaUSDC.asset
    }
  },
  getTokenSymbolByAddress(tokenAddress) {
    if (!tokenAddress) {
      return void 0;
    }
    const [symbol] = Object.entries(TokenUtil.TOKEN_ADDRESSES_BY_SYMBOL).find(([_, addressesByChain]) => Object.values(addressesByChain).includes(tokenAddress)) ?? [];
    return symbol;
  }
};

// node_modules/.pnpm/@reown+appkit-utils@1.8.11_@react-native-async-storage+async-storage@1.24.0_react-nativ_faf548e845ee58e4afd1861473f5d503/node_modules/@reown/appkit-utils/dist/esm/src/LoggerUtil.js
var LoggerUtil = {
  createLogger(onError, level = "error") {
    const loggerOptions = D({
      level
    });
    const { logger } = Y({
      opts: loggerOptions
    });
    logger.error = (...args) => {
      for (const arg of args) {
        if (arg instanceof Error) {
          onError(arg, ...args);
          return;
        }
      }
      onError(void 0, ...args);
    };
    return logger;
  }
};

// node_modules/.pnpm/@reown+appkit-utils@1.8.11_@react-native-async-storage+async-storage@1.24.0_react-nativ_faf548e845ee58e4afd1861473f5d503/node_modules/@reown/appkit-utils/dist/esm/src/PresetsUtil.js
var PresetsUtil = {
  ConnectorExplorerIds: {
    [ConstantsUtil.CONNECTOR_ID.COINBASE]: "fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa",
    [ConstantsUtil.CONNECTOR_ID.COINBASE_SDK]: "fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa",
    [ConstantsUtil.CONNECTOR_ID.SAFE]: "225affb176778569276e484e1b92637ad061b01e13a048b35a9d280c3b58970f",
    [ConstantsUtil.CONNECTOR_ID.LEDGER]: "19177a98252e07ddfc9af2083ba8e07ef627cb6103467ffebb3f8f4205fd7927",
    [ConstantsUtil.CONNECTOR_ID.OKX]: "971e689d0a5be527bac79629b4ee9b925e82208e5168b733496a09c0faed0709",
    /* Connector names */
    [ConstantsUtil3.METMASK_CONNECTOR_NAME]: "c57ca95b47569778a828d19178114f4db188b89b763c899ba0be274e97267d96",
    [ConstantsUtil3.TRUST_CONNECTOR_NAME]: "4622a2b2d6af1c9844944291e5e7351a6aa24cd7b23099efac1b2fd875da31a0",
    [ConstantsUtil3.SOLFLARE_CONNECTOR_NAME]: "1ca0bdd4747578705b1939af023d120677c64fe6ca76add81fda36e350605e79",
    [ConstantsUtil3.PHANTOM_CONNECTOR_NAME]: "a797aa35c0fadbfc1a53e7f675162ed5226968b44a19ee3d24385c64d1d3c393",
    [ConstantsUtil3.COIN98_CONNECTOR_NAME]: "2a3c89040ac3b723a1972a33a125b1db11e258a6975d3a61252cd64e6ea5ea01",
    [ConstantsUtil3.MAGIC_EDEN_CONNECTOR_NAME]: "8b830a2b724a9c3fbab63af6f55ed29c9dfa8a55e732dc88c80a196a2ba136c6",
    [ConstantsUtil3.BACKPACK_CONNECTOR_NAME]: "2bd8c14e035c2d48f184aaa168559e86b0e3433228d3c4075900a221785019b0",
    [ConstantsUtil3.BITGET_CONNECTOR_NAME]: "38f5d18bd8522c244bdd70cb4a68e0e718865155811c043f052fb9f1c51de662",
    [ConstantsUtil3.FRONTIER_CONNECTOR_NAME]: "85db431492aa2e8672e93f4ea7acf10c88b97b867b0d373107af63dc4880f041",
    [ConstantsUtil3.XVERSE_CONNECTOR_NAME]: "2a87d74ae02e10bdd1f51f7ce6c4e1cc53cd5f2c0b6b5ad0d7b3007d2b13de7b",
    [ConstantsUtil3.LEATHER_CONNECTOR_NAME]: "483afe1df1df63daf313109971ff3ef8356ddf1cc4e45877d205eee0b7893a13",
    [ConstantsUtil3.OKX_CONNECTOR_NAME]: "971e689d0a5be527bac79629b4ee9b925e82208e5168b733496a09c0faed0709"
  },
  NetworkImageIds: {
    // Ethereum
    1: "ba0ba0cd-17c6-4806-ad93-f9d174f17900",
    // Arbitrum
    42161: "3bff954d-5cb0-47a0-9a23-d20192e74600",
    // Avalanche
    43114: "30c46e53-e989-45fb-4549-be3bd4eb3b00",
    // Binance Smart Chain
    56: "93564157-2e8e-4ce7-81df-b264dbee9b00",
    // Fantom
    250: "06b26297-fe0c-4733-5d6b-ffa5498aac00",
    // Optimism
    10: "ab9c186a-c52f-464b-2906-ca59d760a400",
    // Polygon
    137: "41d04d42-da3b-4453-8506-668cc0727900",
    // Mantle
    5e3: "e86fae9b-b770-4eea-e520-150e12c81100",
    // Hedera Mainnet
    295: "6a97d510-cac8-4e58-c7ce-e8681b044c00",
    // Sepolia
    11155111: "e909ea0a-f92a-4512-c8fc-748044ea6800",
    // Base Sepolia
    84532: "a18a7ecd-e307-4360-4746-283182228e00",
    // Unichain Sepolia
    1301: "4eeea7ef-0014-4649-5d1d-07271a80f600",
    // Unichain Mainnet
    130: "2257980a-3463-48c6-cbac-a42d2a956e00",
    // Monad Testnet
    10143: "0a728e83-bacb-46db-7844-948f05434900",
    // Gnosis
    100: "02b53f6a-e3d4-479e-1cb4-21178987d100",
    // EVMos
    9001: "f926ff41-260d-4028-635e-91913fc28e00",
    // ZkSync
    324: "b310f07f-4ef7-49f3-7073-2a0a39685800",
    // Filecoin
    314: "5a73b3dd-af74-424e-cae0-0de859ee9400",
    // Iotx
    4689: "34e68754-e536-40da-c153-6ef2e7188a00",
    // Metis,
    1088: "3897a66d-40b9-4833-162f-a2c90531c900",
    // Moonbeam
    1284: "161038da-44ae-4ec7-1208-0ea569454b00",
    // Moonriver
    1285: "f1d73bb6-5450-4e18-38f7-fb6484264a00",
    // Zora
    7777777: "845c60df-d429-4991-e687-91ae45791600",
    // Celo
    42220: "ab781bbc-ccc6-418d-d32d-789b15da1f00",
    // Base
    8453: "7289c336-3981-4081-c5f4-efc26ac64a00",
    // Aurora
    1313161554: "3ff73439-a619-4894-9262-4470c773a100",
    // Ronin Mainnet
    2020: "b8101fc0-9c19-4b6f-ec65-f6dfff106e00",
    // Saigon Testnet (a.k.a. Ronin)
    2021: "b8101fc0-9c19-4b6f-ec65-f6dfff106e00",
    // Berachain Mainnet
    80094: "e329c2c9-59b0-4a02-83e4-212ff3779900",
    // Abstract Mainnet
    2741: "fc2427d1-5af9-4a9c-8da5-6f94627cd900",
    // Solana networks
    "5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp": "a1b58899-f671-4276-6a5e-56ca5bd59700",
    "4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z": "a1b58899-f671-4276-6a5e-56ca5bd59700",
    EtWTRABZaYq6iMfeYKouRu166VU2xqa1: "a1b58899-f671-4276-6a5e-56ca5bd59700",
    // Bitcoin
    "000000000019d6689c085ae165831e93": "0b4838db-0161-4ffe-022d-532bf03dba00",
    // Bitcoin Testnet
    "000000000933ea01ad0ee984209779ba": "39354064-d79b-420b-065d-f980c4b78200",
    // Bitcoin Signet
    "00000008819873e925422c1ff0f99f7c": "b3406e4a-bbfc-44fb-e3a6-89673c78b700"
  },
  ConnectorImageIds: {
    [ConstantsUtil.CONNECTOR_ID.COINBASE]: "0c2840c3-5b04-4c44-9661-fbd4b49e1800",
    [ConstantsUtil.CONNECTOR_ID.COINBASE_SDK]: "0c2840c3-5b04-4c44-9661-fbd4b49e1800",
    [ConstantsUtil.CONNECTOR_ID.SAFE]: "461db637-8616-43ce-035a-d89b8a1d5800",
    [ConstantsUtil.CONNECTOR_ID.LEDGER]: "54a1aa77-d202-4f8d-0fb2-5d2bb6db0300",
    [ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT]: "ef1a1fcf-7fe8-4d69-bd6d-fda1345b4400",
    [ConstantsUtil.CONNECTOR_ID.INJECTED]: "07ba87ed-43aa-4adf-4540-9e6a2b9cae00"
  },
  ConnectorNamesMap: {
    [ConstantsUtil.CONNECTOR_ID.INJECTED]: "Browser Wallet",
    [ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT]: "WalletConnect",
    [ConstantsUtil.CONNECTOR_ID.COINBASE]: "Coinbase",
    [ConstantsUtil.CONNECTOR_ID.COINBASE_SDK]: "Coinbase",
    [ConstantsUtil.CONNECTOR_ID.LEDGER]: "Ledger",
    [ConstantsUtil.CONNECTOR_ID.SAFE]: "Safe"
  },
  ConnectorTypesMap: {
    [ConstantsUtil.CONNECTOR_ID.INJECTED]: "INJECTED",
    [ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT]: "WALLET_CONNECT",
    [ConstantsUtil.CONNECTOR_ID.EIP6963]: "ANNOUNCED",
    [ConstantsUtil.CONNECTOR_ID.AUTH]: "AUTH",
    [ConstantsUtil3.CONNECTOR_TYPE_AUTH]: "AUTH"
  },
  WalletConnectRpcChainIds: [
    // Ethereum
    1,
    // Ethereum Goerli
    5,
    // Ethereum Sepolia
    11155111,
    // Optimism
    10,
    // Optimism Goerli
    420,
    // Arbitrum
    42161,
    // Arbitrum Goerli
    421613,
    // Polygon
    137,
    // Polygon Mumbai
    80001,
    // Celo Mainnet
    42220,
    // Aurora
    1313161554,
    // Aurora Testnet
    1313161555,
    // Binance Smart Chain
    56,
    // Binance Smart Chain Testnet
    97,
    // Avalanche C-Chain
    43114,
    // Avalanche Fuji Testnet
    43113,
    // Gnosis Chain
    100,
    // Base
    8453,
    // Base Goerli
    84531,
    // Zora
    7777777,
    // Zora Goerli
    999,
    // ZkSync Era Mainnet
    324,
    // ZkSync Era Testnet
    280
  ]
};

// node_modules/.pnpm/@reown+appkit-utils@1.8.11_@react-native-async-storage+async-storage@1.24.0_react-nativ_faf548e845ee58e4afd1861473f5d503/node_modules/@reown/appkit-utils/dist/esm/src/CaipNetworkUtil.js
var RPC_URL_HOST = "rpc.walletconnect.org";
function getBlockchainApiRpcUrl(caipNetworkId, projectId) {
  const url = new URL("https://rpc.walletconnect.org/v1/");
  url.searchParams.set("chainId", caipNetworkId);
  url.searchParams.set("projectId", projectId);
  return url.toString();
}
var WC_HTTP_RPC_SUPPORTED_CHAINS = [
  "near:mainnet",
  "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp",
  "eip155:1101",
  "eip155:56",
  "eip155:42161",
  "eip155:7777777",
  "eip155:59144",
  "eip155:324",
  "solana:EtWTRABZaYq6iMfeYKouRu166VU2xqa1",
  "eip155:5000",
  "solana:4sgjmw1sunhzsxgspuhpqldx6wiyjntz",
  "eip155:80084",
  "eip155:5003",
  "eip155:100",
  "eip155:8453",
  "eip155:42220",
  "eip155:1313161555",
  "eip155:17000",
  "eip155:1",
  "eip155:300",
  "eip155:1313161554",
  "eip155:1329",
  "eip155:84532",
  "eip155:421614",
  "eip155:11155111",
  "eip155:8217",
  "eip155:43114",
  "solana:4uhcVJyU9pJkvQyS88uRDiswHXSCkY3z",
  "eip155:999999999",
  "eip155:11155420",
  "eip155:80002",
  "eip155:97",
  "eip155:43113",
  "eip155:137",
  "eip155:10",
  "eip155:1301",
  "eip155:80094",
  "eip155:80069",
  "eip155:560048",
  "eip155:31",
  "eip155:2818",
  "eip155:57054",
  "eip155:911867",
  "eip155:534351",
  "eip155:1112",
  "eip155:534352",
  "eip155:1111",
  "eip155:146",
  "eip155:130",
  "eip155:1284",
  "eip155:30",
  "eip155:2810",
  "bip122:000000000019d6689c085ae165831e93",
  "bip122:000000000933ea01ad0ee984209779ba"
];
var CaipNetworksUtil = {
  /**
   * Extends the RPC URL with the project ID if the RPC URL is a Reown URL
   * @param rpcUrl - The RPC URL to extend
   * @param projectId - The project ID to extend the RPC URL with
   * @returns The extended RPC URL
   */
  extendRpcUrlWithProjectId(rpcUrl, projectId) {
    let isReownUrl = false;
    try {
      const url = new URL(rpcUrl);
      isReownUrl = url.host === RPC_URL_HOST;
    } catch (e) {
      isReownUrl = false;
    }
    if (isReownUrl) {
      const url = new URL(rpcUrl);
      if (!url.searchParams.has("projectId")) {
        url.searchParams.set("projectId", projectId);
      }
      return url.toString();
    }
    return rpcUrl;
  },
  isCaipNetwork(network) {
    return "chainNamespace" in network && "caipNetworkId" in network;
  },
  getChainNamespace(network) {
    if (this.isCaipNetwork(network)) {
      return network.chainNamespace;
    }
    return ConstantsUtil.CHAIN.EVM;
  },
  getCaipNetworkId(network) {
    if (this.isCaipNetwork(network)) {
      return network.caipNetworkId;
    }
    return `${ConstantsUtil.CHAIN.EVM}:${network.id}`;
  },
  // eslint-disable-next-line max-params
  getDefaultRpcUrl(caipNetwork, caipNetworkId, projectId) {
    const defaultRpcUrl = caipNetwork.rpcUrls?.default?.http?.[0];
    if (WC_HTTP_RPC_SUPPORTED_CHAINS.includes(caipNetworkId)) {
      return getBlockchainApiRpcUrl(caipNetworkId, projectId);
    }
    return defaultRpcUrl || "";
  },
  /**
   * Extends the CaipNetwork object with the image ID and image URL if the image ID is not provided
   * @param params - The parameters object
   * @param params.caipNetwork - The CaipNetwork object to extend
   * @param params.networkImageIds - The network image IDs
   * @param params.customNetworkImageUrls - The custom network image URLs
   * @param params.projectId - The project ID
   * @param params.customRpc - Boolean to indicate if the custom RPC URL should be used
   * @param params.customRpcUrls - The map of chain and custom RPC URLs to be used by the AppKit
   * @returns The extended array of CaipNetwork objects
   */
  extendCaipNetwork(caipNetwork, { customNetworkImageUrls, projectId, customRpcUrls }) {
    const chainNamespace = this.getChainNamespace(caipNetwork);
    const caipNetworkId = this.getCaipNetworkId(caipNetwork);
    const networkDefaultRpcUrl = caipNetwork.rpcUrls?.default?.http?.[0];
    const reownRpcUrl = this.getDefaultRpcUrl(caipNetwork, caipNetworkId, projectId);
    const chainDefaultRpcUrl = caipNetwork?.rpcUrls?.["chainDefault"]?.http?.[0] || networkDefaultRpcUrl;
    const customRpcUrlsOfNetwork = customRpcUrls?.[caipNetworkId]?.map((i) => i.url) || [];
    const rpcUrls = [...customRpcUrlsOfNetwork, ...reownRpcUrl ? [reownRpcUrl] : []];
    const rpcUrlsWithoutReown = [...customRpcUrlsOfNetwork];
    if (chainDefaultRpcUrl && !rpcUrlsWithoutReown.includes(chainDefaultRpcUrl)) {
      rpcUrlsWithoutReown.push(chainDefaultRpcUrl);
    }
    return {
      ...caipNetwork,
      chainNamespace,
      caipNetworkId,
      assets: {
        imageId: PresetsUtil.NetworkImageIds[caipNetwork.id],
        imageUrl: customNetworkImageUrls?.[caipNetwork.id]
      },
      rpcUrls: {
        ...caipNetwork.rpcUrls,
        default: {
          http: rpcUrls
        },
        // Save the networks original RPC URL default
        chainDefault: {
          http: rpcUrlsWithoutReown
        }
      }
    };
  },
  /**
   * Extends the array of CaipNetwork objects with the image ID and image URL if the image ID is not provided
   * @param caipNetworks - The array of CaipNetwork objects to extend
   * @param params - The parameters object
   * @param params.networkImageIds - The network image IDs
   * @param params.customNetworkImageUrls - The custom network image URLs
   * @param params.customRpcUrls - The map of chain and custom RPC URLs to be used by the AppKit
   * @param params.projectId - The project ID
   * @returns The extended array of CaipNetwork objects
   */
  extendCaipNetworks(caipNetworks, { customNetworkImageUrls, projectId, customRpcUrls }) {
    return caipNetworks.map((caipNetwork) => CaipNetworksUtil.extendCaipNetwork(caipNetwork, {
      customNetworkImageUrls,
      customRpcUrls,
      projectId
    }));
  },
  getViemTransport(caipNetwork, projectId, customRpcUrls) {
    const transports = [];
    customRpcUrls?.forEach((rpcUrl) => {
      transports.push(http(rpcUrl.url, rpcUrl.config));
    });
    if (WC_HTTP_RPC_SUPPORTED_CHAINS.includes(caipNetwork.caipNetworkId)) {
      transports.push(http(getBlockchainApiRpcUrl(caipNetwork.caipNetworkId, projectId), {
        /*
         * The Blockchain API uses "Content-Type: text/plain" to avoid OPTIONS preflight requests
         * It will only work for viem >= 2.17.7
         */
        fetchOptions: {
          headers: {
            "Content-Type": "text/plain"
          }
        }
      }));
    }
    caipNetwork?.rpcUrls?.default?.http?.forEach((rpcUrl) => {
      transports.push(http(rpcUrl));
    });
    return fallback(transports);
  },
  extendWagmiTransports(caipNetwork, projectId, transport) {
    if (WC_HTTP_RPC_SUPPORTED_CHAINS.includes(caipNetwork.caipNetworkId)) {
      const reownRpcUrl = this.getDefaultRpcUrl(caipNetwork, caipNetwork.caipNetworkId, projectId);
      return fallback([transport, http(reownRpcUrl)]);
    }
    return transport;
  },
  /**
   * Generates the unsupported network object with the given CaipNetwork ID
   * @param caipNetworkId - The CAIP network ID
   * @returns The unsupported CAIP network object
   */
  getUnsupportedNetwork(caipNetworkId) {
    return {
      id: caipNetworkId.split(":")[1],
      caipNetworkId,
      name: ConstantsUtil.UNSUPPORTED_NETWORK_NAME,
      chainNamespace: caipNetworkId.split(":")[0],
      nativeCurrency: {
        name: "",
        decimals: 0,
        symbol: ""
      },
      rpcUrls: {
        default: {
          http: []
        }
      }
    };
  },
  /**
   * Gets the CaipNetwork object from the storage if `@appkit/active_caip_network_id` is being set
   * @returns CaipNetwork or undefined
   */
  getCaipNetworkFromStorage(defaultCaipNetwork) {
    const caipNetworkIdFromStorage = StorageUtil.getActiveCaipNetworkId();
    const caipNetworks = ChainController.getAllRequestedCaipNetworks();
    const availableNamespaces = Array.from(ChainController.state.chains?.keys() || []);
    const namespace = caipNetworkIdFromStorage?.split(":")[0];
    const isNamespaceAvailable = namespace ? availableNamespaces.includes(namespace) : false;
    const caipNetwork = caipNetworks?.find((cn) => cn.caipNetworkId === caipNetworkIdFromStorage);
    const isUnsupportedNetwork = isNamespaceAvailable && !caipNetwork && caipNetworkIdFromStorage;
    if (isUnsupportedNetwork) {
      return this.getUnsupportedNetwork(caipNetworkIdFromStorage);
    }
    if (caipNetwork) {
      return caipNetwork;
    }
    if (defaultCaipNetwork) {
      return defaultCaipNetwork;
    }
    return caipNetworks?.[0];
  }
};

// node_modules/.pnpm/@reown+appkit-utils@1.8.11_@react-native-async-storage+async-storage@1.24.0_react-nativ_faf548e845ee58e4afd1861473f5d503/node_modules/@reown/appkit-utils/dist/esm/src/TypeUtil.js
var SocialProviderEnum;
(function(SocialProviderEnum2) {
  SocialProviderEnum2["Google"] = "google";
  SocialProviderEnum2["Github"] = "github";
  SocialProviderEnum2["Apple"] = "apple";
  SocialProviderEnum2["Facebook"] = "facebook";
  SocialProviderEnum2["X"] = "x";
  SocialProviderEnum2["Discord"] = "discord";
  SocialProviderEnum2["Farcaster"] = "farcaster";
})(SocialProviderEnum || (SocialProviderEnum = {}));

// node_modules/.pnpm/@reown+appkit-scaffold-ui@1.8.11_@react-native-async-storage+async-storage@1.24.0_react_e7f04814cd5c091a390bfd5cbe14c0e9/node_modules/@reown/appkit-scaffold-ui/dist/esm/src/utils/ConnectorUtil.js
var ConnectorUtil = {
  getConnectorsByType(connectors, recommended, featured) {
    const { customWallets } = OptionsController.state;
    const recent = StorageUtil.getRecentWallets();
    const filteredRecommended = WalletUtil.filterOutDuplicateWallets(recommended);
    const filteredFeatured = WalletUtil.filterOutDuplicateWallets(featured);
    const multiChain = connectors.filter((connector) => connector.type === "MULTI_CHAIN");
    const announced = connectors.filter((connector) => connector.type === "ANNOUNCED");
    const injected = connectors.filter((connector) => connector.type === "INJECTED");
    const external = connectors.filter((connector) => connector.type === "EXTERNAL");
    return {
      custom: customWallets,
      recent,
      external,
      multiChain,
      announced,
      injected,
      recommended: filteredRecommended,
      featured: filteredFeatured
    };
  },
  showConnector(connector) {
    const rdns = connector.info?.rdns;
    const isRDNSExcluded = Boolean(rdns) && ApiController.state.excludedWallets.some((wallet) => Boolean(wallet.rdns) && wallet.rdns === rdns);
    const isNameExcluded = Boolean(connector.name) && ApiController.state.excludedWallets.some((wallet) => HelpersUtil.isLowerCaseMatch(wallet.name, connector.name));
    if (connector.type === "INJECTED") {
      const isBrowserWallet = connector.name === "Browser Wallet";
      if (isBrowserWallet) {
        if (!CoreHelperUtil.isMobile()) {
          return false;
        }
        if (CoreHelperUtil.isMobile() && !rdns && !ConnectionController.checkInstalled()) {
          return false;
        }
      }
      if (isRDNSExcluded || isNameExcluded) {
        return false;
      }
    }
    if ((connector.type === "ANNOUNCED" || connector.type === "EXTERNAL") && (isRDNSExcluded || isNameExcluded)) {
      return false;
    }
    return true;
  },
  getIsConnectedWithWC() {
    const chains = Array.from(ChainController.state.chains.values());
    const isConnectedWithWC = chains.some((chain) => {
      const connectorId = ConnectorController.getConnectorId(chain.namespace);
      return connectorId === ConstantsUtil.CONNECTOR_ID.WALLET_CONNECT;
    });
    return isConnectedWithWC;
  },
  getConnectorTypeOrder({ recommended, featured, custom, recent, announced, injected, multiChain, external, overriddenConnectors = OptionsController.state.features?.connectorTypeOrder ?? [] }) {
    const allConnectors = [
      { type: "walletConnect", isEnabled: true },
      { type: "recent", isEnabled: recent.length > 0 },
      { type: "injected", isEnabled: [...injected, ...announced, ...multiChain].length > 0 },
      { type: "featured", isEnabled: featured.length > 0 },
      { type: "custom", isEnabled: custom && custom.length > 0 },
      { type: "external", isEnabled: external.length > 0 },
      { type: "recommended", isEnabled: recommended.length > 0 }
    ];
    const enabledConnectors = allConnectors.filter((option) => option.isEnabled);
    const enabledConnectorTypes = new Set(enabledConnectors.map((option) => option.type));
    const prioritizedConnectors = overriddenConnectors.filter((type) => enabledConnectorTypes.has(type)).map((type) => ({ type, isEnabled: true }));
    const remainingConnectors = enabledConnectors.filter(({ type: enabledConnectorType }) => {
      const hasPrioritizedConnector = prioritizedConnectors.some(({ type: prioritizedConnectorType }) => prioritizedConnectorType === enabledConnectorType);
      return !hasPrioritizedConnector;
    });
    return Array.from(new Set([...prioritizedConnectors, ...remainingConnectors].map(({ type }) => type)));
  },
  sortConnectorsByExplorerWallet(connectors) {
    return [...connectors].sort((a, b) => {
      if (a.explorerWallet && b.explorerWallet) {
        return (a.explorerWallet.order ?? 0) - (b.explorerWallet.order ?? 0);
      }
      if (a.explorerWallet) {
        return -1;
      }
      if (b.explorerWallet) {
        return 1;
      }
      return 0;
    });
  },
  getAuthName({ email, socialUsername, socialProvider }) {
    if (socialUsername) {
      if (socialProvider && socialProvider === "discord" && socialUsername.endsWith("0")) {
        return socialUsername.slice(0, -1);
      }
      return socialUsername;
    }
    return email.length > 30 ? `${email.slice(0, -3)}...` : email;
  },
  async fetchProviderData(connector) {
    try {
      if (connector.name === "Browser Wallet" && !CoreHelperUtil.isMobile()) {
        return { accounts: [], chainId: void 0 };
      }
      if (connector.id === ConstantsUtil.CONNECTOR_ID.AUTH) {
        return { accounts: [], chainId: void 0 };
      }
      const [accounts, chainId] = await Promise.all([
        connector.provider?.request({ method: "eth_accounts" }),
        connector.provider?.request({ method: "eth_chainId" }).then((hexChainId) => Number(hexChainId))
      ]);
      return { accounts, chainId };
    } catch (err) {
      console.warn(`Failed to fetch provider data for ${connector.name}`, err);
      return { accounts: [], chainId: void 0 };
    }
  },
  getFilteredCustomWallets(wallets) {
    const recent = StorageUtil.getRecentWallets();
    const connectorRDNSs = ConnectorController.state.connectors.map((connector) => connector.info?.rdns).filter(Boolean);
    const recentRDNSs = recent.map((wallet) => wallet.rdns).filter(Boolean);
    const allRDNSs = connectorRDNSs.concat(recentRDNSs);
    if (allRDNSs.includes("io.metamask.mobile") && CoreHelperUtil.isMobile()) {
      const index = allRDNSs.indexOf("io.metamask.mobile");
      allRDNSs[index] = "io.metamask";
    }
    const filtered = wallets.filter((wallet) => !allRDNSs.includes(String(wallet?.rdns)));
    return filtered;
  },
  hasWalletConnector(wallet) {
    return ConnectorController.state.connectors.some((connector) => connector.id === wallet.id || connector.name === wallet.name);
  },
  isWalletCompatibleWithCurrentChain(wallet) {
    const currentNamespace = ChainController.state.activeChain;
    if (currentNamespace && wallet.chains) {
      return wallet.chains.some((c) => {
        const chainNamespace = c.split(":")[0];
        return currentNamespace === chainNamespace;
      });
    }
    return true;
  },
  getFilteredRecentWallets() {
    const recentWallets = StorageUtil.getRecentWallets();
    const filteredRecentWallets = recentWallets.filter((wallet) => !WalletUtil.isExcluded(wallet)).filter((wallet) => !this.hasWalletConnector(wallet)).filter((wallet) => this.isWalletCompatibleWithCurrentChain(wallet));
    return filteredRecentWallets;
  },
  getCappedRecommendedWallets(wallets) {
    const { connectors } = ConnectorController.state;
    const { customWallets, featuredWalletIds } = OptionsController.state;
    const wcConnector = connectors.find((c) => c.id === "walletConnect");
    const injectedConnectors = connectors.filter((c) => c.type === "INJECTED" || c.type === "ANNOUNCED" || c.type === "MULTI_CHAIN");
    if (!wcConnector && !injectedConnectors.length && !customWallets?.length) {
      return [];
    }
    const isEmailEnabled = OptionsUtil.isEmailEnabled();
    const isSocialsEnabled = OptionsUtil.isSocialsEnabled();
    const injectedWallets = injectedConnectors.filter((i) => i.name !== "Browser Wallet");
    const featuredWalletAmount = featuredWalletIds?.length || 0;
    const customWalletAmount = customWallets?.length || 0;
    const injectedWalletAmount = injectedWallets.length || 0;
    const emailWalletAmount = isEmailEnabled ? 1 : 0;
    const socialWalletAmount = isSocialsEnabled ? 1 : 0;
    const walletsDisplayed = featuredWalletAmount + customWalletAmount + injectedWalletAmount + emailWalletAmount + socialWalletAmount;
    const DISPLAYED_WALLETS_AMOUNT = 4;
    const sliceAmount = Math.max(0, DISPLAYED_WALLETS_AMOUNT - walletsDisplayed);
    if (sliceAmount <= 0) {
      return [];
    }
    const filtered = WalletUtil.filterOutDuplicateWallets(wallets);
    return filtered.slice(0, sliceAmount);
  }
};

// node_modules/.pnpm/@reown+appkit-scaffold-ui@1.8.11_@react-native-async-storage+async-storage@1.24.0_react_e7f04814cd5c091a390bfd5cbe14c0e9/node_modules/@reown/appkit-scaffold-ui/dist/esm/src/utils/WalletUtil.js
var WalletUtil = {
  filterOutDuplicatesByRDNS(wallets) {
    const connectors = OptionsController.state.enableEIP6963 ? ConnectorController.state.connectors : [];
    const recent = StorageUtil.getRecentWallets();
    const connectorRDNSs = connectors.map((connector) => connector.info?.rdns).filter(Boolean);
    const recentRDNSs = recent.map((wallet) => wallet.rdns).filter(Boolean);
    const allRDNSs = connectorRDNSs.concat(recentRDNSs);
    if (allRDNSs.includes("io.metamask.mobile") && CoreHelperUtil.isMobile()) {
      const index = allRDNSs.indexOf("io.metamask.mobile");
      allRDNSs[index] = "io.metamask";
    }
    const filtered = wallets.filter((wallet) => {
      if (wallet?.rdns && allRDNSs.includes(String(wallet.rdns))) {
        return false;
      }
      if (!wallet?.rdns) {
        const hasMatchingConnectorName = connectors.some((connector) => connector.name === wallet.name);
        if (hasMatchingConnectorName) {
          return false;
        }
      }
      return true;
    });
    return filtered;
  },
  filterOutDuplicatesByIds(wallets) {
    const connectors = ConnectorController.state.connectors.filter((connector) => connector.type === "ANNOUNCED" || connector.type === "INJECTED");
    const recent = StorageUtil.getRecentWallets();
    const connectorIds = connectors.map((connector) => connector.explorerId);
    const recentIds = recent.map((wallet) => wallet.id);
    const allIds = connectorIds.concat(recentIds);
    const filtered = wallets.filter((wallet) => !allIds.includes(wallet?.id));
    return filtered;
  },
  filterOutDuplicateWallets(wallets) {
    const uniqueByRDNS = this.filterOutDuplicatesByRDNS(wallets);
    const uniqueWallets = this.filterOutDuplicatesByIds(uniqueByRDNS);
    return uniqueWallets;
  },
  markWalletsAsInstalled(wallets) {
    const { connectors } = ConnectorController.state;
    const { featuredWalletIds } = OptionsController.state;
    const installedWalletRdnsMap = connectors.filter((connector) => connector.type === "ANNOUNCED").reduce((rdnsMap, connector) => {
      if (!connector.info?.rdns) {
        return rdnsMap;
      }
      rdnsMap[connector.info.rdns] = true;
      return rdnsMap;
    }, {});
    const walletsWithInstallationStatus = wallets.map((wallet) => ({
      ...wallet,
      installed: Boolean(wallet.rdns) && Boolean(installedWalletRdnsMap[wallet.rdns ?? ""])
    }));
    const sortedWallets = walletsWithInstallationStatus.sort((walletA, walletB) => {
      const installationComparison = Number(walletB.installed) - Number(walletA.installed);
      if (installationComparison !== 0) {
        return installationComparison;
      }
      if (featuredWalletIds?.length) {
        const walletAFeaturedIndex = featuredWalletIds.indexOf(walletA.id);
        const walletBFeaturedIndex = featuredWalletIds.indexOf(walletB.id);
        if (walletAFeaturedIndex !== -1 && walletBFeaturedIndex !== -1) {
          return walletAFeaturedIndex - walletBFeaturedIndex;
        }
        if (walletAFeaturedIndex !== -1) {
          return -1;
        }
        if (walletBFeaturedIndex !== -1) {
          return 1;
        }
      }
      return 0;
    });
    return sortedWallets;
  },
  getConnectOrderMethod(_features, _connectors) {
    const connectMethodOrder = _features?.connectMethodsOrder || OptionsController.state.features?.connectMethodsOrder;
    const connectors = _connectors || ConnectorController.state.connectors;
    if (connectMethodOrder) {
      return connectMethodOrder;
    }
    const { injected, announced } = ConnectorUtil.getConnectorsByType(connectors, ApiController.state.recommended, ApiController.state.featured);
    const shownInjected = injected.filter(ConnectorUtil.showConnector);
    const shownAnnounced = announced.filter(ConnectorUtil.showConnector);
    if (shownInjected.length || shownAnnounced.length) {
      return ["wallet", "email", "social"];
    }
    return ConstantsUtil2.DEFAULT_CONNECT_METHOD_ORDER;
  },
  isExcluded(wallet) {
    const isRDNSExcluded = Boolean(wallet.rdns) && ApiController.state.excludedWallets.some((w) => w.rdns === wallet.rdns);
    const isNameExcluded = Boolean(wallet.name) && ApiController.state.excludedWallets.some((w) => HelpersUtil.isLowerCaseMatch(w.name, wallet.name));
    return isRDNSExcluded || isNameExcluded;
  },
  markWalletsWithDisplayIndex(wallets) {
    return wallets.map((w, index) => ({ ...w, display_index: index }));
  }
};

export {
  ConstantsUtil3 as ConstantsUtil,
  HelpersUtil,
  ErrorUtil,
  TokenUtil,
  LoggerUtil,
  CaipNetworksUtil,
  WalletUtil,
  ConnectorUtil
};
//# sourceMappingURL=chunk-2AC6EWRB.js.map
