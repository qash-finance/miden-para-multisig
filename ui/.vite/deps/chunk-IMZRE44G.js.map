{
  "version": 3,
  "sources": ["../../node_modules/.pnpm/@noble+curves@1.9.1/node_modules/@noble/curves/src/abstract/bls.ts", "../../node_modules/.pnpm/@noble+curves@1.9.1/node_modules/@noble/curves/src/abstract/tower.ts", "../../node_modules/.pnpm/@noble+curves@1.9.1/node_modules/@noble/curves/src/bls12-381.ts", "../../node_modules/.pnpm/@noble+curves@1.9.1/node_modules/@noble/curves/src/abstract/edwards.ts", "../../node_modules/.pnpm/@noble+curves@1.9.1/node_modules/@noble/curves/src/abstract/montgomery.ts", "../../node_modules/.pnpm/@noble+curves@1.9.1/node_modules/@noble/curves/src/ed25519.ts", "../../node_modules/.pnpm/@noble+ciphers@1.3.0/node_modules/@noble/ciphers/src/utils.ts", "../../node_modules/.pnpm/@noble+ciphers@1.3.0/node_modules/@noble/ciphers/src/_polyval.ts", "../../node_modules/.pnpm/@noble+ciphers@1.3.0/node_modules/@noble/ciphers/src/aes.ts"],
  "sourcesContent": ["/**\n * BLS (Barreto-Lynn-Scott) family of pairing-friendly curves.\n * BLS != BLS.\n * The file implements BLS (Boneh-Lynn-Shacham) signatures.\n * Used in both BLS (Barreto-Lynn-Scott) and BN (Barreto-Naehrig)\n * families of pairing-friendly curves.\n * Consists of two curves: G1 and G2:\n * - G1 is a subgroup of (x, y) E(Fq) over y² = x³ + 4.\n * - G2 is a subgroup of ((x₁, x₂+i), (y₁, y₂+i)) E(Fq²) over y² = x³ + 4(1 + i) where i is √-1\n * - Gt, created by bilinear (ate) pairing e(G1, G2), consists of p-th roots of unity in\n *   Fq^k where k is embedding degree. Only degree 12 is currently supported, 24 is not.\n * Pairing is used to aggregate and verify signatures.\n * There are two main ways to use it:\n * 1. Fp for short private keys, Fp₂ for signatures\n * 2. Fp for short signatures, Fp₂ for private keys\n * @module\n **/\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// TODO: import { AffinePoint } from './curve.ts';\nimport {\n  type H2CPointConstructor,\n  type htfBasicOpts,\n  type Opts as HTFOpts,\n  type MapToCurve,\n  createHasher,\n} from './hash-to-curve.ts';\nimport { type IField, getMinHashLength, mapHashToField } from './modular.ts';\nimport type { Fp12, Fp12Bls, Fp2, Fp2Bls, Fp6 } from './tower.ts';\nimport { type CHash, type Hex, type PrivKey, ensureBytes, memoized } from './utils.ts';\nimport {\n  type CurvePointsRes,\n  type CurvePointsType,\n  type ProjPointType,\n  weierstrassPoints,\n} from './weierstrass.ts';\n\ntype Fp = bigint; // Can be different field?\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n\nexport type TwistType = 'multiplicative' | 'divisive';\n\nexport type ShortSignatureCoder<Fp> = {\n  fromHex(hex: Hex): ProjPointType<Fp>;\n  toRawBytes(point: ProjPointType<Fp>): Uint8Array;\n  toHex(point: ProjPointType<Fp>): string;\n};\n\nexport type SignatureCoder<Fp> = {\n  fromHex(hex: Hex): ProjPointType<Fp>;\n  toRawBytes(point: ProjPointType<Fp>): Uint8Array;\n  toHex(point: ProjPointType<Fp>): string;\n};\n\nexport type PostPrecomputePointAddFn = (\n  Rx: Fp2,\n  Ry: Fp2,\n  Rz: Fp2,\n  Qx: Fp2,\n  Qy: Fp2\n) => { Rx: Fp2; Ry: Fp2; Rz: Fp2 };\nexport type PostPrecomputeFn = (\n  Rx: Fp2,\n  Ry: Fp2,\n  Rz: Fp2,\n  Qx: Fp2,\n  Qy: Fp2,\n  pointAdd: PostPrecomputePointAddFn\n) => void;\nexport type CurveType = {\n  G1: Omit<CurvePointsType<Fp>, 'n'> & {\n    ShortSignature: SignatureCoder<Fp>;\n    mapToCurve: MapToCurve<Fp>;\n    htfDefaults: HTFOpts;\n  };\n  G2: Omit<CurvePointsType<Fp2>, 'n'> & {\n    Signature: SignatureCoder<Fp2>;\n    mapToCurve: MapToCurve<Fp2>;\n    htfDefaults: HTFOpts;\n  };\n  fields: {\n    Fp: IField<Fp>;\n    Fr: IField<bigint>;\n    Fp2: Fp2Bls;\n    Fp6: IField<Fp6>;\n    Fp12: Fp12Bls;\n  };\n  params: {\n    // NOTE: MSB is always ignored and used as marker for length,\n    // otherwise leading zeros will be lost.\n    // Can be different from 'X' (seed) param!\n    ateLoopSize: bigint;\n    xNegative: boolean;\n    r: bigint;\n    twistType: TwistType; // BLS12-381: Multiplicative, BN254: Divisive\n  };\n  htfDefaults: HTFOpts;\n  hash: CHash; // Because we need outputLen for DRBG\n  randomBytes: (bytesLength?: number) => Uint8Array;\n  // This is super ugly hack for untwist point in BN254 after miller loop\n  postPrecompute?: PostPrecomputeFn;\n};\n\ntype PrecomputeSingle = [Fp2, Fp2, Fp2][];\ntype Precompute = PrecomputeSingle[];\n\nexport type CurveFn = {\n  getPublicKey: (privateKey: PrivKey) => Uint8Array;\n  getPublicKeyForShortSignatures: (privateKey: PrivKey) => Uint8Array;\n  sign: {\n    (message: Hex, privateKey: PrivKey, htfOpts?: htfBasicOpts): Uint8Array;\n    (message: ProjPointType<Fp2>, privateKey: PrivKey, htfOpts?: htfBasicOpts): ProjPointType<Fp2>;\n  };\n  signShortSignature: {\n    (message: Hex, privateKey: PrivKey, htfOpts?: htfBasicOpts): Uint8Array;\n    (message: ProjPointType<Fp>, privateKey: PrivKey, htfOpts?: htfBasicOpts): ProjPointType<Fp>;\n  };\n  verify: (\n    signature: Hex | ProjPointType<Fp2>,\n    message: Hex | ProjPointType<Fp2>,\n    publicKey: Hex | ProjPointType<Fp>,\n    htfOpts?: htfBasicOpts\n  ) => boolean;\n  verifyShortSignature: (\n    signature: Hex | ProjPointType<Fp>,\n    message: Hex | ProjPointType<Fp>,\n    publicKey: Hex | ProjPointType<Fp2>,\n    htfOpts?: htfBasicOpts\n  ) => boolean;\n  verifyBatch: (\n    signature: Hex | ProjPointType<Fp2>,\n    messages: (Hex | ProjPointType<Fp2>)[],\n    publicKeys: (Hex | ProjPointType<Fp>)[],\n    htfOpts?: htfBasicOpts\n  ) => boolean;\n  aggregatePublicKeys: {\n    (publicKeys: Hex[]): Uint8Array;\n    (publicKeys: ProjPointType<Fp>[]): ProjPointType<Fp>;\n  };\n  aggregateSignatures: {\n    (signatures: Hex[]): Uint8Array;\n    (signatures: ProjPointType<Fp2>[]): ProjPointType<Fp2>;\n  };\n  aggregateShortSignatures: {\n    (signatures: Hex[]): Uint8Array;\n    (signatures: ProjPointType<Fp>[]): ProjPointType<Fp>;\n  };\n  millerLoopBatch: (pairs: [Precompute, Fp, Fp][]) => Fp12;\n  pairing: (P: ProjPointType<Fp>, Q: ProjPointType<Fp2>, withFinalExponent?: boolean) => Fp12;\n  pairingBatch: (\n    pairs: { g1: ProjPointType<Fp>; g2: ProjPointType<Fp2> }[],\n    withFinalExponent?: boolean\n  ) => Fp12;\n  G1: CurvePointsRes<Fp> & ReturnType<typeof createHasher<Fp>>;\n  G2: CurvePointsRes<Fp2> & ReturnType<typeof createHasher<Fp2>>;\n  Signature: SignatureCoder<Fp2>;\n  ShortSignature: ShortSignatureCoder<Fp>;\n  params: {\n    ateLoopSize: bigint;\n    r: bigint;\n    G1b: bigint;\n    G2b: Fp2;\n  };\n  fields: {\n    Fp: IField<Fp>;\n    Fp2: Fp2Bls;\n    Fp6: IField<Fp6>;\n    Fp12: Fp12Bls;\n    Fr: IField<bigint>;\n  };\n  utils: {\n    randomPrivateKey: () => Uint8Array;\n    calcPairingPrecomputes: (p: ProjPointType<Fp2>) => Precompute;\n  };\n};\n\n// Not used with BLS12-381 (no sequential `11` in X). Useful for other curves.\nfunction NAfDecomposition(a: bigint) {\n  const res = [];\n  // a>1 because of marker bit\n  for (; a > _1n; a >>= _1n) {\n    if ((a & _1n) === _0n) res.unshift(0);\n    else if ((a & _3n) === _3n) {\n      res.unshift(-1);\n      a += _1n;\n    } else res.unshift(1);\n  }\n  return res;\n}\n\nexport function bls(CURVE: CurveType): CurveFn {\n  // Fields are specific for curve, so for now we'll need to pass them with opts\n  const { Fp, Fr, Fp2, Fp6, Fp12 } = CURVE.fields;\n  const BLS_X_IS_NEGATIVE = CURVE.params.xNegative;\n  const TWIST: TwistType = CURVE.params.twistType;\n  // Point on G1 curve: (x, y)\n  const G1_ = weierstrassPoints({ n: Fr.ORDER, ...CURVE.G1 });\n  const G1 = Object.assign(\n    G1_,\n    createHasher(G1_.ProjectivePoint, CURVE.G1.mapToCurve, {\n      ...CURVE.htfDefaults,\n      ...CURVE.G1.htfDefaults,\n    })\n  );\n  // Point on G2 curve (complex numbers): (x₁, x₂+i), (y₁, y₂+i)\n  const G2_ = weierstrassPoints({ n: Fr.ORDER, ...CURVE.G2 });\n  const G2 = Object.assign(\n    G2_,\n    createHasher(G2_.ProjectivePoint as H2CPointConstructor<Fp2>, CURVE.G2.mapToCurve, {\n      ...CURVE.htfDefaults,\n      ...CURVE.G2.htfDefaults,\n    })\n  );\n  type G1 = typeof G1.ProjectivePoint.BASE;\n  type G2 = typeof G2.ProjectivePoint.BASE;\n\n  // Applies sparse multiplication as line function\n  let lineFunction: (c0: Fp2, c1: Fp2, c2: Fp2, f: Fp12, Px: Fp, Py: Fp) => Fp12;\n  if (TWIST === 'multiplicative') {\n    lineFunction = (c0: Fp2, c1: Fp2, c2: Fp2, f: Fp12, Px: Fp, Py: Fp) =>\n      Fp12.mul014(f, c0, Fp2.mul(c1, Px), Fp2.mul(c2, Py));\n  } else if (TWIST === 'divisive') {\n    // NOTE: it should be [c0, c1, c2], but we use different order here to reduce complexity of\n    // precompute calculations.\n    lineFunction = (c0: Fp2, c1: Fp2, c2: Fp2, f: Fp12, Px: Fp, Py: Fp) =>\n      Fp12.mul034(f, Fp2.mul(c2, Py), Fp2.mul(c1, Px), c0);\n  } else throw new Error('bls: unknown twist type');\n\n  const Fp2div2 = Fp2.div(Fp2.ONE, Fp2.mul(Fp2.ONE, _2n));\n  function pointDouble(ell: PrecomputeSingle, Rx: Fp2, Ry: Fp2, Rz: Fp2) {\n    const t0 = Fp2.sqr(Ry); // Ry²\n    const t1 = Fp2.sqr(Rz); // Rz²\n    const t2 = Fp2.mulByB(Fp2.mul(t1, _3n)); // 3 * T1 * B\n    const t3 = Fp2.mul(t2, _3n); // 3 * T2\n    const t4 = Fp2.sub(Fp2.sub(Fp2.sqr(Fp2.add(Ry, Rz)), t1), t0); // (Ry + Rz)² - T1 - T0\n    const c0 = Fp2.sub(t2, t0); // T2 - T0 (i)\n    const c1 = Fp2.mul(Fp2.sqr(Rx), _3n); // 3 * Rx²\n    const c2 = Fp2.neg(t4); // -T4 (-h)\n\n    ell.push([c0, c1, c2]);\n\n    Rx = Fp2.mul(Fp2.mul(Fp2.mul(Fp2.sub(t0, t3), Rx), Ry), Fp2div2); // ((T0 - T3) * Rx * Ry) / 2\n    Ry = Fp2.sub(Fp2.sqr(Fp2.mul(Fp2.add(t0, t3), Fp2div2)), Fp2.mul(Fp2.sqr(t2), _3n)); // ((T0 + T3) / 2)² - 3 * T2²\n    Rz = Fp2.mul(t0, t4); // T0 * T4\n    return { Rx, Ry, Rz };\n  }\n  function pointAdd(ell: PrecomputeSingle, Rx: Fp2, Ry: Fp2, Rz: Fp2, Qx: Fp2, Qy: Fp2) {\n    // Addition\n    const t0 = Fp2.sub(Ry, Fp2.mul(Qy, Rz)); // Ry - Qy * Rz\n    const t1 = Fp2.sub(Rx, Fp2.mul(Qx, Rz)); // Rx - Qx * Rz\n    const c0 = Fp2.sub(Fp2.mul(t0, Qx), Fp2.mul(t1, Qy)); // T0 * Qx - T1 * Qy == Ry * Qx  - Rx * Qy\n    const c1 = Fp2.neg(t0); // -T0 == Qy * Rz - Ry\n    const c2 = t1; // == Rx - Qx * Rz\n\n    ell.push([c0, c1, c2]);\n\n    const t2 = Fp2.sqr(t1); // T1²\n    const t3 = Fp2.mul(t2, t1); // T2 * T1\n    const t4 = Fp2.mul(t2, Rx); // T2 * Rx\n    const t5 = Fp2.add(Fp2.sub(t3, Fp2.mul(t4, _2n)), Fp2.mul(Fp2.sqr(t0), Rz)); // T3 - 2 * T4 + T0² * Rz\n    Rx = Fp2.mul(t1, t5); // T1 * T5\n    Ry = Fp2.sub(Fp2.mul(Fp2.sub(t4, t5), t0), Fp2.mul(t3, Ry)); // (T4 - T5) * T0 - T3 * Ry\n    Rz = Fp2.mul(Rz, t3); // Rz * T3\n    return { Rx, Ry, Rz };\n  }\n\n  // Pre-compute coefficients for sparse multiplication\n  // Point addition and point double calculations is reused for coefficients\n  // pointAdd happens only if bit set, so wNAF is reasonable. Unfortunately we cannot combine\n  // add + double in windowed precomputes here, otherwise it would be single op (since X is static)\n  const ATE_NAF = NAfDecomposition(CURVE.params.ateLoopSize);\n\n  const calcPairingPrecomputes = memoized((point: G2) => {\n    const p = point;\n    const { x, y } = p.toAffine();\n    // prettier-ignore\n    const Qx = x, Qy = y, negQy = Fp2.neg(y);\n    // prettier-ignore\n    let Rx = Qx, Ry = Qy, Rz = Fp2.ONE;\n    const ell: Precompute = [];\n    for (const bit of ATE_NAF) {\n      const cur: PrecomputeSingle = [];\n      ({ Rx, Ry, Rz } = pointDouble(cur, Rx, Ry, Rz));\n      if (bit) ({ Rx, Ry, Rz } = pointAdd(cur, Rx, Ry, Rz, Qx, bit === -1 ? negQy : Qy));\n      ell.push(cur);\n    }\n    if (CURVE.postPrecompute) {\n      const last = ell[ell.length - 1];\n      CURVE.postPrecompute(Rx, Ry, Rz, Qx, Qy, pointAdd.bind(null, last));\n    }\n    return ell;\n  });\n\n  // Main pairing logic is here. Computes product of miller loops + final exponentiate\n  // Applies calculated precomputes\n  type MillerInput = [Precompute, Fp, Fp][];\n  function millerLoopBatch(pairs: MillerInput, withFinalExponent: boolean = false) {\n    let f12 = Fp12.ONE;\n    if (pairs.length) {\n      const ellLen = pairs[0][0].length;\n      for (let i = 0; i < ellLen; i++) {\n        f12 = Fp12.sqr(f12); // This allows us to do sqr only one time for all pairings\n        // NOTE: we apply multiple pairings in parallel here\n        for (const [ell, Px, Py] of pairs) {\n          for (const [c0, c1, c2] of ell[i]) f12 = lineFunction(c0, c1, c2, f12, Px, Py);\n        }\n      }\n    }\n    if (BLS_X_IS_NEGATIVE) f12 = Fp12.conjugate(f12);\n    return withFinalExponent ? Fp12.finalExponentiate(f12) : f12;\n  }\n  type PairingInput = { g1: G1; g2: G2 };\n  // Calculates product of multiple pairings\n  // This up to x2 faster than just `map(({g1, g2})=>pairing({g1,g2}))`\n  function pairingBatch(pairs: PairingInput[], withFinalExponent: boolean = true) {\n    const res: MillerInput = [];\n    // Cache precomputed toAffine for all points\n    G1.ProjectivePoint.normalizeZ(pairs.map(({ g1 }) => g1));\n    G2.ProjectivePoint.normalizeZ(pairs.map(({ g2 }) => g2));\n    for (const { g1, g2 } of pairs) {\n      if (g1.equals(G1.ProjectivePoint.ZERO) || g2.equals(G2.ProjectivePoint.ZERO))\n        throw new Error('pairing is not available for ZERO point');\n      // This uses toAffine inside\n      g1.assertValidity();\n      g2.assertValidity();\n      const Qa = g1.toAffine();\n      res.push([calcPairingPrecomputes(g2), Qa.x, Qa.y]);\n    }\n    return millerLoopBatch(res, withFinalExponent);\n  }\n  // Calculates bilinear pairing\n  function pairing(Q: G1, P: G2, withFinalExponent: boolean = true): Fp12 {\n    return pairingBatch([{ g1: Q, g2: P }], withFinalExponent);\n  }\n\n  const utils = {\n    randomPrivateKey: (): Uint8Array => {\n      const length = getMinHashLength(Fr.ORDER);\n      return mapHashToField(CURVE.randomBytes(length), Fr.ORDER);\n    },\n    calcPairingPrecomputes,\n  };\n\n  const { ShortSignature } = CURVE.G1;\n  const { Signature } = CURVE.G2;\n\n  type G1Hex = Hex | G1;\n  type G2Hex = Hex | G2;\n  function normP1(point: G1Hex): G1 {\n    return point instanceof G1.ProjectivePoint ? (point as G1) : G1.ProjectivePoint.fromHex(point);\n  }\n  function normP1Hash(point: G1Hex, htfOpts?: htfBasicOpts): G1 {\n    return point instanceof G1.ProjectivePoint\n      ? point\n      : (G1.hashToCurve(ensureBytes('point', point), htfOpts) as G1);\n  }\n  function normP2(point: G2Hex): G2 {\n    return point instanceof G2.ProjectivePoint ? point : Signature.fromHex(point);\n  }\n  function normP2Hash(point: G2Hex, htfOpts?: htfBasicOpts): G2 {\n    return point instanceof G2.ProjectivePoint\n      ? point\n      : (G2.hashToCurve(ensureBytes('point', point), htfOpts) as G2);\n  }\n\n  // Multiplies generator (G1) by private key.\n  // P = pk x G\n  function getPublicKey(privateKey: PrivKey): Uint8Array {\n    return G1.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(true);\n  }\n\n  // Multiplies generator (G2) by private key.\n  // P = pk x G\n  function getPublicKeyForShortSignatures(privateKey: PrivKey): Uint8Array {\n    return G2.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(true);\n  }\n\n  // Executes `hashToCurve` on the message and then multiplies the result by private key.\n  // S = pk x H(m)\n  function sign(message: Hex, privateKey: PrivKey, htfOpts?: htfBasicOpts): Uint8Array;\n  function sign(message: G2, privateKey: PrivKey, htfOpts?: htfBasicOpts): G2;\n  function sign(message: G2Hex, privateKey: PrivKey, htfOpts?: htfBasicOpts): Uint8Array | G2 {\n    const msgPoint = normP2Hash(message, htfOpts);\n    msgPoint.assertValidity();\n    const sigPoint = msgPoint.multiply(G1.normPrivateKeyToScalar(privateKey));\n    if (message instanceof G2.ProjectivePoint) return sigPoint;\n    return Signature.toRawBytes(sigPoint);\n  }\n\n  function signShortSignature(\n    message: Hex,\n    privateKey: PrivKey,\n    htfOpts?: htfBasicOpts\n  ): Uint8Array;\n  function signShortSignature(message: G1, privateKey: PrivKey, htfOpts?: htfBasicOpts): G1;\n  function signShortSignature(\n    message: G1Hex,\n    privateKey: PrivKey,\n    htfOpts?: htfBasicOpts\n  ): Uint8Array | G1 {\n    const msgPoint = normP1Hash(message, htfOpts);\n    msgPoint.assertValidity();\n    const sigPoint = msgPoint.multiply(G1.normPrivateKeyToScalar(privateKey));\n    if (message instanceof G1.ProjectivePoint) return sigPoint;\n    return ShortSignature.toRawBytes(sigPoint);\n  }\n\n  // Checks if pairing of public key & hash is equal to pairing of generator & signature.\n  // e(P, H(m)) == e(G, S)\n  function verify(\n    signature: G2Hex,\n    message: G2Hex,\n    publicKey: G1Hex,\n    htfOpts?: htfBasicOpts\n  ): boolean {\n    const P = normP1(publicKey);\n    const Hm = normP2Hash(message, htfOpts);\n    const G = G1.ProjectivePoint.BASE;\n    const S = normP2(signature);\n    const exp = pairingBatch([\n      { g1: P.negate(), g2: Hm }, // ePHM = pairing(P.negate(), Hm, false);\n      { g1: G, g2: S }, // eGS = pairing(G, S, false);\n    ]);\n    return Fp12.eql(exp, Fp12.ONE);\n  }\n\n  // Checks if pairing of public key & hash is equal to pairing of generator & signature.\n  // e(S, G) == e(H(m), P)\n  function verifyShortSignature(\n    signature: G1Hex,\n    message: G1Hex,\n    publicKey: G2Hex,\n    htfOpts?: htfBasicOpts\n  ): boolean {\n    const P = normP2(publicKey);\n    const Hm = normP1Hash(message, htfOpts);\n    const G = G2.ProjectivePoint.BASE;\n    const S = normP1(signature);\n    const exp = pairingBatch([\n      { g1: Hm, g2: P }, // eHmP = pairing(Hm, P, false);\n      { g1: S, g2: G.negate() }, // eSG = pairing(S, G.negate(), false);\n    ]);\n    return Fp12.eql(exp, Fp12.ONE);\n  }\n\n  function aNonEmpty(arr: any[]) {\n    if (!Array.isArray(arr) || arr.length === 0) throw new Error('expected non-empty array');\n  }\n\n  // Adds a bunch of public key points together.\n  // pk1 + pk2 + pk3 = pkA\n  function aggregatePublicKeys(publicKeys: Hex[]): Uint8Array;\n  function aggregatePublicKeys(publicKeys: G1[]): G1;\n  function aggregatePublicKeys(publicKeys: G1Hex[]): Uint8Array | G1 {\n    aNonEmpty(publicKeys);\n    const agg = publicKeys.map(normP1).reduce((sum, p) => sum.add(p), G1.ProjectivePoint.ZERO);\n    const aggAffine = agg; //.toAffine();\n    if (publicKeys[0] instanceof G1.ProjectivePoint) {\n      aggAffine.assertValidity();\n      return aggAffine;\n    }\n    // toRawBytes ensures point validity\n    return aggAffine.toRawBytes(true);\n  }\n\n  // Adds a bunch of signature points together.\n  function aggregateSignatures(signatures: Hex[]): Uint8Array;\n  function aggregateSignatures(signatures: G2[]): G2;\n  function aggregateSignatures(signatures: G2Hex[]): Uint8Array | G2 {\n    aNonEmpty(signatures);\n    const agg = signatures.map(normP2).reduce((sum, s) => sum.add(s), G2.ProjectivePoint.ZERO);\n    const aggAffine = agg; //.toAffine();\n    if (signatures[0] instanceof G2.ProjectivePoint) {\n      aggAffine.assertValidity();\n      return aggAffine;\n    }\n    return Signature.toRawBytes(aggAffine);\n  }\n\n  // Adds a bunch of signature points together.\n  function aggregateShortSignatures(signatures: Hex[]): Uint8Array;\n  function aggregateShortSignatures(signatures: G1[]): G1;\n  function aggregateShortSignatures(signatures: G1Hex[]): Uint8Array | G1 {\n    aNonEmpty(signatures);\n    const agg = signatures.map(normP1).reduce((sum, s) => sum.add(s), G1.ProjectivePoint.ZERO);\n    const aggAffine = agg; //.toAffine();\n    if (signatures[0] instanceof G1.ProjectivePoint) {\n      aggAffine.assertValidity();\n      return aggAffine;\n    }\n    return ShortSignature.toRawBytes(aggAffine);\n  }\n\n  // https://ethresear.ch/t/fast-verification-of-multiple-bls-signatures/5407\n  // e(G, S) = e(G, SUM(n)(Si)) = MUL(n)(e(G, Si))\n  function verifyBatch(\n    signature: G2Hex,\n    // TODO: maybe `{message: G2Hex, publicKey: G1Hex}[]` instead?\n    messages: G2Hex[],\n    publicKeys: G1Hex[],\n    htfOpts?: htfBasicOpts\n  ): boolean {\n    aNonEmpty(messages);\n    if (publicKeys.length !== messages.length)\n      throw new Error('amount of public keys and messages should be equal');\n    const sig = normP2(signature);\n    const nMessages = messages.map((i) => normP2Hash(i, htfOpts));\n    const nPublicKeys = publicKeys.map(normP1);\n    // NOTE: this works only for exact same object\n    const messagePubKeyMap = new Map<G2, G1[]>();\n    for (let i = 0; i < nPublicKeys.length; i++) {\n      const pub = nPublicKeys[i];\n      const msg = nMessages[i];\n      let keys = messagePubKeyMap.get(msg);\n      if (keys === undefined) {\n        keys = [];\n        messagePubKeyMap.set(msg, keys);\n      }\n      keys.push(pub);\n    }\n    const paired = [];\n    try {\n      for (const [msg, keys] of messagePubKeyMap) {\n        const groupPublicKey = keys.reduce((acc, msg) => acc.add(msg));\n        paired.push({ g1: groupPublicKey, g2: msg });\n      }\n      paired.push({ g1: G1.ProjectivePoint.BASE.negate(), g2: sig });\n      return Fp12.eql(pairingBatch(paired), Fp12.ONE);\n    } catch {\n      return false;\n    }\n  }\n\n  G1.ProjectivePoint.BASE._setWindowSize(4);\n\n  return {\n    getPublicKey,\n    getPublicKeyForShortSignatures,\n    sign,\n    signShortSignature,\n    verify,\n    verifyBatch,\n    verifyShortSignature,\n    aggregatePublicKeys,\n    aggregateSignatures,\n    aggregateShortSignatures,\n    millerLoopBatch,\n    pairing,\n    pairingBatch,\n    G1,\n    G2,\n    Signature,\n    ShortSignature,\n    fields: {\n      Fr,\n      Fp,\n      Fp2,\n      Fp6,\n      Fp12,\n    },\n    params: {\n      ateLoopSize: CURVE.params.ateLoopSize,\n      r: CURVE.params.r,\n      G1b: CURVE.G1.b,\n      G2b: CURVE.G2.b,\n    },\n    utils,\n  };\n}\n", "/**\n * Towered extension fields.\n * Rather than implementing a massive 12th-degree extension directly, it is more efficient\n * to build it up from smaller extensions: a tower of extensions.\n *\n * For BLS12-381, the Fp12 field is implemented as a quadratic (degree two) extension,\n * on top of a cubic (degree three) extension, on top of a quadratic extension of Fp.\n *\n * For more info: \"Pairings for beginners\" by Costello, section 7.3.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport * as mod from './modular.ts';\nimport { bitLen, bitMask, concatBytes, notImplemented } from './utils.ts';\nimport type { ProjConstructor, ProjPointType } from './weierstrass.ts';\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n\n// Fp₂ over complex plane\nexport type BigintTuple = [bigint, bigint];\nexport type Fp = bigint;\n// Finite extension field over irreducible polynominal.\n// Fp(u) / (u² - β) where β = -1\nexport type Fp2 = { c0: bigint; c1: bigint };\nexport type BigintSix = [bigint, bigint, bigint, bigint, bigint, bigint];\nexport type Fp6 = { c0: Fp2; c1: Fp2; c2: Fp2 };\nexport type Fp12 = { c0: Fp6; c1: Fp6 }; // Fp₁₂ = Fp₆² => Fp₂³, Fp₆(w) / (w² - γ) where γ = v\n// prettier-ignore\nexport type BigintTwelve = [\n  bigint, bigint, bigint, bigint, bigint, bigint,\n  bigint, bigint, bigint, bigint, bigint, bigint\n];\n\nexport type Fp2Bls = mod.IField<Fp2> & {\n  reim: (num: Fp2) => { re: Fp; im: Fp };\n  mulByB: (num: Fp2) => Fp2;\n  frobeniusMap(num: Fp2, power: number): Fp2;\n  fromBigTuple(num: [bigint, bigint]): Fp2;\n};\n\nexport type Fp12Bls = mod.IField<Fp12> & {\n  frobeniusMap(num: Fp12, power: number): Fp12;\n  mul014(num: Fp12, o0: Fp2, o1: Fp2, o4: Fp2): Fp12;\n  mul034(num: Fp12, o0: Fp2, o3: Fp2, o4: Fp2): Fp12;\n  conjugate(num: Fp12): Fp12;\n  finalExponentiate(num: Fp12): Fp12;\n  fromBigTwelve(num: BigintTwelve): Fp12;\n};\n\nfunction calcFrobeniusCoefficients<T>(\n  Fp: mod.IField<T>,\n  nonResidue: T,\n  modulus: bigint,\n  degree: number,\n  num: number = 1,\n  divisor?: number\n) {\n  const _divisor = BigInt(divisor === undefined ? degree : divisor);\n  const towerModulus: any = modulus ** BigInt(degree);\n  const res: T[][] = [];\n  for (let i = 0; i < num; i++) {\n    const a = BigInt(i + 1);\n    const powers: T[] = [];\n    for (let j = 0, qPower = _1n; j < degree; j++) {\n      const power = ((a * qPower - a) / _divisor) % towerModulus;\n      powers.push(Fp.pow(nonResidue, power));\n      qPower *= modulus;\n    }\n    res.push(powers);\n  }\n  return res;\n}\n\n// This works same at least for bls12-381, bn254 and bls12-377\nexport function psiFrobenius(\n  Fp: mod.IField<Fp>,\n  Fp2: Fp2Bls,\n  base: Fp2\n): {\n  psi: (x: Fp2, y: Fp2) => [Fp2, Fp2];\n  psi2: (x: Fp2, y: Fp2) => [Fp2, Fp2];\n  G2psi: (c: ProjConstructor<Fp2>, P: ProjPointType<Fp2>) => ProjPointType<Fp2>;\n  G2psi2: (c: ProjConstructor<Fp2>, P: ProjPointType<Fp2>) => ProjPointType<Fp2>;\n  PSI_X: Fp2;\n  PSI_Y: Fp2;\n  PSI2_X: Fp2;\n  PSI2_Y: Fp2;\n} {\n  // GLV endomorphism Ψ(P)\n  const PSI_X = Fp2.pow(base, (Fp.ORDER - _1n) / _3n); // u^((p-1)/3)\n  const PSI_Y = Fp2.pow(base, (Fp.ORDER - _1n) / _2n); // u^((p-1)/2)\n  function psi(x: Fp2, y: Fp2): [Fp2, Fp2] {\n    // This x10 faster than previous version in bls12-381\n    const x2 = Fp2.mul(Fp2.frobeniusMap(x, 1), PSI_X);\n    const y2 = Fp2.mul(Fp2.frobeniusMap(y, 1), PSI_Y);\n    return [x2, y2];\n  }\n  // Ψ²(P) endomorphism (psi2(x) = psi(psi(x)))\n  const PSI2_X = Fp2.pow(base, (Fp.ORDER ** _2n - _1n) / _3n); // u^((p^2 - 1)/3)\n  // This equals -1, which causes y to be Fp2.neg(y).\n  // But not sure if there are case when this is not true?\n  const PSI2_Y = Fp2.pow(base, (Fp.ORDER ** _2n - _1n) / _2n); // u^((p^2 - 1)/3)\n  if (!Fp2.eql(PSI2_Y, Fp2.neg(Fp2.ONE))) throw new Error('psiFrobenius: PSI2_Y!==-1');\n  function psi2(x: Fp2, y: Fp2): [Fp2, Fp2] {\n    return [Fp2.mul(x, PSI2_X), Fp2.neg(y)];\n  }\n  // Map points\n  const mapAffine =\n    <T>(fn: (x: T, y: T) => [T, T]) =>\n    (c: ProjConstructor<T>, P: ProjPointType<T>) => {\n      const affine = P.toAffine();\n      const p = fn(affine.x, affine.y);\n      return c.fromAffine({ x: p[0], y: p[1] });\n    };\n  const G2psi = mapAffine(psi);\n  const G2psi2 = mapAffine(psi2);\n  return { psi, psi2, G2psi, G2psi2, PSI_X, PSI_Y, PSI2_X, PSI2_Y };\n}\n\nexport type Tower12Opts = {\n  ORDER: bigint;\n  NONRESIDUE?: Fp;\n  // Fp2\n  FP2_NONRESIDUE: BigintTuple;\n  Fp2sqrt?: (num: Fp2) => Fp2;\n  Fp2mulByB: (num: Fp2) => Fp2;\n  // Fp12\n  Fp12cyclotomicSquare: (num: Fp12) => Fp12;\n  Fp12cyclotomicExp: (num: Fp12, n: bigint) => Fp12;\n  Fp12finalExponentiate: (num: Fp12) => Fp12;\n};\n\nexport function tower12(opts: Tower12Opts): {\n  Fp: Readonly<mod.IField<bigint> & Required<Pick<mod.IField<bigint>, 'isOdd'>>>;\n  Fp2: mod.IField<Fp2> & {\n    NONRESIDUE: Fp2;\n    fromBigTuple: (tuple: BigintTuple | bigint[]) => Fp2;\n    reim: (num: Fp2) => { re: bigint; im: bigint };\n    mulByNonresidue: (num: Fp2) => Fp2;\n    mulByB: (num: Fp2) => Fp2;\n    frobeniusMap(num: Fp2, power: number): Fp2;\n  };\n  Fp6: mod.IField<Fp6> & {\n    fromBigSix: (tuple: BigintSix) => Fp6;\n    mulByNonresidue: (num: Fp6) => Fp6;\n    frobeniusMap(num: Fp6, power: number): Fp6;\n    mul1(num: Fp6, b1: Fp2): Fp6;\n    mul01(num: Fp6, b0: Fp2, b1: Fp2): Fp6;\n    mulByFp2(lhs: Fp6, rhs: Fp2): Fp6;\n  };\n  Fp4Square: (a: Fp2, b: Fp2) => { first: Fp2; second: Fp2 };\n  Fp12: mod.IField<Fp12> & {\n    fromBigTwelve: (t: BigintTwelve) => Fp12;\n    frobeniusMap(num: Fp12, power: number): Fp12;\n    mul014(num: Fp12, o0: Fp2, o1: Fp2, o4: Fp2): Fp12;\n    mul034(num: Fp12, o0: Fp2, o3: Fp2, o4: Fp2): Fp12;\n    mulByFp2(lhs: Fp12, rhs: Fp2): Fp12;\n    conjugate(num: Fp12): Fp12;\n    finalExponentiate(num: Fp12): Fp12;\n    _cyclotomicSquare(num: Fp12): Fp12;\n    _cyclotomicExp(num: Fp12, n: bigint): Fp12;\n  };\n} {\n  const { ORDER } = opts;\n  // Fp\n  const Fp = mod.Field(ORDER);\n  const FpNONRESIDUE = Fp.create(opts.NONRESIDUE || BigInt(-1));\n  const Fpdiv2 = Fp.div(Fp.ONE, _2n); // 1/2\n\n  // Fp2\n  const FP2_FROBENIUS_COEFFICIENTS = calcFrobeniusCoefficients(Fp, FpNONRESIDUE, Fp.ORDER, 2)[0];\n  const Fp2Add = ({ c0, c1 }: Fp2, { c0: r0, c1: r1 }: Fp2) => ({\n    c0: Fp.add(c0, r0),\n    c1: Fp.add(c1, r1),\n  });\n  const Fp2Subtract = ({ c0, c1 }: Fp2, { c0: r0, c1: r1 }: Fp2) => ({\n    c0: Fp.sub(c0, r0),\n    c1: Fp.sub(c1, r1),\n  });\n  const Fp2Multiply = ({ c0, c1 }: Fp2, rhs: Fp2) => {\n    if (typeof rhs === 'bigint') return { c0: Fp.mul(c0, rhs), c1: Fp.mul(c1, rhs) };\n    // (a+bi)(c+di) = (ac−bd) + (ad+bc)i\n    const { c0: r0, c1: r1 } = rhs;\n    let t1 = Fp.mul(c0, r0); // c0 * o0\n    let t2 = Fp.mul(c1, r1); // c1 * o1\n    // (T1 - T2) + ((c0 + c1) * (r0 + r1) - (T1 + T2))*i\n    const o0 = Fp.sub(t1, t2);\n    const o1 = Fp.sub(Fp.mul(Fp.add(c0, c1), Fp.add(r0, r1)), Fp.add(t1, t2));\n    return { c0: o0, c1: o1 };\n  };\n  const Fp2Square = ({ c0, c1 }: Fp2) => {\n    const a = Fp.add(c0, c1);\n    const b = Fp.sub(c0, c1);\n    const c = Fp.add(c0, c0);\n    return { c0: Fp.mul(a, b), c1: Fp.mul(c, c1) };\n  };\n  type Fp2Utils = {\n    NONRESIDUE: Fp2;\n    fromBigTuple: (tuple: BigintTuple | bigint[]) => Fp2;\n    reim: (num: Fp2) => { re: bigint; im: bigint };\n    mulByNonresidue: (num: Fp2) => Fp2;\n    mulByB: (num: Fp2) => Fp2;\n    frobeniusMap(num: Fp2, power: number): Fp2;\n  };\n  const Fp2fromBigTuple = (tuple: BigintTuple | bigint[]) => {\n    if (tuple.length !== 2) throw new Error('invalid tuple');\n    const fps = tuple.map((n) => Fp.create(n)) as [Fp, Fp];\n    return { c0: fps[0], c1: fps[1] };\n  };\n\n  const FP2_ORDER = ORDER * ORDER;\n  const Fp2Nonresidue = Fp2fromBigTuple(opts.FP2_NONRESIDUE);\n  const Fp2: mod.IField<Fp2> & Fp2Utils = {\n    ORDER: FP2_ORDER,\n    isLE: Fp.isLE,\n    NONRESIDUE: Fp2Nonresidue,\n    BITS: bitLen(FP2_ORDER),\n    BYTES: Math.ceil(bitLen(FP2_ORDER) / 8),\n    MASK: bitMask(bitLen(FP2_ORDER)),\n    ZERO: { c0: Fp.ZERO, c1: Fp.ZERO },\n    ONE: { c0: Fp.ONE, c1: Fp.ZERO },\n    create: (num) => num,\n    isValid: ({ c0, c1 }) => typeof c0 === 'bigint' && typeof c1 === 'bigint',\n    is0: ({ c0, c1 }) => Fp.is0(c0) && Fp.is0(c1),\n    eql: ({ c0, c1 }: Fp2, { c0: r0, c1: r1 }: Fp2) => Fp.eql(c0, r0) && Fp.eql(c1, r1),\n    neg: ({ c0, c1 }) => ({ c0: Fp.neg(c0), c1: Fp.neg(c1) }),\n    pow: (num, power) => mod.FpPow(Fp2, num, power),\n    invertBatch: (nums) => mod.FpInvertBatch(Fp2, nums),\n    // Normalized\n    add: Fp2Add,\n    sub: Fp2Subtract,\n    mul: Fp2Multiply,\n    sqr: Fp2Square,\n    // NonNormalized stuff\n    addN: Fp2Add,\n    subN: Fp2Subtract,\n    mulN: Fp2Multiply,\n    sqrN: Fp2Square,\n    // Why inversion for bigint inside Fp instead of Fp2? it is even used in that context?\n    div: (lhs, rhs) =>\n      Fp2.mul(lhs, typeof rhs === 'bigint' ? Fp.inv(Fp.create(rhs)) : Fp2.inv(rhs)),\n    inv: ({ c0: a, c1: b }) => {\n      // We wish to find the multiplicative inverse of a nonzero\n      // element a + bu in Fp2. We leverage an identity\n      //\n      // (a + bu)(a - bu) = a² + b²\n      //\n      // which holds because u² = -1. This can be rewritten as\n      //\n      // (a + bu)(a - bu)/(a² + b²) = 1\n      //\n      // because a² + b² = 0 has no nonzero solutions for (a, b).\n      // This gives that (a - bu)/(a² + b²) is the inverse\n      // of (a + bu). Importantly, this can be computing using\n      // only a single inversion in Fp.\n      const factor = Fp.inv(Fp.create(a * a + b * b));\n      return { c0: Fp.mul(factor, Fp.create(a)), c1: Fp.mul(factor, Fp.create(-b)) };\n    },\n    sqrt: (num) => {\n      if (opts.Fp2sqrt) return opts.Fp2sqrt(num);\n      // This is generic for all quadratic extensions (Fp2)\n      const { c0, c1 } = num;\n      if (Fp.is0(c1)) {\n        // if c0 is quadratic residue\n        if (mod.FpLegendre(Fp, c0) === 1) return Fp2.create({ c0: Fp.sqrt(c0), c1: Fp.ZERO });\n        else return Fp2.create({ c0: Fp.ZERO, c1: Fp.sqrt(Fp.div(c0, FpNONRESIDUE)) });\n      }\n      const a = Fp.sqrt(Fp.sub(Fp.sqr(c0), Fp.mul(Fp.sqr(c1), FpNONRESIDUE)));\n      let d = Fp.mul(Fp.add(a, c0), Fpdiv2);\n      const legendre = mod.FpLegendre(Fp, d);\n      // -1, Quadratic non residue\n      if (legendre === -1) d = Fp.sub(d, a);\n      const a0 = Fp.sqrt(d);\n      const candidateSqrt = Fp2.create({ c0: a0, c1: Fp.div(Fp.mul(c1, Fpdiv2), a0) });\n      if (!Fp2.eql(Fp2.sqr(candidateSqrt), num)) throw new Error('Cannot find square root');\n      // Normalize root: at this point candidateSqrt ** 2 = num, but also -candidateSqrt ** 2 = num\n      const x1 = candidateSqrt;\n      const x2 = Fp2.neg(x1);\n      const { re: re1, im: im1 } = Fp2.reim(x1);\n      const { re: re2, im: im2 } = Fp2.reim(x2);\n      if (im1 > im2 || (im1 === im2 && re1 > re2)) return x1;\n      return x2;\n    },\n    // Same as sgn0_m_eq_2 in RFC 9380\n    isOdd: (x: Fp2) => {\n      const { re: x0, im: x1 } = Fp2.reim(x);\n      const sign_0 = x0 % _2n;\n      const zero_0 = x0 === _0n;\n      const sign_1 = x1 % _2n;\n      return BigInt(sign_0 || (zero_0 && sign_1)) == _1n;\n    },\n    // Bytes util\n    fromBytes(b: Uint8Array): Fp2 {\n      if (b.length !== Fp2.BYTES) throw new Error('fromBytes invalid length=' + b.length);\n      return { c0: Fp.fromBytes(b.subarray(0, Fp.BYTES)), c1: Fp.fromBytes(b.subarray(Fp.BYTES)) };\n    },\n    toBytes: ({ c0, c1 }) => concatBytes(Fp.toBytes(c0), Fp.toBytes(c1)),\n    cmov: ({ c0, c1 }, { c0: r0, c1: r1 }, c) => ({\n      c0: Fp.cmov(c0, r0, c),\n      c1: Fp.cmov(c1, r1, c),\n    }),\n    reim: ({ c0, c1 }) => ({ re: c0, im: c1 }),\n    // multiply by u + 1\n    mulByNonresidue: ({ c0, c1 }) => Fp2.mul({ c0, c1 }, Fp2Nonresidue),\n    mulByB: opts.Fp2mulByB,\n    fromBigTuple: Fp2fromBigTuple,\n    frobeniusMap: ({ c0, c1 }, power: number): Fp2 => ({\n      c0,\n      c1: Fp.mul(c1, FP2_FROBENIUS_COEFFICIENTS[power % 2]),\n    }),\n  };\n  // Fp6\n  const Fp6Add = ({ c0, c1, c2 }: Fp6, { c0: r0, c1: r1, c2: r2 }: Fp6) => ({\n    c0: Fp2.add(c0, r0),\n    c1: Fp2.add(c1, r1),\n    c2: Fp2.add(c2, r2),\n  });\n  const Fp6Subtract = ({ c0, c1, c2 }: Fp6, { c0: r0, c1: r1, c2: r2 }: Fp6) => ({\n    c0: Fp2.sub(c0, r0),\n    c1: Fp2.sub(c1, r1),\n    c2: Fp2.sub(c2, r2),\n  });\n  const Fp6Multiply = ({ c0, c1, c2 }: Fp6, rhs: Fp6 | bigint) => {\n    if (typeof rhs === 'bigint') {\n      return {\n        c0: Fp2.mul(c0, rhs),\n        c1: Fp2.mul(c1, rhs),\n        c2: Fp2.mul(c2, rhs),\n      };\n    }\n    const { c0: r0, c1: r1, c2: r2 } = rhs;\n    const t0 = Fp2.mul(c0, r0); // c0 * o0\n    const t1 = Fp2.mul(c1, r1); // c1 * o1\n    const t2 = Fp2.mul(c2, r2); // c2 * o2\n    return {\n      // t0 + (c1 + c2) * (r1 * r2) - (T1 + T2) * (u + 1)\n      c0: Fp2.add(\n        t0,\n        Fp2.mulByNonresidue(Fp2.sub(Fp2.mul(Fp2.add(c1, c2), Fp2.add(r1, r2)), Fp2.add(t1, t2)))\n      ),\n      // (c0 + c1) * (r0 + r1) - (T0 + T1) + T2 * (u + 1)\n      c1: Fp2.add(\n        Fp2.sub(Fp2.mul(Fp2.add(c0, c1), Fp2.add(r0, r1)), Fp2.add(t0, t1)),\n        Fp2.mulByNonresidue(t2)\n      ),\n      // T1 + (c0 + c2) * (r0 + r2) - T0 + T2\n      c2: Fp2.sub(Fp2.add(t1, Fp2.mul(Fp2.add(c0, c2), Fp2.add(r0, r2))), Fp2.add(t0, t2)),\n    };\n  };\n  const Fp6Square = ({ c0, c1, c2 }: Fp6) => {\n    let t0 = Fp2.sqr(c0); // c0²\n    let t1 = Fp2.mul(Fp2.mul(c0, c1), _2n); // 2 * c0 * c1\n    let t3 = Fp2.mul(Fp2.mul(c1, c2), _2n); // 2 * c1 * c2\n    let t4 = Fp2.sqr(c2); // c2²\n    return {\n      c0: Fp2.add(Fp2.mulByNonresidue(t3), t0), // T3 * (u + 1) + T0\n      c1: Fp2.add(Fp2.mulByNonresidue(t4), t1), // T4 * (u + 1) + T1\n      // T1 + (c0 - c1 + c2)² + T3 - T0 - T4\n      c2: Fp2.sub(Fp2.sub(Fp2.add(Fp2.add(t1, Fp2.sqr(Fp2.add(Fp2.sub(c0, c1), c2))), t3), t0), t4),\n    };\n  };\n  type Fp6Utils = {\n    fromBigSix: (tuple: BigintSix) => Fp6;\n    mulByNonresidue: (num: Fp6) => Fp6;\n    frobeniusMap(num: Fp6, power: number): Fp6;\n    mul1(num: Fp6, b1: Fp2): Fp6;\n    mul01(num: Fp6, b0: Fp2, b1: Fp2): Fp6;\n    mulByFp2(lhs: Fp6, rhs: Fp2): Fp6;\n  };\n\n  const [FP6_FROBENIUS_COEFFICIENTS_1, FP6_FROBENIUS_COEFFICIENTS_2] = calcFrobeniusCoefficients(\n    Fp2,\n    Fp2Nonresidue,\n    Fp.ORDER,\n    6,\n    2,\n    3\n  );\n\n  const Fp6: mod.IField<Fp6> & Fp6Utils = {\n    ORDER: Fp2.ORDER, // TODO: unused, but need to verify\n    isLE: Fp2.isLE,\n    BITS: 3 * Fp2.BITS,\n    BYTES: 3 * Fp2.BYTES,\n    MASK: bitMask(3 * Fp2.BITS),\n    ZERO: { c0: Fp2.ZERO, c1: Fp2.ZERO, c2: Fp2.ZERO },\n    ONE: { c0: Fp2.ONE, c1: Fp2.ZERO, c2: Fp2.ZERO },\n    create: (num) => num,\n    isValid: ({ c0, c1, c2 }) => Fp2.isValid(c0) && Fp2.isValid(c1) && Fp2.isValid(c2),\n    is0: ({ c0, c1, c2 }) => Fp2.is0(c0) && Fp2.is0(c1) && Fp2.is0(c2),\n    neg: ({ c0, c1, c2 }) => ({ c0: Fp2.neg(c0), c1: Fp2.neg(c1), c2: Fp2.neg(c2) }),\n    eql: ({ c0, c1, c2 }, { c0: r0, c1: r1, c2: r2 }) =>\n      Fp2.eql(c0, r0) && Fp2.eql(c1, r1) && Fp2.eql(c2, r2),\n    sqrt: notImplemented,\n    // Do we need division by bigint at all? Should be done via order:\n    div: (lhs, rhs) =>\n      Fp6.mul(lhs, typeof rhs === 'bigint' ? Fp.inv(Fp.create(rhs)) : Fp6.inv(rhs)),\n    pow: (num, power) => mod.FpPow(Fp6, num, power),\n    invertBatch: (nums) => mod.FpInvertBatch(Fp6, nums),\n    // Normalized\n    add: Fp6Add,\n    sub: Fp6Subtract,\n    mul: Fp6Multiply,\n    sqr: Fp6Square,\n    // NonNormalized stuff\n    addN: Fp6Add,\n    subN: Fp6Subtract,\n    mulN: Fp6Multiply,\n    sqrN: Fp6Square,\n\n    inv: ({ c0, c1, c2 }) => {\n      let t0 = Fp2.sub(Fp2.sqr(c0), Fp2.mulByNonresidue(Fp2.mul(c2, c1))); // c0² - c2 * c1 * (u + 1)\n      let t1 = Fp2.sub(Fp2.mulByNonresidue(Fp2.sqr(c2)), Fp2.mul(c0, c1)); // c2² * (u + 1) - c0 * c1\n      let t2 = Fp2.sub(Fp2.sqr(c1), Fp2.mul(c0, c2)); // c1² - c0 * c2\n      // 1/(((c2 * T1 + c1 * T2) * v) + c0 * T0)\n      let t4 = Fp2.inv(\n        Fp2.add(Fp2.mulByNonresidue(Fp2.add(Fp2.mul(c2, t1), Fp2.mul(c1, t2))), Fp2.mul(c0, t0))\n      );\n      return { c0: Fp2.mul(t4, t0), c1: Fp2.mul(t4, t1), c2: Fp2.mul(t4, t2) };\n    },\n    // Bytes utils\n    fromBytes: (b: Uint8Array): Fp6 => {\n      if (b.length !== Fp6.BYTES) throw new Error('fromBytes invalid length=' + b.length);\n      return {\n        c0: Fp2.fromBytes(b.subarray(0, Fp2.BYTES)),\n        c1: Fp2.fromBytes(b.subarray(Fp2.BYTES, 2 * Fp2.BYTES)),\n        c2: Fp2.fromBytes(b.subarray(2 * Fp2.BYTES)),\n      };\n    },\n    toBytes: ({ c0, c1, c2 }): Uint8Array =>\n      concatBytes(Fp2.toBytes(c0), Fp2.toBytes(c1), Fp2.toBytes(c2)),\n    cmov: ({ c0, c1, c2 }: Fp6, { c0: r0, c1: r1, c2: r2 }: Fp6, c) => ({\n      c0: Fp2.cmov(c0, r0, c),\n      c1: Fp2.cmov(c1, r1, c),\n      c2: Fp2.cmov(c2, r2, c),\n    }),\n    fromBigSix: (t: BigintSix): Fp6 => {\n      if (!Array.isArray(t) || t.length !== 6) throw new Error('invalid Fp6 usage');\n      return {\n        c0: Fp2.fromBigTuple(t.slice(0, 2)),\n        c1: Fp2.fromBigTuple(t.slice(2, 4)),\n        c2: Fp2.fromBigTuple(t.slice(4, 6)),\n      };\n    },\n    frobeniusMap: ({ c0, c1, c2 }, power: number) => ({\n      c0: Fp2.frobeniusMap(c0, power),\n      c1: Fp2.mul(Fp2.frobeniusMap(c1, power), FP6_FROBENIUS_COEFFICIENTS_1[power % 6]),\n      c2: Fp2.mul(Fp2.frobeniusMap(c2, power), FP6_FROBENIUS_COEFFICIENTS_2[power % 6]),\n    }),\n    mulByFp2: ({ c0, c1, c2 }, rhs: Fp2): Fp6 => ({\n      c0: Fp2.mul(c0, rhs),\n      c1: Fp2.mul(c1, rhs),\n      c2: Fp2.mul(c2, rhs),\n    }),\n    mulByNonresidue: ({ c0, c1, c2 }) => ({ c0: Fp2.mulByNonresidue(c2), c1: c0, c2: c1 }),\n    // Sparse multiplication\n    mul1: ({ c0, c1, c2 }, b1: Fp2): Fp6 => ({\n      c0: Fp2.mulByNonresidue(Fp2.mul(c2, b1)),\n      c1: Fp2.mul(c0, b1),\n      c2: Fp2.mul(c1, b1),\n    }),\n    // Sparse multiplication\n    mul01({ c0, c1, c2 }, b0: Fp2, b1: Fp2): Fp6 {\n      let t0 = Fp2.mul(c0, b0); // c0 * b0\n      let t1 = Fp2.mul(c1, b1); // c1 * b1\n      return {\n        // ((c1 + c2) * b1 - T1) * (u + 1) + T0\n        c0: Fp2.add(Fp2.mulByNonresidue(Fp2.sub(Fp2.mul(Fp2.add(c1, c2), b1), t1)), t0),\n        // (b0 + b1) * (c0 + c1) - T0 - T1\n        c1: Fp2.sub(Fp2.sub(Fp2.mul(Fp2.add(b0, b1), Fp2.add(c0, c1)), t0), t1),\n        // (c0 + c2) * b0 - T0 + T1\n        c2: Fp2.add(Fp2.sub(Fp2.mul(Fp2.add(c0, c2), b0), t0), t1),\n      };\n    },\n  };\n\n  // Fp12\n  const FP12_FROBENIUS_COEFFICIENTS = calcFrobeniusCoefficients(\n    Fp2,\n    Fp2Nonresidue,\n    Fp.ORDER,\n    12,\n    1,\n    6\n  )[0];\n\n  const Fp12Add = ({ c0, c1 }: Fp12, { c0: r0, c1: r1 }: Fp12) => ({\n    c0: Fp6.add(c0, r0),\n    c1: Fp6.add(c1, r1),\n  });\n  const Fp12Subtract = ({ c0, c1 }: Fp12, { c0: r0, c1: r1 }: Fp12) => ({\n    c0: Fp6.sub(c0, r0),\n    c1: Fp6.sub(c1, r1),\n  });\n  const Fp12Multiply = ({ c0, c1 }: Fp12, rhs: Fp12 | bigint) => {\n    if (typeof rhs === 'bigint') return { c0: Fp6.mul(c0, rhs), c1: Fp6.mul(c1, rhs) };\n    let { c0: r0, c1: r1 } = rhs;\n    let t1 = Fp6.mul(c0, r0); // c0 * r0\n    let t2 = Fp6.mul(c1, r1); // c1 * r1\n    return {\n      c0: Fp6.add(t1, Fp6.mulByNonresidue(t2)), // T1 + T2 * v\n      // (c0 + c1) * (r0 + r1) - (T1 + T2)\n      c1: Fp6.sub(Fp6.mul(Fp6.add(c0, c1), Fp6.add(r0, r1)), Fp6.add(t1, t2)),\n    };\n  };\n  const Fp12Square = ({ c0, c1 }: Fp12) => {\n    let ab = Fp6.mul(c0, c1); // c0 * c1\n    return {\n      // (c1 * v + c0) * (c0 + c1) - AB - AB * v\n      c0: Fp6.sub(\n        Fp6.sub(Fp6.mul(Fp6.add(Fp6.mulByNonresidue(c1), c0), Fp6.add(c0, c1)), ab),\n        Fp6.mulByNonresidue(ab)\n      ),\n      c1: Fp6.add(ab, ab),\n    }; // AB + AB\n  };\n  function Fp4Square(a: Fp2, b: Fp2): { first: Fp2; second: Fp2 } {\n    const a2 = Fp2.sqr(a);\n    const b2 = Fp2.sqr(b);\n    return {\n      first: Fp2.add(Fp2.mulByNonresidue(b2), a2), // b² * Nonresidue + a²\n      second: Fp2.sub(Fp2.sub(Fp2.sqr(Fp2.add(a, b)), a2), b2), // (a + b)² - a² - b²\n    };\n  }\n  type Fp12Utils = {\n    fromBigTwelve: (t: BigintTwelve) => Fp12;\n    frobeniusMap(num: Fp12, power: number): Fp12;\n    mul014(num: Fp12, o0: Fp2, o1: Fp2, o4: Fp2): Fp12;\n    mul034(num: Fp12, o0: Fp2, o3: Fp2, o4: Fp2): Fp12;\n    mulByFp2(lhs: Fp12, rhs: Fp2): Fp12;\n    conjugate(num: Fp12): Fp12;\n    finalExponentiate(num: Fp12): Fp12;\n    _cyclotomicSquare(num: Fp12): Fp12;\n    _cyclotomicExp(num: Fp12, n: bigint): Fp12;\n  };\n\n  const Fp12: mod.IField<Fp12> & Fp12Utils = {\n    ORDER: Fp2.ORDER, // TODO: unused, but need to verify\n    isLE: Fp6.isLE,\n    BITS: 2 * Fp6.BITS,\n    BYTES: 2 * Fp6.BYTES,\n    MASK: bitMask(2 * Fp6.BITS),\n    ZERO: { c0: Fp6.ZERO, c1: Fp6.ZERO },\n    ONE: { c0: Fp6.ONE, c1: Fp6.ZERO },\n    create: (num) => num,\n    isValid: ({ c0, c1 }) => Fp6.isValid(c0) && Fp6.isValid(c1),\n    is0: ({ c0, c1 }) => Fp6.is0(c0) && Fp6.is0(c1),\n    neg: ({ c0, c1 }) => ({ c0: Fp6.neg(c0), c1: Fp6.neg(c1) }),\n    eql: ({ c0, c1 }, { c0: r0, c1: r1 }) => Fp6.eql(c0, r0) && Fp6.eql(c1, r1),\n    sqrt: notImplemented,\n    inv: ({ c0, c1 }) => {\n      let t = Fp6.inv(Fp6.sub(Fp6.sqr(c0), Fp6.mulByNonresidue(Fp6.sqr(c1)))); // 1 / (c0² - c1² * v)\n      return { c0: Fp6.mul(c0, t), c1: Fp6.neg(Fp6.mul(c1, t)) }; // ((C0 * T) * T) + (-C1 * T) * w\n    },\n    div: (lhs, rhs) =>\n      Fp12.mul(lhs, typeof rhs === 'bigint' ? Fp.inv(Fp.create(rhs)) : Fp12.inv(rhs)),\n    pow: (num, power) => mod.FpPow(Fp12, num, power),\n    invertBatch: (nums) => mod.FpInvertBatch(Fp12, nums),\n    // Normalized\n    add: Fp12Add,\n    sub: Fp12Subtract,\n    mul: Fp12Multiply,\n    sqr: Fp12Square,\n    // NonNormalized stuff\n    addN: Fp12Add,\n    subN: Fp12Subtract,\n    mulN: Fp12Multiply,\n    sqrN: Fp12Square,\n\n    // Bytes utils\n    fromBytes: (b: Uint8Array): Fp12 => {\n      if (b.length !== Fp12.BYTES) throw new Error('fromBytes invalid length=' + b.length);\n      return {\n        c0: Fp6.fromBytes(b.subarray(0, Fp6.BYTES)),\n        c1: Fp6.fromBytes(b.subarray(Fp6.BYTES)),\n      };\n    },\n    toBytes: ({ c0, c1 }): Uint8Array => concatBytes(Fp6.toBytes(c0), Fp6.toBytes(c1)),\n    cmov: ({ c0, c1 }, { c0: r0, c1: r1 }, c) => ({\n      c0: Fp6.cmov(c0, r0, c),\n      c1: Fp6.cmov(c1, r1, c),\n    }),\n    // Utils\n    // toString() {\n    //   return '' + 'Fp12(' + this.c0 + this.c1 + '* w');\n    // },\n    // fromTuple(c: [Fp6, Fp6]) {\n    //   return new Fp12(...c);\n    // }\n    fromBigTwelve: (t: BigintTwelve): Fp12 => ({\n      c0: Fp6.fromBigSix(t.slice(0, 6) as BigintSix),\n      c1: Fp6.fromBigSix(t.slice(6, 12) as BigintSix),\n    }),\n    // Raises to q**i -th power\n    frobeniusMap(lhs, power: number) {\n      const { c0, c1, c2 } = Fp6.frobeniusMap(lhs.c1, power);\n      const coeff = FP12_FROBENIUS_COEFFICIENTS[power % 12];\n      return {\n        c0: Fp6.frobeniusMap(lhs.c0, power),\n        c1: Fp6.create({\n          c0: Fp2.mul(c0, coeff),\n          c1: Fp2.mul(c1, coeff),\n          c2: Fp2.mul(c2, coeff),\n        }),\n      };\n    },\n    mulByFp2: ({ c0, c1 }, rhs: Fp2): Fp12 => ({\n      c0: Fp6.mulByFp2(c0, rhs),\n      c1: Fp6.mulByFp2(c1, rhs),\n    }),\n    conjugate: ({ c0, c1 }): Fp12 => ({ c0, c1: Fp6.neg(c1) }),\n    // Sparse multiplication\n    mul014: ({ c0, c1 }, o0: Fp2, o1: Fp2, o4: Fp2) => {\n      let t0 = Fp6.mul01(c0, o0, o1);\n      let t1 = Fp6.mul1(c1, o4);\n      return {\n        c0: Fp6.add(Fp6.mulByNonresidue(t1), t0), // T1 * v + T0\n        // (c1 + c0) * [o0, o1+o4] - T0 - T1\n        c1: Fp6.sub(Fp6.sub(Fp6.mul01(Fp6.add(c1, c0), o0, Fp2.add(o1, o4)), t0), t1),\n      };\n    },\n    mul034: ({ c0, c1 }, o0: Fp2, o3: Fp2, o4: Fp2) => {\n      const a = Fp6.create({\n        c0: Fp2.mul(c0.c0, o0),\n        c1: Fp2.mul(c0.c1, o0),\n        c2: Fp2.mul(c0.c2, o0),\n      });\n      const b = Fp6.mul01(c1, o3, o4);\n      const e = Fp6.mul01(Fp6.add(c0, c1), Fp2.add(o0, o3), o4);\n      return {\n        c0: Fp6.add(Fp6.mulByNonresidue(b), a),\n        c1: Fp6.sub(e, Fp6.add(a, b)),\n      };\n    },\n\n    // A cyclotomic group is a subgroup of Fp^n defined by\n    //   GΦₙ(p) = {α ∈ Fpⁿ : α^Φₙ(p) = 1}\n    // The result of any pairing is in a cyclotomic subgroup\n    // https://eprint.iacr.org/2009/565.pdf\n    _cyclotomicSquare: opts.Fp12cyclotomicSquare,\n    _cyclotomicExp: opts.Fp12cyclotomicExp,\n    // https://eprint.iacr.org/2010/354.pdf\n    // https://eprint.iacr.org/2009/565.pdf\n    finalExponentiate: opts.Fp12finalExponentiate,\n  };\n\n  return { Fp, Fp2, Fp6, Fp4Square, Fp12 };\n}\n", "/**\n * bls12-381 is pairing-friendly Barreto-Lynn-Scott elliptic curve construction allowing to:\n * * Construct zk-SNARKs at the ~120-bit security\n * * Efficiently verify N aggregate signatures with 1 pairing and N ec additions:\n *   the Boneh-Lynn-Shacham signature scheme is orders of magnitude more efficient than Schnorr\n *\n * ### Summary\n * 1. BLS Relies on Bilinear Pairing (expensive)\n * 2. Private Keys: 32 bytes\n * 3. Public Keys: 48 bytes: 381 bit affine x coordinate, encoded into 48 big-endian bytes.\n * 4. Signatures: 96 bytes: two 381 bit integers (affine x coordinate), encoded into two 48 big-endian byte arrays.\n *     - The signature is a point on the G2 subgroup, which is defined over a finite field\n *       with elements twice as big as the G1 curve (G2 is over Fp2 rather than Fp. Fp2 is analogous to the\n *       complex numbers).\n *     - We also support reversed 96-byte pubkeys & 48-byte short signatures.\n * 5. The 12 stands for the Embedding degree.\n *\n * ### Formulas\n * - `P = pk x G` - public keys\n * - `S = pk x H(m)` - signing\n * - `e(P, H(m)) == e(G, S)` - verification using pairings\n * - `e(G, S) = e(G, SUM(n)(Si)) = MUL(n)(e(G, Si))` - signature aggregation\n *\n * ### Compatibility and notes\n * 1. It is compatible with Algorand, Chia, Dfinity, Ethereum, Filecoin, ZEC.\n * Filecoin uses little endian byte arrays for private keys - make sure to reverse byte order.\n * 2. Some projects use G2 for public keys and G1 for signatures. It's called \"short signature\".\n * 3. Curve security level is about 120 bits as per [Barbulescu-Duquesne 2017](https://hal.science/hal-01534101/file/main.pdf)\n * 4. Compatible with specs:\n *    [cfrg-pairing-friendly-curves-11](https://tools.ietf.org/html/draft-irtf-cfrg-pairing-friendly-curves-11),\n *    [cfrg-bls-signature-05](https://www.rfc-editor.org/rfc/draft-irtf-cfrg-bls-signature-05),\n *    RFC 9380.\n *\n * ### Params\n * To verify curve parameters, see\n * [pairing-friendly-curves spec](https://www.rfc-editor.org/rfc/draft-irtf-cfrg-pairing-friendly-curves-11).\n * Basic math is done over finite fields over p.\n * More complicated math is done over polynominal extension fields.\n * To simplify calculations in Fp12, we construct extension tower:\n *\n * Embedding degree (k): 12\n * Seed (X): -15132376222941642752\n * Fr:  (x⁴-x²+1)\n * Fp: ((x-1)² ⋅ r(x)/3+x)\n * (E/Fp): Y²=X³+4\n * (Eₜ/Fp²): Y² = X³+4(u+1) (M-type twist)\n * Ate loop size: X\n *\n * ### Towers\n * - Fp₁₂ = Fp₆² => Fp₂³\n * - Fp(u) / (u² - β) where β = -1\n * - Fp₂(v) / (v³ - ξ) where ξ = u + 1\n * - Fp₆(w) / (w² - γ) where γ = v\n * - Fp²[u] = Fp/u²+1\n * - Fp⁶[v] = Fp²/v³-1-u\n * - Fp¹²[w] = Fp⁶/w²-v\n *\n * @todo construct bls & bn fp/fr from seed.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha256 } from '@noble/hashes/sha2';\nimport { randomBytes } from '@noble/hashes/utils';\nimport { bls, type CurveFn } from './abstract/bls.ts';\nimport { Field } from './abstract/modular.ts';\nimport {\n  bitGet,\n  bitLen,\n  bytesToHex,\n  bytesToNumberBE,\n  concatBytes as concatB,\n  ensureBytes,\n  numberToBytesBE,\n  type Hex,\n} from './abstract/utils.ts';\n// Types\nimport { isogenyMap } from './abstract/hash-to-curve.ts';\nimport type { Fp, Fp12, Fp2, Fp6 } from './abstract/tower.ts';\nimport { psiFrobenius, tower12 } from './abstract/tower.ts';\nimport {\n  mapToCurveSimpleSWU,\n  type AffinePoint,\n  type ProjPointType,\n} from './abstract/weierstrass.ts';\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\n\n// The BLS parameter x (seed) for BLS12-381. NOTE: it is negative!\nconst BLS_X = BigInt('0xd201000000010000');\nconst BLS_X_LEN = bitLen(BLS_X);\n\n// CURVE FIELDS\nconst { Fp, Fp2, Fp6, Fp4Square, Fp12 } = tower12({\n  // Order of Fp\n  ORDER: BigInt(\n    '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'\n  ),\n  // Finite extension field over irreducible polynominal.\n  // Fp(u) / (u² - β) where β = -1\n  FP2_NONRESIDUE: [_1n, _1n],\n  Fp2mulByB: ({ c0, c1 }) => {\n    const t0 = Fp.mul(c0, _4n); // 4 * c0\n    const t1 = Fp.mul(c1, _4n); // 4 * c1\n    // (T0-T1) + (T0+T1)*i\n    return { c0: Fp.sub(t0, t1), c1: Fp.add(t0, t1) };\n  },\n  // Fp12\n  // A cyclotomic group is a subgroup of Fp^n defined by\n  //   GΦₙ(p) = {α ∈ Fpⁿ : α^Φₙ(p) = 1}\n  // The result of any pairing is in a cyclotomic subgroup\n  // https://eprint.iacr.org/2009/565.pdf\n  Fp12cyclotomicSquare: ({ c0, c1 }): Fp12 => {\n    const { c0: c0c0, c1: c0c1, c2: c0c2 } = c0;\n    const { c0: c1c0, c1: c1c1, c2: c1c2 } = c1;\n    const { first: t3, second: t4 } = Fp4Square(c0c0, c1c1);\n    const { first: t5, second: t6 } = Fp4Square(c1c0, c0c2);\n    const { first: t7, second: t8 } = Fp4Square(c0c1, c1c2);\n    const t9 = Fp2.mulByNonresidue(t8); // T8 * (u + 1)\n    return {\n      c0: Fp6.create({\n        c0: Fp2.add(Fp2.mul(Fp2.sub(t3, c0c0), _2n), t3), // 2 * (T3 - c0c0)  + T3\n        c1: Fp2.add(Fp2.mul(Fp2.sub(t5, c0c1), _2n), t5), // 2 * (T5 - c0c1)  + T5\n        c2: Fp2.add(Fp2.mul(Fp2.sub(t7, c0c2), _2n), t7),\n      }), // 2 * (T7 - c0c2)  + T7\n      c1: Fp6.create({\n        c0: Fp2.add(Fp2.mul(Fp2.add(t9, c1c0), _2n), t9), // 2 * (T9 + c1c0) + T9\n        c1: Fp2.add(Fp2.mul(Fp2.add(t4, c1c1), _2n), t4), // 2 * (T4 + c1c1) + T4\n        c2: Fp2.add(Fp2.mul(Fp2.add(t6, c1c2), _2n), t6),\n      }),\n    }; // 2 * (T6 + c1c2) + T6\n  },\n  Fp12cyclotomicExp(num, n) {\n    let z = Fp12.ONE;\n    for (let i = BLS_X_LEN - 1; i >= 0; i--) {\n      z = Fp12._cyclotomicSquare(z);\n      if (bitGet(n, i)) z = Fp12.mul(z, num);\n    }\n    return z;\n  },\n  // https://eprint.iacr.org/2010/354.pdf\n  // https://eprint.iacr.org/2009/565.pdf\n  Fp12finalExponentiate: (num) => {\n    const x = BLS_X;\n    // this^(q⁶) / this\n    const t0 = Fp12.div(Fp12.frobeniusMap(num, 6), num);\n    // t0^(q²) * t0\n    const t1 = Fp12.mul(Fp12.frobeniusMap(t0, 2), t0);\n    const t2 = Fp12.conjugate(Fp12._cyclotomicExp(t1, x));\n    const t3 = Fp12.mul(Fp12.conjugate(Fp12._cyclotomicSquare(t1)), t2);\n    const t4 = Fp12.conjugate(Fp12._cyclotomicExp(t3, x));\n    const t5 = Fp12.conjugate(Fp12._cyclotomicExp(t4, x));\n    const t6 = Fp12.mul(Fp12.conjugate(Fp12._cyclotomicExp(t5, x)), Fp12._cyclotomicSquare(t2));\n    const t7 = Fp12.conjugate(Fp12._cyclotomicExp(t6, x));\n    const t2_t5_pow_q2 = Fp12.frobeniusMap(Fp12.mul(t2, t5), 2);\n    const t4_t1_pow_q3 = Fp12.frobeniusMap(Fp12.mul(t4, t1), 3);\n    const t6_t1c_pow_q1 = Fp12.frobeniusMap(Fp12.mul(t6, Fp12.conjugate(t1)), 1);\n    const t7_t3c_t1 = Fp12.mul(Fp12.mul(t7, Fp12.conjugate(t3)), t1);\n    // (t2 * t5)^(q²) * (t4 * t1)^(q³) * (t6 * t1.conj)^(q^1) * t7 * t3.conj * t1\n    return Fp12.mul(Fp12.mul(Fp12.mul(t2_t5_pow_q2, t4_t1_pow_q3), t6_t1c_pow_q1), t7_t3c_t1);\n  },\n});\n\n// Finite field over r.\n// This particular field is not used anywhere in bls12-381, but it is still useful.\nconst Fr = Field(BigInt('0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001'));\n\n// END OF CURVE FIELDS\n\n// HashToCurve\n\n// 3-isogeny map from E' to E https://www.rfc-editor.org/rfc/rfc9380#appendix-E.3\nconst isogenyMapG2 = isogenyMap(\n  Fp2,\n  [\n    // xNum\n    [\n      [\n        '0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6',\n        '0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6',\n      ],\n      [\n        '0x0',\n        '0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71a',\n      ],\n      [\n        '0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71e',\n        '0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38d',\n      ],\n      [\n        '0x171d6541fa38ccfaed6dea691f5fb614cb14b4e7f4e810aa22d6108f142b85757098e38d0f671c7188e2aaaaaaaa5ed1',\n        '0x0',\n      ],\n    ],\n    // xDen\n    [\n      [\n        '0x0',\n        '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa63',\n      ],\n      [\n        '0xc',\n        '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa9f',\n      ],\n      ['0x1', '0x0'], // LAST 1\n    ],\n    // yNum\n    [\n      [\n        '0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706',\n        '0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706',\n      ],\n      [\n        '0x0',\n        '0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97be',\n      ],\n      [\n        '0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71c',\n        '0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38f',\n      ],\n      [\n        '0x124c9ad43b6cf79bfbf7043de3811ad0761b0f37a1e26286b0e977c69aa274524e79097a56dc4bd9e1b371c71c718b10',\n        '0x0',\n      ],\n    ],\n    // yDen\n    [\n      [\n        '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb',\n        '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb',\n      ],\n      [\n        '0x0',\n        '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa9d3',\n      ],\n      [\n        '0x12',\n        '0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa99',\n      ],\n      ['0x1', '0x0'], // LAST 1\n    ],\n  ].map((i) => i.map((pair) => Fp2.fromBigTuple(pair.map(BigInt)))) as [Fp2[], Fp2[], Fp2[], Fp2[]]\n);\n// 11-isogeny map from E' to E\nconst isogenyMapG1 = isogenyMap(\n  Fp,\n  [\n    // xNum\n    [\n      '0x11a05f2b1e833340b809101dd99815856b303e88a2d7005ff2627b56cdb4e2c85610c2d5f2e62d6eaeac1662734649b7',\n      '0x17294ed3e943ab2f0588bab22147a81c7c17e75b2f6a8417f565e33c70d1e86b4838f2a6f318c356e834eef1b3cb83bb',\n      '0xd54005db97678ec1d1048c5d10a9a1bce032473295983e56878e501ec68e25c958c3e3d2a09729fe0179f9dac9edcb0',\n      '0x1778e7166fcc6db74e0609d307e55412d7f5e4656a8dbf25f1b33289f1b330835336e25ce3107193c5b388641d9b6861',\n      '0xe99726a3199f4436642b4b3e4118e5499db995a1257fb3f086eeb65982fac18985a286f301e77c451154ce9ac8895d9',\n      '0x1630c3250d7313ff01d1201bf7a74ab5db3cb17dd952799b9ed3ab9097e68f90a0870d2dcae73d19cd13c1c66f652983',\n      '0xd6ed6553fe44d296a3726c38ae652bfb11586264f0f8ce19008e218f9c86b2a8da25128c1052ecaddd7f225a139ed84',\n      '0x17b81e7701abdbe2e8743884d1117e53356de5ab275b4db1a682c62ef0f2753339b7c8f8c8f475af9ccb5618e3f0c88e',\n      '0x80d3cf1f9a78fc47b90b33563be990dc43b756ce79f5574a2c596c928c5d1de4fa295f296b74e956d71986a8497e317',\n      '0x169b1f8e1bcfa7c42e0c37515d138f22dd2ecb803a0c5c99676314baf4bb1b7fa3190b2edc0327797f241067be390c9e',\n      '0x10321da079ce07e272d8ec09d2565b0dfa7dccdde6787f96d50af36003b14866f69b771f8c285decca67df3f1605fb7b',\n      '0x6e08c248e260e70bd1e962381edee3d31d79d7e22c837bc23c0bf1bc24c6b68c24b1b80b64d391fa9c8ba2e8ba2d229',\n    ],\n    // xDen\n    [\n      '0x8ca8d548cff19ae18b2e62f4bd3fa6f01d5ef4ba35b48ba9c9588617fc8ac62b558d681be343df8993cf9fa40d21b1c',\n      '0x12561a5deb559c4348b4711298e536367041e8ca0cf0800c0126c2588c48bf5713daa8846cb026e9e5c8276ec82b3bff',\n      '0xb2962fe57a3225e8137e629bff2991f6f89416f5a718cd1fca64e00b11aceacd6a3d0967c94fedcfcc239ba5cb83e19',\n      '0x3425581a58ae2fec83aafef7c40eb545b08243f16b1655154cca8abc28d6fd04976d5243eecf5c4130de8938dc62cd8',\n      '0x13a8e162022914a80a6f1d5f43e7a07dffdfc759a12062bb8d6b44e833b306da9bd29ba81f35781d539d395b3532a21e',\n      '0xe7355f8e4e667b955390f7f0506c6e9395735e9ce9cad4d0a43bcef24b8982f7400d24bc4228f11c02df9a29f6304a5',\n      '0x772caacf16936190f3e0c63e0596721570f5799af53a1894e2e073062aede9cea73b3538f0de06cec2574496ee84a3a',\n      '0x14a7ac2a9d64a8b230b3f5b074cf01996e7f63c21bca68a81996e1cdf9822c580fa5b9489d11e2d311f7d99bbdcc5a5e',\n      '0xa10ecf6ada54f825e920b3dafc7a3cce07f8d1d7161366b74100da67f39883503826692abba43704776ec3a79a1d641',\n      '0x95fc13ab9e92ad4476d6e3eb3a56680f682b4ee96f7d03776df533978f31c1593174e4b4b7865002d6384d168ecdd0a',\n      '0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n      '0x90d97c81ba24ee0259d1f094980dcfa11ad138e48a869522b52af6c956543d3cd0c7aee9b3ba3c2be9845719707bb33',\n      '0x134996a104ee5811d51036d776fb46831223e96c254f383d0f906343eb67ad34d6c56711962fa8bfe097e75a2e41c696',\n      '0xcc786baa966e66f4a384c86a3b49942552e2d658a31ce2c344be4b91400da7d26d521628b00523b8dfe240c72de1f6',\n      '0x1f86376e8981c217898751ad8746757d42aa7b90eeb791c09e4a3ec03251cf9de405aba9ec61deca6355c77b0e5f4cb',\n      '0x8cc03fdefe0ff135caf4fe2a21529c4195536fbe3ce50b879833fd221351adc2ee7f8dc099040a841b6daecf2e8fedb',\n      '0x16603fca40634b6a2211e11db8f0a6a074a7d0d4afadb7bd76505c3d3ad5544e203f6326c95a807299b23ab13633a5f0',\n      '0x4ab0b9bcfac1bbcb2c977d027796b3ce75bb8ca2be184cb5231413c4d634f3747a87ac2460f415ec961f8855fe9d6f2',\n      '0x987c8d5333ab86fde9926bd2ca6c674170a05bfe3bdd81ffd038da6c26c842642f64550fedfe935a15e4ca31870fb29',\n      '0x9fc4018bd96684be88c9e221e4da1bb8f3abd16679dc26c1e8b6e6a1f20cabe69d65201c78607a360370e577bdba587',\n      '0xe1bba7a1186bdb5223abde7ada14a23c42a0ca7915af6fe06985e7ed1e4d43b9b3f7055dd4eba6f2bafaaebca731c30',\n      '0x19713e47937cd1be0dfd0b8f1d43fb93cd2fcbcb6caf493fd1183e416389e61031bf3a5cce3fbafce813711ad011c132',\n      '0x18b46a908f36f6deb918c143fed2edcc523559b8aaf0c2462e6bfe7f911f643249d9cdf41b44d606ce07c8a4d0074d8e',\n      '0xb182cac101b9399d155096004f53f447aa7b12a3426b08ec02710e807b4633f06c851c1919211f20d4c04f00b971ef8',\n      '0x245a394ad1eca9b72fc00ae7be315dc757b3b080d4c158013e6632d3c40659cc6cf90ad1c232a6442d9d3f5db980133',\n      '0x5c129645e44cf1102a159f748c4a3fc5e673d81d7e86568d9ab0f5d396a7ce46ba1049b6579afb7866b1e715475224b',\n      '0x15e6be4e990f03ce4ea50b3b42df2eb5cb181d8f84965a3957add4fa95af01b2b665027efec01c7704b456be69c8b604',\n    ],\n    // yDen\n    [\n      '0x16112c4c3a9c98b252181140fad0eae9601a6de578980be6eec3232b5be72e7a07f3688ef60c206d01479253b03663c1',\n      '0x1962d75c2381201e1a0cbd6c43c348b885c84ff731c4d59ca4a10356f453e01f78a4260763529e3532f6102c2e49a03d',\n      '0x58df3306640da276faaae7d6e8eb15778c4855551ae7f310c35a5dd279cd2eca6757cd636f96f891e2538b53dbf67f2',\n      '0x16b7d288798e5395f20d23bf89edb4d1d115c5dbddbcd30e123da489e726af41727364f2c28297ada8d26d98445f5416',\n      '0xbe0e079545f43e4b00cc912f8228ddcc6d19c9f0f69bbb0542eda0fc9dec916a20b15dc0fd2ededda39142311a5001d',\n      '0x8d9e5297186db2d9fb266eaac783182b70152c65550d881c5ecd87b6f0f5a6449f38db9dfa9cce202c6477faaf9b7ac',\n      '0x166007c08a99db2fc3ba8734ace9824b5eecfdfa8d0cf8ef5dd365bc400a0051d5fa9c01a58b1fb93d1a1399126a775c',\n      '0x16a3ef08be3ea7ea03bcddfabba6ff6ee5a4375efa1f4fd7feb34fd206357132b920f5b00801dee460ee415a15812ed9',\n      '0x1866c8ed336c61231a1be54fd1d74cc4f9fb0ce4c6af5920abc5750c4bf39b4852cfe2f7bb9248836b233d9d55535d4a',\n      '0x167a55cda70a6e1cea820597d94a84903216f763e13d87bb5308592e7ea7d4fbc7385ea3d529b35e346ef48bb8913f55',\n      '0x4d2f259eea405bd48f010a01ad2911d9c6dd039bb61a6290e591b36e636a5c871a5c29f4f83060400f8b49cba8f6aa8',\n      '0xaccbb67481d033ff5852c1e48c50c477f94ff8aefce42d28c0f9a88cea7913516f968986f7ebbea9684b529e2561092',\n      '0xad6b9514c767fe3c3613144b45f1496543346d98adf02267d5ceef9a00d9b8693000763e3b90ac11e99b138573345cc',\n      '0x2660400eb2e4f3b628bdd0d53cd76f2bf565b94e72927c1cb748df27942480e420517bd8714cc80d1fadc1326ed06f7',\n      '0xe0fa1d816ddc03e6b24255e0d7819c171c40f65e273b853324efcd6356caa205ca2f570f13497804415473a1d634b8f',\n      '0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n  ].map((i) => i.map((j) => BigInt(j))) as [Fp[], Fp[], Fp[], Fp[]]\n);\n\n// SWU Map - Fp2 to G2': y² = x³ + 240i * x + 1012 + 1012i\nconst G2_SWU = mapToCurveSimpleSWU(Fp2, {\n  A: Fp2.create({ c0: Fp.create(_0n), c1: Fp.create(BigInt(240)) }), // A' = 240 * I\n  B: Fp2.create({ c0: Fp.create(BigInt(1012)), c1: Fp.create(BigInt(1012)) }), // B' = 1012 * (1 + I)\n  Z: Fp2.create({ c0: Fp.create(BigInt(-2)), c1: Fp.create(BigInt(-1)) }), // Z: -(2 + I)\n});\n// Optimized SWU Map - Fp to G1\nconst G1_SWU = mapToCurveSimpleSWU(Fp, {\n  A: Fp.create(\n    BigInt(\n      '0x144698a3b8e9433d693a02c96d4982b0ea985383ee66a8d8e8981aefd881ac98936f8da0e0f97f5cf428082d584c1d'\n    )\n  ),\n  B: Fp.create(\n    BigInt(\n      '0x12e2908d11688030018b12e8753eee3b2016c1f0f24f4070a0b9c14fcef35ef55a23215a316ceaa5d1cc48e98e172be0'\n    )\n  ),\n  Z: Fp.create(BigInt(11)),\n});\n\n// GLV endomorphism Ψ(P), for fast cofactor clearing\nconst { G2psi, G2psi2 } = psiFrobenius(Fp, Fp2, Fp2.div(Fp2.ONE, Fp2.NONRESIDUE)); // 1/(u+1)\n\n// Default hash_to_field options are for hash to G2.\n//\n// Parameter definitions are in section 5.3 of the spec unless otherwise noted.\n// Parameter values come from section 8.8.2 of the spec.\n// https://www.rfc-editor.org/rfc/rfc9380#section-8.8.2\n//\n// Base field F is GF(p^m)\n// p = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab\n// m = 2 (or 1 for G1 see section 8.8.1)\n// k = 128\nconst htfDefaults = Object.freeze({\n  // DST: a domain separation tag\n  // defined in section 2.2.5\n  // Use utils.getDSTLabel(), utils.setDSTLabel(value)\n  DST: 'BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_',\n  encodeDST: 'BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_',\n  // p: the characteristic of F\n  //    where F is a finite field of characteristic p and order q = p^m\n  p: Fp.ORDER,\n  // m: the extension degree of F, m >= 1\n  //     where F is a finite field of characteristic p and order q = p^m\n  m: 2,\n  // k: the target security level for the suite in bits\n  // defined in section 5.1\n  k: 128,\n  // option to use a message that has already been processed by\n  // expand_message_xmd\n  expand: 'xmd',\n  // Hash functions for: expand_message_xmd is appropriate for use with a\n  // wide range of hash functions, including SHA-2, SHA-3, BLAKE2, and others.\n  // BBS+ uses blake2: https://github.com/hyperledger/aries-framework-go/issues/2247\n  hash: sha256,\n} as const);\n\n// Encoding utils\n// Point on G1 curve: (x, y)\n\n// Compressed point of infinity\nconst COMPRESSED_ZERO = setMask(Fp.toBytes(_0n), { infinity: true, compressed: true }); // set compressed & point-at-infinity bits\n\nfunction parseMask(bytes: Uint8Array) {\n  // Copy, so we can remove mask data. It will be removed also later, when Fp.create will call modulo.\n  bytes = bytes.slice();\n  const mask = bytes[0] & 0b1110_0000;\n  const compressed = !!((mask >> 7) & 1); // compression bit (0b1000_0000)\n  const infinity = !!((mask >> 6) & 1); // point at infinity bit (0b0100_0000)\n  const sort = !!((mask >> 5) & 1); // sort bit (0b0010_0000)\n  bytes[0] &= 0b0001_1111; // clear mask (zero first 3 bits)\n  return { compressed, infinity, sort, value: bytes };\n}\n\nfunction setMask(\n  bytes: Uint8Array,\n  mask: { compressed?: boolean; infinity?: boolean; sort?: boolean }\n) {\n  if (bytes[0] & 0b1110_0000) throw new Error('setMask: non-empty mask');\n  if (mask.compressed) bytes[0] |= 0b1000_0000;\n  if (mask.infinity) bytes[0] |= 0b0100_0000;\n  if (mask.sort) bytes[0] |= 0b0010_0000;\n  return bytes;\n}\n\nfunction signatureG1ToRawBytes(point: ProjPointType<Fp>) {\n  point.assertValidity();\n  const isZero = point.equals(bls12_381.G1.ProjectivePoint.ZERO);\n  const { x, y } = point.toAffine();\n  if (isZero) return COMPRESSED_ZERO.slice();\n  const P = Fp.ORDER;\n  const sort = Boolean((y * _2n) / P);\n  return setMask(numberToBytesBE(x, Fp.BYTES), { compressed: true, sort });\n}\n\nfunction signatureG2ToRawBytes(point: ProjPointType<Fp2>) {\n  // NOTE: by some reasons it was missed in bls12-381, looks like bug\n  point.assertValidity();\n  const len = Fp.BYTES;\n  if (point.equals(bls12_381.G2.ProjectivePoint.ZERO))\n    return concatB(COMPRESSED_ZERO, numberToBytesBE(_0n, len));\n  const { x, y } = point.toAffine();\n  const { re: x0, im: x1 } = Fp2.reim(x);\n  const { re: y0, im: y1 } = Fp2.reim(y);\n  const tmp = y1 > _0n ? y1 * _2n : y0 * _2n;\n  const sort = Boolean((tmp / Fp.ORDER) & _1n);\n  const z2 = x0;\n  return concatB(\n    setMask(numberToBytesBE(x1, len), { sort, compressed: true }),\n    numberToBytesBE(z2, len)\n  );\n}\n\n/**\n * bls12-381 pairing-friendly curve.\n * @example\n * import { bls12_381 as bls } from '@noble/curves/bls12-381';\n * // G1 keys, G2 signatures\n * const privateKey = '67d53f170b908cabb9eb326c3c337762d59289a8fec79f7bc9254b584b73265c';\n * const message = '64726e3da8';\n * const publicKey = bls.getPublicKey(privateKey);\n * const signature = bls.sign(message, privateKey);\n * const isValid = bls.verify(signature, message, publicKey);\n */\nexport const bls12_381: CurveFn = bls({\n  // Fields\n  fields: {\n    Fp,\n    Fp2,\n    Fp6,\n    Fp12,\n    Fr,\n  },\n  // G1 is the order-q subgroup of E1(Fp) : y² = x³ + 4, #E1(Fp) = h1q, where\n  // characteristic; z + (z⁴ - z² + 1)(z - 1)²/3\n  G1: {\n    Fp,\n    // cofactor; (z - 1)²/3\n    h: BigInt('0x396c8c005555e1568c00aaab0000aaab'),\n    // generator's coordinates\n    // x = 3685416753713387016781088315183077757961620795782546409894578378688607592378376318836054947676345821548104185464507\n    // y = 1339506544944476473020471379941921221584933875938349620426543736416511423956333506472724655353366534992391756441569\n    Gx: BigInt(\n      '0x17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb'\n    ),\n    Gy: BigInt(\n      '0x08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1'\n    ),\n    a: Fp.ZERO,\n    b: _4n,\n    htfDefaults: { ...htfDefaults, m: 1, DST: 'BLS_SIG_BLS12381G1_XMD:SHA-256_SSWU_RO_NUL_' },\n    wrapPrivateKey: true,\n    allowInfinityPoint: true,\n    // Checks is the point resides in prime-order subgroup.\n    // point.isTorsionFree() should return true for valid points\n    // It returns false for shitty points.\n    // https://eprint.iacr.org/2021/1130.pdf\n    isTorsionFree: (c, point): boolean => {\n      // GLV endomorphism ψ(P)\n      const beta = BigInt(\n        '0x5f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe'\n      );\n      const phi = new c(Fp.mul(point.px, beta), point.py, point.pz);\n      // TODO: unroll\n      const xP = point.multiplyUnsafe(BLS_X).negate(); // [x]P\n      const u2P = xP.multiplyUnsafe(BLS_X); // [u2]P\n      return u2P.equals(phi);\n    },\n    // Clear cofactor of G1\n    // https://eprint.iacr.org/2019/403\n    clearCofactor: (_c, point) => {\n      // return this.multiplyUnsafe(CURVE.h);\n      return point.multiplyUnsafe(BLS_X).add(point); // x*P + P\n    },\n    mapToCurve: (scalars: bigint[]) => {\n      const { x, y } = G1_SWU(Fp.create(scalars[0]));\n      return isogenyMapG1(x, y);\n    },\n    fromBytes: (bytes: Uint8Array): AffinePoint<Fp> => {\n      const { compressed, infinity, sort, value } = parseMask(bytes);\n      if (value.length === 48 && compressed) {\n        // TODO: Fp.bytes\n        const P = Fp.ORDER;\n        const compressedValue = bytesToNumberBE(value);\n        // Zero\n        const x = Fp.create(compressedValue & Fp.MASK);\n        if (infinity) {\n          if (x !== _0n) throw new Error('G1: non-empty compressed point at infinity');\n          return { x: _0n, y: _0n };\n        }\n        const right = Fp.add(Fp.pow(x, _3n), Fp.create(bls12_381.params.G1b)); // y² = x³ + b\n        let y = Fp.sqrt(right);\n        if (!y) throw new Error('invalid compressed G1 point');\n        if ((y * _2n) / P !== BigInt(sort)) y = Fp.neg(y);\n        return { x: Fp.create(x), y: Fp.create(y) };\n      } else if (value.length === 96 && !compressed) {\n        // Check if the infinity flag is set\n        const x = bytesToNumberBE(value.subarray(0, Fp.BYTES));\n        const y = bytesToNumberBE(value.subarray(Fp.BYTES));\n        if (infinity) {\n          if (x !== _0n || y !== _0n) throw new Error('G1: non-empty point at infinity');\n          return bls12_381.G1.ProjectivePoint.ZERO.toAffine();\n        }\n        return { x: Fp.create(x), y: Fp.create(y) };\n      } else {\n        throw new Error('invalid point G1, expected 48/96 bytes');\n      }\n    },\n    toBytes: (c, point, isCompressed) => {\n      const isZero = point.equals(c.ZERO);\n      const { x, y } = point.toAffine();\n      if (isCompressed) {\n        if (isZero) return COMPRESSED_ZERO.slice();\n        const P = Fp.ORDER;\n        const sort = Boolean((y * _2n) / P);\n        return setMask(numberToBytesBE(x, Fp.BYTES), { compressed: true, sort });\n      } else {\n        if (isZero) {\n          // 2x PUBLIC_KEY_LENGTH\n          const x = concatB(new Uint8Array([0x40]), new Uint8Array(2 * Fp.BYTES - 1));\n          return x;\n        } else {\n          return concatB(numberToBytesBE(x, Fp.BYTES), numberToBytesBE(y, Fp.BYTES));\n        }\n      }\n    },\n    ShortSignature: {\n      fromHex(hex: Hex): ProjPointType<Fp> {\n        const { infinity, sort, value } = parseMask(ensureBytes('signatureHex', hex, 48));\n        const P = Fp.ORDER;\n        const compressedValue = bytesToNumberBE(value);\n        // Zero\n        if (infinity) return bls12_381.G1.ProjectivePoint.ZERO;\n        const x = Fp.create(compressedValue & Fp.MASK);\n        const right = Fp.add(Fp.pow(x, _3n), Fp.create(bls12_381.params.G1b)); // y² = x³ + b\n        let y = Fp.sqrt(right);\n        if (!y) throw new Error('invalid compressed G1 point');\n        const aflag = BigInt(sort);\n        if ((y * _2n) / P !== aflag) y = Fp.neg(y);\n        const point = bls12_381.G1.ProjectivePoint.fromAffine({ x, y });\n        point.assertValidity();\n        return point;\n      },\n      toRawBytes(point: ProjPointType<Fp>) {\n        return signatureG1ToRawBytes(point);\n      },\n      toHex(point: ProjPointType<Fp>) {\n        return bytesToHex(signatureG1ToRawBytes(point));\n      },\n    },\n  },\n  // G2 is the order-q subgroup of E2(Fp²) : y² = x³+4(1+√−1),\n  // where Fp2 is Fp[√−1]/(x2+1). #E2(Fp2 ) = h2q, where\n  // G² - 1\n  // h2q\n  G2: {\n    Fp: Fp2,\n    // cofactor\n    h: BigInt(\n      '0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5'\n    ),\n    Gx: Fp2.fromBigTuple([\n      BigInt(\n        '0x024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8'\n      ),\n      BigInt(\n        '0x13e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e'\n      ),\n    ]),\n    // y =\n    // 927553665492332455747201965776037880757740193453592970025027978793976877002675564980949289727957565575433344219582,\n    // 1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905\n    Gy: Fp2.fromBigTuple([\n      BigInt(\n        '0x0ce5d527727d6e118cc9cdc6da2e351aadfd9baa8cbdd3a76d429a695160d12c923ac9cc3baca289e193548608b82801'\n      ),\n      BigInt(\n        '0x0606c4a02ea734cc32acd2b02bc28b99cb3e287e85a763af267492ab572e99ab3f370d275cec1da1aaa9075ff05f79be'\n      ),\n    ]),\n    a: Fp2.ZERO,\n    b: Fp2.fromBigTuple([_4n, _4n]),\n    hEff: BigInt(\n      '0xbc69f08f2ee75b3584c6a0ea91b352888e2a8e9145ad7689986ff031508ffe1329c2f178731db956d82bf015d1212b02ec0ec69d7477c1ae954cbc06689f6a359894c0adebbf6b4e8020005aaa95551'\n    ),\n    htfDefaults: { ...htfDefaults },\n    wrapPrivateKey: true,\n    allowInfinityPoint: true,\n    mapToCurve: (scalars: bigint[]) => {\n      const { x, y } = G2_SWU(Fp2.fromBigTuple(scalars));\n      return isogenyMapG2(x, y);\n    },\n    // Checks is the point resides in prime-order subgroup.\n    // point.isTorsionFree() should return true for valid points\n    // It returns false for shitty points.\n    // https://eprint.iacr.org/2021/1130.pdf\n    // Older version: https://eprint.iacr.org/2019/814.pdf\n    isTorsionFree: (c, P): boolean => {\n      return P.multiplyUnsafe(BLS_X).negate().equals(G2psi(c, P)); // ψ(P) == [u](P)\n    },\n    // Maps the point into the prime-order subgroup G2.\n    // clear_cofactor_bls12381_g2 from RFC 9380.\n    // https://eprint.iacr.org/2017/419.pdf\n    // prettier-ignore\n    clearCofactor: (c, P) => {\n      const x = BLS_X;\n      let t1 = P.multiplyUnsafe(x).negate();  // [-x]P\n      let t2 = G2psi(c, P);                   // Ψ(P)\n      let t3 = P.double();                    // 2P\n      t3 = G2psi2(c, t3);                     // Ψ²(2P)\n      t3 = t3.subtract(t2);                   // Ψ²(2P) - Ψ(P)\n      t2 = t1.add(t2);                        // [-x]P + Ψ(P)\n      t2 = t2.multiplyUnsafe(x).negate();     // [x²]P - [x]Ψ(P)\n      t3 = t3.add(t2);                        // Ψ²(2P) - Ψ(P) + [x²]P - [x]Ψ(P)\n      t3 = t3.subtract(t1);                   // Ψ²(2P) - Ψ(P) + [x²]P - [x]Ψ(P) + [x]P\n      const Q = t3.subtract(P);               // Ψ²(2P) - Ψ(P) + [x²]P - [x]Ψ(P) + [x]P - 1P\n      return Q;                               // [x²-x-1]P + [x-1]Ψ(P) + Ψ²(2P)\n    },\n    fromBytes: (bytes: Uint8Array): AffinePoint<Fp2> => {\n      const { compressed, infinity, sort, value } = parseMask(bytes);\n      if (\n        (!compressed && !infinity && sort) || // 00100000\n        (!compressed && infinity && sort) || // 01100000\n        (sort && infinity && compressed) // 11100000\n      ) {\n        throw new Error('invalid encoding flag: ' + (bytes[0] & 0b1110_0000));\n      }\n      const L = Fp.BYTES;\n      const slc = (b: Uint8Array, from: number, to?: number) => bytesToNumberBE(b.slice(from, to));\n      if (value.length === 96 && compressed) {\n        const b = bls12_381.params.G2b;\n        const P = Fp.ORDER;\n        if (infinity) {\n          // check that all bytes are 0\n          if (value.reduce((p, c) => (p !== 0 ? c + 1 : c), 0) > 0) {\n            throw new Error('invalid compressed G2 point');\n          }\n          return { x: Fp2.ZERO, y: Fp2.ZERO };\n        }\n        const x_1 = slc(value, 0, L);\n        const x_0 = slc(value, L, 2 * L);\n        const x = Fp2.create({ c0: Fp.create(x_0), c1: Fp.create(x_1) });\n        const right = Fp2.add(Fp2.pow(x, _3n), b); // y² = x³ + 4 * (u+1) = x³ + b\n        let y = Fp2.sqrt(right);\n        const Y_bit = y.c1 === _0n ? (y.c0 * _2n) / P : (y.c1 * _2n) / P ? _1n : _0n;\n        y = sort && Y_bit > 0 ? y : Fp2.neg(y);\n        return { x, y };\n      } else if (value.length === 192 && !compressed) {\n        if (infinity) {\n          if (value.reduce((p, c) => (p !== 0 ? c + 1 : c), 0) > 0) {\n            throw new Error('invalid uncompressed G2 point');\n          }\n          return { x: Fp2.ZERO, y: Fp2.ZERO };\n        }\n        const x1 = slc(value, 0, L);\n        const x0 = slc(value, L, 2 * L);\n        const y1 = slc(value, 2 * L, 3 * L);\n        const y0 = slc(value, 3 * L, 4 * L);\n        return { x: Fp2.fromBigTuple([x0, x1]), y: Fp2.fromBigTuple([y0, y1]) };\n      } else {\n        throw new Error('invalid point G2, expected 96/192 bytes');\n      }\n    },\n    toBytes: (c, point, isCompressed) => {\n      const { BYTES: len, ORDER: P } = Fp;\n      const isZero = point.equals(c.ZERO);\n      const { x, y } = point.toAffine();\n      if (isCompressed) {\n        if (isZero) return concatB(COMPRESSED_ZERO, numberToBytesBE(_0n, len));\n        const flag = Boolean(y.c1 === _0n ? (y.c0 * _2n) / P : (y.c1 * _2n) / P);\n        return concatB(\n          setMask(numberToBytesBE(x.c1, len), { compressed: true, sort: flag }),\n          numberToBytesBE(x.c0, len)\n        );\n      } else {\n        if (isZero) return concatB(new Uint8Array([0x40]), new Uint8Array(4 * len - 1)); // bytes[0] |= 1 << 6;\n        const { re: x0, im: x1 } = Fp2.reim(x);\n        const { re: y0, im: y1 } = Fp2.reim(y);\n        return concatB(\n          numberToBytesBE(x1, len),\n          numberToBytesBE(x0, len),\n          numberToBytesBE(y1, len),\n          numberToBytesBE(y0, len)\n        );\n      }\n    },\n    Signature: {\n      // TODO: Optimize, it's very slow because of sqrt.\n      fromHex(hex: Hex): ProjPointType<Fp2> {\n        const { infinity, sort, value } = parseMask(ensureBytes('signatureHex', hex));\n        const P = Fp.ORDER;\n        const half = value.length / 2;\n        if (half !== 48 && half !== 96)\n          throw new Error('invalid compressed signature length, must be 96 or 192');\n        const z1 = bytesToNumberBE(value.slice(0, half));\n        const z2 = bytesToNumberBE(value.slice(half));\n        // Indicates the infinity point\n        if (infinity) return bls12_381.G2.ProjectivePoint.ZERO;\n        const x1 = Fp.create(z1 & Fp.MASK);\n        const x2 = Fp.create(z2);\n        const x = Fp2.create({ c0: x2, c1: x1 });\n        const y2 = Fp2.add(Fp2.pow(x, _3n), bls12_381.params.G2b); // y² = x³ + 4\n        // The slow part\n        let y = Fp2.sqrt(y2);\n        if (!y) throw new Error('Failed to find a square root');\n\n        // Choose the y whose leftmost bit of the imaginary part is equal to the a_flag1\n        // If y1 happens to be zero, then use the bit of y0\n        const { re: y0, im: y1 } = Fp2.reim(y);\n        const aflag1 = BigInt(sort);\n        const isGreater = y1 > _0n && (y1 * _2n) / P !== aflag1;\n        const isZero = y1 === _0n && (y0 * _2n) / P !== aflag1;\n        if (isGreater || isZero) y = Fp2.neg(y);\n        const point = bls12_381.G2.ProjectivePoint.fromAffine({ x, y });\n        point.assertValidity();\n        return point;\n      },\n      toRawBytes(point: ProjPointType<Fp2>) {\n        return signatureG2ToRawBytes(point);\n      },\n      toHex(point: ProjPointType<Fp2>) {\n        return bytesToHex(signatureG2ToRawBytes(point));\n      },\n    },\n  },\n  params: {\n    ateLoopSize: BLS_X, // The BLS parameter x for BLS12-381\n    r: Fr.ORDER, // order; z⁴ − z² + 1; CURVE.n from other curves\n    xNegative: true,\n    twistType: 'multiplicative',\n  },\n  htfDefaults,\n  hash: sha256,\n  randomBytes,\n});\n", "/**\n * Twisted Edwards curve. The formula is: ax² + y² = 1 + dx²y².\n * For design rationale of types / exports, see weierstrass module documentation.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// prettier-ignore\nimport {\n  pippenger, validateBasic, wNAF,\n  type AffinePoint, type BasicCurve, type Group, type GroupConstructor\n} from './curve.ts';\nimport { Field, FpInvertBatch, mod } from './modular.ts';\n// prettier-ignore\nimport {\n  abool, aInRange, bytesToHex, bytesToNumberLE, concatBytes,\n  ensureBytes, memoized, numberToBytesLE, validateObject,\n  type FHash, type Hex\n} from './utils.ts';\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);\n\n/** Edwards curves must declare params a & d. */\nexport type CurveType = BasicCurve<bigint> & {\n  a: bigint; // curve param a\n  d: bigint; // curve param d\n  hash: FHash; // Hashing\n  randomBytes: (bytesLength?: number) => Uint8Array; // CSPRNG\n  adjustScalarBytes?: (bytes: Uint8Array) => Uint8Array; // clears bits to get valid field elemtn\n  domain?: (data: Uint8Array, ctx: Uint8Array, phflag: boolean) => Uint8Array; // Used for hashing\n  uvRatio?: (u: bigint, v: bigint) => { isValid: boolean; value: bigint }; // Ratio √(u/v)\n  prehash?: FHash; // RFC 8032 pre-hashing of messages to sign() / verify()\n  mapToCurve?: (scalar: bigint[]) => AffinePoint<bigint>; // for hash-to-curve standard\n};\n\nexport type CurveTypeWithLength = Readonly<CurveType & { nByteLength: number; nBitLength: number }>;\n\n// verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\nconst VERIFY_DEFAULT = { zip215: true };\n\nfunction validateOpts(curve: CurveType): CurveTypeWithLength {\n  const opts = validateBasic(curve);\n  validateObject(\n    curve,\n    {\n      hash: 'function',\n      a: 'bigint',\n      d: 'bigint',\n      randomBytes: 'function',\n    },\n    {\n      adjustScalarBytes: 'function',\n      domain: 'function',\n      uvRatio: 'function',\n      mapToCurve: 'function',\n    }\n  );\n  // Set defaults\n  return Object.freeze({ ...opts } as const);\n}\n\n/** Instance of Extended Point with coordinates in X, Y, Z, T. */\nexport interface ExtPointType extends Group<ExtPointType> {\n  readonly ex: bigint;\n  readonly ey: bigint;\n  readonly ez: bigint;\n  readonly et: bigint;\n  get x(): bigint;\n  get y(): bigint;\n  assertValidity(): void;\n  multiply(scalar: bigint): ExtPointType;\n  multiplyUnsafe(scalar: bigint): ExtPointType;\n  isSmallOrder(): boolean;\n  isTorsionFree(): boolean;\n  clearCofactor(): ExtPointType;\n  toAffine(iz?: bigint): AffinePoint<bigint>;\n  toRawBytes(isCompressed?: boolean): Uint8Array;\n  toHex(isCompressed?: boolean): string;\n  _setWindowSize(windowSize: number): void;\n}\n/** Static methods of Extended Point with coordinates in X, Y, Z, T. */\nexport interface ExtPointConstructor extends GroupConstructor<ExtPointType> {\n  new (x: bigint, y: bigint, z: bigint, t: bigint): ExtPointType;\n  fromAffine(p: AffinePoint<bigint>): ExtPointType;\n  fromHex(hex: Hex): ExtPointType;\n  fromPrivateKey(privateKey: Hex): ExtPointType;\n  msm(points: ExtPointType[], scalars: bigint[]): ExtPointType;\n}\n\n/**\n * Edwards Curve interface.\n * Main methods: `getPublicKey(priv)`, `sign(msg, priv)`, `verify(sig, msg, pub)`.\n */\nexport type CurveFn = {\n  CURVE: ReturnType<typeof validateOpts>;\n  getPublicKey: (privateKey: Hex) => Uint8Array;\n  sign: (message: Hex, privateKey: Hex, options?: { context?: Hex }) => Uint8Array;\n  verify: (\n    sig: Hex,\n    message: Hex,\n    publicKey: Hex,\n    options?: { context?: Hex; zip215: boolean }\n  ) => boolean;\n  ExtendedPoint: ExtPointConstructor;\n  utils: {\n    randomPrivateKey: () => Uint8Array;\n    getExtendedPublicKey: (key: Hex) => {\n      head: Uint8Array;\n      prefix: Uint8Array;\n      scalar: bigint;\n      point: ExtPointType;\n      pointBytes: Uint8Array;\n    };\n    precompute: (windowSize?: number, point?: ExtPointType) => ExtPointType;\n  };\n};\n\n/**\n * Creates Twisted Edwards curve with EdDSA signatures.\n * @example\n * import { Field } from '@noble/curves/abstract/modular';\n * // Before that, define BigInt-s: a, d, p, n, Gx, Gy, h\n * const curve = twistedEdwards({ a, d, Fp: Field(p), n, Gx, Gy, h })\n */\nexport function twistedEdwards(curveDef: CurveType): CurveFn {\n  const CURVE = validateOpts(curveDef) as ReturnType<typeof validateOpts>;\n  const {\n    Fp,\n    n: CURVE_ORDER,\n    prehash: prehash,\n    hash: cHash,\n    randomBytes,\n    nByteLength,\n    h: cofactor,\n  } = CURVE;\n  // Important:\n  // There are some places where Fp.BYTES is used instead of nByteLength.\n  // So far, everything has been tested with curves of Fp.BYTES == nByteLength.\n  // TODO: test and find curves which behave otherwise.\n  const MASK = _2n << (BigInt(nByteLength * 8) - _1n);\n  const modP = Fp.create; // Function overrides\n  const Fn = Field(CURVE.n, CURVE.nBitLength);\n\n  function isEdValidXY(x: bigint, y: bigint): boolean {\n    const x2 = Fp.sqr(x);\n    const y2 = Fp.sqr(y);\n    const left = Fp.add(Fp.mul(CURVE.a, x2), y2);\n    const right = Fp.add(Fp.ONE, Fp.mul(CURVE.d, Fp.mul(x2, y2)));\n    return Fp.eql(left, right);\n  }\n\n  // Validate whether the passed curve params are valid.\n  // equation ax² + y² = 1 + dx²y² should work for generator point.\n  if (!isEdValidXY(CURVE.Gx, CURVE.Gy)) throw new Error('bad curve params: generator point');\n\n  // sqrt(u/v)\n  const uvRatio =\n    CURVE.uvRatio ||\n    ((u: bigint, v: bigint) => {\n      try {\n        return { isValid: true, value: Fp.sqrt(u * Fp.inv(v)) };\n      } catch (e) {\n        return { isValid: false, value: _0n };\n      }\n    });\n  const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes: Uint8Array) => bytes); // NOOP\n  const domain =\n    CURVE.domain ||\n    ((data: Uint8Array, ctx: Uint8Array, phflag: boolean) => {\n      abool('phflag', phflag);\n      if (ctx.length || phflag) throw new Error('Contexts/pre-hash are not supported');\n      return data;\n    }); // NOOP\n  // 0 <= n < MASK\n  // Coordinates larger than Fp.ORDER are allowed for zip215\n  function aCoordinate(title: string, n: bigint, banZero = false) {\n    const min = banZero ? _1n : _0n;\n    aInRange('coordinate ' + title, n, min, MASK);\n  }\n\n  function aextpoint(other: unknown) {\n    if (!(other instanceof Point)) throw new Error('ExtendedPoint expected');\n  }\n  // Converts Extended point to default (x, y) coordinates.\n  // Can accept precomputed Z^-1 - for example, from invertBatch.\n  const toAffineMemo = memoized((p: Point, iz?: bigint): AffinePoint<bigint> => {\n    const { ex: x, ey: y, ez: z } = p;\n    const is0 = p.is0();\n    if (iz == null) iz = is0 ? _8n : (Fp.inv(z) as bigint); // 8 was chosen arbitrarily\n    const ax = modP(x * iz);\n    const ay = modP(y * iz);\n    const zz = modP(z * iz);\n    if (is0) return { x: _0n, y: _1n };\n    if (zz !== _1n) throw new Error('invZ was invalid');\n    return { x: ax, y: ay };\n  });\n  const assertValidMemo = memoized((p: Point) => {\n    const { a, d } = CURVE;\n    if (p.is0()) throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?\n    // Equation in affine coordinates: ax² + y² = 1 + dx²y²\n    // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX² + Y²)Z² = Z⁴ + dX²Y²\n    const { ex: X, ey: Y, ez: Z, et: T } = p;\n    const X2 = modP(X * X); // X²\n    const Y2 = modP(Y * Y); // Y²\n    const Z2 = modP(Z * Z); // Z²\n    const Z4 = modP(Z2 * Z2); // Z⁴\n    const aX2 = modP(X2 * a); // aX²\n    const left = modP(Z2 * modP(aX2 + Y2)); // (aX² + Y²)Z²\n    const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z⁴ + dX²Y²\n    if (left !== right) throw new Error('bad point: equation left != right (1)');\n    // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n    const XY = modP(X * Y);\n    const ZT = modP(Z * T);\n    if (XY !== ZT) throw new Error('bad point: equation left != right (2)');\n    return true;\n  });\n\n  // Extended Point works in extended coordinates: (X, Y, Z, T) ∋ (x=X/Z, y=Y/Z, T=xy).\n  // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n  class Point implements ExtPointType {\n    // base / generator point\n    static readonly BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n    // zero / infinity / identity point\n    static readonly ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n    readonly ex: bigint;\n    readonly ey: bigint;\n    readonly ez: bigint;\n    readonly et: bigint;\n\n    constructor(ex: bigint, ey: bigint, ez: bigint, et: bigint) {\n      aCoordinate('x', ex);\n      aCoordinate('y', ey);\n      aCoordinate('z', ez, true);\n      aCoordinate('t', et);\n      this.ex = ex;\n      this.ey = ey;\n      this.ez = ez;\n      this.et = et;\n      Object.freeze(this);\n    }\n\n    get x(): bigint {\n      return this.toAffine().x;\n    }\n    get y(): bigint {\n      return this.toAffine().y;\n    }\n\n    static fromAffine(p: AffinePoint<bigint>): Point {\n      if (p instanceof Point) throw new Error('extended point not allowed');\n      const { x, y } = p || {};\n      aCoordinate('x', x);\n      aCoordinate('y', y);\n      return new Point(x, y, _1n, modP(x * y));\n    }\n    static normalizeZ(points: Point[]): Point[] {\n      const toInv = FpInvertBatch(\n        Fp,\n        points.map((p) => p.ez)\n      );\n      return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n    }\n    // Multiscalar Multiplication\n    static msm(points: Point[], scalars: bigint[]): Point {\n      return pippenger(Point, Fn, points, scalars);\n    }\n\n    // \"Private method\", don't use it directly\n    _setWindowSize(windowSize: number) {\n      wnaf.setWindowSize(this, windowSize);\n    }\n    // Not required for fromHex(), which always creates valid points.\n    // Could be useful for fromAffine().\n    assertValidity(): void {\n      assertValidMemo(this);\n    }\n\n    // Compare one point to another.\n    equals(other: Point): boolean {\n      aextpoint(other);\n      const { ex: X1, ey: Y1, ez: Z1 } = this;\n      const { ex: X2, ey: Y2, ez: Z2 } = other;\n      const X1Z2 = modP(X1 * Z2);\n      const X2Z1 = modP(X2 * Z1);\n      const Y1Z2 = modP(Y1 * Z2);\n      const Y2Z1 = modP(Y2 * Z1);\n      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n\n    is0(): boolean {\n      return this.equals(Point.ZERO);\n    }\n\n    negate(): Point {\n      // Flips point sign to a negative one (-x, y in affine coords)\n      return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));\n    }\n\n    // Fast algo for doubling Extended Point.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n    // Cost: 4M + 4S + 1*a + 6add + 1*2.\n    double(): Point {\n      const { a } = CURVE;\n      const { ex: X1, ey: Y1, ez: Z1 } = this;\n      const A = modP(X1 * X1); // A = X12\n      const B = modP(Y1 * Y1); // B = Y12\n      const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n      const D = modP(a * A); // D = a*A\n      const x1y1 = X1 + Y1;\n      const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n      const G = D + B; // G = D+B\n      const F = G - C; // F = G-C\n      const H = D - B; // H = D-B\n      const X3 = modP(E * F); // X3 = E*F\n      const Y3 = modP(G * H); // Y3 = G*H\n      const T3 = modP(E * H); // T3 = E*H\n      const Z3 = modP(F * G); // Z3 = F*G\n      return new Point(X3, Y3, Z3, T3);\n    }\n\n    // Fast algo for adding 2 Extended Points.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n    // Cost: 9M + 1*a + 1*d + 7add.\n    add(other: Point) {\n      aextpoint(other);\n      const { a, d } = CURVE;\n      const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;\n      const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;\n      const A = modP(X1 * X2); // A = X1*X2\n      const B = modP(Y1 * Y2); // B = Y1*Y2\n      const C = modP(T1 * d * T2); // C = T1*d*T2\n      const D = modP(Z1 * Z2); // D = Z1*Z2\n      const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n      const F = D - C; // F = D-C\n      const G = D + C; // G = D+C\n      const H = modP(B - a * A); // H = B-a*A\n      const X3 = modP(E * F); // X3 = E*F\n      const Y3 = modP(G * H); // Y3 = G*H\n      const T3 = modP(E * H); // T3 = E*H\n      const Z3 = modP(F * G); // Z3 = F*G\n      return new Point(X3, Y3, Z3, T3);\n    }\n\n    subtract(other: Point): Point {\n      return this.add(other.negate());\n    }\n\n    private wNAF(n: bigint): { p: Point; f: Point } {\n      return wnaf.wNAFCached(this, n, Point.normalizeZ);\n    }\n\n    // Constant-time multiplication.\n    multiply(scalar: bigint): Point {\n      const n = scalar;\n      aInRange('scalar', n, _1n, CURVE_ORDER); // 1 <= scalar < L\n      const { p, f } = this.wNAF(n);\n      return Point.normalizeZ([p, f])[0];\n    }\n\n    // Non-constant-time multiplication. Uses double-and-add algorithm.\n    // It's faster, but should only be used when you don't care about\n    // an exposed private key e.g. sig verification.\n    // Does NOT allow scalars higher than CURVE.n.\n    // Accepts optional accumulator to merge with multiply (important for sparse scalars)\n    multiplyUnsafe(scalar: bigint, acc = Point.ZERO): Point {\n      const n = scalar;\n      aInRange('scalar', n, _0n, CURVE_ORDER); // 0 <= scalar < L\n      if (n === _0n) return I;\n      if (this.is0() || n === _1n) return this;\n      return wnaf.wNAFCachedUnsafe(this, n, Point.normalizeZ, acc);\n    }\n\n    // Checks if point is of small order.\n    // If you add something to small order point, you will have \"dirty\"\n    // point with torsion component.\n    // Multiplies point by cofactor and checks if the result is 0.\n    isSmallOrder(): boolean {\n      return this.multiplyUnsafe(cofactor).is0();\n    }\n\n    // Multiplies point by curve order and checks if the result is 0.\n    // Returns `false` is the point is dirty.\n    isTorsionFree(): boolean {\n      return wnaf.unsafeLadder(this, CURVE_ORDER).is0();\n    }\n\n    // Converts Extended point to default (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    toAffine(iz?: bigint): AffinePoint<bigint> {\n      return toAffineMemo(this, iz);\n    }\n\n    clearCofactor(): Point {\n      const { h: cofactor } = CURVE;\n      if (cofactor === _1n) return this;\n      return this.multiplyUnsafe(cofactor);\n    }\n\n    // Converts hash string or Uint8Array to Point.\n    // Uses algo from RFC8032 5.1.3.\n    static fromHex(hex: Hex, zip215 = false): Point {\n      const { d, a } = CURVE;\n      const len = Fp.BYTES;\n      hex = ensureBytes('pointHex', hex, len); // copy hex to a new array\n      abool('zip215', zip215);\n      const normed = hex.slice(); // copy again, we'll manipulate it\n      const lastByte = hex[len - 1]; // select last byte\n      normed[len - 1] = lastByte & ~0x80; // clear last bit\n      const y = bytesToNumberLE(normed);\n\n      // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n      // RFC8032 prohibits >= p, but ZIP215 doesn't\n      // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n      // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n      const max = zip215 ? MASK : Fp.ORDER;\n      aInRange('pointHex.y', y, _0n, max);\n\n      // Ed25519: x² = (y²-1)/(dy²+1) mod p. Ed448: x² = (y²-1)/(dy²-1) mod p. Generic case:\n      // ax²+y²=1+dx²y² => y²-1=dx²y²-ax² => y²-1=x²(dy²-a) => x²=(y²-1)/(dy²-a)\n      const y2 = modP(y * y); // denominator is always non-0 mod p.\n      const u = modP(y2 - _1n); // u = y² - 1\n      const v = modP(d * y2 - a); // v = d y² + 1.\n      let { isValid, value: x } = uvRatio(u, v); // √(u/v)\n      if (!isValid) throw new Error('Point.fromHex: invalid y coordinate');\n      const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n      const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n      if (!zip215 && x === _0n && isLastByteOdd)\n        // if x=0 and x_0 = 1, fail\n        throw new Error('Point.fromHex: x=0 and x_0=1');\n      if (isLastByteOdd !== isXOdd) x = modP(-x); // if x_0 != x mod 2, set x = p-x\n      return Point.fromAffine({ x, y });\n    }\n    static fromPrivateKey(privKey: Hex): Point {\n      const { scalar } = getPrivateScalar(privKey);\n      return G.multiply(scalar); // reduced one call of `toRawBytes`\n    }\n    toRawBytes(): Uint8Array {\n      const { x, y } = this.toAffine();\n      const bytes = numberToBytesLE(y, Fp.BYTES); // each y has 2 x values (x, -y)\n      bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0; // when compressing, it's enough to store y\n      return bytes; // and use the last byte to encode sign of x\n    }\n    toHex(): string {\n      return bytesToHex(this.toRawBytes()); // Same as toRawBytes, but returns string.\n    }\n  }\n  const { BASE: G, ZERO: I } = Point;\n  const wnaf = wNAF(Point, nByteLength * 8);\n\n  function modN(a: bigint) {\n    return mod(a, CURVE_ORDER);\n  }\n  // Little-endian SHA512 with modulo n\n  function modN_LE(hash: Uint8Array): bigint {\n    return modN(bytesToNumberLE(hash));\n  }\n\n  // Get the hashed private scalar per RFC8032 5.1.5\n  function getPrivateScalar(key: Hex) {\n    const len = Fp.BYTES;\n    key = ensureBytes('private key', key, len);\n    // Hash private key with curve's hash function to produce uniformingly random input\n    // Check byte lengths: ensure(64, h(ensure(32, key)))\n    const hashed = ensureBytes('hashed private key', cHash(key), 2 * len);\n    const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n    const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n    const scalar = modN_LE(head); // The actual private scalar\n    return { head, prefix, scalar };\n  }\n\n  // Convenience method that creates public key from scalar. RFC8032 5.1.5\n  function getExtendedPublicKey(key: Hex) {\n    const { head, prefix, scalar } = getPrivateScalar(key);\n    const point = G.multiply(scalar); // Point on Edwards curve aka public key\n    const pointBytes = point.toRawBytes(); // Uint8Array representation\n    return { head, prefix, scalar, point, pointBytes };\n  }\n\n  // Calculates EdDSA pub key. RFC8032 5.1.5. Privkey is hashed. Use first half with 3 bits cleared\n  function getPublicKey(privKey: Hex): Uint8Array {\n    return getExtendedPublicKey(privKey).pointBytes;\n  }\n\n  // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n  function hashDomainToScalar(context: Hex = Uint8Array.of(), ...msgs: Uint8Array[]) {\n    const msg = concatBytes(...msgs);\n    return modN_LE(cHash(domain(msg, ensureBytes('context', context), !!prehash)));\n  }\n\n  /** Signs message with privateKey. RFC8032 5.1.6 */\n  function sign(msg: Hex, privKey: Hex, options: { context?: Hex } = {}): Uint8Array {\n    msg = ensureBytes('message', msg);\n    if (prehash) msg = prehash(msg); // for ed25519ph etc.\n    const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);\n    const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n    const R = G.multiply(r).toRawBytes(); // R = rG\n    const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n    const s = modN(r + k * scalar); // S = (r + k * s) mod L\n    aInRange('signature.s', s, _0n, CURVE_ORDER); // 0 <= s < l\n    const res = concatBytes(R, numberToBytesLE(s, Fp.BYTES));\n    return ensureBytes('result', res, Fp.BYTES * 2); // 64-byte signature\n  }\n\n  const verifyOpts: { context?: Hex; zip215?: boolean } = VERIFY_DEFAULT;\n\n  /**\n   * Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n   * An extended group equation is checked.\n   */\n  function verify(sig: Hex, msg: Hex, publicKey: Hex, options = verifyOpts): boolean {\n    const { context, zip215 } = options;\n    const len = Fp.BYTES; // Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n    sig = ensureBytes('signature', sig, 2 * len); // An extended group equation is checked.\n    msg = ensureBytes('message', msg);\n    publicKey = ensureBytes('publicKey', publicKey, len);\n    if (zip215 !== undefined) abool('zip215', zip215);\n    if (prehash) msg = prehash(msg); // for ed25519ph, etc\n\n    const s = bytesToNumberLE(sig.slice(len, 2 * len));\n    let A, R, SB;\n    try {\n      // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n      // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n      // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n      A = Point.fromHex(publicKey, zip215);\n      R = Point.fromHex(sig.slice(0, len), zip215);\n      SB = G.multiplyUnsafe(s); // 0 <= s < l is done inside\n    } catch (error) {\n      return false;\n    }\n    if (!zip215 && A.isSmallOrder()) return false;\n\n    const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);\n    const RkA = R.add(A.multiplyUnsafe(k));\n    // Extended group equation\n    // [8][S]B = [8]R + [8][k]A'\n    return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);\n  }\n\n  G._setWindowSize(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n\n  const utils = {\n    getExtendedPublicKey,\n    /** ed25519 priv keys are uniform 32b. No need to check for modulo bias, like in secp256k1. */\n    randomPrivateKey: (): Uint8Array => randomBytes(Fp.BYTES),\n\n    /**\n     * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT\n     * values. This slows down first getPublicKey() by milliseconds (see Speed section),\n     * but allows to speed-up subsequent getPublicKey() calls up to 20x.\n     * @param windowSize 2, 4, 8, 16\n     */\n    precompute(windowSize = 8, point: ExtPointType = Point.BASE): ExtPointType {\n      point._setWindowSize(windowSize);\n      point.multiply(BigInt(3));\n      return point;\n    },\n  };\n\n  return {\n    CURVE,\n    getPublicKey,\n    sign,\n    verify,\n    ExtendedPoint: Point,\n    utils,\n  };\n}\n", "/**\n * Montgomery curve methods. It's not really whole montgomery curve,\n * just bunch of very specific methods for X25519 / X448 from\n * [RFC 7748](https://www.rfc-editor.org/rfc/rfc7748)\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { mod } from './modular.ts';\nimport {\n  aInRange,\n  bytesToNumberLE,\n  ensureBytes,\n  numberToBytesLE,\n  validateObject,\n} from './utils.ts';\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\ntype Hex = string | Uint8Array;\n\nexport type CurveType = {\n  P: bigint; // finite field prime\n  type: 'x25519' | 'x448';\n  adjustScalarBytes: (bytes: Uint8Array) => Uint8Array;\n  powPminus2: (x: bigint) => bigint;\n  randomBytes: (bytesLength?: number) => Uint8Array;\n};\n\nexport type CurveFn = {\n  scalarMult: (scalar: Hex, u: Hex) => Uint8Array;\n  scalarMultBase: (scalar: Hex) => Uint8Array;\n  getSharedSecret: (privateKeyA: Hex, publicKeyB: Hex) => Uint8Array;\n  getPublicKey: (privateKey: Hex) => Uint8Array;\n  utils: { randomPrivateKey: () => Uint8Array };\n  GuBytes: Uint8Array;\n};\n\nfunction validateOpts(curve: CurveType) {\n  validateObject(curve, {\n    adjustScalarBytes: 'function',\n    powPminus2: 'function',\n  });\n  return Object.freeze({ ...curve } as const);\n}\n\nexport function montgomery(curveDef: CurveType): CurveFn {\n  const CURVE = validateOpts(curveDef);\n  const { P, type, adjustScalarBytes, powPminus2 } = CURVE;\n  const is25519 = type === 'x25519';\n  if (!is25519 && type !== 'x448') throw new Error('invalid type');\n\n  const montgomeryBits = is25519 ? 255 : 448;\n  const fieldLen = is25519 ? 32 : 56;\n  const Gu = is25519 ? BigInt(9) : BigInt(5);\n  // RFC 7748 #5:\n  // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519 and\n  // (156326 - 2) / 4 = 39081 for curve448/X448\n  // const a = is25519 ? 156326n : 486662n;\n  const a24 = is25519 ? BigInt(121665) : BigInt(39081);\n  // RFC: x25519 \"the resulting integer is of the form 2^254 plus\n  // eight times a value between 0 and 2^251 - 1 (inclusive)\"\n  // x448: \"2^447 plus four times a value between 0 and 2^445 - 1 (inclusive)\"\n  const minScalar = is25519 ? _2n ** BigInt(254) : _2n ** BigInt(447);\n  const maxAdded = is25519\n    ? BigInt(8) * _2n ** BigInt(251) - _1n\n    : BigInt(4) * _2n ** BigInt(445) - _1n;\n  const maxScalar = minScalar + maxAdded + _1n; // (inclusive)\n  const modP = (n: bigint) => mod(n, P);\n  const GuBytes = encodeU(Gu);\n  function encodeU(u: bigint): Uint8Array {\n    return numberToBytesLE(modP(u), fieldLen);\n  }\n  function decodeU(u: Hex): bigint {\n    const _u = ensureBytes('u coordinate', u, fieldLen);\n    // RFC: When receiving such an array, implementations of X25519\n    // (but not X448) MUST mask the most significant bit in the final byte.\n    if (is25519) _u[31] &= 127; // 0b0111_1111\n    // RFC: Implementations MUST accept non-canonical values and process them as\n    // if they had been reduced modulo the field prime.  The non-canonical\n    // values are 2^255 - 19 through 2^255 - 1 for X25519 and 2^448 - 2^224\n    // - 1 through 2^448 - 1 for X448.\n    return modP(bytesToNumberLE(_u));\n  }\n  function decodeScalar(scalar: Hex): bigint {\n    return bytesToNumberLE(adjustScalarBytes(ensureBytes('scalar', scalar, fieldLen)));\n  }\n  function scalarMult(scalar: Hex, u: Hex): Uint8Array {\n    const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));\n    // Some public keys are useless, of low-order. Curve author doesn't think\n    // it needs to be validated, but we do it nonetheless.\n    // https://cr.yp.to/ecdh.html#validate\n    if (pu === _0n) throw new Error('invalid private or public key received');\n    return encodeU(pu);\n  }\n  // Computes public key from private. By doing scalar multiplication of base point.\n  function scalarMultBase(scalar: Hex): Uint8Array {\n    return scalarMult(scalar, GuBytes);\n  }\n\n  // cswap from RFC7748 \"example code\"\n  function cswap(swap: bigint, x_2: bigint, x_3: bigint): { x_2: bigint; x_3: bigint } {\n    // dummy = mask(swap) AND (x_2 XOR x_3)\n    // Where mask(swap) is the all-1 or all-0 word of the same length as x_2\n    // and x_3, computed, e.g., as mask(swap) = 0 - swap.\n    const dummy = modP(swap * (x_2 - x_3));\n    x_2 = modP(x_2 - dummy); // x_2 = x_2 XOR dummy\n    x_3 = modP(x_3 + dummy); // x_3 = x_3 XOR dummy\n    return { x_2, x_3 };\n  }\n\n  /**\n   * Montgomery x-only multiplication ladder.\n   * @param pointU u coordinate (x) on Montgomery Curve 25519\n   * @param scalar by which the point would be multiplied\n   * @returns new Point on Montgomery curve\n   */\n  function montgomeryLadder(u: bigint, scalar: bigint): bigint {\n    aInRange('u', u, _0n, P);\n    aInRange('scalar', scalar, minScalar, maxScalar);\n    const k = scalar;\n    const x_1 = u;\n    let x_2 = _1n;\n    let z_2 = _0n;\n    let x_3 = u;\n    let z_3 = _1n;\n    let swap = _0n;\n    for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {\n      const k_t = (k >> t) & _1n;\n      swap ^= k_t;\n      ({ x_2, x_3 } = cswap(swap, x_2, x_3));\n      ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));\n      swap = k_t;\n\n      const A = x_2 + z_2;\n      const AA = modP(A * A);\n      const B = x_2 - z_2;\n      const BB = modP(B * B);\n      const E = AA - BB;\n      const C = x_3 + z_3;\n      const D = x_3 - z_3;\n      const DA = modP(D * A);\n      const CB = modP(C * B);\n      const dacb = DA + CB;\n      const da_cb = DA - CB;\n      x_3 = modP(dacb * dacb);\n      z_3 = modP(x_1 * modP(da_cb * da_cb));\n      x_2 = modP(AA * BB);\n      z_2 = modP(E * (AA + modP(a24 * E)));\n    }\n    ({ x_2, x_3 } = cswap(swap, x_2, x_3));\n    ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));\n    const z2 = powPminus2(z_2); // `Fp.pow(x, P - _2n)` is much slower equivalent\n    return modP(x_2 * z2); // Return x_2 * (z_2^(p - 2))\n  }\n\n  return {\n    scalarMult,\n    scalarMultBase,\n    getSharedSecret: (privateKey: Hex, publicKey: Hex) => scalarMult(privateKey, publicKey),\n    getPublicKey: (privateKey: Hex): Uint8Array => scalarMultBase(privateKey),\n    utils: { randomPrivateKey: () => CURVE.randomBytes!(fieldLen) },\n    GuBytes: GuBytes.slice(),\n  };\n}\n", "/**\n * ed25519 Twisted Edwards curve with following addons:\n * - X25519 ECDH\n * - Ristretto cofactor elimination\n * - Elligator hash-to-group / point indistinguishability\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha512 } from '@noble/hashes/sha2';\nimport { concatBytes, randomBytes, utf8ToBytes } from '@noble/hashes/utils';\nimport { type AffinePoint, type Group, pippenger } from './abstract/curve.ts';\nimport { type CurveFn, type ExtPointType, twistedEdwards } from './abstract/edwards.ts';\nimport {\n  createHasher,\n  expand_message_xmd,\n  type Hasher,\n  type htfBasicOpts,\n  type HTFMethod,\n} from './abstract/hash-to-curve.ts';\nimport { Field, FpInvertBatch, FpSqrtEven, isNegativeLE, mod, pow2 } from './abstract/modular.ts';\nimport { montgomery, type CurveFn as XCurveFn } from './abstract/montgomery.ts';\nimport {\n  bytesToHex,\n  bytesToNumberLE,\n  ensureBytes,\n  equalBytes,\n  type Hex,\n  numberToBytesLE,\n} from './abstract/utils.ts';\n\n// 2n**255n - 19n\nconst ED25519_P = BigInt(\n  '57896044618658097711785492504343953926634992332820282019728792003956564819949'\n);\n// √(-1) aka √(a) aka 2^((p-1)/4)\n// Fp.sqrt(Fp.neg(1))\nconst ED25519_SQRT_M1 = /* @__PURE__ */ BigInt(\n  '19681161376707505956807079304988542015446066515923890162744021073123829784752'\n);\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _5n = BigInt(5), _8n = BigInt(8);\n\nfunction ed25519_pow_2_252_3(x: bigint) {\n  // prettier-ignore\n  const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);\n  const P = ED25519_P;\n  const x2 = (x * x) % P;\n  const b2 = (x2 * x) % P; // x^3, 11\n  const b4 = (pow2(b2, _2n, P) * b2) % P; // x^15, 1111\n  const b5 = (pow2(b4, _1n, P) * x) % P; // x^31\n  const b10 = (pow2(b5, _5n, P) * b5) % P;\n  const b20 = (pow2(b10, _10n, P) * b10) % P;\n  const b40 = (pow2(b20, _20n, P) * b20) % P;\n  const b80 = (pow2(b40, _40n, P) * b40) % P;\n  const b160 = (pow2(b80, _80n, P) * b80) % P;\n  const b240 = (pow2(b160, _80n, P) * b80) % P;\n  const b250 = (pow2(b240, _10n, P) * b10) % P;\n  const pow_p_5_8 = (pow2(b250, _2n, P) * x) % P;\n  // ^ To pow to (p+3)/8, multiply it by x.\n  return { pow_p_5_8, b2 };\n}\n\nfunction adjustScalarBytes(bytes: Uint8Array): Uint8Array {\n  // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,\n  // set the three least significant bits of the first byte\n  bytes[0] &= 248; // 0b1111_1000\n  // and the most significant bit of the last to zero,\n  bytes[31] &= 127; // 0b0111_1111\n  // set the second most significant bit of the last byte to 1\n  bytes[31] |= 64; // 0b0100_0000\n  return bytes;\n}\n\n// sqrt(u/v)\nfunction uvRatio(u: bigint, v: bigint): { isValid: boolean; value: bigint } {\n  const P = ED25519_P;\n  const v3 = mod(v * v * v, P); // v³\n  const v7 = mod(v3 * v3 * v, P); // v⁷\n  // (p+3)/8 and (p-5)/8\n  const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;\n  let x = mod(u * v3 * pow, P); // (uv³)(uv⁷)^(p-5)/8\n  const vx2 = mod(v * x * x, P); // vx²\n  const root1 = x; // First root candidate\n  const root2 = mod(x * ED25519_SQRT_M1, P); // Second root candidate\n  const useRoot1 = vx2 === u; // If vx² = u (mod p), x is a square root\n  const useRoot2 = vx2 === mod(-u, P); // If vx² = -u, set x <-- x * 2^((p-1)/4)\n  const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P); // There is no valid root, vx² = -u√(-1)\n  if (useRoot1) x = root1;\n  if (useRoot2 || noRoot) x = root2; // We return root2 anyway, for const-time\n  if (isNegativeLE(x, P)) x = mod(-x, P);\n  return { isValid: useRoot1 || useRoot2, value: x };\n}\n\n/** Weird / bogus points, useful for debugging. */\nexport const ED25519_TORSION_SUBGROUP: string[] = [\n  '0100000000000000000000000000000000000000000000000000000000000000',\n  'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',\n  '0000000000000000000000000000000000000000000000000000000000000080',\n  '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',\n  'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',\n  '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',\n  '0000000000000000000000000000000000000000000000000000000000000000',\n  'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',\n];\n\nconst Fp = /* @__PURE__ */ (() => Field(ED25519_P, undefined, true))();\n\nconst ed25519Defaults = /* @__PURE__ */ (() =>\n  ({\n    // Removing Fp.create() will still work, and is 10% faster on sign\n    a: Fp.create(BigInt(-1)),\n    // d is -121665/121666 a.k.a. Fp.neg(121665 * Fp.inv(121666))\n    d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),\n    // Finite field 2n**255n - 19n\n    Fp,\n    // Subgroup order 2n**252n + 27742317777372353535851937790883648493n;\n    n: BigInt('7237005577332262213973186563042994240857116359379907606001950938285454250989'),\n    h: _8n,\n    Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),\n    Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960'),\n    hash: sha512,\n    randomBytes,\n    adjustScalarBytes,\n    // dom2\n    // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.\n    // Constant-time, u/√v\n    uvRatio,\n  }) as const)();\n\n/**\n * ed25519 curve with EdDSA signatures.\n * @example\n * import { ed25519 } from '@noble/curves/ed25519';\n * const priv = ed25519.utils.randomPrivateKey();\n * const pub = ed25519.getPublicKey(priv);\n * const msg = new TextEncoder().encode('hello');\n * const sig = ed25519.sign(msg, priv);\n * ed25519.verify(sig, msg, pub); // Default mode: follows ZIP215\n * ed25519.verify(sig, msg, pub, { zip215: false }); // RFC8032 / FIPS 186-5\n */\nexport const ed25519: CurveFn = /* @__PURE__ */ (() => twistedEdwards(ed25519Defaults))();\n\nfunction ed25519_domain(data: Uint8Array, ctx: Uint8Array, phflag: boolean) {\n  if (ctx.length > 255) throw new Error('Context is too big');\n  return concatBytes(\n    utf8ToBytes('SigEd25519 no Ed25519 collisions'),\n    new Uint8Array([phflag ? 1 : 0, ctx.length]),\n    ctx,\n    data\n  );\n}\n\nexport const ed25519ctx: CurveFn = /* @__PURE__ */ (() =>\n  twistedEdwards({\n    ...ed25519Defaults,\n    domain: ed25519_domain,\n  }))();\nexport const ed25519ph: CurveFn = /* @__PURE__ */ (() =>\n  twistedEdwards(\n    Object.assign({}, ed25519Defaults, {\n      domain: ed25519_domain,\n      prehash: sha512,\n    })\n  ))();\n\n/**\n * ECDH using curve25519 aka x25519.\n * @example\n * import { x25519 } from '@noble/curves/ed25519';\n * const priv = 'a546e36bf0527c9d3b16154b82465edd62144c0ac1fc5a18506a2244ba449ac4';\n * const pub = 'e6db6867583030db3594c1a424b15f7c726624ec26b3353b10a903a6d0ab1c4c';\n * x25519.getSharedSecret(priv, pub) === x25519.scalarMult(priv, pub); // aliases\n * x25519.getPublicKey(priv) === x25519.scalarMultBase(priv);\n * x25519.getPublicKey(x25519.utils.randomPrivateKey());\n */\nexport const x25519: XCurveFn = /* @__PURE__ */ (() =>\n  montgomery({\n    P: ED25519_P,\n    type: 'x25519',\n    powPminus2: (x: bigint): bigint => {\n      const P = ED25519_P;\n      // x^(p-2) aka x^(2^255-21)\n      const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);\n      return mod(pow2(pow_p_5_8, _3n, P) * b2, P);\n    },\n    adjustScalarBytes,\n    randomBytes,\n  }))();\n\n/**\n * Converts ed25519 public key to x25519 public key. Uses formula:\n * * `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`\n * * `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`\n * @example\n *   const someonesPub = ed25519.getPublicKey(ed25519.utils.randomPrivateKey());\n *   const aPriv = x25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(aPriv, edwardsToMontgomeryPub(someonesPub))\n */\nexport function edwardsToMontgomeryPub(edwardsPub: Hex): Uint8Array {\n  const { y } = ed25519.ExtendedPoint.fromHex(edwardsPub);\n  const _1n = BigInt(1);\n  return Fp.toBytes(Fp.create((_1n + y) * Fp.inv(_1n - y)));\n}\nexport const edwardsToMontgomery: typeof edwardsToMontgomeryPub = edwardsToMontgomeryPub; // deprecated\n\n/**\n * Converts ed25519 secret key to x25519 secret key.\n * @example\n *   const someonesPub = x25519.getPublicKey(x25519.utils.randomPrivateKey());\n *   const aPriv = ed25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(edwardsToMontgomeryPriv(aPriv), someonesPub)\n */\nexport function edwardsToMontgomeryPriv(edwardsPriv: Uint8Array): Uint8Array {\n  const hashed = ed25519Defaults.hash(edwardsPriv.subarray(0, 32));\n  return ed25519Defaults.adjustScalarBytes(hashed).subarray(0, 32);\n}\n\n// Hash To Curve Elligator2 Map (NOTE: different from ristretto255 elligator)\n// NOTE: very important part is usage of FpSqrtEven for ELL2_C1_EDWARDS, since\n// SageMath returns different root first and everything falls apart\n\nconst ELL2_C1 = /* @__PURE__ */ (() => (Fp.ORDER + _3n) / _8n)(); // 1. c1 = (q + 3) / 8       # Integer arithmetic\nconst ELL2_C2 = /* @__PURE__ */ (() => Fp.pow(_2n, ELL2_C1))(); // 2. c2 = 2^c1\nconst ELL2_C3 = /* @__PURE__ */ (() => Fp.sqrt(Fp.neg(Fp.ONE)))(); // 3. c3 = sqrt(-1)\n\n// prettier-ignore\nfunction map_to_curve_elligator2_curve25519(u: bigint) {\n  const ELL2_C4 = (Fp.ORDER - _5n) / _8n; // 4. c4 = (q - 5) / 8       # Integer arithmetic\n  const ELL2_J = BigInt(486662);\n\n  let tv1 = Fp.sqr(u);          //  1.  tv1 = u^2\n  tv1 = Fp.mul(tv1, _2n);       //  2.  tv1 = 2 * tv1\n  let xd = Fp.add(tv1, Fp.ONE); //  3.   xd = tv1 + 1         # Nonzero: -1 is square (mod p), tv1 is not\n  let x1n = Fp.neg(ELL2_J);     //  4.  x1n = -J              # x1 = x1n / xd = -J / (1 + 2 * u^2)\n  let tv2 = Fp.sqr(xd);         //  5.  tv2 = xd^2\n  let gxd = Fp.mul(tv2, xd);    //  6.  gxd = tv2 * xd        # gxd = xd^3\n  let gx1 = Fp.mul(tv1, ELL2_J);//  7.  gx1 = J * tv1         # x1n + J * xd\n  gx1 = Fp.mul(gx1, x1n);       //  8.  gx1 = gx1 * x1n       # x1n^2 + J * x1n * xd\n  gx1 = Fp.add(gx1, tv2);       //  9.  gx1 = gx1 + tv2       # x1n^2 + J * x1n * xd + xd^2\n  gx1 = Fp.mul(gx1, x1n);       //  10. gx1 = gx1 * x1n       # x1n^3 + J * x1n^2 * xd + x1n * xd^2\n  let tv3 = Fp.sqr(gxd);        //  11. tv3 = gxd^2\n  tv2 = Fp.sqr(tv3);            //  12. tv2 = tv3^2           # gxd^4\n  tv3 = Fp.mul(tv3, gxd);       //  13. tv3 = tv3 * gxd       # gxd^3\n  tv3 = Fp.mul(tv3, gx1);       //  14. tv3 = tv3 * gx1       # gx1 * gxd^3\n  tv2 = Fp.mul(tv2, tv3);       //  15. tv2 = tv2 * tv3       # gx1 * gxd^7\n  let y11 = Fp.pow(tv2, ELL2_C4); //  16. y11 = tv2^c4        # (gx1 * gxd^7)^((p - 5) / 8)\n  y11 = Fp.mul(y11, tv3);       //  17. y11 = y11 * tv3       # gx1*gxd^3*(gx1*gxd^7)^((p-5)/8)\n  let y12 = Fp.mul(y11, ELL2_C3); //  18. y12 = y11 * c3\n  tv2 = Fp.sqr(y11);            //  19. tv2 = y11^2\n  tv2 = Fp.mul(tv2, gxd);       //  20. tv2 = tv2 * gxd\n  let e1 = Fp.eql(tv2, gx1);    //  21.  e1 = tv2 == gx1\n  let y1 = Fp.cmov(y12, y11, e1); //  22.  y1 = CMOV(y12, y11, e1)  # If g(x1) is square, this is its sqrt\n  let x2n = Fp.mul(x1n, tv1);   //  23. x2n = x1n * tv1       # x2 = x2n / xd = 2 * u^2 * x1n / xd\n  let y21 = Fp.mul(y11, u);     //  24. y21 = y11 * u\n  y21 = Fp.mul(y21, ELL2_C2);   //  25. y21 = y21 * c2\n  let y22 = Fp.mul(y21, ELL2_C3); //  26. y22 = y21 * c3\n  let gx2 = Fp.mul(gx1, tv1);   //  27. gx2 = gx1 * tv1       # g(x2) = gx2 / gxd = 2 * u^2 * g(x1)\n  tv2 = Fp.sqr(y21);            //  28. tv2 = y21^2\n  tv2 = Fp.mul(tv2, gxd);       //  29. tv2 = tv2 * gxd\n  let e2 = Fp.eql(tv2, gx2);    //  30.  e2 = tv2 == gx2\n  let y2 = Fp.cmov(y22, y21, e2); //  31.  y2 = CMOV(y22, y21, e2)  # If g(x2) is square, this is its sqrt\n  tv2 = Fp.sqr(y1);             //  32. tv2 = y1^2\n  tv2 = Fp.mul(tv2, gxd);       //  33. tv2 = tv2 * gxd\n  let e3 = Fp.eql(tv2, gx1);    //  34.  e3 = tv2 == gx1\n  let xn = Fp.cmov(x2n, x1n, e3); //  35.  xn = CMOV(x2n, x1n, e3)  # If e3, x = x1, else x = x2\n  let y = Fp.cmov(y2, y1, e3);  //  36.   y = CMOV(y2, y1, e3)    # If e3, y = y1, else y = y2\n  let e4 = Fp.isOdd(y);         //  37.  e4 = sgn0(y) == 1        # Fix sign of y\n  y = Fp.cmov(y, Fp.neg(y), e3 !== e4); //  38.   y = CMOV(y, -y, e3 XOR e4)\n  return { xMn: xn, xMd: xd, yMn: y, yMd: _1n }; //  39. return (xn, xd, y, 1)\n}\n\nconst ELL2_C1_EDWARDS = /* @__PURE__ */ (() => FpSqrtEven(Fp, Fp.neg(BigInt(486664))))(); // sgn0(c1) MUST equal 0\nfunction map_to_curve_elligator2_edwards25519(u: bigint) {\n  const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u); //  1.  (xMn, xMd, yMn, yMd) =\n  // map_to_curve_elligator2_curve25519(u)\n  let xn = Fp.mul(xMn, yMd); //  2.  xn = xMn * yMd\n  xn = Fp.mul(xn, ELL2_C1_EDWARDS); //  3.  xn = xn * c1\n  let xd = Fp.mul(xMd, yMn); //  4.  xd = xMd * yMn    # xn / xd = c1 * xM / yM\n  let yn = Fp.sub(xMn, xMd); //  5.  yn = xMn - xMd\n  let yd = Fp.add(xMn, xMd); //  6.  yd = xMn + xMd    # (n / d - 1) / (n / d + 1) = (n - d) / (n + d)\n  let tv1 = Fp.mul(xd, yd); //  7. tv1 = xd * yd\n  let e = Fp.eql(tv1, Fp.ZERO); //  8.   e = tv1 == 0\n  xn = Fp.cmov(xn, Fp.ZERO, e); //  9.  xn = CMOV(xn, 0, e)\n  xd = Fp.cmov(xd, Fp.ONE, e); //  10. xd = CMOV(xd, 1, e)\n  yn = Fp.cmov(yn, Fp.ONE, e); //  11. yn = CMOV(yn, 1, e)\n  yd = Fp.cmov(yd, Fp.ONE, e); //  12. yd = CMOV(yd, 1, e)\n  const [xd_inv, yd_inv] = FpInvertBatch(Fp, [xd, yd], true); // batch division\n  return { x: Fp.mul(xn, xd_inv), y: Fp.mul(yn, yd_inv) }; //  13. return (xn, xd, yn, yd)\n}\n\nexport const ed25519_hasher: Hasher<bigint> = /* @__PURE__ */ (() =>\n  createHasher(\n    ed25519.ExtendedPoint,\n    (scalars: bigint[]) => map_to_curve_elligator2_edwards25519(scalars[0]),\n    {\n      DST: 'edwards25519_XMD:SHA-512_ELL2_RO_',\n      encodeDST: 'edwards25519_XMD:SHA-512_ELL2_NU_',\n      p: Fp.ORDER,\n      m: 1,\n      k: 128,\n      expand: 'xmd',\n      hash: sha512,\n    }\n  ))();\nexport const hashToCurve: HTFMethod<bigint> = /* @__PURE__ */ (() => ed25519_hasher.hashToCurve)();\nexport const encodeToCurve: HTFMethod<bigint> = /* @__PURE__ */ (() =>\n  ed25519_hasher.encodeToCurve)();\n\nfunction aristp(other: unknown) {\n  if (!(other instanceof RistPoint)) throw new Error('RistrettoPoint expected');\n}\n\n// √(-1) aka √(a) aka 2^((p-1)/4)\nconst SQRT_M1 = ED25519_SQRT_M1;\n// √(ad - 1)\nconst SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt(\n  '25063068953384623474111414158702152701244531502492656460079210482610430750235'\n);\n// 1 / √(a-d)\nconst INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt(\n  '54469307008909316920995813868745141605393597292927456921205312896311721017578'\n);\n// 1-d²\nconst ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt(\n  '1159843021668779879193775521855586647937357759715417654439879720876111806838'\n);\n// (d-1)²\nconst D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt(\n  '40440834346308536858101042469323190826248399146238708352240133220865137265952'\n);\n// Calculates 1/√(number)\nconst invertSqrt = (number: bigint) => uvRatio(_1n, number);\n\nconst MAX_255B = /* @__PURE__ */ BigInt(\n  '0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'\n);\nconst bytes255ToNumberLE = (bytes: Uint8Array) =>\n  ed25519.CURVE.Fp.create(bytesToNumberLE(bytes) & MAX_255B);\n\ntype ExtendedPoint = ExtPointType;\n\n/**\n * Computes Elligator map for Ristretto255.\n * Described in [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#appendix-B) and on\n * the [website](https://ristretto.group/formulas/elligator.html).\n */\nfunction calcElligatorRistrettoMap(r0: bigint): ExtendedPoint {\n  const { d } = ed25519.CURVE;\n  const P = ed25519.CURVE.Fp.ORDER;\n  const mod = ed25519.CURVE.Fp.create;\n  const r = mod(SQRT_M1 * r0 * r0); // 1\n  const Ns = mod((r + _1n) * ONE_MINUS_D_SQ); // 2\n  let c = BigInt(-1); // 3\n  const D = mod((c - d * r) * mod(r + d)); // 4\n  let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D); // 5\n  let s_ = mod(s * r0); // 6\n  if (!isNegativeLE(s_, P)) s_ = mod(-s_);\n  if (!Ns_D_is_sq) s = s_; // 7\n  if (!Ns_D_is_sq) c = r; // 8\n  const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D); // 9\n  const s2 = s * s;\n  const W0 = mod((s + s) * D); // 10\n  const W1 = mod(Nt * SQRT_AD_MINUS_ONE); // 11\n  const W2 = mod(_1n - s2); // 12\n  const W3 = mod(_1n + s2); // 13\n  return new ed25519.ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n}\n\n/**\n * Each ed25519/ExtendedPoint has 8 different equivalent points. This can be\n * a source of bugs for protocols like ring signatures. Ristretto was created to solve this.\n * Ristretto point operates in X:Y:Z:T extended coordinates like ExtendedPoint,\n * but it should work in its own namespace: do not combine those two.\n * See [RFC9496](https://www.rfc-editor.org/rfc/rfc9496).\n */\nclass RistPoint implements Group<RistPoint> {\n  static BASE: RistPoint;\n  static ZERO: RistPoint;\n  private readonly ep: ExtendedPoint;\n  // Private property to discourage combining ExtendedPoint + RistrettoPoint\n  // Always use Ristretto encoding/decoding instead.\n  constructor(ep: ExtendedPoint) {\n    this.ep = ep;\n  }\n\n  static fromAffine(ap: AffinePoint<bigint>): RistPoint {\n    return new RistPoint(ed25519.ExtendedPoint.fromAffine(ap));\n  }\n\n  /**\n   * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.\n   * The hash-to-group operation applies Elligator twice and adds the results.\n   * **Note:** this is one-way map, there is no conversion from point to hash.\n   * Described in [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#appendix-B) and on\n   * the [website](https://ristretto.group/formulas/elligator.html).\n   * @param hex 64-byte output of a hash function\n   */\n  static hashToCurve(hex: Hex): RistPoint {\n    hex = ensureBytes('ristrettoHash', hex, 64);\n    const r1 = bytes255ToNumberLE(hex.slice(0, 32));\n    const R1 = calcElligatorRistrettoMap(r1);\n    const r2 = bytes255ToNumberLE(hex.slice(32, 64));\n    const R2 = calcElligatorRistrettoMap(r2);\n    return new RistPoint(R1.add(R2));\n  }\n\n  /**\n   * Converts ristretto-encoded string to ristretto point.\n   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).\n   * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding\n   */\n  static fromHex(hex: Hex): RistPoint {\n    hex = ensureBytes('ristrettoHex', hex, 32);\n    const { a, d } = ed25519.CURVE;\n    const P = ed25519.CURVE.Fp.ORDER;\n    const mod = ed25519.CURVE.Fp.create;\n    const emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';\n    const s = bytes255ToNumberLE(hex);\n    // 1. Check that s_bytes is the canonical encoding of a field element, or else abort.\n    // 3. Check that s is non-negative, or else abort\n    if (!equalBytes(numberToBytesLE(s, 32), hex) || isNegativeLE(s, P)) throw new Error(emsg);\n    const s2 = mod(s * s);\n    const u1 = mod(_1n + a * s2); // 4 (a is -1)\n    const u2 = mod(_1n - a * s2); // 5\n    const u1_2 = mod(u1 * u1);\n    const u2_2 = mod(u2 * u2);\n    const v = mod(a * d * u1_2 - u2_2); // 6\n    const { isValid, value: I } = invertSqrt(mod(v * u2_2)); // 7\n    const Dx = mod(I * u2); // 8\n    const Dy = mod(I * Dx * v); // 9\n    let x = mod((s + s) * Dx); // 10\n    if (isNegativeLE(x, P)) x = mod(-x); // 10\n    const y = mod(u1 * Dy); // 11\n    const t = mod(x * y); // 12\n    if (!isValid || isNegativeLE(t, P) || y === _0n) throw new Error(emsg);\n    return new RistPoint(new ed25519.ExtendedPoint(x, y, _1n, t));\n  }\n\n  static msm(points: RistPoint[], scalars: bigint[]): RistPoint {\n    const Fn = Field(ed25519.CURVE.n, ed25519.CURVE.nBitLength);\n    return pippenger(RistPoint, Fn, points, scalars);\n  }\n\n  /**\n   * Encodes ristretto point to Uint8Array.\n   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).\n   */\n  toRawBytes(): Uint8Array {\n    let { ex: x, ey: y, ez: z, et: t } = this.ep;\n    const P = ed25519.CURVE.Fp.ORDER;\n    const mod = ed25519.CURVE.Fp.create;\n    const u1 = mod(mod(z + y) * mod(z - y)); // 1\n    const u2 = mod(x * y); // 2\n    // Square root always exists\n    const u2sq = mod(u2 * u2);\n    const { value: invsqrt } = invertSqrt(mod(u1 * u2sq)); // 3\n    const D1 = mod(invsqrt * u1); // 4\n    const D2 = mod(invsqrt * u2); // 5\n    const zInv = mod(D1 * D2 * t); // 6\n    let D: bigint; // 7\n    if (isNegativeLE(t * zInv, P)) {\n      let _x = mod(y * SQRT_M1);\n      let _y = mod(x * SQRT_M1);\n      x = _x;\n      y = _y;\n      D = mod(D1 * INVSQRT_A_MINUS_D);\n    } else {\n      D = D2; // 8\n    }\n    if (isNegativeLE(x * zInv, P)) y = mod(-y); // 9\n    let s = mod((z - y) * D); // 10 (check footer's note, no sqrt(-a))\n    if (isNegativeLE(s, P)) s = mod(-s);\n    return numberToBytesLE(s, 32); // 11\n  }\n\n  toHex(): string {\n    return bytesToHex(this.toRawBytes());\n  }\n\n  toString(): string {\n    return this.toHex();\n  }\n\n  /**\n   * Compares two Ristretto points.\n   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).\n   */\n  equals(other: RistPoint): boolean {\n    aristp(other);\n    const { ex: X1, ey: Y1 } = this.ep;\n    const { ex: X2, ey: Y2 } = other.ep;\n    const mod = ed25519.CURVE.Fp.create;\n    // (x1 * y2 == y1 * x2) | (y1 * y2 == x1 * x2)\n    const one = mod(X1 * Y2) === mod(Y1 * X2);\n    const two = mod(Y1 * Y2) === mod(X1 * X2);\n    return one || two;\n  }\n\n  add(other: RistPoint): RistPoint {\n    aristp(other);\n    return new RistPoint(this.ep.add(other.ep));\n  }\n\n  subtract(other: RistPoint): RistPoint {\n    aristp(other);\n    return new RistPoint(this.ep.subtract(other.ep));\n  }\n\n  multiply(scalar: bigint): RistPoint {\n    return new RistPoint(this.ep.multiply(scalar));\n  }\n\n  multiplyUnsafe(scalar: bigint): RistPoint {\n    return new RistPoint(this.ep.multiplyUnsafe(scalar));\n  }\n\n  double(): RistPoint {\n    return new RistPoint(this.ep.double());\n  }\n\n  negate(): RistPoint {\n    return new RistPoint(this.ep.negate());\n  }\n}\n\n/**\n * Wrapper over Edwards Point for ristretto255 from\n * [RFC9496](https://www.rfc-editor.org/rfc/rfc9496).\n */\nexport const RistrettoPoint: typeof RistPoint = /* @__PURE__ */ (() => {\n  if (!RistPoint.BASE) RistPoint.BASE = new RistPoint(ed25519.ExtendedPoint.BASE);\n  if (!RistPoint.ZERO) RistPoint.ZERO = new RistPoint(ed25519.ExtendedPoint.ZERO);\n  return RistPoint;\n})();\n\n/**\n * hash-to-curve for ristretto255.\n * Described in [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#appendix-B).\n */\nexport const hashToRistretto255 = (msg: Uint8Array, options: htfBasicOpts): RistPoint => {\n  const d = options.DST;\n  const DST = typeof d === 'string' ? utf8ToBytes(d) : d;\n  const uniform_bytes = expand_message_xmd(msg, DST, 64, sha512);\n  const P = RistPoint.hashToCurve(uniform_bytes);\n  return P;\n};\n/** @deprecated */\nexport const hash_to_ristretto255: (msg: Uint8Array, options: htfBasicOpts) => RistPoint =\n  hashToRistretto255; // legacy\n", "/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */\n\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n/** Asserts something is boolean. */\nexport function abool(b: boolean): void {\n  if (typeof b !== 'boolean') throw new Error(`boolean expected, not ${b}`);\n}\n\n/** Asserts something is positive integer. */\nexport function anumber(n: number): void {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);\n}\n\n/** Asserts something is Uint8Array. */\nexport function abytes(b: Uint8Array | undefined, ...lengths: number[]): void {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n\n/**\n * Asserts something is hash\n * TODO: remove\n * @deprecated\n */\nexport function ahash(h: IHash): void {\n  if (typeof h !== 'function' || typeof h.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.createHasher');\n  anumber(h.outputLen);\n  anumber(h.blockLen);\n}\n\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance: any, checkFinished = true): void {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\n\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out: any, instance: any): void {\n  abytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error('digestInto() expects output buffer of length at least ' + min);\n  }\n}\n\nexport type IHash = {\n  (data: string | Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\n\n/** Generic type encompassing 8/16/32-byte arrays - but not 64-byte. */\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr: TypedArray): Uint8Array {\n  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr: TypedArray): Uint32Array {\n  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays: TypedArray[]): void {\n  for (let i = 0; i < arrays.length; i++) {\n    arrays[i].fill(0);\n  }\n}\n\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr: TypedArray): DataView {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE: boolean = /* @__PURE__ */ (() =>\n  new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin: boolean = /* @__PURE__ */ (() =>\n  // @ts-ignore\n  typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // @ts-ignore\n  if (hasHexBuiltin) return bytes.toHex();\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // @ts-ignore\n  if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n// Used in micro\nexport function hexToNumber(hex: string): bigint {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  return BigInt(hex === '' ? '0' : '0x' + hex); // Big Endian\n}\n\n// Used in ff1\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes: Uint8Array): bigint {\n  return hexToNumber(bytesToHex(bytes));\n}\n\n// Used in micro, ff1\nexport function numberToBytesBE(n: number | bigint, len: number): Uint8Array {\n  return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\n\n// TODO: remove\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async (): Promise<void> => {};\n\n// Global symbols, but ts doesn't see them: https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('string expected');\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(new Uint8Array([97, 98, 99])) // 'abc'\n */\nexport function bytesToUtf8(bytes: Uint8Array): string {\n  return new TextDecoder().decode(bytes);\n}\n\n// TODO: remove\nexport type Input = Uint8Array | string;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: string | Uint8Array): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  else if (isBytes(data)) data = copyBytes(data);\n  else throw new Error('Uint8Array expected, got ' + typeof data);\n  return data;\n}\n\n/**\n * Checks if two U8A use same underlying buffer and overlaps.\n * This is invalid and can corrupt data.\n */\nexport function overlapBytes(a: Uint8Array, b: Uint8Array): boolean {\n  return (\n    a.buffer === b.buffer && // best we can do, may fail with an obscure Proxy\n    a.byteOffset < b.byteOffset + b.byteLength && // a starts before b end\n    b.byteOffset < a.byteOffset + a.byteLength // b starts before a end\n  );\n}\n\n/**\n * If input and output overlap and input starts before output, we will overwrite end of input before\n * we start processing it, so this is not supported for most ciphers (except chacha/salse, which designed with this)\n */\nexport function complexOverlapBytes(input: Uint8Array, output: Uint8Array): void {\n  // This is very cursed. It works somehow, but I'm completely unsure,\n  // reasoning about overlapping aligned windows is very hard.\n  if (overlapBytes(input, output) && input.byteOffset < output.byteOffset)\n    throw new Error('complex overlap of input and output is not supported');\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\n// Used in ARX only\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts: T2\n): T1 & T2 {\n  if (opts == null || typeof opts !== 'object') throw new Error('options must be defined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\n/** Compares 2 uint8array-s in kinda constant time. */\nexport function equalBytes(a: Uint8Array, b: Uint8Array): boolean {\n  if (a.length !== b.length) return false;\n  let diff = 0;\n  for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];\n  return diff === 0;\n}\n\n// TODO: remove\n/** For runtime check if class implements interface. */\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: string | Uint8Array): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n}\n\n// This will allow to re-use with composable things like packed & base encoders\n// Also, we probably can make tags composable\n\n/** Sync cipher: takes byte array and returns byte array. */\nexport type Cipher = {\n  encrypt(plaintext: Uint8Array): Uint8Array;\n  decrypt(ciphertext: Uint8Array): Uint8Array;\n};\n\n/** Async cipher e.g. from built-in WebCrypto. */\nexport type AsyncCipher = {\n  encrypt(plaintext: Uint8Array): Promise<Uint8Array>;\n  decrypt(ciphertext: Uint8Array): Promise<Uint8Array>;\n};\n\n/** Cipher with `output` argument which can optimize by doing 1 less allocation. */\nexport type CipherWithOutput = Cipher & {\n  encrypt(plaintext: Uint8Array, output?: Uint8Array): Uint8Array;\n  decrypt(ciphertext: Uint8Array, output?: Uint8Array): Uint8Array;\n};\n\n/**\n * Params are outside of return type, so it is accessible before calling constructor.\n * If function support multiple nonceLength's, we return the best one.\n */\nexport type CipherParams = {\n  blockSize: number;\n  nonceLength?: number;\n  tagLength?: number;\n  varSizeNonce?: boolean;\n};\n/** ARX cipher, like salsa or chacha. */\nexport type ARXCipher = ((\n  key: Uint8Array,\n  nonce: Uint8Array,\n  AAD?: Uint8Array\n) => CipherWithOutput) & {\n  blockSize: number;\n  nonceLength: number;\n  tagLength: number;\n};\nexport type CipherCons<T extends any[]> = (key: Uint8Array, ...args: T) => Cipher;\n/**\n * Wraps a cipher: validates args, ensures encrypt() can only be called once.\n * @__NO_SIDE_EFFECTS__\n */\nexport const wrapCipher = <C extends CipherCons<any>, P extends CipherParams>(\n  params: P,\n  constructor: C\n): C & P => {\n  function wrappedCipher(key: Uint8Array, ...args: any[]): CipherWithOutput {\n    // Validate key\n    abytes(key);\n\n    // Big-Endian hardware is rare. Just in case someone still decides to run ciphers:\n    if (!isLE) throw new Error('Non little-endian hardware is not yet supported');\n\n    // Validate nonce if nonceLength is present\n    if (params.nonceLength !== undefined) {\n      const nonce = args[0];\n      if (!nonce) throw new Error('nonce / iv required');\n      if (params.varSizeNonce) abytes(nonce);\n      else abytes(nonce, params.nonceLength);\n    }\n\n    // Validate AAD if tagLength present\n    const tagl = params.tagLength;\n    if (tagl && args[1] !== undefined) {\n      abytes(args[1]);\n    }\n\n    const cipher = constructor(key, ...args);\n    const checkOutput = (fnLength: number, output?: Uint8Array) => {\n      if (output !== undefined) {\n        if (fnLength !== 2) throw new Error('cipher output not supported');\n        abytes(output);\n      }\n    };\n    // Create wrapped cipher with validation and single-use encryption\n    let called = false;\n    const wrCipher = {\n      encrypt(data: Uint8Array, output?: Uint8Array) {\n        if (called) throw new Error('cannot encrypt() twice with same key + nonce');\n        called = true;\n        abytes(data);\n        checkOutput(cipher.encrypt.length, output);\n        return (cipher as CipherWithOutput).encrypt(data, output);\n      },\n      decrypt(data: Uint8Array, output?: Uint8Array) {\n        abytes(data);\n        if (tagl && data.length < tagl)\n          throw new Error('invalid ciphertext length: smaller than tagLength=' + tagl);\n        checkOutput(cipher.decrypt.length, output);\n        return (cipher as CipherWithOutput).decrypt(data, output);\n      },\n    };\n\n    return wrCipher;\n  }\n\n  Object.assign(wrappedCipher, params);\n  return wrappedCipher as C & P;\n};\n\n/** Represents salsa / chacha stream. */\nexport type XorStream = (\n  key: Uint8Array,\n  nonce: Uint8Array,\n  data: Uint8Array,\n  output?: Uint8Array,\n  counter?: number\n) => Uint8Array;\n\n/**\n * By default, returns u8a of length.\n * When out is available, it checks it for validity and uses it.\n */\nexport function getOutput(\n  expectedLength: number,\n  out?: Uint8Array,\n  onlyAligned = true\n): Uint8Array {\n  if (out === undefined) return new Uint8Array(expectedLength);\n  if (out.length !== expectedLength)\n    throw new Error('invalid output length, expected ' + expectedLength + ', got: ' + out.length);\n  if (onlyAligned && !isAligned32(out)) throw new Error('invalid output, must be aligned');\n  return out;\n}\n\n/** Polyfill for Safari 14. */\nexport function setBigUint64(\n  view: DataView,\n  byteOffset: number,\n  value: bigint,\n  isLE: boolean\n): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\nexport function u64Lengths(dataLength: number, aadLength: number, isLE: boolean): Uint8Array {\n  abool(isLE);\n  const num = new Uint8Array(16);\n  const view = createView(num);\n  setBigUint64(view, 0, BigInt(aadLength), isLE);\n  setBigUint64(view, 8, BigInt(dataLength), isLE);\n  return num;\n}\n\n// Is byte array aligned to 4 byte offset (u32)?\nexport function isAligned32(bytes: Uint8Array): boolean {\n  return bytes.byteOffset % 4 === 0;\n}\n\n// copy bytes to new u8a (aligned). Because Buffer.slice is broken.\nexport function copyBytes(bytes: Uint8Array): Uint8Array {\n  return Uint8Array.from(bytes);\n}\n", "/**\n * GHash from AES-GCM and its little-endian \"mirror image\" Polyval from AES-SIV.\n *\n * Implemented in terms of GHash with conversion function for keys\n * GCM GHASH from\n * [NIST SP800-38d](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf),\n * SIV from\n * [RFC 8452](https://datatracker.ietf.org/doc/html/rfc8452).\n *\n * GHASH   modulo: x^128 + x^7   + x^2   + x     + 1\n * POLYVAL modulo: x^128 + x^127 + x^126 + x^121 + 1\n *\n * @module\n */\n// prettier-ignore\nimport {\n  abytes, aexists, aoutput,\n  clean, copyBytes, createView, Hash, type Input, toBytes, u32,\n} from './utils.ts';\n\nconst BLOCK_SIZE = 16;\n// TODO: rewrite\n// temporary padding buffer\nconst ZEROS16 = /* @__PURE__ */ new Uint8Array(16);\nconst ZEROS32 = u32(ZEROS16);\nconst POLY = 0xe1; // v = 2*v % POLY\n\n// v = 2*v % POLY\n// NOTE: because x + x = 0 (add/sub is same), mul2(x) != x+x\n// We can multiply any number using montgomery ladder and this function (works as double, add is simple xor)\nconst mul2 = (s0: number, s1: number, s2: number, s3: number) => {\n  const hiBit = s3 & 1;\n  return {\n    s3: (s2 << 31) | (s3 >>> 1),\n    s2: (s1 << 31) | (s2 >>> 1),\n    s1: (s0 << 31) | (s1 >>> 1),\n    s0: (s0 >>> 1) ^ ((POLY << 24) & -(hiBit & 1)), // reduce % poly\n  };\n};\n\nconst swapLE = (n: number) =>\n  (((n >>> 0) & 0xff) << 24) |\n  (((n >>> 8) & 0xff) << 16) |\n  (((n >>> 16) & 0xff) << 8) |\n  ((n >>> 24) & 0xff) |\n  0;\n\n/**\n * `mulX_POLYVAL(ByteReverse(H))` from spec\n * @param k mutated in place\n */\nexport function _toGHASHKey(k: Uint8Array): Uint8Array {\n  k.reverse();\n  const hiBit = k[15] & 1;\n  // k >>= 1\n  let carry = 0;\n  for (let i = 0; i < k.length; i++) {\n    const t = k[i];\n    k[i] = (t >>> 1) | carry;\n    carry = (t & 1) << 7;\n  }\n  k[0] ^= -hiBit & 0xe1; // if (hiBit) n ^= 0xe1000000000000000000000000000000;\n  return k;\n}\n\ntype Value = { s0: number; s1: number; s2: number; s3: number };\n\nconst estimateWindow = (bytes: number) => {\n  if (bytes > 64 * 1024) return 8;\n  if (bytes > 1024) return 4;\n  return 2;\n};\n\nclass GHASH implements Hash<GHASH> {\n  readonly blockLen = BLOCK_SIZE;\n  readonly outputLen = BLOCK_SIZE;\n  protected s0 = 0;\n  protected s1 = 0;\n  protected s2 = 0;\n  protected s3 = 0;\n  protected finished = false;\n  protected t: Value[];\n  private W: number;\n  private windowSize: number;\n  // We select bits per window adaptively based on expectedLength\n  constructor(key: Input, expectedLength?: number) {\n    key = toBytes(key);\n    abytes(key, 16);\n    const kView = createView(key);\n    let k0 = kView.getUint32(0, false);\n    let k1 = kView.getUint32(4, false);\n    let k2 = kView.getUint32(8, false);\n    let k3 = kView.getUint32(12, false);\n    // generate table of doubled keys (half of montgomery ladder)\n    const doubles: Value[] = [];\n    for (let i = 0; i < 128; i++) {\n      doubles.push({ s0: swapLE(k0), s1: swapLE(k1), s2: swapLE(k2), s3: swapLE(k3) });\n      ({ s0: k0, s1: k1, s2: k2, s3: k3 } = mul2(k0, k1, k2, k3));\n    }\n    const W = estimateWindow(expectedLength || 1024);\n    if (![1, 2, 4, 8].includes(W))\n      throw new Error('ghash: invalid window size, expected 2, 4 or 8');\n    this.W = W;\n    const bits = 128; // always 128 bits;\n    const windows = bits / W;\n    const windowSize = (this.windowSize = 2 ** W);\n    const items: Value[] = [];\n    // Create precompute table for window of W bits\n    for (let w = 0; w < windows; w++) {\n      // truth table: 00, 01, 10, 11\n      for (let byte = 0; byte < windowSize; byte++) {\n        // prettier-ignore\n        let s0 = 0, s1 = 0, s2 = 0, s3 = 0;\n        for (let j = 0; j < W; j++) {\n          const bit = (byte >>> (W - j - 1)) & 1;\n          if (!bit) continue;\n          const { s0: d0, s1: d1, s2: d2, s3: d3 } = doubles[W * w + j];\n          (s0 ^= d0), (s1 ^= d1), (s2 ^= d2), (s3 ^= d3);\n        }\n        items.push({ s0, s1, s2, s3 });\n      }\n    }\n    this.t = items;\n  }\n  protected _updateBlock(s0: number, s1: number, s2: number, s3: number) {\n    (s0 ^= this.s0), (s1 ^= this.s1), (s2 ^= this.s2), (s3 ^= this.s3);\n    const { W, t, windowSize } = this;\n    // prettier-ignore\n    let o0 = 0, o1 = 0, o2 = 0, o3 = 0;\n    const mask = (1 << W) - 1; // 2**W will kill performance.\n    let w = 0;\n    for (const num of [s0, s1, s2, s3]) {\n      for (let bytePos = 0; bytePos < 4; bytePos++) {\n        const byte = (num >>> (8 * bytePos)) & 0xff;\n        for (let bitPos = 8 / W - 1; bitPos >= 0; bitPos--) {\n          const bit = (byte >>> (W * bitPos)) & mask;\n          const { s0: e0, s1: e1, s2: e2, s3: e3 } = t[w * windowSize + bit];\n          (o0 ^= e0), (o1 ^= e1), (o2 ^= e2), (o3 ^= e3);\n          w += 1;\n        }\n      }\n    }\n    this.s0 = o0;\n    this.s1 = o1;\n    this.s2 = o2;\n    this.s3 = o3;\n  }\n  update(data: Input): this {\n    aexists(this);\n    data = toBytes(data);\n    abytes(data);\n    const b32 = u32(data);\n    const blocks = Math.floor(data.length / BLOCK_SIZE);\n    const left = data.length % BLOCK_SIZE;\n    for (let i = 0; i < blocks; i++) {\n      this._updateBlock(b32[i * 4 + 0], b32[i * 4 + 1], b32[i * 4 + 2], b32[i * 4 + 3]);\n    }\n    if (left) {\n      ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));\n      this._updateBlock(ZEROS32[0], ZEROS32[1], ZEROS32[2], ZEROS32[3]);\n      clean(ZEROS32); // clean tmp buffer\n    }\n    return this;\n  }\n  destroy() {\n    const { t } = this;\n    // clean precompute table\n    for (const elm of t) {\n      (elm.s0 = 0), (elm.s1 = 0), (elm.s2 = 0), (elm.s3 = 0);\n    }\n  }\n  digestInto(out: Uint8Array) {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    const { s0, s1, s2, s3 } = this;\n    const o32 = u32(out);\n    o32[0] = s0;\n    o32[1] = s1;\n    o32[2] = s2;\n    o32[3] = s3;\n    return out;\n  }\n  digest(): Uint8Array {\n    const res = new Uint8Array(BLOCK_SIZE);\n    this.digestInto(res);\n    this.destroy();\n    return res;\n  }\n}\n\nclass Polyval extends GHASH {\n  constructor(key: Input, expectedLength?: number) {\n    key = toBytes(key);\n    abytes(key);\n    const ghKey = _toGHASHKey(copyBytes(key));\n    super(ghKey, expectedLength);\n    clean(ghKey);\n  }\n  update(data: Input): this {\n    data = toBytes(data);\n    aexists(this);\n    const b32 = u32(data);\n    const left = data.length % BLOCK_SIZE;\n    const blocks = Math.floor(data.length / BLOCK_SIZE);\n    for (let i = 0; i < blocks; i++) {\n      this._updateBlock(\n        swapLE(b32[i * 4 + 3]),\n        swapLE(b32[i * 4 + 2]),\n        swapLE(b32[i * 4 + 1]),\n        swapLE(b32[i * 4 + 0])\n      );\n    }\n    if (left) {\n      ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));\n      this._updateBlock(\n        swapLE(ZEROS32[3]),\n        swapLE(ZEROS32[2]),\n        swapLE(ZEROS32[1]),\n        swapLE(ZEROS32[0])\n      );\n      clean(ZEROS32);\n    }\n    return this;\n  }\n  digestInto(out: Uint8Array) {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    // tmp ugly hack\n    const { s0, s1, s2, s3 } = this;\n    const o32 = u32(out);\n    o32[0] = s0;\n    o32[1] = s1;\n    o32[2] = s2;\n    o32[3] = s3;\n    return out.reverse();\n  }\n}\n\nexport type CHashPV = ReturnType<typeof wrapConstructorWithKey>;\nfunction wrapConstructorWithKey<H extends Hash<H>>(\n  hashCons: (key: Input, expectedLength?: number) => Hash<H>\n): {\n  (msg: Input, key: Input): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(key: Input, expectedLength?: number): Hash<H>;\n} {\n  const hashC = (msg: Input, key: Input): Uint8Array =>\n    hashCons(key, msg.length).update(toBytes(msg)).digest();\n  const tmp = hashCons(new Uint8Array(16), 0);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (key: Input, expectedLength?: number) => hashCons(key, expectedLength);\n  return hashC;\n}\n\n/** GHash MAC for AES-GCM. */\nexport const ghash: CHashPV = wrapConstructorWithKey(\n  (key, expectedLength) => new GHASH(key, expectedLength)\n);\n\n/** Polyval MAC for AES-SIV. */\nexport const polyval: CHashPV = wrapConstructorWithKey(\n  (key, expectedLength) => new Polyval(key, expectedLength)\n);\n", "/**\n * [AES](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard)\n * a.k.a. Advanced Encryption Standard\n * is a variant of Rijndael block cipher, standardized by NIST in 2001.\n * We provide the fastest available pure JS implementation.\n *\n * Data is split into 128-bit blocks. Encrypted in 10/12/14 rounds (128/192/256 bits). In every round:\n * 1. **S-box**, table substitution\n * 2. **Shift rows**, cyclic shift left of all rows of data array\n * 3. **Mix columns**, multiplying every column by fixed polynomial\n * 4. **Add round key**, round_key xor i-th column of array\n *\n * Check out [FIPS-197](https://csrc.nist.gov/files/pubs/fips/197/final/docs/fips-197.pdf)\n * and [original proposal](https://csrc.nist.gov/csrc/media/projects/cryptographic-standards-and-guidelines/documents/aes-development/rijndael-ammended.pdf)\n * @module\n */\nimport { ghash, polyval } from './_polyval.ts';\n// prettier-ignore\nimport {\n  abytes, clean, complexOverlapBytes, concatBytes,\n  copyBytes, createView, equalBytes, getOutput, isAligned32, overlapBytes,\n  setBigUint64, u32, u64Lengths, u8, wrapCipher,\n  type Cipher, type CipherWithOutput,\n} from './utils.ts';\n\nconst BLOCK_SIZE = 16;\nconst BLOCK_SIZE32 = 4;\nconst EMPTY_BLOCK = /* @__PURE__ */ new Uint8Array(BLOCK_SIZE);\nconst POLY = 0x11b; // 1 + x + x**3 + x**4 + x**8\n\n// TODO: remove multiplication, binary ops only\nfunction mul2(n: number) {\n  return (n << 1) ^ (POLY & -(n >> 7));\n}\n\nfunction mul(a: number, b: number) {\n  let res = 0;\n  for (; b > 0; b >>= 1) {\n    // Montgomery ladder\n    res ^= a & -(b & 1); // if (b&1) res ^=a (but const-time).\n    a = mul2(a); // a = 2*a\n  }\n  return res;\n}\n\n// AES S-box is generated using finite field inversion,\n// an affine transform, and xor of a constant 0x63.\nconst sbox = /* @__PURE__ */ (() => {\n  const t = new Uint8Array(256);\n  for (let i = 0, x = 1; i < 256; i++, x ^= mul2(x)) t[i] = x;\n  const box = new Uint8Array(256);\n  box[0] = 0x63; // first elm\n  for (let i = 0; i < 255; i++) {\n    let x = t[255 - i];\n    x |= x << 8;\n    box[t[i]] = (x ^ (x >> 4) ^ (x >> 5) ^ (x >> 6) ^ (x >> 7) ^ 0x63) & 0xff;\n  }\n  clean(t);\n  return box;\n})();\n\n// Inverted S-box\nconst invSbox = /* @__PURE__ */ sbox.map((_, j) => sbox.indexOf(j));\n\n// Rotate u32 by 8\nconst rotr32_8 = (n: number) => (n << 24) | (n >>> 8);\nconst rotl32_8 = (n: number) => (n << 8) | (n >>> 24);\n// The byte swap operation for uint32 (LE<->BE)\nconst byteSwap = (word: number) =>\n  ((word << 24) & 0xff000000) |\n  ((word << 8) & 0xff0000) |\n  ((word >>> 8) & 0xff00) |\n  ((word >>> 24) & 0xff);\n\n// T-table is optimization suggested in 5.2 of original proposal (missed from FIPS-197). Changes:\n// - LE instead of BE\n// - bigger tables: T0 and T1 are merged into T01 table and T2 & T3 into T23;\n//   so index is u16, instead of u8. This speeds up things, unexpectedly\nfunction genTtable(sbox: Uint8Array, fn: (n: number) => number) {\n  if (sbox.length !== 256) throw new Error('Wrong sbox length');\n  const T0 = new Uint32Array(256).map((_, j) => fn(sbox[j]));\n  const T1 = T0.map(rotl32_8);\n  const T2 = T1.map(rotl32_8);\n  const T3 = T2.map(rotl32_8);\n  const T01 = new Uint32Array(256 * 256);\n  const T23 = new Uint32Array(256 * 256);\n  const sbox2 = new Uint16Array(256 * 256);\n  for (let i = 0; i < 256; i++) {\n    for (let j = 0; j < 256; j++) {\n      const idx = i * 256 + j;\n      T01[idx] = T0[i] ^ T1[j];\n      T23[idx] = T2[i] ^ T3[j];\n      sbox2[idx] = (sbox[i] << 8) | sbox[j];\n    }\n  }\n  return { sbox, sbox2, T0, T1, T2, T3, T01, T23 };\n}\n\nconst tableEncoding = /* @__PURE__ */ genTtable(\n  sbox,\n  (s: number) => (mul(s, 3) << 24) | (s << 16) | (s << 8) | mul(s, 2)\n);\nconst tableDecoding = /* @__PURE__ */ genTtable(\n  invSbox,\n  (s) => (mul(s, 11) << 24) | (mul(s, 13) << 16) | (mul(s, 9) << 8) | mul(s, 14)\n);\n\nconst xPowers = /* @__PURE__ */ (() => {\n  const p = new Uint8Array(16);\n  for (let i = 0, x = 1; i < 16; i++, x = mul2(x)) p[i] = x;\n  return p;\n})();\n\n/** Key expansion used in CTR. */\nfunction expandKeyLE(key: Uint8Array): Uint32Array {\n  abytes(key);\n  const len = key.length;\n  if (![16, 24, 32].includes(len))\n    throw new Error('aes: invalid key size, should be 16, 24 or 32, got ' + len);\n  const { sbox2 } = tableEncoding;\n  const toClean = [];\n  if (!isAligned32(key)) toClean.push((key = copyBytes(key)));\n  const k32 = u32(key);\n  const Nk = k32.length;\n  const subByte = (n: number) => applySbox(sbox2, n, n, n, n);\n  const xk = new Uint32Array(len + 28); // expanded key\n  xk.set(k32);\n  // 4.3.1 Key expansion\n  for (let i = Nk; i < xk.length; i++) {\n    let t = xk[i - 1];\n    if (i % Nk === 0) t = subByte(rotr32_8(t)) ^ xPowers[i / Nk - 1];\n    else if (Nk > 6 && i % Nk === 4) t = subByte(t);\n    xk[i] = xk[i - Nk] ^ t;\n  }\n  clean(...toClean);\n  return xk;\n}\n\nfunction expandKeyDecLE(key: Uint8Array): Uint32Array {\n  const encKey = expandKeyLE(key);\n  const xk = encKey.slice();\n  const Nk = encKey.length;\n  const { sbox2 } = tableEncoding;\n  const { T0, T1, T2, T3 } = tableDecoding;\n  // Inverse key by chunks of 4 (rounds)\n  for (let i = 0; i < Nk; i += 4) {\n    for (let j = 0; j < 4; j++) xk[i + j] = encKey[Nk - i - 4 + j];\n  }\n  clean(encKey);\n  // apply InvMixColumn except first & last round\n  for (let i = 4; i < Nk - 4; i++) {\n    const x = xk[i];\n    const w = applySbox(sbox2, x, x, x, x);\n    xk[i] = T0[w & 0xff] ^ T1[(w >>> 8) & 0xff] ^ T2[(w >>> 16) & 0xff] ^ T3[w >>> 24];\n  }\n  return xk;\n}\n\n// Apply tables\nfunction apply0123(\n  T01: Uint32Array,\n  T23: Uint32Array,\n  s0: number,\n  s1: number,\n  s2: number,\n  s3: number\n) {\n  return (\n    T01[((s0 << 8) & 0xff00) | ((s1 >>> 8) & 0xff)] ^\n    T23[((s2 >>> 8) & 0xff00) | ((s3 >>> 24) & 0xff)]\n  );\n}\n\nfunction applySbox(sbox2: Uint16Array, s0: number, s1: number, s2: number, s3: number) {\n  return (\n    sbox2[(s0 & 0xff) | (s1 & 0xff00)] |\n    (sbox2[((s2 >>> 16) & 0xff) | ((s3 >>> 16) & 0xff00)] << 16)\n  );\n}\n\nfunction encrypt(\n  xk: Uint32Array,\n  s0: number,\n  s1: number,\n  s2: number,\n  s3: number\n): { s0: number; s1: number; s2: number; s3: number } {\n  const { sbox2, T01, T23 } = tableEncoding;\n  let k = 0;\n  (s0 ^= xk[k++]), (s1 ^= xk[k++]), (s2 ^= xk[k++]), (s3 ^= xk[k++]);\n  const rounds = xk.length / 4 - 2;\n  for (let i = 0; i < rounds; i++) {\n    const t0 = xk[k++] ^ apply0123(T01, T23, s0, s1, s2, s3);\n    const t1 = xk[k++] ^ apply0123(T01, T23, s1, s2, s3, s0);\n    const t2 = xk[k++] ^ apply0123(T01, T23, s2, s3, s0, s1);\n    const t3 = xk[k++] ^ apply0123(T01, T23, s3, s0, s1, s2);\n    (s0 = t0), (s1 = t1), (s2 = t2), (s3 = t3);\n  }\n  // last round (without mixcolumns, so using SBOX2 table)\n  const t0 = xk[k++] ^ applySbox(sbox2, s0, s1, s2, s3);\n  const t1 = xk[k++] ^ applySbox(sbox2, s1, s2, s3, s0);\n  const t2 = xk[k++] ^ applySbox(sbox2, s2, s3, s0, s1);\n  const t3 = xk[k++] ^ applySbox(sbox2, s3, s0, s1, s2);\n  return { s0: t0, s1: t1, s2: t2, s3: t3 };\n}\n\n// Can't be merged with encrypt: arg positions for apply0123 / applySbox are different\nfunction decrypt(\n  xk: Uint32Array,\n  s0: number,\n  s1: number,\n  s2: number,\n  s3: number\n): {\n  s0: number;\n  s1: number;\n  s2: number;\n  s3: number;\n} {\n  const { sbox2, T01, T23 } = tableDecoding;\n  let k = 0;\n  (s0 ^= xk[k++]), (s1 ^= xk[k++]), (s2 ^= xk[k++]), (s3 ^= xk[k++]);\n  const rounds = xk.length / 4 - 2;\n  for (let i = 0; i < rounds; i++) {\n    const t0 = xk[k++] ^ apply0123(T01, T23, s0, s3, s2, s1);\n    const t1 = xk[k++] ^ apply0123(T01, T23, s1, s0, s3, s2);\n    const t2 = xk[k++] ^ apply0123(T01, T23, s2, s1, s0, s3);\n    const t3 = xk[k++] ^ apply0123(T01, T23, s3, s2, s1, s0);\n    (s0 = t0), (s1 = t1), (s2 = t2), (s3 = t3);\n  }\n  // Last round\n  const t0: number = xk[k++] ^ applySbox(sbox2, s0, s3, s2, s1);\n  const t1: number = xk[k++] ^ applySbox(sbox2, s1, s0, s3, s2);\n  const t2: number = xk[k++] ^ applySbox(sbox2, s2, s1, s0, s3);\n  const t3: number = xk[k++] ^ applySbox(sbox2, s3, s2, s1, s0);\n  return { s0: t0, s1: t1, s2: t2, s3: t3 };\n}\n\n// TODO: investigate merging with ctr32\nfunction ctrCounter(\n  xk: Uint32Array,\n  nonce: Uint8Array,\n  src: Uint8Array,\n  dst?: Uint8Array\n): Uint8Array {\n  abytes(nonce, BLOCK_SIZE);\n  abytes(src);\n  const srcLen = src.length;\n  dst = getOutput(srcLen, dst);\n  complexOverlapBytes(src, dst);\n  const ctr = nonce;\n  const c32 = u32(ctr);\n  // Fill block (empty, ctr=0)\n  let { s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]);\n  const src32 = u32(src);\n  const dst32 = u32(dst);\n  // process blocks\n  for (let i = 0; i + 4 <= src32.length; i += 4) {\n    dst32[i + 0] = src32[i + 0] ^ s0;\n    dst32[i + 1] = src32[i + 1] ^ s1;\n    dst32[i + 2] = src32[i + 2] ^ s2;\n    dst32[i + 3] = src32[i + 3] ^ s3;\n    // Full 128 bit counter with wrap around\n    let carry = 1;\n    for (let i = ctr.length - 1; i >= 0; i--) {\n      carry = (carry + (ctr[i] & 0xff)) | 0;\n      ctr[i] = carry & 0xff;\n      carry >>>= 8;\n    }\n    ({ s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]));\n  }\n  // leftovers (less than block)\n  // It's possible to handle > u32 fast, but is it worth it?\n  const start = BLOCK_SIZE * Math.floor(src32.length / BLOCK_SIZE32);\n  if (start < srcLen) {\n    const b32 = new Uint32Array([s0, s1, s2, s3]);\n    const buf = u8(b32);\n    for (let i = start, pos = 0; i < srcLen; i++, pos++) dst[i] = src[i] ^ buf[pos];\n    clean(b32);\n  }\n  return dst;\n}\n\n// AES CTR with overflowing 32 bit counter\n// It's possible to do 32le significantly simpler (and probably faster) by using u32.\n// But, we need both, and perf bottleneck is in ghash anyway.\nfunction ctr32(\n  xk: Uint32Array,\n  isLE: boolean,\n  nonce: Uint8Array,\n  src: Uint8Array,\n  dst?: Uint8Array\n): Uint8Array {\n  abytes(nonce, BLOCK_SIZE);\n  abytes(src);\n  dst = getOutput(src.length, dst);\n  const ctr = nonce; // write new value to nonce, so it can be re-used\n  const c32 = u32(ctr);\n  const view = createView(ctr);\n  const src32 = u32(src);\n  const dst32 = u32(dst);\n  const ctrPos = isLE ? 0 : 12;\n  const srcLen = src.length;\n  // Fill block (empty, ctr=0)\n  let ctrNum = view.getUint32(ctrPos, isLE); // read current counter value\n  let { s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]);\n  // process blocks\n  for (let i = 0; i + 4 <= src32.length; i += 4) {\n    dst32[i + 0] = src32[i + 0] ^ s0;\n    dst32[i + 1] = src32[i + 1] ^ s1;\n    dst32[i + 2] = src32[i + 2] ^ s2;\n    dst32[i + 3] = src32[i + 3] ^ s3;\n    ctrNum = (ctrNum + 1) >>> 0; // u32 wrap\n    view.setUint32(ctrPos, ctrNum, isLE);\n    ({ s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]));\n  }\n  // leftovers (less than a block)\n  const start = BLOCK_SIZE * Math.floor(src32.length / BLOCK_SIZE32);\n  if (start < srcLen) {\n    const b32 = new Uint32Array([s0, s1, s2, s3]);\n    const buf = u8(b32);\n    for (let i = start, pos = 0; i < srcLen; i++, pos++) dst[i] = src[i] ^ buf[pos];\n    clean(b32);\n  }\n  return dst;\n}\n\n/**\n * CTR: counter mode. Creates stream cipher.\n * Requires good IV. Parallelizable. OK, but no MAC.\n */\nexport const ctr: ((key: Uint8Array, nonce: Uint8Array) => CipherWithOutput) & {\n  blockSize: number;\n  nonceLength: number;\n} = /* @__PURE__ */ wrapCipher(\n  { blockSize: 16, nonceLength: 16 },\n  function aesctr(key: Uint8Array, nonce: Uint8Array): CipherWithOutput {\n    function processCtr(buf: Uint8Array, dst?: Uint8Array) {\n      abytes(buf);\n      if (dst !== undefined) {\n        abytes(dst);\n        if (!isAligned32(dst)) throw new Error('unaligned destination');\n      }\n      const xk = expandKeyLE(key);\n      const n = copyBytes(nonce); // align + avoid changing\n      const toClean = [xk, n];\n      if (!isAligned32(buf)) toClean.push((buf = copyBytes(buf)));\n      const out = ctrCounter(xk, n, buf, dst);\n      clean(...toClean);\n      return out;\n    }\n    return {\n      encrypt: (plaintext: Uint8Array, dst?: Uint8Array) => processCtr(plaintext, dst),\n      decrypt: (ciphertext: Uint8Array, dst?: Uint8Array) => processCtr(ciphertext, dst),\n    };\n  }\n);\n\nfunction validateBlockDecrypt(data: Uint8Array) {\n  abytes(data);\n  if (data.length % BLOCK_SIZE !== 0) {\n    throw new Error(\n      'aes-(cbc/ecb).decrypt ciphertext should consist of blocks with size ' + BLOCK_SIZE\n    );\n  }\n}\n\nfunction validateBlockEncrypt(plaintext: Uint8Array, pcks5: boolean, dst?: Uint8Array) {\n  abytes(plaintext);\n  let outLen = plaintext.length;\n  const remaining = outLen % BLOCK_SIZE;\n  if (!pcks5 && remaining !== 0)\n    throw new Error('aec/(cbc-ecb): unpadded plaintext with disabled padding');\n  if (!isAligned32(plaintext)) plaintext = copyBytes(plaintext);\n  const b = u32(plaintext);\n  if (pcks5) {\n    let left = BLOCK_SIZE - remaining;\n    if (!left) left = BLOCK_SIZE; // if no bytes left, create empty padding block\n    outLen = outLen + left;\n  }\n  dst = getOutput(outLen, dst);\n  complexOverlapBytes(plaintext, dst);\n  const o = u32(dst);\n  return { b, o, out: dst };\n}\n\nfunction validatePCKS(data: Uint8Array, pcks5: boolean) {\n  if (!pcks5) return data;\n  const len = data.length;\n  if (!len) throw new Error('aes/pcks5: empty ciphertext not allowed');\n  const lastByte = data[len - 1];\n  if (lastByte <= 0 || lastByte > 16) throw new Error('aes/pcks5: wrong padding');\n  const out = data.subarray(0, -lastByte);\n  for (let i = 0; i < lastByte; i++)\n    if (data[len - i - 1] !== lastByte) throw new Error('aes/pcks5: wrong padding');\n  return out;\n}\n\nfunction padPCKS(left: Uint8Array) {\n  const tmp = new Uint8Array(16);\n  const tmp32 = u32(tmp);\n  tmp.set(left);\n  const paddingByte = BLOCK_SIZE - left.length;\n  for (let i = BLOCK_SIZE - paddingByte; i < BLOCK_SIZE; i++) tmp[i] = paddingByte;\n  return tmp32;\n}\n\n/** Options for ECB and CBC. */\nexport type BlockOpts = { disablePadding?: boolean };\n\n/**\n * ECB: Electronic CodeBook. Simple deterministic replacement.\n * Dangerous: always map x to y. See [AES Penguin](https://words.filippo.io/the-ecb-penguin/).\n */\nexport const ecb: ((key: Uint8Array, opts?: BlockOpts) => CipherWithOutput) & {\n  blockSize: number;\n} = /* @__PURE__ */ wrapCipher(\n  { blockSize: 16 },\n  function aesecb(key: Uint8Array, opts: BlockOpts = {}): CipherWithOutput {\n    const pcks5 = !opts.disablePadding;\n    return {\n      encrypt(plaintext: Uint8Array, dst?: Uint8Array) {\n        const { b, o, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);\n        const xk = expandKeyLE(key);\n        let i = 0;\n        for (; i + 4 <= b.length; ) {\n          const { s0, s1, s2, s3 } = encrypt(xk, b[i + 0], b[i + 1], b[i + 2], b[i + 3]);\n          (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n        }\n        if (pcks5) {\n          const tmp32 = padPCKS(plaintext.subarray(i * 4));\n          const { s0, s1, s2, s3 } = encrypt(xk, tmp32[0], tmp32[1], tmp32[2], tmp32[3]);\n          (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n        }\n        clean(xk);\n        return _out;\n      },\n      decrypt(ciphertext: Uint8Array, dst?: Uint8Array) {\n        validateBlockDecrypt(ciphertext);\n        const xk = expandKeyDecLE(key);\n        dst = getOutput(ciphertext.length, dst);\n        const toClean: (Uint8Array | Uint32Array)[] = [xk];\n        if (!isAligned32(ciphertext)) toClean.push((ciphertext = copyBytes(ciphertext)));\n        complexOverlapBytes(ciphertext, dst);\n        const b = u32(ciphertext);\n        const o = u32(dst);\n        for (let i = 0; i + 4 <= b.length; ) {\n          const { s0, s1, s2, s3 } = decrypt(xk, b[i + 0], b[i + 1], b[i + 2], b[i + 3]);\n          (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n        }\n        clean(...toClean);\n        return validatePCKS(dst, pcks5);\n      },\n    };\n  }\n);\n\n/**\n * CBC: Cipher-Block-Chaining. Key is previous round’s block.\n * Fragile: needs proper padding. Unauthenticated: needs MAC.\n */\nexport const cbc: ((key: Uint8Array, iv: Uint8Array, opts?: BlockOpts) => CipherWithOutput) & {\n  blockSize: number;\n  nonceLength: number;\n} = /* @__PURE__ */ wrapCipher(\n  { blockSize: 16, nonceLength: 16 },\n  function aescbc(key: Uint8Array, iv: Uint8Array, opts: BlockOpts = {}): CipherWithOutput {\n    const pcks5 = !opts.disablePadding;\n    return {\n      encrypt(plaintext: Uint8Array, dst?: Uint8Array) {\n        const xk = expandKeyLE(key);\n        const { b, o, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);\n        let _iv = iv;\n        const toClean: (Uint8Array | Uint32Array)[] = [xk];\n        if (!isAligned32(_iv)) toClean.push((_iv = copyBytes(_iv)));\n        const n32 = u32(_iv);\n        // prettier-ignore\n        let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];\n        let i = 0;\n        for (; i + 4 <= b.length; ) {\n          (s0 ^= b[i + 0]), (s1 ^= b[i + 1]), (s2 ^= b[i + 2]), (s3 ^= b[i + 3]);\n          ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));\n          (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n        }\n        if (pcks5) {\n          const tmp32 = padPCKS(plaintext.subarray(i * 4));\n          (s0 ^= tmp32[0]), (s1 ^= tmp32[1]), (s2 ^= tmp32[2]), (s3 ^= tmp32[3]);\n          ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));\n          (o[i++] = s0), (o[i++] = s1), (o[i++] = s2), (o[i++] = s3);\n        }\n        clean(...toClean);\n        return _out;\n      },\n      decrypt(ciphertext: Uint8Array, dst?: Uint8Array) {\n        validateBlockDecrypt(ciphertext);\n        const xk = expandKeyDecLE(key);\n        let _iv = iv;\n        const toClean: (Uint8Array | Uint32Array)[] = [xk];\n        if (!isAligned32(_iv)) toClean.push((_iv = copyBytes(_iv)));\n        const n32 = u32(_iv);\n        dst = getOutput(ciphertext.length, dst);\n        if (!isAligned32(ciphertext)) toClean.push((ciphertext = copyBytes(ciphertext)));\n        complexOverlapBytes(ciphertext, dst);\n        const b = u32(ciphertext);\n        const o = u32(dst);\n        // prettier-ignore\n        let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];\n        for (let i = 0; i + 4 <= b.length; ) {\n          // prettier-ignore\n          const ps0 = s0, ps1 = s1, ps2 = s2, ps3 = s3;\n          (s0 = b[i + 0]), (s1 = b[i + 1]), (s2 = b[i + 2]), (s3 = b[i + 3]);\n          const { s0: o0, s1: o1, s2: o2, s3: o3 } = decrypt(xk, s0, s1, s2, s3);\n          (o[i++] = o0 ^ ps0), (o[i++] = o1 ^ ps1), (o[i++] = o2 ^ ps2), (o[i++] = o3 ^ ps3);\n        }\n        clean(...toClean);\n        return validatePCKS(dst, pcks5);\n      },\n    };\n  }\n);\n\n/**\n * CFB: Cipher Feedback Mode. The input for the block cipher is the previous cipher output.\n * Unauthenticated: needs MAC.\n */\nexport const cfb: ((key: Uint8Array, iv: Uint8Array) => CipherWithOutput) & {\n  blockSize: number;\n  nonceLength: number;\n} = /* @__PURE__ */ wrapCipher(\n  { blockSize: 16, nonceLength: 16 },\n  function aescfb(key: Uint8Array, iv: Uint8Array): CipherWithOutput {\n    function processCfb(src: Uint8Array, isEncrypt: boolean, dst?: Uint8Array) {\n      abytes(src);\n      const srcLen = src.length;\n      dst = getOutput(srcLen, dst);\n      if (overlapBytes(src, dst)) throw new Error('overlapping src and dst not supported.');\n      const xk = expandKeyLE(key);\n      let _iv = iv;\n      const toClean: (Uint8Array | Uint32Array)[] = [xk];\n      if (!isAligned32(_iv)) toClean.push((_iv = copyBytes(_iv)));\n      if (!isAligned32(src)) toClean.push((src = copyBytes(src)));\n      const src32 = u32(src);\n      const dst32 = u32(dst);\n      const next32 = isEncrypt ? dst32 : src32;\n      const n32 = u32(_iv);\n      // prettier-ignore\n      let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];\n      for (let i = 0; i + 4 <= src32.length; ) {\n        const { s0: e0, s1: e1, s2: e2, s3: e3 } = encrypt(xk, s0, s1, s2, s3);\n        dst32[i + 0] = src32[i + 0] ^ e0;\n        dst32[i + 1] = src32[i + 1] ^ e1;\n        dst32[i + 2] = src32[i + 2] ^ e2;\n        dst32[i + 3] = src32[i + 3] ^ e3;\n        (s0 = next32[i++]), (s1 = next32[i++]), (s2 = next32[i++]), (s3 = next32[i++]);\n      }\n      // leftovers (less than block)\n      const start = BLOCK_SIZE * Math.floor(src32.length / BLOCK_SIZE32);\n      if (start < srcLen) {\n        ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));\n        const buf = u8(new Uint32Array([s0, s1, s2, s3]));\n        for (let i = start, pos = 0; i < srcLen; i++, pos++) dst[i] = src[i] ^ buf[pos];\n        clean(buf);\n      }\n      clean(...toClean);\n      return dst;\n    }\n    return {\n      encrypt: (plaintext: Uint8Array, dst?: Uint8Array) => processCfb(plaintext, true, dst),\n      decrypt: (ciphertext: Uint8Array, dst?: Uint8Array) => processCfb(ciphertext, false, dst),\n    };\n  }\n);\n\n// TODO: merge with chacha, however gcm has bitLen while chacha has byteLen\nfunction computeTag(\n  fn: typeof ghash,\n  isLE: boolean,\n  key: Uint8Array,\n  data: Uint8Array,\n  AAD?: Uint8Array\n) {\n  const aadLength = AAD ? AAD.length : 0;\n  const h = fn.create(key, data.length + aadLength);\n  if (AAD) h.update(AAD);\n  const num = u64Lengths(8 * data.length, 8 * aadLength, isLE);\n  h.update(data);\n  h.update(num);\n  const res = h.digest();\n  clean(num);\n  return res;\n}\n\n/**\n * GCM: Galois/Counter Mode.\n * Modern, parallel version of CTR, with MAC.\n * Be careful: MACs can be forged.\n * Unsafe to use random nonces under the same key, due to collision chance.\n * As for nonce size, prefer 12-byte, instead of 8-byte.\n */\nexport const gcm: ((key: Uint8Array, nonce: Uint8Array, AAD?: Uint8Array) => Cipher) & {\n  blockSize: number;\n  nonceLength: number;\n  tagLength: number;\n  varSizeNonce: true;\n} = /* @__PURE__ */ wrapCipher(\n  { blockSize: 16, nonceLength: 12, tagLength: 16, varSizeNonce: true },\n  function aesgcm(key: Uint8Array, nonce: Uint8Array, AAD?: Uint8Array): Cipher {\n    // NIST 800-38d doesn't enforce minimum nonce length.\n    // We enforce 8 bytes for compat with openssl.\n    // 12 bytes are recommended. More than 12 bytes would be converted into 12.\n    if (nonce.length < 8) throw new Error('aes/gcm: invalid nonce length');\n    const tagLength = 16;\n    function _computeTag(authKey: Uint8Array, tagMask: Uint8Array, data: Uint8Array) {\n      const tag = computeTag(ghash, false, authKey, data, AAD);\n      for (let i = 0; i < tagMask.length; i++) tag[i] ^= tagMask[i];\n      return tag;\n    }\n    function deriveKeys() {\n      const xk = expandKeyLE(key);\n      const authKey = EMPTY_BLOCK.slice();\n      const counter = EMPTY_BLOCK.slice();\n      ctr32(xk, false, counter, counter, authKey);\n      // NIST 800-38d, page 15: different behavior for 96-bit and non-96-bit nonces\n      if (nonce.length === 12) {\n        counter.set(nonce);\n      } else {\n        const nonceLen = EMPTY_BLOCK.slice();\n        const view = createView(nonceLen);\n        setBigUint64(view, 8, BigInt(nonce.length * 8), false);\n        // ghash(nonce || u64be(0) || u64be(nonceLen*8))\n        const g = ghash.create(authKey).update(nonce).update(nonceLen);\n        g.digestInto(counter); // digestInto doesn't trigger '.destroy'\n        g.destroy();\n      }\n      const tagMask = ctr32(xk, false, counter, EMPTY_BLOCK);\n      return { xk, authKey, counter, tagMask };\n    }\n    return {\n      encrypt(plaintext: Uint8Array) {\n        const { xk, authKey, counter, tagMask } = deriveKeys();\n        const out = new Uint8Array(plaintext.length + tagLength);\n        const toClean: (Uint8Array | Uint32Array)[] = [xk, authKey, counter, tagMask];\n        if (!isAligned32(plaintext)) toClean.push((plaintext = copyBytes(plaintext)));\n        ctr32(xk, false, counter, plaintext, out.subarray(0, plaintext.length));\n        const tag = _computeTag(authKey, tagMask, out.subarray(0, out.length - tagLength));\n        toClean.push(tag);\n        out.set(tag, plaintext.length);\n        clean(...toClean);\n        return out;\n      },\n      decrypt(ciphertext: Uint8Array) {\n        const { xk, authKey, counter, tagMask } = deriveKeys();\n        const toClean: (Uint8Array | Uint32Array)[] = [xk, authKey, tagMask, counter];\n        if (!isAligned32(ciphertext)) toClean.push((ciphertext = copyBytes(ciphertext)));\n        const data = ciphertext.subarray(0, -tagLength);\n        const passedTag = ciphertext.subarray(-tagLength);\n        const tag = _computeTag(authKey, tagMask, data);\n        toClean.push(tag);\n        if (!equalBytes(tag, passedTag)) throw new Error('aes/gcm: invalid ghash tag');\n        const out = ctr32(xk, false, counter, data);\n        clean(...toClean);\n        return out;\n      },\n    };\n  }\n);\n\nconst limit = (name: string, min: number, max: number) => (value: number) => {\n  if (!Number.isSafeInteger(value) || min > value || value > max) {\n    const minmax = '[' + min + '..' + max + ']';\n    throw new Error('' + name + ': expected value in range ' + minmax + ', got ' + value);\n  }\n};\n\n/**\n * AES-GCM-SIV: classic AES-GCM with nonce-misuse resistance.\n * Guarantees that, when a nonce is repeated, the only security loss is that identical\n * plaintexts will produce identical ciphertexts.\n * RFC 8452, https://datatracker.ietf.org/doc/html/rfc8452\n */\nexport const gcmsiv: ((key: Uint8Array, nonce: Uint8Array, AAD?: Uint8Array) => Cipher) & {\n  blockSize: number;\n  nonceLength: number;\n  tagLength: number;\n  varSizeNonce: true;\n} = /* @__PURE__ */ wrapCipher(\n  { blockSize: 16, nonceLength: 12, tagLength: 16, varSizeNonce: true },\n  function aessiv(key: Uint8Array, nonce: Uint8Array, AAD?: Uint8Array): Cipher {\n    const tagLength = 16;\n    // From RFC 8452: Section 6\n    const AAD_LIMIT = limit('AAD', 0, 2 ** 36);\n    const PLAIN_LIMIT = limit('plaintext', 0, 2 ** 36);\n    const NONCE_LIMIT = limit('nonce', 12, 12);\n    const CIPHER_LIMIT = limit('ciphertext', 16, 2 ** 36 + 16);\n    abytes(key, 16, 24, 32);\n    NONCE_LIMIT(nonce.length);\n    if (AAD !== undefined) AAD_LIMIT(AAD.length);\n    function deriveKeys() {\n      const xk = expandKeyLE(key);\n      const encKey = new Uint8Array(key.length);\n      const authKey = new Uint8Array(16);\n      const toClean: (Uint8Array | Uint32Array)[] = [xk, encKey];\n      let _nonce = nonce;\n      if (!isAligned32(_nonce)) toClean.push((_nonce = copyBytes(_nonce)));\n      const n32 = u32(_nonce);\n      // prettier-ignore\n      let s0 = 0, s1 = n32[0], s2 = n32[1], s3 = n32[2];\n      let counter = 0;\n      for (const derivedKey of [authKey, encKey].map(u32)) {\n        const d32 = u32(derivedKey);\n        for (let i = 0; i < d32.length; i += 2) {\n          // aes(u32le(0) || nonce)[:8] || aes(u32le(1) || nonce)[:8] ...\n          const { s0: o0, s1: o1 } = encrypt(xk, s0, s1, s2, s3);\n          d32[i + 0] = o0;\n          d32[i + 1] = o1;\n          s0 = ++counter; // increment counter inside state\n        }\n      }\n      const res = { authKey, encKey: expandKeyLE(encKey) };\n      // Cleanup\n      clean(...toClean);\n      return res;\n    }\n    function _computeTag(encKey: Uint32Array, authKey: Uint8Array, data: Uint8Array) {\n      const tag = computeTag(polyval, true, authKey, data, AAD);\n      // Compute the expected tag by XORing S_s and the nonce, clearing the\n      // most significant bit of the last byte and encrypting with the\n      // message-encryption key.\n      for (let i = 0; i < 12; i++) tag[i] ^= nonce[i];\n      tag[15] &= 0x7f; // Clear the highest bit\n      // encrypt tag as block\n      const t32 = u32(tag);\n      // prettier-ignore\n      let s0 = t32[0], s1 = t32[1], s2 = t32[2], s3 = t32[3];\n      ({ s0, s1, s2, s3 } = encrypt(encKey, s0, s1, s2, s3));\n      (t32[0] = s0), (t32[1] = s1), (t32[2] = s2), (t32[3] = s3);\n      return tag;\n    }\n    // actual decrypt/encrypt of message.\n    function processSiv(encKey: Uint32Array, tag: Uint8Array, input: Uint8Array) {\n      let block = copyBytes(tag);\n      block[15] |= 0x80; // Force highest bit\n      const res = ctr32(encKey, true, block, input);\n      // Cleanup\n      clean(block);\n      return res;\n    }\n    return {\n      encrypt(plaintext: Uint8Array) {\n        PLAIN_LIMIT(plaintext.length);\n        const { encKey, authKey } = deriveKeys();\n        const tag = _computeTag(encKey, authKey, plaintext);\n        const toClean: (Uint8Array | Uint32Array)[] = [encKey, authKey, tag];\n        if (!isAligned32(plaintext)) toClean.push((plaintext = copyBytes(plaintext)));\n        const out = new Uint8Array(plaintext.length + tagLength);\n        out.set(tag, plaintext.length);\n        out.set(processSiv(encKey, tag, plaintext));\n        // Cleanup\n        clean(...toClean);\n        return out;\n      },\n      decrypt(ciphertext: Uint8Array) {\n        CIPHER_LIMIT(ciphertext.length);\n        const tag = ciphertext.subarray(-tagLength);\n        const { encKey, authKey } = deriveKeys();\n        const toClean: (Uint8Array | Uint32Array)[] = [encKey, authKey];\n        if (!isAligned32(ciphertext)) toClean.push((ciphertext = copyBytes(ciphertext)));\n        const plaintext = processSiv(encKey, tag, ciphertext.subarray(0, -tagLength));\n        const expectedTag = _computeTag(encKey, authKey, plaintext);\n        toClean.push(expectedTag);\n        if (!equalBytes(tag, expectedTag)) {\n          clean(...toClean);\n          throw new Error('invalid polyval tag');\n        }\n        // Cleanup\n        clean(...toClean);\n        return plaintext;\n      },\n    };\n  }\n);\n\n/**\n * AES-GCM-SIV, not AES-SIV.\n * This is legace name, use `gcmsiv` export instead.\n * @deprecated\n */\nexport const siv: typeof gcmsiv = gcmsiv;\n\nfunction isBytes32(a: unknown): a is Uint32Array {\n  return (\n    a instanceof Uint32Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint32Array')\n  );\n}\n\nfunction encryptBlock(xk: Uint32Array, block: Uint8Array): Uint8Array {\n  abytes(block, 16);\n  if (!isBytes32(xk)) throw new Error('_encryptBlock accepts result of expandKeyLE');\n  const b32 = u32(block);\n  let { s0, s1, s2, s3 } = encrypt(xk, b32[0], b32[1], b32[2], b32[3]);\n  (b32[0] = s0), (b32[1] = s1), (b32[2] = s2), (b32[3] = s3);\n  return block;\n}\n\nfunction decryptBlock(xk: Uint32Array, block: Uint8Array): Uint8Array {\n  abytes(block, 16);\n  if (!isBytes32(xk)) throw new Error('_decryptBlock accepts result of expandKeyLE');\n  const b32 = u32(block);\n  let { s0, s1, s2, s3 } = decrypt(xk, b32[0], b32[1], b32[2], b32[3]);\n  (b32[0] = s0), (b32[1] = s1), (b32[2] = s2), (b32[3] = s3);\n  return block;\n}\n\n/**\n * AES-W (base for AESKW/AESKWP).\n * Specs: [SP800-38F](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-38F.pdf),\n * [RFC 3394](https://datatracker.ietf.org/doc/rfc3394/),\n * [RFC 5649](https://datatracker.ietf.org/doc/rfc5649/).\n */\nconst AESW = {\n  /*\n  High-level pseudocode:\n  ```\n  A: u64 = IV\n  out = []\n  for (let i=0, ctr = 0; i<6; i++) {\n    for (const chunk of chunks(plaintext, 8)) {\n      A ^= swapEndianess(ctr++)\n      [A, res] = chunks(encrypt(A || chunk), 8);\n      out ||= res\n    }\n  }\n  out = A || out\n  ```\n  Decrypt is the same, but reversed.\n  */\n  encrypt(kek: Uint8Array, out: Uint8Array) {\n    // Size is limited to 4GB, otherwise ctr will overflow and we'll need to switch to bigints.\n    // If you need it larger, open an issue.\n    if (out.length >= 2 ** 32) throw new Error('plaintext should be less than 4gb');\n    const xk = expandKeyLE(kek);\n    if (out.length === 16) encryptBlock(xk, out);\n    else {\n      const o32 = u32(out);\n      // prettier-ignore\n      let a0 = o32[0], a1 = o32[1]; // A\n      for (let j = 0, ctr = 1; j < 6; j++) {\n        for (let pos = 2; pos < o32.length; pos += 2, ctr++) {\n          const { s0, s1, s2, s3 } = encrypt(xk, a0, a1, o32[pos], o32[pos + 1]);\n          // A = MSB(64, B) ^ t where t = (n*j)+i\n          (a0 = s0), (a1 = s1 ^ byteSwap(ctr)), (o32[pos] = s2), (o32[pos + 1] = s3);\n        }\n      }\n      (o32[0] = a0), (o32[1] = a1); // out = A || out\n    }\n    xk.fill(0);\n  },\n  decrypt(kek: Uint8Array, out: Uint8Array) {\n    if (out.length - 8 >= 2 ** 32) throw new Error('ciphertext should be less than 4gb');\n    const xk = expandKeyDecLE(kek);\n    const chunks = out.length / 8 - 1; // first chunk is IV\n    if (chunks === 1) decryptBlock(xk, out);\n    else {\n      const o32 = u32(out);\n      // prettier-ignore\n      let a0 = o32[0], a1 = o32[1]; // A\n      for (let j = 0, ctr = chunks * 6; j < 6; j++) {\n        for (let pos = chunks * 2; pos >= 1; pos -= 2, ctr--) {\n          a1 ^= byteSwap(ctr);\n          const { s0, s1, s2, s3 } = decrypt(xk, a0, a1, o32[pos], o32[pos + 1]);\n          (a0 = s0), (a1 = s1), (o32[pos] = s2), (o32[pos + 1] = s3);\n        }\n      }\n      (o32[0] = a0), (o32[1] = a1);\n    }\n    xk.fill(0);\n  },\n};\n\nconst AESKW_IV = /* @__PURE__ */ new Uint8Array(8).fill(0xa6); // A6A6A6A6A6A6A6A6\n\n/**\n * AES-KW (key-wrap). Injects static IV into plaintext, adds counter, encrypts 6 times.\n * Reduces block size from 16 to 8 bytes.\n * For padded version, use aeskwp.\n * [RFC 3394](https://datatracker.ietf.org/doc/rfc3394/),\n * [NIST.SP.800-38F](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-38F.pdf).\n */\nexport const aeskw: ((kek: Uint8Array) => Cipher) & {\n  blockSize: number;\n} = /* @__PURE__ */ wrapCipher(\n  { blockSize: 8 },\n  (kek: Uint8Array): Cipher => ({\n    encrypt(plaintext: Uint8Array) {\n      if (!plaintext.length || plaintext.length % 8 !== 0)\n        throw new Error('invalid plaintext length');\n      if (plaintext.length === 8)\n        throw new Error('8-byte keys not allowed in AESKW, use AESKWP instead');\n      const out = concatBytes(AESKW_IV, plaintext);\n      AESW.encrypt(kek, out);\n      return out;\n    },\n    decrypt(ciphertext: Uint8Array) {\n      // ciphertext must be at least 24 bytes and a multiple of 8 bytes\n      // 24 because should have at least two block (1 iv + 2).\n      // Replace with 16 to enable '8-byte keys'\n      if (ciphertext.length % 8 !== 0 || ciphertext.length < 3 * 8)\n        throw new Error('invalid ciphertext length');\n      const out = copyBytes(ciphertext);\n      AESW.decrypt(kek, out);\n      if (!equalBytes(out.subarray(0, 8), AESKW_IV)) throw new Error('integrity check failed');\n      out.subarray(0, 8).fill(0); // ciphertext.subarray(0, 8) === IV, but we clean it anyway\n      return out.subarray(8);\n    },\n  })\n);\n\n/*\nWe don't support 8-byte keys. The rabbit hole:\n\n- Wycheproof says: \"NIST SP 800-38F does not define the wrapping of 8 byte keys.\n  RFC 3394 Section 2  on the other hand specifies that 8 byte keys are wrapped\n  by directly encrypting one block with AES.\"\n    - https://github.com/C2SP/wycheproof/blob/master/doc/key_wrap.md\n    - \"RFC 3394 specifies in Section 2, that the input for the key wrap\n      algorithm must be at least two blocks and otherwise the constant\n      field and key are simply encrypted with ECB as a single block\"\n- What RFC 3394 actually says (in Section 2):\n    - \"Before being wrapped, the key data is parsed into n blocks of 64 bits.\n      The only restriction the key wrap algorithm places on n is that n be\n      at least two\"\n    - \"For key data with length less than or equal to 64 bits, the constant\n      field used in this specification and the key data form a single\n      128-bit codebook input making this key wrap unnecessary.\"\n- Which means \"assert(n >= 2)\" and \"use something else for 8 byte keys\"\n- NIST SP800-38F actually prohibits 8-byte in \"5.3.1 Mandatory Limits\".\n  It states that plaintext for KW should be \"2 to 2^54 -1 semiblocks\".\n- So, where does \"directly encrypt single block with AES\" come from?\n    - Not RFC 3394. Pseudocode of key wrap in 2.2 explicitly uses\n      loop of 6 for any code path\n    - There is a weird W3C spec:\n      https://www.w3.org/TR/2002/REC-xmlenc-core-20021210/Overview.html#kw-aes128\n    - This spec is outdated, as admitted by Wycheproof authors\n    - There is RFC 5649 for padded key wrap, which is padding construction on\n      top of AESKW. In '4.1.2' it says: \"If the padded plaintext contains exactly\n      eight octets, then prepend the AIV as defined in Section 3 above to P[1] and\n      encrypt the resulting 128-bit block using AES in ECB mode [Modes] with key\n      K (the KEK).  In this case, the output is two 64-bit blocks C[0] and C[1]:\"\n    - Browser subtle crypto is actually crashes on wrapping keys less than 16 bytes:\n      `Error: error:1C8000E6:Provider routines::invalid input length] { opensslErrorStack: [ 'error:030000BD:digital envelope routines::update error' ]`\n\nIn the end, seems like a bug in Wycheproof.\nThe 8-byte check can be easily disabled inside of AES_W.\n*/\n\nconst AESKWP_IV = 0xa65959a6; // single u32le value\n\n/**\n * AES-KW, but with padding and allows random keys.\n * Second u32 of IV is used as counter for length.\n * [RFC 5649](https://www.rfc-editor.org/rfc/rfc5649)\n */\nexport const aeskwp: ((kek: Uint8Array) => Cipher) & {\n  blockSize: number;\n} = /* @__PURE__ */ wrapCipher(\n  { blockSize: 8 },\n  (kek: Uint8Array): Cipher => ({\n    encrypt(plaintext: Uint8Array) {\n      if (!plaintext.length) throw new Error('invalid plaintext length');\n      const padded = Math.ceil(plaintext.length / 8) * 8;\n      const out = new Uint8Array(8 + padded);\n      out.set(plaintext, 8);\n      const out32 = u32(out);\n      out32[0] = AESKWP_IV;\n      out32[1] = byteSwap(plaintext.length);\n      AESW.encrypt(kek, out);\n      return out;\n    },\n    decrypt(ciphertext: Uint8Array) {\n      // 16 because should have at least one block\n      if (ciphertext.length < 16) throw new Error('invalid ciphertext length');\n      const out = copyBytes(ciphertext);\n      const o32 = u32(out);\n      AESW.decrypt(kek, out);\n      const len = byteSwap(o32[1]) >>> 0;\n      const padded = Math.ceil(len / 8) * 8;\n      if (o32[0] !== AESKWP_IV || out.length - 8 !== padded)\n        throw new Error('integrity check failed');\n      for (let i = len; i < padded; i++)\n        if (out[8 + i] !== 0) throw new Error('integrity check failed');\n      out.subarray(0, 8).fill(0); // ciphertext.subarray(0, 8) === IV, but we clean it anyway\n      return out.subarray(8, 8 + len);\n    },\n  })\n);\n\n/** Unsafe low-level internal methods. May change at any time. */\nexport const unsafe: {\n  expandKeyLE: typeof expandKeyLE;\n  expandKeyDecLE: typeof expandKeyDecLE;\n  encrypt: typeof encrypt;\n  decrypt: typeof decrypt;\n  encryptBlock: typeof encryptBlock;\n  decryptBlock: typeof decryptBlock;\n  ctrCounter: typeof ctrCounter;\n  ctr32: typeof ctr32;\n} = {\n  expandKeyLE,\n  expandKeyDecLE,\n  encrypt,\n  decrypt,\n  encryptBlock,\n  decryptBlock,\n  ctrCounter,\n  ctr32,\n};\n"],
  "mappings": "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",
  "names": ["Fp", "Fr", "Fp2", "Fp6", "Fp12", "msg", "_0n", "_1n", "_2n", "_3n", "Fp", "Fp2", "G2psi", "G2psi2", "concatBytes", "Fp6", "Fp4Square", "Fp12", "_0n", "_1n", "_2n", "_3n", "concatBytes", "x", "_0n", "_1n", "_2n", "Fp", "randomBytes", "uvRatio", "adjustScalarBytes", "G", "cofactor", "concatBytes", "_0n", "_1n", "_2n", "validateOpts", "adjustScalarBytes", "_0n", "_1n", "_2n", "_3n", "_8n", "Fp", "_8n", "_3n", "Fp", "_3n", "_8n", "_2n", "_1n", "mod", "_0n", "abool", "utf8ToBytes", "utf8ToBytes", "concatBytes", "equalBytes", "isLE", "abool", "BLOCK_SIZE", "POLY", "mul2", "sbox", "sbox2", "t0", "t1", "t2", "t3", "ctr", "i", "isLE", "equalBytes", "ctr", "concatBytes", "equalBytes"]
}
