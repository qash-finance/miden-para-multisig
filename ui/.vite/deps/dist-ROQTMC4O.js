"use client";
import {
  require_zustand_sync_tabs
} from "./chunk-RSKXLY4J.js";
import {
  ConfigCtrl,
  ModalCtrl,
  OptionsCtrl,
  ThemeCtrl
} from "./chunk-BLSP2NP3.js";
import {
  A,
  E,
  concat,
  fromString,
  import_pino,
  k,
  recoverAddress,
  toString,
  y
} from "./chunk-GUI73XLH.js";
import {
  C,
  IEvents,
  Po,
  Qe,
  Qo,
  detect,
  esm_exports,
  f,
  formatJsonRpcError,
  formatJsonRpcRequest,
  formatJsonRpcResult,
  getBigIntRpcId,
  h,
  i,
  isJsonRpcError,
  isJsonRpcRequest,
  isJsonRpcResponse,
  isJsonRpcResult,
  o,
  payloadId,
  r,
  require_cjs,
  require_cjs2,
  require_cjs3,
  sn
} from "./chunk-CQZIVQNU.js";
import {
  esm_default
} from "./chunk-R2GSB7OH.js";
import {
  safeJsonParse,
  safeJsonStringify
} from "./chunk-3LQKBV2Y.js";
import {
  require_hmac,
  require_legacy,
  require_sha2,
  require_sha3,
  require_utils
} from "./chunk-SMPG444G.js";
import "./chunk-LXLJHZJN.js";
import "./chunk-SZOIEDKM.js";
import "./chunk-72YVARPT.js";
import "./chunk-RQSEBTAP.js";
import {
  require_define_data_property,
  require_gopd,
  require_has_property_descriptors
} from "./chunk-YRXUBSJD.js";
import "./chunk-2R7IBRRR.js";
import "./chunk-QSHPD2PE.js";
import "./chunk-T2A5ZAMZ.js";
import "./chunk-Y7BWPSR5.js";
import {
  create
} from "./chunk-O7NLK35K.js";
import {
  defaultCosmosExternalWallet
} from "./chunk-HDIQWJJX.js";
import "./chunk-IKAB4A4D.js";
import "./chunk-EO4ZYWSJ.js";
import "./chunk-3QM4QFEZ.js";
import {
  useMutation,
  useQuery
} from "./chunk-MSPEGW6G.js";
import {
  require_jsx_runtime
} from "./chunk-UPMDYLTV.js";
import {
  getCosmosAddress,
  hexToSignature,
  hexToUint8Array,
  isMobile,
  rawSecp256k1PubkeyToRawAddress
} from "./chunk-AMXWO4KO.js";
import "./chunk-WAIU3DJR.js";
import "./chunk-U23KTIEM.js";
import {
  require_base64_js
} from "./chunk-G6422SFU.js";
import {
  require_events
} from "./chunk-EIHG224A.js";
import "./chunk-PMFATS67.js";
import "./chunk-M6UVRKN6.js";
import "./chunk-3ZL3LWEU.js";
import "./chunk-Q5OWYOJ4.js";
import {
  require_react
} from "./chunk-NSM7HXF2.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-QEK2ZTOW.js";

// node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/pbkdf2.js
var require_pbkdf2 = __commonJS({
  "node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/pbkdf2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pbkdf2 = pbkdf22;
    exports.pbkdf2Async = pbkdf2Async;
    var hmac_ts_1 = require_hmac();
    var utils_ts_1 = require_utils();
    function pbkdf2Init(hash2, _password, _salt, _opts) {
      (0, utils_ts_1.ahash)(hash2);
      const opts = (0, utils_ts_1.checkOpts)({ dkLen: 32, asyncTick: 10 }, _opts);
      const { c: c3, dkLen, asyncTick } = opts;
      (0, utils_ts_1.anumber)(c3);
      (0, utils_ts_1.anumber)(dkLen);
      (0, utils_ts_1.anumber)(asyncTick);
      if (c3 < 1)
        throw new Error("iterations (c) should be >= 1");
      const password = (0, utils_ts_1.kdfInputToBytes)(_password);
      const salt = (0, utils_ts_1.kdfInputToBytes)(_salt);
      const DK = new Uint8Array(dkLen);
      const PRF = hmac_ts_1.hmac.create(hash2, password);
      const PRFSalt = PRF._cloneInto().update(salt);
      return { c: c3, dkLen, asyncTick, DK, PRF, PRFSalt };
    }
    function pbkdf2Output(PRF, PRFSalt, DK, prfW, u4) {
      PRF.destroy();
      PRFSalt.destroy();
      if (prfW)
        prfW.destroy();
      (0, utils_ts_1.clean)(u4);
      return DK;
    }
    function pbkdf22(hash2, password, salt, opts) {
      const { c: c3, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash2, password, salt, opts);
      let prfW;
      const arr = new Uint8Array(4);
      const view = (0, utils_ts_1.createView)(arr);
      const u4 = new Uint8Array(PRF.outputLen);
      for (let ti2 = 1, pos = 0; pos < dkLen; ti2++, pos += PRF.outputLen) {
        const Ti3 = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti2, false);
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u4);
        Ti3.set(u4.subarray(0, Ti3.length));
        for (let ui2 = 1; ui2 < c3; ui2++) {
          PRF._cloneInto(prfW).update(u4).digestInto(u4);
          for (let i3 = 0; i3 < Ti3.length; i3++)
            Ti3[i3] ^= u4[i3];
        }
      }
      return pbkdf2Output(PRF, PRFSalt, DK, prfW, u4);
    }
    async function pbkdf2Async(hash2, password, salt, opts) {
      const { c: c3, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash2, password, salt, opts);
      let prfW;
      const arr = new Uint8Array(4);
      const view = (0, utils_ts_1.createView)(arr);
      const u4 = new Uint8Array(PRF.outputLen);
      for (let ti2 = 1, pos = 0; pos < dkLen; ti2++, pos += PRF.outputLen) {
        const Ti3 = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti2, false);
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u4);
        Ti3.set(u4.subarray(0, Ti3.length));
        await (0, utils_ts_1.asyncLoop)(c3 - 1, asyncTick, () => {
          PRF._cloneInto(prfW).update(u4).digestInto(u4);
          for (let i3 = 0; i3 < Ti3.length; i3++)
            Ti3[i3] ^= u4[i3];
        });
      }
      return pbkdf2Output(PRF, PRFSalt, DK, prfW, u4);
    }
  }
});

// node_modules/.pnpm/@scure+base@1.2.6/node_modules/@scure/base/lib/index.js
var require_lib = __commonJS({
  "node_modules/.pnpm/@scure+base@1.2.6/node_modules/@scure/base/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bytes = exports.stringToBytes = exports.str = exports.bytesToString = exports.hex = exports.utf8 = exports.bech32m = exports.bech32 = exports.base58check = exports.createBase58check = exports.base58xmr = exports.base58xrp = exports.base58flickr = exports.base58 = exports.base64urlnopad = exports.base64url = exports.base64nopad = exports.base64 = exports.base32crockford = exports.base32hexnopad = exports.base32hex = exports.base32nopad = exports.base32 = exports.base16 = exports.utils = void 0;
    function isBytes2(a2) {
      return a2 instanceof Uint8Array || ArrayBuffer.isView(a2) && a2.constructor.name === "Uint8Array";
    }
    function abytes2(b5, ...lengths) {
      if (!isBytes2(b5))
        throw new Error("Uint8Array expected");
      if (lengths.length > 0 && !lengths.includes(b5.length))
        throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b5.length);
    }
    function isArrayOf2(isString, arr) {
      if (!Array.isArray(arr))
        return false;
      if (arr.length === 0)
        return true;
      if (isString) {
        return arr.every((item) => typeof item === "string");
      } else {
        return arr.every((item) => Number.isSafeInteger(item));
      }
    }
    function afn2(input) {
      if (typeof input !== "function")
        throw new Error("function expected");
      return true;
    }
    function astr2(label, input) {
      if (typeof input !== "string")
        throw new Error(`${label}: string expected`);
      return true;
    }
    function anumber2(n2) {
      if (!Number.isSafeInteger(n2))
        throw new Error(`invalid integer: ${n2}`);
    }
    function aArr2(input) {
      if (!Array.isArray(input))
        throw new Error("array expected");
    }
    function astrArr2(label, input) {
      if (!isArrayOf2(true, input))
        throw new Error(`${label}: array of strings expected`);
    }
    function anumArr2(label, input) {
      if (!isArrayOf2(false, input))
        throw new Error(`${label}: array of numbers expected`);
    }
    function chain2(...args) {
      const id = (a2) => a2;
      const wrap = (a2, b5) => (c3) => a2(b5(c3));
      const encode = args.map((x3) => x3.encode).reduceRight(wrap, id);
      const decode = args.map((x3) => x3.decode).reduce(wrap, id);
      return { encode, decode };
    }
    function alphabet2(letters) {
      const lettersA = typeof letters === "string" ? letters.split("") : letters;
      const len = lettersA.length;
      astrArr2("alphabet", lettersA);
      const indexes = new Map(lettersA.map((l3, i3) => [l3, i3]));
      return {
        encode: (digits) => {
          aArr2(digits);
          return digits.map((i3) => {
            if (!Number.isSafeInteger(i3) || i3 < 0 || i3 >= len)
              throw new Error(`alphabet.encode: digit index outside alphabet "${i3}". Allowed: ${letters}`);
            return lettersA[i3];
          });
        },
        decode: (input) => {
          aArr2(input);
          return input.map((letter) => {
            astr2("alphabet.decode", letter);
            const i3 = indexes.get(letter);
            if (i3 === void 0)
              throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);
            return i3;
          });
        }
      };
    }
    function join2(separator = "") {
      astr2("join", separator);
      return {
        encode: (from) => {
          astrArr2("join.decode", from);
          return from.join(separator);
        },
        decode: (to3) => {
          astr2("join.decode", to3);
          return to3.split(separator);
        }
      };
    }
    function padding2(bits, chr = "=") {
      anumber2(bits);
      astr2("padding", chr);
      return {
        encode(data2) {
          astrArr2("padding.encode", data2);
          while (data2.length * bits % 8)
            data2.push(chr);
          return data2;
        },
        decode(input) {
          astrArr2("padding.decode", input);
          let end = input.length;
          if (end * bits % 8)
            throw new Error("padding: invalid, string should have whole number of bytes");
          for (; end > 0 && input[end - 1] === chr; end--) {
            const last = end - 1;
            const byte = last * bits;
            if (byte % 8 === 0)
              throw new Error("padding: invalid, string has too much padding");
          }
          return input.slice(0, end);
        }
      };
    }
    function normalize2(fn3) {
      afn2(fn3);
      return { encode: (from) => from, decode: (to3) => fn3(to3) };
    }
    function convertRadix3(data2, from, to3) {
      if (from < 2)
        throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);
      if (to3 < 2)
        throw new Error(`convertRadix: invalid to=${to3}, base cannot be less than 2`);
      aArr2(data2);
      if (!data2.length)
        return [];
      let pos = 0;
      const res = [];
      const digits = Array.from(data2, (d3) => {
        anumber2(d3);
        if (d3 < 0 || d3 >= from)
          throw new Error(`invalid integer: ${d3}`);
        return d3;
      });
      const dlen = digits.length;
      while (true) {
        let carry = 0;
        let done = true;
        for (let i3 = pos; i3 < dlen; i3++) {
          const digit2 = digits[i3];
          const fromCarry = from * carry;
          const digitBase = fromCarry + digit2;
          if (!Number.isSafeInteger(digitBase) || fromCarry / from !== carry || digitBase - digit2 !== fromCarry) {
            throw new Error("convertRadix: carry overflow");
          }
          const div = digitBase / to3;
          carry = digitBase % to3;
          const rounded = Math.floor(div);
          digits[i3] = rounded;
          if (!Number.isSafeInteger(rounded) || rounded * to3 + carry !== digitBase)
            throw new Error("convertRadix: carry overflow");
          if (!done)
            continue;
          else if (!rounded)
            pos = i3;
          else
            done = false;
        }
        res.push(carry);
        if (done)
          break;
      }
      for (let i3 = 0; i3 < data2.length - 1 && data2[i3] === 0; i3++)
        res.push(0);
      return res.reverse();
    }
    var gcd2 = (a2, b5) => b5 === 0 ? a2 : gcd2(b5, a2 % b5);
    var radix2carry2 = (from, to3) => from + (to3 - gcd2(from, to3));
    var powers2 = (() => {
      let res = [];
      for (let i3 = 0; i3 < 40; i3++)
        res.push(2 ** i3);
      return res;
    })();
    function convertRadix22(data2, from, to3, padding3) {
      aArr2(data2);
      if (from <= 0 || from > 32)
        throw new Error(`convertRadix2: wrong from=${from}`);
      if (to3 <= 0 || to3 > 32)
        throw new Error(`convertRadix2: wrong to=${to3}`);
      if (radix2carry2(from, to3) > 32) {
        throw new Error(`convertRadix2: carry overflow from=${from} to=${to3} carryBits=${radix2carry2(from, to3)}`);
      }
      let carry = 0;
      let pos = 0;
      const max = powers2[from];
      const mask = powers2[to3] - 1;
      const res = [];
      for (const n2 of data2) {
        anumber2(n2);
        if (n2 >= max)
          throw new Error(`convertRadix2: invalid data word=${n2} from=${from}`);
        carry = carry << from | n2;
        if (pos + from > 32)
          throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
        pos += from;
        for (; pos >= to3; pos -= to3)
          res.push((carry >> pos - to3 & mask) >>> 0);
        const pow = powers2[pos];
        if (pow === void 0)
          throw new Error("invalid carry");
        carry &= pow - 1;
      }
      carry = carry << to3 - pos & mask;
      if (!padding3 && pos >= from)
        throw new Error("Excess padding");
      if (!padding3 && carry > 0)
        throw new Error(`Non-zero padding: ${carry}`);
      if (padding3 && pos > 0)
        res.push(carry >>> 0);
      return res;
    }
    function radix3(num) {
      anumber2(num);
      const _256 = 2 ** 8;
      return {
        encode: (bytes2) => {
          if (!isBytes2(bytes2))
            throw new Error("radix.encode input should be Uint8Array");
          return convertRadix3(Array.from(bytes2), _256, num);
        },
        decode: (digits) => {
          anumArr2("radix.decode", digits);
          return Uint8Array.from(convertRadix3(digits, num, _256));
        }
      };
    }
    function radix22(bits, revPadding = false) {
      anumber2(bits);
      if (bits <= 0 || bits > 32)
        throw new Error("radix2: bits should be in (0..32]");
      if (radix2carry2(8, bits) > 32 || radix2carry2(bits, 8) > 32)
        throw new Error("radix2: carry overflow");
      return {
        encode: (bytes2) => {
          if (!isBytes2(bytes2))
            throw new Error("radix2.encode input should be Uint8Array");
          return convertRadix22(Array.from(bytes2), 8, bits, !revPadding);
        },
        decode: (digits) => {
          anumArr2("radix2.decode", digits);
          return Uint8Array.from(convertRadix22(digits, bits, 8, revPadding));
        }
      };
    }
    function unsafeWrapper2(fn3) {
      afn2(fn3);
      return function(...args) {
        try {
          return fn3.apply(null, args);
        } catch (e) {
        }
      };
    }
    function checksum2(len, fn3) {
      anumber2(len);
      afn2(fn3);
      return {
        encode(data2) {
          if (!isBytes2(data2))
            throw new Error("checksum.encode: input should be Uint8Array");
          const sum = fn3(data2).slice(0, len);
          const res = new Uint8Array(data2.length + len);
          res.set(data2);
          res.set(sum, data2.length);
          return res;
        },
        decode(data2) {
          if (!isBytes2(data2))
            throw new Error("checksum.decode: input should be Uint8Array");
          const payload = data2.slice(0, -len);
          const oldChecksum = data2.slice(-len);
          const newChecksum = fn3(payload).slice(0, len);
          for (let i3 = 0; i3 < len; i3++)
            if (newChecksum[i3] !== oldChecksum[i3])
              throw new Error("Invalid checksum");
          return payload;
        }
      };
    }
    exports.utils = {
      alphabet: alphabet2,
      chain: chain2,
      checksum: checksum2,
      convertRadix: convertRadix3,
      convertRadix2: convertRadix22,
      radix: radix3,
      radix2: radix22,
      join: join2,
      padding: padding2
    };
    exports.base16 = chain2(radix22(4), alphabet2("0123456789ABCDEF"), join2(""));
    exports.base32 = chain2(radix22(5), alphabet2("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding2(5), join2(""));
    exports.base32nopad = chain2(radix22(5), alphabet2("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), join2(""));
    exports.base32hex = chain2(radix22(5), alphabet2("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding2(5), join2(""));
    exports.base32hexnopad = chain2(radix22(5), alphabet2("0123456789ABCDEFGHIJKLMNOPQRSTUV"), join2(""));
    exports.base32crockford = chain2(radix22(5), alphabet2("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join2(""), normalize2((s2) => s2.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
    var hasBase64Builtin2 = (() => typeof Uint8Array.from([]).toBase64 === "function" && typeof Uint8Array.fromBase64 === "function")();
    var decodeBase64Builtin2 = (s2, isUrl) => {
      astr2("base64", s2);
      const re4 = isUrl ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/;
      const alphabet3 = isUrl ? "base64url" : "base64";
      if (s2.length > 0 && !re4.test(s2))
        throw new Error("invalid base64");
      return Uint8Array.fromBase64(s2, { alphabet: alphabet3, lastChunkHandling: "strict" });
    };
    exports.base64 = hasBase64Builtin2 ? {
      encode(b5) {
        abytes2(b5);
        return b5.toBase64();
      },
      decode(s2) {
        return decodeBase64Builtin2(s2, false);
      }
    } : chain2(radix22(6), alphabet2("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding2(6), join2(""));
    exports.base64nopad = chain2(radix22(6), alphabet2("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), join2(""));
    exports.base64url = hasBase64Builtin2 ? {
      encode(b5) {
        abytes2(b5);
        return b5.toBase64({ alphabet: "base64url" });
      },
      decode(s2) {
        return decodeBase64Builtin2(s2, true);
      }
    } : chain2(radix22(6), alphabet2("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding2(6), join2(""));
    exports.base64urlnopad = chain2(radix22(6), alphabet2("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), join2(""));
    var genBase582 = (abc) => chain2(radix3(58), alphabet2(abc), join2(""));
    exports.base58 = genBase582("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
    exports.base58flickr = genBase582("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
    exports.base58xrp = genBase582("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
    var XMR_BLOCK_LEN2 = [0, 2, 3, 5, 6, 7, 9, 10, 11];
    exports.base58xmr = {
      encode(data2) {
        let res = "";
        for (let i3 = 0; i3 < data2.length; i3 += 8) {
          const block = data2.subarray(i3, i3 + 8);
          res += exports.base58.encode(block).padStart(XMR_BLOCK_LEN2[block.length], "1");
        }
        return res;
      },
      decode(str2) {
        let res = [];
        for (let i3 = 0; i3 < str2.length; i3 += 11) {
          const slice = str2.slice(i3, i3 + 11);
          const blockLen = XMR_BLOCK_LEN2.indexOf(slice.length);
          const block = exports.base58.decode(slice);
          for (let j3 = 0; j3 < block.length - blockLen; j3++) {
            if (block[j3] !== 0)
              throw new Error("base58xmr: wrong padding");
          }
          res = res.concat(Array.from(block.slice(block.length - blockLen)));
        }
        return Uint8Array.from(res);
      }
    };
    var createBase58check2 = (sha2563) => chain2(checksum2(4, (data2) => sha2563(sha2563(data2))), exports.base58);
    exports.createBase58check = createBase58check2;
    exports.base58check = exports.createBase58check;
    var BECH_ALPHABET2 = chain2(alphabet2("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join2(""));
    var POLYMOD_GENERATORS2 = [996825010, 642813549, 513874426, 1027748829, 705979059];
    function bech32Polymod2(pre) {
      const b5 = pre >> 25;
      let chk = (pre & 33554431) << 5;
      for (let i3 = 0; i3 < POLYMOD_GENERATORS2.length; i3++) {
        if ((b5 >> i3 & 1) === 1)
          chk ^= POLYMOD_GENERATORS2[i3];
      }
      return chk;
    }
    function bechChecksum2(prefix, words, encodingConst = 1) {
      const len = prefix.length;
      let chk = 1;
      for (let i3 = 0; i3 < len; i3++) {
        const c3 = prefix.charCodeAt(i3);
        if (c3 < 33 || c3 > 126)
          throw new Error(`Invalid prefix (${prefix})`);
        chk = bech32Polymod2(chk) ^ c3 >> 5;
      }
      chk = bech32Polymod2(chk);
      for (let i3 = 0; i3 < len; i3++)
        chk = bech32Polymod2(chk) ^ prefix.charCodeAt(i3) & 31;
      for (let v9 of words)
        chk = bech32Polymod2(chk) ^ v9;
      for (let i3 = 0; i3 < 6; i3++)
        chk = bech32Polymod2(chk);
      chk ^= encodingConst;
      return BECH_ALPHABET2.encode(convertRadix22([chk % powers2[30]], 30, 5, false));
    }
    function genBech322(encoding) {
      const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
      const _words = radix22(5);
      const fromWords = _words.decode;
      const toWords = _words.encode;
      const fromWordsUnsafe = unsafeWrapper2(fromWords);
      function encode(prefix, words, limit = 90) {
        astr2("bech32.encode prefix", prefix);
        if (isBytes2(words))
          words = Array.from(words);
        anumArr2("bech32.encode", words);
        const plen = prefix.length;
        if (plen === 0)
          throw new TypeError(`Invalid prefix length ${plen}`);
        const actualLength = plen + 7 + words.length;
        if (limit !== false && actualLength > limit)
          throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
        const lowered = prefix.toLowerCase();
        const sum = bechChecksum2(lowered, words, ENCODING_CONST);
        return `${lowered}1${BECH_ALPHABET2.encode(words)}${sum}`;
      }
      function decode(str2, limit = 90) {
        astr2("bech32.decode input", str2);
        const slen = str2.length;
        if (slen < 8 || limit !== false && slen > limit)
          throw new TypeError(`invalid string length: ${slen} (${str2}). Expected (8..${limit})`);
        const lowered = str2.toLowerCase();
        if (str2 !== lowered && str2 !== str2.toUpperCase())
          throw new Error(`String must be lowercase or uppercase`);
        const sepIndex = lowered.lastIndexOf("1");
        if (sepIndex === 0 || sepIndex === -1)
          throw new Error(`Letter "1" must be present between prefix and data only`);
        const prefix = lowered.slice(0, sepIndex);
        const data2 = lowered.slice(sepIndex + 1);
        if (data2.length < 6)
          throw new Error("Data must be at least 6 characters long");
        const words = BECH_ALPHABET2.decode(data2).slice(0, -6);
        const sum = bechChecksum2(prefix, words, ENCODING_CONST);
        if (!data2.endsWith(sum))
          throw new Error(`Invalid checksum in ${str2}: expected "${sum}"`);
        return { prefix, words };
      }
      const decodeUnsafe = unsafeWrapper2(decode);
      function decodeToBytes(str2) {
        const { prefix, words } = decode(str2, false);
        return { prefix, words, bytes: fromWords(words) };
      }
      function encodeFromBytes(prefix, bytes2) {
        return encode(prefix, toWords(bytes2));
      }
      return {
        encode,
        decode,
        encodeFromBytes,
        decodeToBytes,
        decodeUnsafe,
        fromWords,
        fromWordsUnsafe,
        toWords
      };
    }
    exports.bech32 = genBech322("bech32");
    exports.bech32m = genBech322("bech32m");
    exports.utf8 = {
      encode: (data2) => new TextDecoder().decode(data2),
      decode: (str2) => new TextEncoder().encode(str2)
    };
    var hasHexBuiltin2 = (() => typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function")();
    var hexBuiltin2 = {
      encode(data2) {
        abytes2(data2);
        return data2.toHex();
      },
      decode(s2) {
        astr2("hex", s2);
        return Uint8Array.fromHex(s2);
      }
    };
    exports.hex = hasHexBuiltin2 ? hexBuiltin2 : chain2(radix22(4), alphabet2("0123456789abcdef"), join2(""), normalize2((s2) => {
      if (typeof s2 !== "string" || s2.length % 2 !== 0)
        throw new TypeError(`hex.decode: expected string, got ${typeof s2} with length ${s2.length}`);
      return s2.toLowerCase();
    }));
    var CODERS2 = {
      utf8: exports.utf8,
      hex: exports.hex,
      base16: exports.base16,
      base32: exports.base32,
      base64: exports.base64,
      base64url: exports.base64url,
      base58: exports.base58,
      base58xmr: exports.base58xmr
    };
    var coderTypeError2 = "Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr";
    var bytesToString2 = (type, bytes2) => {
      if (typeof type !== "string" || !CODERS2.hasOwnProperty(type))
        throw new TypeError(coderTypeError2);
      if (!isBytes2(bytes2))
        throw new TypeError("bytesToString() expects Uint8Array");
      return CODERS2[type].encode(bytes2);
    };
    exports.bytesToString = bytesToString2;
    exports.str = exports.bytesToString;
    var stringToBytes3 = (type, str2) => {
      if (!CODERS2.hasOwnProperty(type))
        throw new TypeError(coderTypeError2);
      if (typeof str2 !== "string")
        throw new TypeError("stringToBytes() expects string");
      return CODERS2[type].decode(str2);
    };
    exports.stringToBytes = stringToBytes3;
    exports.bytes = exports.stringToBytes;
  }
});

// node_modules/.pnpm/@scure+bip39@1.6.0/node_modules/@scure/bip39/index.js
var require_bip39 = __commonJS({
  "node_modules/.pnpm/@scure+bip39@1.6.0/node_modules/@scure/bip39/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateMnemonic = generateMnemonic;
    exports.mnemonicToEntropy = mnemonicToEntropy;
    exports.entropyToMnemonic = entropyToMnemonic;
    exports.validateMnemonic = validateMnemonic;
    exports.mnemonicToSeed = mnemonicToSeed;
    exports.mnemonicToSeedSync = mnemonicToSeedSync;
    var pbkdf2_1 = require_pbkdf2();
    var sha2_1 = require_sha2();
    var utils_1 = require_utils();
    var base_1 = require_lib();
    var isJapanese = (wordlist) => wordlist[0] === "あいこくしん";
    function nfkd(str2) {
      if (typeof str2 !== "string")
        throw new TypeError("invalid mnemonic type: " + typeof str2);
      return str2.normalize("NFKD");
    }
    function normalize2(str2) {
      const norm = nfkd(str2);
      const words = norm.split(" ");
      if (![12, 15, 18, 21, 24].includes(words.length))
        throw new Error("Invalid mnemonic");
      return { nfkd: norm, words };
    }
    function aentropy(ent) {
      (0, utils_1.abytes)(ent, 16, 20, 24, 28, 32);
    }
    function generateMnemonic(wordlist, strength = 128) {
      (0, utils_1.anumber)(strength);
      if (strength % 32 !== 0 || strength > 256)
        throw new TypeError("Invalid entropy");
      return entropyToMnemonic((0, utils_1.randomBytes)(strength / 8), wordlist);
    }
    var calcChecksum = (entropy) => {
      const bitsLeft = 8 - entropy.length / 4;
      return new Uint8Array([(0, sha2_1.sha256)(entropy)[0] >> bitsLeft << bitsLeft]);
    };
    function getCoder(wordlist) {
      if (!Array.isArray(wordlist) || wordlist.length !== 2048 || typeof wordlist[0] !== "string")
        throw new Error("Wordlist: expected array of 2048 strings");
      wordlist.forEach((i3) => {
        if (typeof i3 !== "string")
          throw new Error("wordlist: non-string element: " + i3);
      });
      return base_1.utils.chain(base_1.utils.checksum(1, calcChecksum), base_1.utils.radix2(11, true), base_1.utils.alphabet(wordlist));
    }
    function mnemonicToEntropy(mnemonic, wordlist) {
      const { words } = normalize2(mnemonic);
      const entropy = getCoder(wordlist).decode(words);
      aentropy(entropy);
      return entropy;
    }
    function entropyToMnemonic(entropy, wordlist) {
      aentropy(entropy);
      const words = getCoder(wordlist).encode(entropy);
      return words.join(isJapanese(wordlist) ? "　" : " ");
    }
    function validateMnemonic(mnemonic, wordlist) {
      try {
        mnemonicToEntropy(mnemonic, wordlist);
      } catch (e) {
        return false;
      }
      return true;
    }
    var psalt = (passphrase) => nfkd("mnemonic" + passphrase);
    function mnemonicToSeed(mnemonic, passphrase = "") {
      return (0, pbkdf2_1.pbkdf2Async)(sha2_1.sha512, normalize2(mnemonic).nfkd, psalt(passphrase), { c: 2048, dkLen: 64 });
    }
    function mnemonicToSeedSync(mnemonic, passphrase = "") {
      return (0, pbkdf2_1.pbkdf2)(sha2_1.sha512, normalize2(mnemonic).nfkd, psalt(passphrase), { c: 2048, dkLen: 64 });
    }
  }
});

// node_modules/.pnpm/@scure+bip39@1.6.0/node_modules/@scure/bip39/wordlists/english.js
var require_english = __commonJS({
  "node_modules/.pnpm/@scure+bip39@1.6.0/node_modules/@scure/bip39/wordlists/english.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wordlist = void 0;
    exports.wordlist = `abandon
ability
able
about
above
absent
absorb
abstract
absurd
abuse
access
accident
account
accuse
achieve
acid
acoustic
acquire
across
act
action
actor
actress
actual
adapt
add
addict
address
adjust
admit
adult
advance
advice
aerobic
affair
afford
afraid
again
age
agent
agree
ahead
aim
air
airport
aisle
alarm
album
alcohol
alert
alien
all
alley
allow
almost
alone
alpha
already
also
alter
always
amateur
amazing
among
amount
amused
analyst
anchor
ancient
anger
angle
angry
animal
ankle
announce
annual
another
answer
antenna
antique
anxiety
any
apart
apology
appear
apple
approve
april
arch
arctic
area
arena
argue
arm
armed
armor
army
around
arrange
arrest
arrive
arrow
art
artefact
artist
artwork
ask
aspect
assault
asset
assist
assume
asthma
athlete
atom
attack
attend
attitude
attract
auction
audit
august
aunt
author
auto
autumn
average
avocado
avoid
awake
aware
away
awesome
awful
awkward
axis
baby
bachelor
bacon
badge
bag
balance
balcony
ball
bamboo
banana
banner
bar
barely
bargain
barrel
base
basic
basket
battle
beach
bean
beauty
because
become
beef
before
begin
behave
behind
believe
below
belt
bench
benefit
best
betray
better
between
beyond
bicycle
bid
bike
bind
biology
bird
birth
bitter
black
blade
blame
blanket
blast
bleak
bless
blind
blood
blossom
blouse
blue
blur
blush
board
boat
body
boil
bomb
bone
bonus
book
boost
border
boring
borrow
boss
bottom
bounce
box
boy
bracket
brain
brand
brass
brave
bread
breeze
brick
bridge
brief
bright
bring
brisk
broccoli
broken
bronze
broom
brother
brown
brush
bubble
buddy
budget
buffalo
build
bulb
bulk
bullet
bundle
bunker
burden
burger
burst
bus
business
busy
butter
buyer
buzz
cabbage
cabin
cable
cactus
cage
cake
call
calm
camera
camp
can
canal
cancel
candy
cannon
canoe
canvas
canyon
capable
capital
captain
car
carbon
card
cargo
carpet
carry
cart
case
cash
casino
castle
casual
cat
catalog
catch
category
cattle
caught
cause
caution
cave
ceiling
celery
cement
census
century
cereal
certain
chair
chalk
champion
change
chaos
chapter
charge
chase
chat
cheap
check
cheese
chef
cherry
chest
chicken
chief
child
chimney
choice
choose
chronic
chuckle
chunk
churn
cigar
cinnamon
circle
citizen
city
civil
claim
clap
clarify
claw
clay
clean
clerk
clever
click
client
cliff
climb
clinic
clip
clock
clog
close
cloth
cloud
clown
club
clump
cluster
clutch
coach
coast
coconut
code
coffee
coil
coin
collect
color
column
combine
come
comfort
comic
common
company
concert
conduct
confirm
congress
connect
consider
control
convince
cook
cool
copper
copy
coral
core
corn
correct
cost
cotton
couch
country
couple
course
cousin
cover
coyote
crack
cradle
craft
cram
crane
crash
crater
crawl
crazy
cream
credit
creek
crew
cricket
crime
crisp
critic
crop
cross
crouch
crowd
crucial
cruel
cruise
crumble
crunch
crush
cry
crystal
cube
culture
cup
cupboard
curious
current
curtain
curve
cushion
custom
cute
cycle
dad
damage
damp
dance
danger
daring
dash
daughter
dawn
day
deal
debate
debris
decade
december
decide
decline
decorate
decrease
deer
defense
define
defy
degree
delay
deliver
demand
demise
denial
dentist
deny
depart
depend
deposit
depth
deputy
derive
describe
desert
design
desk
despair
destroy
detail
detect
develop
device
devote
diagram
dial
diamond
diary
dice
diesel
diet
differ
digital
dignity
dilemma
dinner
dinosaur
direct
dirt
disagree
discover
disease
dish
dismiss
disorder
display
distance
divert
divide
divorce
dizzy
doctor
document
dog
doll
dolphin
domain
donate
donkey
donor
door
dose
double
dove
draft
dragon
drama
drastic
draw
dream
dress
drift
drill
drink
drip
drive
drop
drum
dry
duck
dumb
dune
during
dust
dutch
duty
dwarf
dynamic
eager
eagle
early
earn
earth
easily
east
easy
echo
ecology
economy
edge
edit
educate
effort
egg
eight
either
elbow
elder
electric
elegant
element
elephant
elevator
elite
else
embark
embody
embrace
emerge
emotion
employ
empower
empty
enable
enact
end
endless
endorse
enemy
energy
enforce
engage
engine
enhance
enjoy
enlist
enough
enrich
enroll
ensure
enter
entire
entry
envelope
episode
equal
equip
era
erase
erode
erosion
error
erupt
escape
essay
essence
estate
eternal
ethics
evidence
evil
evoke
evolve
exact
example
excess
exchange
excite
exclude
excuse
execute
exercise
exhaust
exhibit
exile
exist
exit
exotic
expand
expect
expire
explain
expose
express
extend
extra
eye
eyebrow
fabric
face
faculty
fade
faint
faith
fall
false
fame
family
famous
fan
fancy
fantasy
farm
fashion
fat
fatal
father
fatigue
fault
favorite
feature
february
federal
fee
feed
feel
female
fence
festival
fetch
fever
few
fiber
fiction
field
figure
file
film
filter
final
find
fine
finger
finish
fire
firm
first
fiscal
fish
fit
fitness
fix
flag
flame
flash
flat
flavor
flee
flight
flip
float
flock
floor
flower
fluid
flush
fly
foam
focus
fog
foil
fold
follow
food
foot
force
forest
forget
fork
fortune
forum
forward
fossil
foster
found
fox
fragile
frame
frequent
fresh
friend
fringe
frog
front
frost
frown
frozen
fruit
fuel
fun
funny
furnace
fury
future
gadget
gain
galaxy
gallery
game
gap
garage
garbage
garden
garlic
garment
gas
gasp
gate
gather
gauge
gaze
general
genius
genre
gentle
genuine
gesture
ghost
giant
gift
giggle
ginger
giraffe
girl
give
glad
glance
glare
glass
glide
glimpse
globe
gloom
glory
glove
glow
glue
goat
goddess
gold
good
goose
gorilla
gospel
gossip
govern
gown
grab
grace
grain
grant
grape
grass
gravity
great
green
grid
grief
grit
grocery
group
grow
grunt
guard
guess
guide
guilt
guitar
gun
gym
habit
hair
half
hammer
hamster
hand
happy
harbor
hard
harsh
harvest
hat
have
hawk
hazard
head
health
heart
heavy
hedgehog
height
hello
helmet
help
hen
hero
hidden
high
hill
hint
hip
hire
history
hobby
hockey
hold
hole
holiday
hollow
home
honey
hood
hope
horn
horror
horse
hospital
host
hotel
hour
hover
hub
huge
human
humble
humor
hundred
hungry
hunt
hurdle
hurry
hurt
husband
hybrid
ice
icon
idea
identify
idle
ignore
ill
illegal
illness
image
imitate
immense
immune
impact
impose
improve
impulse
inch
include
income
increase
index
indicate
indoor
industry
infant
inflict
inform
inhale
inherit
initial
inject
injury
inmate
inner
innocent
input
inquiry
insane
insect
inside
inspire
install
intact
interest
into
invest
invite
involve
iron
island
isolate
issue
item
ivory
jacket
jaguar
jar
jazz
jealous
jeans
jelly
jewel
job
join
joke
journey
joy
judge
juice
jump
jungle
junior
junk
just
kangaroo
keen
keep
ketchup
key
kick
kid
kidney
kind
kingdom
kiss
kit
kitchen
kite
kitten
kiwi
knee
knife
knock
know
lab
label
labor
ladder
lady
lake
lamp
language
laptop
large
later
latin
laugh
laundry
lava
law
lawn
lawsuit
layer
lazy
leader
leaf
learn
leave
lecture
left
leg
legal
legend
leisure
lemon
lend
length
lens
leopard
lesson
letter
level
liar
liberty
library
license
life
lift
light
like
limb
limit
link
lion
liquid
list
little
live
lizard
load
loan
lobster
local
lock
logic
lonely
long
loop
lottery
loud
lounge
love
loyal
lucky
luggage
lumber
lunar
lunch
luxury
lyrics
machine
mad
magic
magnet
maid
mail
main
major
make
mammal
man
manage
mandate
mango
mansion
manual
maple
marble
march
margin
marine
market
marriage
mask
mass
master
match
material
math
matrix
matter
maximum
maze
meadow
mean
measure
meat
mechanic
medal
media
melody
melt
member
memory
mention
menu
mercy
merge
merit
merry
mesh
message
metal
method
middle
midnight
milk
million
mimic
mind
minimum
minor
minute
miracle
mirror
misery
miss
mistake
mix
mixed
mixture
mobile
model
modify
mom
moment
monitor
monkey
monster
month
moon
moral
more
morning
mosquito
mother
motion
motor
mountain
mouse
move
movie
much
muffin
mule
multiply
muscle
museum
mushroom
music
must
mutual
myself
mystery
myth
naive
name
napkin
narrow
nasty
nation
nature
near
neck
need
negative
neglect
neither
nephew
nerve
nest
net
network
neutral
never
news
next
nice
night
noble
noise
nominee
noodle
normal
north
nose
notable
note
nothing
notice
novel
now
nuclear
number
nurse
nut
oak
obey
object
oblige
obscure
observe
obtain
obvious
occur
ocean
october
odor
off
offer
office
often
oil
okay
old
olive
olympic
omit
once
one
onion
online
only
open
opera
opinion
oppose
option
orange
orbit
orchard
order
ordinary
organ
orient
original
orphan
ostrich
other
outdoor
outer
output
outside
oval
oven
over
own
owner
oxygen
oyster
ozone
pact
paddle
page
pair
palace
palm
panda
panel
panic
panther
paper
parade
parent
park
parrot
party
pass
patch
path
patient
patrol
pattern
pause
pave
payment
peace
peanut
pear
peasant
pelican
pen
penalty
pencil
people
pepper
perfect
permit
person
pet
phone
photo
phrase
physical
piano
picnic
picture
piece
pig
pigeon
pill
pilot
pink
pioneer
pipe
pistol
pitch
pizza
place
planet
plastic
plate
play
please
pledge
pluck
plug
plunge
poem
poet
point
polar
pole
police
pond
pony
pool
popular
portion
position
possible
post
potato
pottery
poverty
powder
power
practice
praise
predict
prefer
prepare
present
pretty
prevent
price
pride
primary
print
priority
prison
private
prize
problem
process
produce
profit
program
project
promote
proof
property
prosper
protect
proud
provide
public
pudding
pull
pulp
pulse
pumpkin
punch
pupil
puppy
purchase
purity
purpose
purse
push
put
puzzle
pyramid
quality
quantum
quarter
question
quick
quit
quiz
quote
rabbit
raccoon
race
rack
radar
radio
rail
rain
raise
rally
ramp
ranch
random
range
rapid
rare
rate
rather
raven
raw
razor
ready
real
reason
rebel
rebuild
recall
receive
recipe
record
recycle
reduce
reflect
reform
refuse
region
regret
regular
reject
relax
release
relief
rely
remain
remember
remind
remove
render
renew
rent
reopen
repair
repeat
replace
report
require
rescue
resemble
resist
resource
response
result
retire
retreat
return
reunion
reveal
review
reward
rhythm
rib
ribbon
rice
rich
ride
ridge
rifle
right
rigid
ring
riot
ripple
risk
ritual
rival
river
road
roast
robot
robust
rocket
romance
roof
rookie
room
rose
rotate
rough
round
route
royal
rubber
rude
rug
rule
run
runway
rural
sad
saddle
sadness
safe
sail
salad
salmon
salon
salt
salute
same
sample
sand
satisfy
satoshi
sauce
sausage
save
say
scale
scan
scare
scatter
scene
scheme
school
science
scissors
scorpion
scout
scrap
screen
script
scrub
sea
search
season
seat
second
secret
section
security
seed
seek
segment
select
sell
seminar
senior
sense
sentence
series
service
session
settle
setup
seven
shadow
shaft
shallow
share
shed
shell
sheriff
shield
shift
shine
ship
shiver
shock
shoe
shoot
shop
short
shoulder
shove
shrimp
shrug
shuffle
shy
sibling
sick
side
siege
sight
sign
silent
silk
silly
silver
similar
simple
since
sing
siren
sister
situate
six
size
skate
sketch
ski
skill
skin
skirt
skull
slab
slam
sleep
slender
slice
slide
slight
slim
slogan
slot
slow
slush
small
smart
smile
smoke
smooth
snack
snake
snap
sniff
snow
soap
soccer
social
sock
soda
soft
solar
soldier
solid
solution
solve
someone
song
soon
sorry
sort
soul
sound
soup
source
south
space
spare
spatial
spawn
speak
special
speed
spell
spend
sphere
spice
spider
spike
spin
spirit
split
spoil
sponsor
spoon
sport
spot
spray
spread
spring
spy
square
squeeze
squirrel
stable
stadium
staff
stage
stairs
stamp
stand
start
state
stay
steak
steel
stem
step
stereo
stick
still
sting
stock
stomach
stone
stool
story
stove
strategy
street
strike
strong
struggle
student
stuff
stumble
style
subject
submit
subway
success
such
sudden
suffer
sugar
suggest
suit
summer
sun
sunny
sunset
super
supply
supreme
sure
surface
surge
surprise
surround
survey
suspect
sustain
swallow
swamp
swap
swarm
swear
sweet
swift
swim
swing
switch
sword
symbol
symptom
syrup
system
table
tackle
tag
tail
talent
talk
tank
tape
target
task
taste
tattoo
taxi
teach
team
tell
ten
tenant
tennis
tent
term
test
text
thank
that
theme
then
theory
there
they
thing
this
thought
three
thrive
throw
thumb
thunder
ticket
tide
tiger
tilt
timber
time
tiny
tip
tired
tissue
title
toast
tobacco
today
toddler
toe
together
toilet
token
tomato
tomorrow
tone
tongue
tonight
tool
tooth
top
topic
topple
torch
tornado
tortoise
toss
total
tourist
toward
tower
town
toy
track
trade
traffic
tragic
train
transfer
trap
trash
travel
tray
treat
tree
trend
trial
tribe
trick
trigger
trim
trip
trophy
trouble
truck
true
truly
trumpet
trust
truth
try
tube
tuition
tumble
tuna
tunnel
turkey
turn
turtle
twelve
twenty
twice
twin
twist
two
type
typical
ugly
umbrella
unable
unaware
uncle
uncover
under
undo
unfair
unfold
unhappy
uniform
unique
unit
universe
unknown
unlock
until
unusual
unveil
update
upgrade
uphold
upon
upper
upset
urban
urge
usage
use
used
useful
useless
usual
utility
vacant
vacuum
vague
valid
valley
valve
van
vanish
vapor
various
vast
vault
vehicle
velvet
vendor
venture
venue
verb
verify
version
very
vessel
veteran
viable
vibrant
vicious
victory
video
view
village
vintage
violin
virtual
virus
visa
visit
visual
vital
vivid
vocal
voice
void
volcano
volume
vote
voyage
wage
wagon
wait
walk
wall
walnut
want
warfare
warm
warrior
wash
wasp
waste
water
wave
way
wealth
weapon
wear
weasel
weather
web
wedding
weekend
weird
welcome
west
wet
whale
what
wheat
wheel
when
where
whip
whisper
wide
width
wife
wild
will
win
window
wine
wing
wink
winner
winter
wire
wisdom
wise
wish
witness
wolf
woman
wonder
wood
wool
word
work
world
worry
worth
wrap
wreck
wrestle
wrist
write
wrong
yard
year
yellow
you
young
youth
zebra
zero
zone
zoo`.split("\n");
  }
});

// node_modules/.pnpm/@cosmjs+crypto@0.37.0/node_modules/@cosmjs/crypto/build/bip39.js
var require_bip392 = __commonJS({
  "node_modules/.pnpm/@cosmjs+crypto@0.37.0/node_modules/@cosmjs/crypto/build/bip39.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Bip39 = exports.EnglishMnemonic = void 0;
    var bip39_1 = require_bip39();
    var english_1 = require_english();
    var EnglishMnemonic = class {
      static wordlist = english_1.wordlist;
      data;
      constructor(mnemonic) {
        const _2 = (0, bip39_1.mnemonicToEntropy)(mnemonic, english_1.wordlist);
        this.data = mnemonic;
      }
      toString() {
        return this.data;
      }
    };
    exports.EnglishMnemonic = EnglishMnemonic;
    var Bip39 = class {
      /**
       * Encodes raw entropy of length 16, 20, 24, 28 or 32 bytes as an English mnemonic between 12 and 24 words.
       *
       * | Entropy            | Words |
       * |--------------------|-------|
       * | 128 bit (16 bytes) |    12 |
       * | 160 bit (20 bytes) |    15 |
       * | 192 bit (24 bytes) |    18 |
       * | 224 bit (28 bytes) |    21 |
       * | 256 bit (32 bytes) |    24 |
       *
       *
       * @see https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki#generating-the-mnemonic
       * @param entropy The entropy to be encoded. This must be cryptographically secure.
       */
      static encode(entropy) {
        return new EnglishMnemonic((0, bip39_1.entropyToMnemonic)(entropy, english_1.wordlist));
      }
      static decode(mnemonic) {
        return (0, bip39_1.mnemonicToEntropy)(mnemonic.toString(), english_1.wordlist);
      }
      static async mnemonicToSeed(mnemonic, password) {
        return await (0, bip39_1.mnemonicToSeed)(mnemonic.toString(), password);
      }
    };
    exports.Bip39 = Bip39;
  }
});

// node_modules/.pnpm/@cosmjs+crypto@0.37.0/node_modules/@cosmjs/crypto/build/hmac.js
var require_hmac2 = __commonJS({
  "node_modules/.pnpm/@cosmjs+crypto@0.37.0/node_modules/@cosmjs/crypto/build/hmac.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Hmac = void 0;
    var Hmac = class {
      blockSize;
      messageHasher;
      oKeyPad;
      iKeyPad;
      hash;
      constructor(hashFunctionConstructor, originalKey) {
        const blockSize = new hashFunctionConstructor().blockSize;
        this.hash = (data2) => new hashFunctionConstructor().update(data2).digest();
        let key = originalKey;
        if (key.length > blockSize) {
          key = this.hash(key);
        }
        if (key.length < blockSize) {
          const zeroPadding = new Uint8Array(blockSize - key.length);
          key = new Uint8Array([...key, ...zeroPadding]);
        }
        this.oKeyPad = key.map((keyByte) => keyByte ^ 92);
        this.iKeyPad = key.map((keyByte) => keyByte ^ 54);
        this.messageHasher = new hashFunctionConstructor();
        this.blockSize = blockSize;
        this.update(this.iKeyPad);
      }
      update(data2) {
        this.messageHasher.update(data2);
        return this;
      }
      digest() {
        const innerHash = this.messageHasher.digest();
        return this.hash(new Uint8Array([...this.oKeyPad, ...innerHash]));
      }
    };
    exports.Hmac = Hmac;
  }
});

// node_modules/.pnpm/@cosmjs+crypto@0.37.0/node_modules/@cosmjs/crypto/build/utils.js
var require_utils2 = __commonJS({
  "node_modules/.pnpm/@cosmjs+crypto@0.37.0/node_modules/@cosmjs/crypto/build/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toRealUint8Array = toRealUint8Array;
    function toRealUint8Array(data2) {
      if (data2 instanceof Uint8Array)
        return data2;
      else
        return Uint8Array.from(data2);
    }
  }
});

// node_modules/.pnpm/@cosmjs+crypto@0.37.0/node_modules/@cosmjs/crypto/build/keccak.js
var require_keccak = __commonJS({
  "node_modules/.pnpm/@cosmjs+crypto@0.37.0/node_modules/@cosmjs/crypto/build/keccak.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Keccak256 = void 0;
    exports.keccak256 = keccak256;
    var sha3_js_1 = require_sha3();
    var utils_1 = require_utils2();
    var Keccak256 = class {
      blockSize = 512 / 8;
      impl = sha3_js_1.keccak_256.create();
      constructor(firstData) {
        if (firstData) {
          this.update(firstData);
        }
      }
      update(data2) {
        this.impl.update((0, utils_1.toRealUint8Array)(data2));
        return this;
      }
      digest() {
        return this.impl.digest();
      }
    };
    exports.Keccak256 = Keccak256;
    function keccak256(data2) {
      return new Keccak256(data2).digest();
    }
  }
});

// node_modules/.pnpm/@cosmjs+utils@0.37.0/node_modules/@cosmjs/utils/build/arrays.js
var require_arrays = __commonJS({
  "node_modules/.pnpm/@cosmjs+utils@0.37.0/node_modules/@cosmjs/utils/build/arrays.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.arrayContentEquals = arrayContentEquals;
    exports.arrayContentStartsWith = arrayContentStartsWith;
    function arrayContentEquals(a2, b5) {
      if (a2.length !== b5.length)
        return false;
      for (let i3 = 0; i3 < a2.length; ++i3) {
        if (a2[i3] !== b5[i3])
          return false;
      }
      return true;
    }
    function arrayContentStartsWith(a2, b5) {
      if (a2.length < b5.length)
        return false;
      for (let i3 = 0; i3 < b5.length; ++i3) {
        if (a2[i3] !== b5[i3])
          return false;
      }
      return true;
    }
  }
});

// node_modules/.pnpm/@cosmjs+utils@0.37.0/node_modules/@cosmjs/utils/build/assert.js
var require_assert = __commonJS({
  "node_modules/.pnpm/@cosmjs+utils@0.37.0/node_modules/@cosmjs/utils/build/assert.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assert = assert;
    exports.assertDefined = assertDefined;
    exports.assertDefinedAndNotNull = assertDefinedAndNotNull;
    function assert(condition, msg) {
      if (!condition) {
        throw new Error(msg || "condition is not truthy");
      }
    }
    function assertDefined(value, msg) {
      if (value === void 0) {
        throw new Error(msg ?? "value is undefined");
      }
    }
    function assertDefinedAndNotNull(value, msg) {
      if (value === void 0 || value === null) {
        throw new Error(msg ?? "value is undefined or null");
      }
    }
  }
});

// node_modules/.pnpm/@cosmjs+utils@0.37.0/node_modules/@cosmjs/utils/build/sleep.js
var require_sleep = __commonJS({
  "node_modules/.pnpm/@cosmjs+utils@0.37.0/node_modules/@cosmjs/utils/build/sleep.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sleep = sleep;
    async function sleep(ms2) {
      return new Promise((resolve) => setTimeout(resolve, ms2));
    }
  }
});

// node_modules/.pnpm/@cosmjs+utils@0.37.0/node_modules/@cosmjs/utils/build/typechecks.js
var require_typechecks = __commonJS({
  "node_modules/.pnpm/@cosmjs+utils@0.37.0/node_modules/@cosmjs/utils/build/typechecks.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isNonNullObject = isNonNullObject;
    exports.isUint8Array = isUint8Array;
    exports.isDefined = isDefined;
    function isNonNullObject(data2) {
      return typeof data2 === "object" && data2 !== null;
    }
    function isUint8Array(data2) {
      if (!isNonNullObject(data2))
        return false;
      if (Object.prototype.toString.call(data2) !== "[object Uint8Array]")
        return false;
      if (typeof Buffer !== "undefined" && typeof Buffer.isBuffer !== "undefined") {
        if (Buffer.isBuffer(data2))
          return false;
      }
      return true;
    }
    function isDefined(value) {
      return value !== void 0;
    }
  }
});

// node_modules/.pnpm/@cosmjs+utils@0.37.0/node_modules/@cosmjs/utils/build/index.js
var require_build = __commonJS({
  "node_modules/.pnpm/@cosmjs+utils@0.37.0/node_modules/@cosmjs/utils/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isUint8Array = exports.isNonNullObject = exports.isDefined = exports.sleep = exports.assertDefinedAndNotNull = exports.assertDefined = exports.assert = exports.arrayContentStartsWith = exports.arrayContentEquals = void 0;
    var arrays_1 = require_arrays();
    Object.defineProperty(exports, "arrayContentEquals", { enumerable: true, get: function() {
      return arrays_1.arrayContentEquals;
    } });
    Object.defineProperty(exports, "arrayContentStartsWith", { enumerable: true, get: function() {
      return arrays_1.arrayContentStartsWith;
    } });
    var assert_1 = require_assert();
    Object.defineProperty(exports, "assert", { enumerable: true, get: function() {
      return assert_1.assert;
    } });
    Object.defineProperty(exports, "assertDefined", { enumerable: true, get: function() {
      return assert_1.assertDefined;
    } });
    Object.defineProperty(exports, "assertDefinedAndNotNull", { enumerable: true, get: function() {
      return assert_1.assertDefinedAndNotNull;
    } });
    var sleep_1 = require_sleep();
    Object.defineProperty(exports, "sleep", { enumerable: true, get: function() {
      return sleep_1.sleep;
    } });
    var typechecks_1 = require_typechecks();
    Object.defineProperty(exports, "isDefined", { enumerable: true, get: function() {
      return typechecks_1.isDefined;
    } });
    Object.defineProperty(exports, "isNonNullObject", { enumerable: true, get: function() {
      return typechecks_1.isNonNullObject;
    } });
    Object.defineProperty(exports, "isUint8Array", { enumerable: true, get: function() {
      return typechecks_1.isUint8Array;
    } });
  }
});

// node_modules/.pnpm/@noble+ciphers@1.3.0/node_modules/@noble/ciphers/utils.js
var require_utils3 = __commonJS({
  "node_modules/.pnpm/@noble+ciphers@1.3.0/node_modules/@noble/ciphers/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wrapCipher = exports.Hash = exports.nextTick = exports.isLE = void 0;
    exports.isBytes = isBytes2;
    exports.abool = abool;
    exports.anumber = anumber2;
    exports.abytes = abytes2;
    exports.ahash = ahash;
    exports.aexists = aexists;
    exports.aoutput = aoutput;
    exports.u8 = u8;
    exports.u32 = u32;
    exports.clean = clean;
    exports.createView = createView;
    exports.bytesToHex = bytesToHex;
    exports.hexToBytes = hexToBytes;
    exports.hexToNumber = hexToNumber;
    exports.bytesToNumberBE = bytesToNumberBE;
    exports.numberToBytesBE = numberToBytesBE;
    exports.utf8ToBytes = utf8ToBytes;
    exports.bytesToUtf8 = bytesToUtf8;
    exports.toBytes = toBytes2;
    exports.overlapBytes = overlapBytes;
    exports.complexOverlapBytes = complexOverlapBytes;
    exports.concatBytes = concatBytes;
    exports.checkOpts = checkOpts;
    exports.equalBytes = equalBytes;
    exports.getOutput = getOutput;
    exports.setBigUint64 = setBigUint64;
    exports.u64Lengths = u64Lengths;
    exports.isAligned32 = isAligned32;
    exports.copyBytes = copyBytes;
    function isBytes2(a2) {
      return a2 instanceof Uint8Array || ArrayBuffer.isView(a2) && a2.constructor.name === "Uint8Array";
    }
    function abool(b5) {
      if (typeof b5 !== "boolean")
        throw new Error(`boolean expected, not ${b5}`);
    }
    function anumber2(n2) {
      if (!Number.isSafeInteger(n2) || n2 < 0)
        throw new Error("positive integer expected, got " + n2);
    }
    function abytes2(b5, ...lengths) {
      if (!isBytes2(b5))
        throw new Error("Uint8Array expected");
      if (lengths.length > 0 && !lengths.includes(b5.length))
        throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b5.length);
    }
    function ahash(h4) {
      if (typeof h4 !== "function" || typeof h4.create !== "function")
        throw new Error("Hash should be wrapped by utils.createHasher");
      anumber2(h4.outputLen);
      anumber2(h4.blockLen);
    }
    function aexists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    function aoutput(out, instance) {
      abytes2(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error("digestInto() expects output buffer of length at least " + min);
      }
    }
    function u8(arr) {
      return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    function u32(arr) {
      return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    }
    function clean(...arrays) {
      for (let i3 = 0; i3 < arrays.length; i3++) {
        arrays[i3].fill(0);
      }
    }
    function createView(arr) {
      return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    }
    exports.isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
    var hasHexBuiltin2 = (() => (
      // @ts-ignore
      typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
    ))();
    var hexes = Array.from({ length: 256 }, (_2, i3) => i3.toString(16).padStart(2, "0"));
    function bytesToHex(bytes2) {
      abytes2(bytes2);
      if (hasHexBuiltin2)
        return bytes2.toHex();
      let hex2 = "";
      for (let i3 = 0; i3 < bytes2.length; i3++) {
        hex2 += hexes[bytes2[i3]];
      }
      return hex2;
    }
    var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
    function asciiToBase16(ch) {
      if (ch >= asciis._0 && ch <= asciis._9)
        return ch - asciis._0;
      if (ch >= asciis.A && ch <= asciis.F)
        return ch - (asciis.A - 10);
      if (ch >= asciis.a && ch <= asciis.f)
        return ch - (asciis.a - 10);
      return;
    }
    function hexToBytes(hex2) {
      if (typeof hex2 !== "string")
        throw new Error("hex string expected, got " + typeof hex2);
      if (hasHexBuiltin2)
        return Uint8Array.fromHex(hex2);
      const hl = hex2.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("hex string expected, got unpadded hex of length " + hl);
      const array = new Uint8Array(al);
      for (let ai2 = 0, hi2 = 0; ai2 < al; ai2++, hi2 += 2) {
        const n1 = asciiToBase16(hex2.charCodeAt(hi2));
        const n2 = asciiToBase16(hex2.charCodeAt(hi2 + 1));
        if (n1 === void 0 || n2 === void 0) {
          const char = hex2[hi2] + hex2[hi2 + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi2);
        }
        array[ai2] = n1 * 16 + n2;
      }
      return array;
    }
    function hexToNumber(hex2) {
      if (typeof hex2 !== "string")
        throw new Error("hex string expected, got " + typeof hex2);
      return BigInt(hex2 === "" ? "0" : "0x" + hex2);
    }
    function bytesToNumberBE(bytes2) {
      return hexToNumber(bytesToHex(bytes2));
    }
    function numberToBytesBE(n2, len) {
      return hexToBytes(n2.toString(16).padStart(len * 2, "0"));
    }
    var nextTick = async () => {
    };
    exports.nextTick = nextTick;
    function utf8ToBytes(str2) {
      if (typeof str2 !== "string")
        throw new Error("string expected");
      return new Uint8Array(new TextEncoder().encode(str2));
    }
    function bytesToUtf8(bytes2) {
      return new TextDecoder().decode(bytes2);
    }
    function toBytes2(data2) {
      if (typeof data2 === "string")
        data2 = utf8ToBytes(data2);
      else if (isBytes2(data2))
        data2 = copyBytes(data2);
      else
        throw new Error("Uint8Array expected, got " + typeof data2);
      return data2;
    }
    function overlapBytes(a2, b5) {
      return a2.buffer === b5.buffer && // best we can do, may fail with an obscure Proxy
      a2.byteOffset < b5.byteOffset + b5.byteLength && // a starts before b end
      b5.byteOffset < a2.byteOffset + a2.byteLength;
    }
    function complexOverlapBytes(input, output) {
      if (overlapBytes(input, output) && input.byteOffset < output.byteOffset)
        throw new Error("complex overlap of input and output is not supported");
    }
    function concatBytes(...arrays) {
      let sum = 0;
      for (let i3 = 0; i3 < arrays.length; i3++) {
        const a2 = arrays[i3];
        abytes2(a2);
        sum += a2.length;
      }
      const res = new Uint8Array(sum);
      for (let i3 = 0, pad = 0; i3 < arrays.length; i3++) {
        const a2 = arrays[i3];
        res.set(a2, pad);
        pad += a2.length;
      }
      return res;
    }
    function checkOpts(defaults, opts) {
      if (opts == null || typeof opts !== "object")
        throw new Error("options must be defined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    function equalBytes(a2, b5) {
      if (a2.length !== b5.length)
        return false;
      let diff = 0;
      for (let i3 = 0; i3 < a2.length; i3++)
        diff |= a2[i3] ^ b5[i3];
      return diff === 0;
    }
    var Hash = class {
    };
    exports.Hash = Hash;
    var wrapCipher = (params, constructor) => {
      function wrappedCipher(key, ...args) {
        abytes2(key);
        if (!exports.isLE)
          throw new Error("Non little-endian hardware is not yet supported");
        if (params.nonceLength !== void 0) {
          const nonce = args[0];
          if (!nonce)
            throw new Error("nonce / iv required");
          if (params.varSizeNonce)
            abytes2(nonce);
          else
            abytes2(nonce, params.nonceLength);
        }
        const tagl = params.tagLength;
        if (tagl && args[1] !== void 0) {
          abytes2(args[1]);
        }
        const cipher = constructor(key, ...args);
        const checkOutput = (fnLength, output) => {
          if (output !== void 0) {
            if (fnLength !== 2)
              throw new Error("cipher output not supported");
            abytes2(output);
          }
        };
        let called = false;
        const wrCipher = {
          encrypt(data2, output) {
            if (called)
              throw new Error("cannot encrypt() twice with same key + nonce");
            called = true;
            abytes2(data2);
            checkOutput(cipher.encrypt.length, output);
            return cipher.encrypt(data2, output);
          },
          decrypt(data2, output) {
            abytes2(data2);
            if (tagl && data2.length < tagl)
              throw new Error("invalid ciphertext length: smaller than tagLength=" + tagl);
            checkOutput(cipher.decrypt.length, output);
            return cipher.decrypt(data2, output);
          }
        };
        return wrCipher;
      }
      Object.assign(wrappedCipher, params);
      return wrappedCipher;
    };
    exports.wrapCipher = wrapCipher;
    function getOutput(expectedLength, out, onlyAligned = true) {
      if (out === void 0)
        return new Uint8Array(expectedLength);
      if (out.length !== expectedLength)
        throw new Error("invalid output length, expected " + expectedLength + ", got: " + out.length);
      if (onlyAligned && !isAligned32(out))
        throw new Error("invalid output, must be aligned");
      return out;
    }
    function setBigUint64(view, byteOffset, value, isLE) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE);
      const _32n = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n & _u32_max);
      const wl = Number(value & _u32_max);
      const h4 = isLE ? 4 : 0;
      const l3 = isLE ? 0 : 4;
      view.setUint32(byteOffset + h4, wh, isLE);
      view.setUint32(byteOffset + l3, wl, isLE);
    }
    function u64Lengths(dataLength, aadLength, isLE) {
      abool(isLE);
      const num = new Uint8Array(16);
      const view = createView(num);
      setBigUint64(view, 0, BigInt(aadLength), isLE);
      setBigUint64(view, 8, BigInt(dataLength), isLE);
      return num;
    }
    function isAligned32(bytes2) {
      return bytes2.byteOffset % 4 === 0;
    }
    function copyBytes(bytes2) {
      return Uint8Array.from(bytes2);
    }
  }
});

// node_modules/.pnpm/@noble+ciphers@1.3.0/node_modules/@noble/ciphers/_arx.js
var require_arx = __commonJS({
  "node_modules/.pnpm/@noble+ciphers@1.3.0/node_modules/@noble/ciphers/_arx.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rotl = rotl;
    exports.createCipher = createCipher;
    var utils_ts_1 = require_utils3();
    var _utf8ToBytes = (str2) => Uint8Array.from(str2.split("").map((c3) => c3.charCodeAt(0)));
    var sigma16 = _utf8ToBytes("expand 16-byte k");
    var sigma32 = _utf8ToBytes("expand 32-byte k");
    var sigma16_32 = (0, utils_ts_1.u32)(sigma16);
    var sigma32_32 = (0, utils_ts_1.u32)(sigma32);
    function rotl(a2, b5) {
      return a2 << b5 | a2 >>> 32 - b5;
    }
    function isAligned32(b5) {
      return b5.byteOffset % 4 === 0;
    }
    var BLOCK_LEN = 64;
    var BLOCK_LEN32 = 16;
    var MAX_COUNTER = 2 ** 32 - 1;
    var U32_EMPTY = new Uint32Array();
    function runCipher(core, sigma, key, nonce, data2, output, counter, rounds) {
      const len = data2.length;
      const block = new Uint8Array(BLOCK_LEN);
      const b32 = (0, utils_ts_1.u32)(block);
      const isAligned = isAligned32(data2) && isAligned32(output);
      const d32 = isAligned ? (0, utils_ts_1.u32)(data2) : U32_EMPTY;
      const o32 = isAligned ? (0, utils_ts_1.u32)(output) : U32_EMPTY;
      for (let pos = 0; pos < len; counter++) {
        core(sigma, key, nonce, b32, counter, rounds);
        if (counter >= MAX_COUNTER)
          throw new Error("arx: counter overflow");
        const take = Math.min(BLOCK_LEN, len - pos);
        if (isAligned && take === BLOCK_LEN) {
          const pos32 = pos / 4;
          if (pos % 4 !== 0)
            throw new Error("arx: invalid block position");
          for (let j3 = 0, posj; j3 < BLOCK_LEN32; j3++) {
            posj = pos32 + j3;
            o32[posj] = d32[posj] ^ b32[j3];
          }
          pos += BLOCK_LEN;
          continue;
        }
        for (let j3 = 0, posj; j3 < take; j3++) {
          posj = pos + j3;
          output[posj] = data2[posj] ^ block[j3];
        }
        pos += take;
      }
    }
    function createCipher(core, opts) {
      const { allowShortKeys, extendNonceFn, counterLength, counterRight, rounds } = (0, utils_ts_1.checkOpts)({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, opts);
      if (typeof core !== "function")
        throw new Error("core must be a function");
      (0, utils_ts_1.anumber)(counterLength);
      (0, utils_ts_1.anumber)(rounds);
      (0, utils_ts_1.abool)(counterRight);
      (0, utils_ts_1.abool)(allowShortKeys);
      return (key, nonce, data2, output, counter = 0) => {
        (0, utils_ts_1.abytes)(key);
        (0, utils_ts_1.abytes)(nonce);
        (0, utils_ts_1.abytes)(data2);
        const len = data2.length;
        if (output === void 0)
          output = new Uint8Array(len);
        (0, utils_ts_1.abytes)(output);
        (0, utils_ts_1.anumber)(counter);
        if (counter < 0 || counter >= MAX_COUNTER)
          throw new Error("arx: counter overflow");
        if (output.length < len)
          throw new Error(`arx: output (${output.length}) is shorter than data (${len})`);
        const toClean = [];
        let l3 = key.length;
        let k5;
        let sigma;
        if (l3 === 32) {
          toClean.push(k5 = (0, utils_ts_1.copyBytes)(key));
          sigma = sigma32_32;
        } else if (l3 === 16 && allowShortKeys) {
          k5 = new Uint8Array(32);
          k5.set(key);
          k5.set(key, 16);
          sigma = sigma16_32;
          toClean.push(k5);
        } else {
          throw new Error(`arx: invalid 32-byte key, got length=${l3}`);
        }
        if (!isAligned32(nonce))
          toClean.push(nonce = (0, utils_ts_1.copyBytes)(nonce));
        const k32 = (0, utils_ts_1.u32)(k5);
        if (extendNonceFn) {
          if (nonce.length !== 24)
            throw new Error(`arx: extended nonce must be 24 bytes`);
          extendNonceFn(sigma, k32, (0, utils_ts_1.u32)(nonce.subarray(0, 16)), k32);
          nonce = nonce.subarray(16);
        }
        const nonceNcLen = 16 - counterLength;
        if (nonceNcLen !== nonce.length)
          throw new Error(`arx: nonce must be ${nonceNcLen} or 16 bytes`);
        if (nonceNcLen !== 12) {
          const nc2 = new Uint8Array(12);
          nc2.set(nonce, counterRight ? 0 : 12 - nonce.length);
          nonce = nc2;
          toClean.push(nonce);
        }
        const n32 = (0, utils_ts_1.u32)(nonce);
        runCipher(core, sigma, k32, n32, data2, output, counter, rounds);
        (0, utils_ts_1.clean)(...toClean);
        return output;
      };
    }
  }
});

// node_modules/.pnpm/@noble+ciphers@1.3.0/node_modules/@noble/ciphers/_poly1305.js
var require_poly1305 = __commonJS({
  "node_modules/.pnpm/@noble+ciphers@1.3.0/node_modules/@noble/ciphers/_poly1305.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.poly1305 = void 0;
    exports.wrapConstructorWithKey = wrapConstructorWithKey;
    var utils_ts_1 = require_utils3();
    var u8to16 = (a2, i3) => a2[i3++] & 255 | (a2[i3++] & 255) << 8;
    var Poly1305 = class {
      constructor(key) {
        this.blockLen = 16;
        this.outputLen = 16;
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.pos = 0;
        this.finished = false;
        key = (0, utils_ts_1.toBytes)(key);
        (0, utils_ts_1.abytes)(key, 32);
        const t0 = u8to16(key, 0);
        const t1 = u8to16(key, 2);
        const t2 = u8to16(key, 4);
        const t3 = u8to16(key, 6);
        const t4 = u8to16(key, 8);
        const t5 = u8to16(key, 10);
        const t6 = u8to16(key, 12);
        const t7 = u8to16(key, 14);
        this.r[0] = t0 & 8191;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this.r[5] = t4 >>> 1 & 8190;
        this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this.r[9] = t7 >>> 5 & 127;
        for (let i3 = 0; i3 < 8; i3++)
          this.pad[i3] = u8to16(key, 16 + 2 * i3);
      }
      process(data2, offset, isLast = false) {
        const hibit = isLast ? 0 : 1 << 11;
        const { h: h4, r: r2 } = this;
        const r0 = r2[0];
        const r1 = r2[1];
        const r22 = r2[2];
        const r3 = r2[3];
        const r4 = r2[4];
        const r5 = r2[5];
        const r6 = r2[6];
        const r7 = r2[7];
        const r8 = r2[8];
        const r9 = r2[9];
        const t0 = u8to16(data2, offset + 0);
        const t1 = u8to16(data2, offset + 2);
        const t2 = u8to16(data2, offset + 4);
        const t3 = u8to16(data2, offset + 6);
        const t4 = u8to16(data2, offset + 8);
        const t5 = u8to16(data2, offset + 10);
        const t6 = u8to16(data2, offset + 12);
        const t7 = u8to16(data2, offset + 14);
        let h0 = h4[0] + (t0 & 8191);
        let h1 = h4[1] + ((t0 >>> 13 | t1 << 3) & 8191);
        let h22 = h4[2] + ((t1 >>> 10 | t2 << 6) & 8191);
        let h32 = h4[3] + ((t2 >>> 7 | t3 << 9) & 8191);
        let h42 = h4[4] + ((t3 >>> 4 | t4 << 12) & 8191);
        let h5 = h4[5] + (t4 >>> 1 & 8191);
        let h6 = h4[6] + ((t4 >>> 14 | t5 << 2) & 8191);
        let h7 = h4[7] + ((t5 >>> 11 | t6 << 5) & 8191);
        let h8 = h4[8] + ((t6 >>> 8 | t7 << 8) & 8191);
        let h9 = h4[9] + (t7 >>> 5 | hibit);
        let c3 = 0;
        let d0 = c3 + h0 * r0 + h1 * (5 * r9) + h22 * (5 * r8) + h32 * (5 * r7) + h42 * (5 * r6);
        c3 = d0 >>> 13;
        d0 &= 8191;
        d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r22) + h9 * (5 * r1);
        c3 += d0 >>> 13;
        d0 &= 8191;
        let d1 = c3 + h0 * r1 + h1 * r0 + h22 * (5 * r9) + h32 * (5 * r8) + h42 * (5 * r7);
        c3 = d1 >>> 13;
        d1 &= 8191;
        d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r22);
        c3 += d1 >>> 13;
        d1 &= 8191;
        let d22 = c3 + h0 * r22 + h1 * r1 + h22 * r0 + h32 * (5 * r9) + h42 * (5 * r8);
        c3 = d22 >>> 13;
        d22 &= 8191;
        d22 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);
        c3 += d22 >>> 13;
        d22 &= 8191;
        let d3 = c3 + h0 * r3 + h1 * r22 + h22 * r1 + h32 * r0 + h42 * (5 * r9);
        c3 = d3 >>> 13;
        d3 &= 8191;
        d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);
        c3 += d3 >>> 13;
        d3 &= 8191;
        let d4 = c3 + h0 * r4 + h1 * r3 + h22 * r22 + h32 * r1 + h42 * r0;
        c3 = d4 >>> 13;
        d4 &= 8191;
        d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);
        c3 += d4 >>> 13;
        d4 &= 8191;
        let d5 = c3 + h0 * r5 + h1 * r4 + h22 * r3 + h32 * r22 + h42 * r1;
        c3 = d5 >>> 13;
        d5 &= 8191;
        d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);
        c3 += d5 >>> 13;
        d5 &= 8191;
        let d6 = c3 + h0 * r6 + h1 * r5 + h22 * r4 + h32 * r3 + h42 * r22;
        c3 = d6 >>> 13;
        d6 &= 8191;
        d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);
        c3 += d6 >>> 13;
        d6 &= 8191;
        let d7 = c3 + h0 * r7 + h1 * r6 + h22 * r5 + h32 * r4 + h42 * r3;
        c3 = d7 >>> 13;
        d7 &= 8191;
        d7 += h5 * r22 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);
        c3 += d7 >>> 13;
        d7 &= 8191;
        let d8 = c3 + h0 * r8 + h1 * r7 + h22 * r6 + h32 * r5 + h42 * r4;
        c3 = d8 >>> 13;
        d8 &= 8191;
        d8 += h5 * r3 + h6 * r22 + h7 * r1 + h8 * r0 + h9 * (5 * r9);
        c3 += d8 >>> 13;
        d8 &= 8191;
        let d9 = c3 + h0 * r9 + h1 * r8 + h22 * r7 + h32 * r6 + h42 * r5;
        c3 = d9 >>> 13;
        d9 &= 8191;
        d9 += h5 * r4 + h6 * r3 + h7 * r22 + h8 * r1 + h9 * r0;
        c3 += d9 >>> 13;
        d9 &= 8191;
        c3 = (c3 << 2) + c3 | 0;
        c3 = c3 + d0 | 0;
        d0 = c3 & 8191;
        c3 = c3 >>> 13;
        d1 += c3;
        h4[0] = d0;
        h4[1] = d1;
        h4[2] = d22;
        h4[3] = d3;
        h4[4] = d4;
        h4[5] = d5;
        h4[6] = d6;
        h4[7] = d7;
        h4[8] = d8;
        h4[9] = d9;
      }
      finalize() {
        const { h: h4, pad } = this;
        const g2 = new Uint16Array(10);
        let c3 = h4[1] >>> 13;
        h4[1] &= 8191;
        for (let i3 = 2; i3 < 10; i3++) {
          h4[i3] += c3;
          c3 = h4[i3] >>> 13;
          h4[i3] &= 8191;
        }
        h4[0] += c3 * 5;
        c3 = h4[0] >>> 13;
        h4[0] &= 8191;
        h4[1] += c3;
        c3 = h4[1] >>> 13;
        h4[1] &= 8191;
        h4[2] += c3;
        g2[0] = h4[0] + 5;
        c3 = g2[0] >>> 13;
        g2[0] &= 8191;
        for (let i3 = 1; i3 < 10; i3++) {
          g2[i3] = h4[i3] + c3;
          c3 = g2[i3] >>> 13;
          g2[i3] &= 8191;
        }
        g2[9] -= 1 << 13;
        let mask = (c3 ^ 1) - 1;
        for (let i3 = 0; i3 < 10; i3++)
          g2[i3] &= mask;
        mask = ~mask;
        for (let i3 = 0; i3 < 10; i3++)
          h4[i3] = h4[i3] & mask | g2[i3];
        h4[0] = (h4[0] | h4[1] << 13) & 65535;
        h4[1] = (h4[1] >>> 3 | h4[2] << 10) & 65535;
        h4[2] = (h4[2] >>> 6 | h4[3] << 7) & 65535;
        h4[3] = (h4[3] >>> 9 | h4[4] << 4) & 65535;
        h4[4] = (h4[4] >>> 12 | h4[5] << 1 | h4[6] << 14) & 65535;
        h4[5] = (h4[6] >>> 2 | h4[7] << 11) & 65535;
        h4[6] = (h4[7] >>> 5 | h4[8] << 8) & 65535;
        h4[7] = (h4[8] >>> 8 | h4[9] << 5) & 65535;
        let f6 = h4[0] + pad[0];
        h4[0] = f6 & 65535;
        for (let i3 = 1; i3 < 8; i3++) {
          f6 = (h4[i3] + pad[i3] | 0) + (f6 >>> 16) | 0;
          h4[i3] = f6 & 65535;
        }
        (0, utils_ts_1.clean)(g2);
      }
      update(data2) {
        (0, utils_ts_1.aexists)(this);
        data2 = (0, utils_ts_1.toBytes)(data2);
        (0, utils_ts_1.abytes)(data2);
        const { buffer, blockLen } = this;
        const len = data2.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(data2, pos);
            continue;
          }
          buffer.set(data2.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(buffer, 0, false);
            this.pos = 0;
          }
        }
        return this;
      }
      destroy() {
        (0, utils_ts_1.clean)(this.h, this.r, this.buffer, this.pad);
      }
      digestInto(out) {
        (0, utils_ts_1.aexists)(this);
        (0, utils_ts_1.aoutput)(out, this);
        this.finished = true;
        const { buffer, h: h4 } = this;
        let { pos } = this;
        if (pos) {
          buffer[pos++] = 1;
          for (; pos < 16; pos++)
            buffer[pos] = 0;
          this.process(buffer, 0, true);
        }
        this.finalize();
        let opos = 0;
        for (let i3 = 0; i3 < 8; i3++) {
          out[opos++] = h4[i3] >>> 0;
          out[opos++] = h4[i3] >>> 8;
        }
        return out;
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
    };
    function wrapConstructorWithKey(hashCons) {
      const hashC = (msg, key) => hashCons(key).update((0, utils_ts_1.toBytes)(msg)).digest();
      const tmp = hashCons(new Uint8Array(32));
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (key) => hashCons(key);
      return hashC;
    }
    exports.poly1305 = wrapConstructorWithKey((key) => new Poly1305(key));
  }
});

// node_modules/.pnpm/@noble+ciphers@1.3.0/node_modules/@noble/ciphers/chacha.js
var require_chacha = __commonJS({
  "node_modules/.pnpm/@noble+ciphers@1.3.0/node_modules/@noble/ciphers/chacha.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.xchacha20poly1305 = exports.chacha20poly1305 = exports._poly1305_aead = exports.chacha12 = exports.chacha8 = exports.xchacha20 = exports.chacha20 = exports.chacha20orig = void 0;
    exports.hchacha = hchacha;
    var _arx_ts_1 = require_arx();
    var _poly1305_ts_1 = require_poly1305();
    var utils_ts_1 = require_utils3();
    function chachaCore(s2, k5, n2, out, cnt, rounds = 20) {
      let y00 = s2[0], y01 = s2[1], y02 = s2[2], y03 = s2[3], y04 = k5[0], y05 = k5[1], y06 = k5[2], y07 = k5[3], y08 = k5[4], y09 = k5[5], y10 = k5[6], y11 = k5[7], y12 = cnt, y13 = n2[0], y14 = n2[1], y15 = n2[2];
      let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
      for (let r2 = 0; r2 < rounds; r2 += 2) {
        x00 = x00 + x04 | 0;
        x12 = (0, _arx_ts_1.rotl)(x12 ^ x00, 16);
        x08 = x08 + x12 | 0;
        x04 = (0, _arx_ts_1.rotl)(x04 ^ x08, 12);
        x00 = x00 + x04 | 0;
        x12 = (0, _arx_ts_1.rotl)(x12 ^ x00, 8);
        x08 = x08 + x12 | 0;
        x04 = (0, _arx_ts_1.rotl)(x04 ^ x08, 7);
        x01 = x01 + x05 | 0;
        x13 = (0, _arx_ts_1.rotl)(x13 ^ x01, 16);
        x09 = x09 + x13 | 0;
        x05 = (0, _arx_ts_1.rotl)(x05 ^ x09, 12);
        x01 = x01 + x05 | 0;
        x13 = (0, _arx_ts_1.rotl)(x13 ^ x01, 8);
        x09 = x09 + x13 | 0;
        x05 = (0, _arx_ts_1.rotl)(x05 ^ x09, 7);
        x02 = x02 + x06 | 0;
        x14 = (0, _arx_ts_1.rotl)(x14 ^ x02, 16);
        x10 = x10 + x14 | 0;
        x06 = (0, _arx_ts_1.rotl)(x06 ^ x10, 12);
        x02 = x02 + x06 | 0;
        x14 = (0, _arx_ts_1.rotl)(x14 ^ x02, 8);
        x10 = x10 + x14 | 0;
        x06 = (0, _arx_ts_1.rotl)(x06 ^ x10, 7);
        x03 = x03 + x07 | 0;
        x15 = (0, _arx_ts_1.rotl)(x15 ^ x03, 16);
        x11 = x11 + x15 | 0;
        x07 = (0, _arx_ts_1.rotl)(x07 ^ x11, 12);
        x03 = x03 + x07 | 0;
        x15 = (0, _arx_ts_1.rotl)(x15 ^ x03, 8);
        x11 = x11 + x15 | 0;
        x07 = (0, _arx_ts_1.rotl)(x07 ^ x11, 7);
        x00 = x00 + x05 | 0;
        x15 = (0, _arx_ts_1.rotl)(x15 ^ x00, 16);
        x10 = x10 + x15 | 0;
        x05 = (0, _arx_ts_1.rotl)(x05 ^ x10, 12);
        x00 = x00 + x05 | 0;
        x15 = (0, _arx_ts_1.rotl)(x15 ^ x00, 8);
        x10 = x10 + x15 | 0;
        x05 = (0, _arx_ts_1.rotl)(x05 ^ x10, 7);
        x01 = x01 + x06 | 0;
        x12 = (0, _arx_ts_1.rotl)(x12 ^ x01, 16);
        x11 = x11 + x12 | 0;
        x06 = (0, _arx_ts_1.rotl)(x06 ^ x11, 12);
        x01 = x01 + x06 | 0;
        x12 = (0, _arx_ts_1.rotl)(x12 ^ x01, 8);
        x11 = x11 + x12 | 0;
        x06 = (0, _arx_ts_1.rotl)(x06 ^ x11, 7);
        x02 = x02 + x07 | 0;
        x13 = (0, _arx_ts_1.rotl)(x13 ^ x02, 16);
        x08 = x08 + x13 | 0;
        x07 = (0, _arx_ts_1.rotl)(x07 ^ x08, 12);
        x02 = x02 + x07 | 0;
        x13 = (0, _arx_ts_1.rotl)(x13 ^ x02, 8);
        x08 = x08 + x13 | 0;
        x07 = (0, _arx_ts_1.rotl)(x07 ^ x08, 7);
        x03 = x03 + x04 | 0;
        x14 = (0, _arx_ts_1.rotl)(x14 ^ x03, 16);
        x09 = x09 + x14 | 0;
        x04 = (0, _arx_ts_1.rotl)(x04 ^ x09, 12);
        x03 = x03 + x04 | 0;
        x14 = (0, _arx_ts_1.rotl)(x14 ^ x03, 8);
        x09 = x09 + x14 | 0;
        x04 = (0, _arx_ts_1.rotl)(x04 ^ x09, 7);
      }
      let oi3 = 0;
      out[oi3++] = y00 + x00 | 0;
      out[oi3++] = y01 + x01 | 0;
      out[oi3++] = y02 + x02 | 0;
      out[oi3++] = y03 + x03 | 0;
      out[oi3++] = y04 + x04 | 0;
      out[oi3++] = y05 + x05 | 0;
      out[oi3++] = y06 + x06 | 0;
      out[oi3++] = y07 + x07 | 0;
      out[oi3++] = y08 + x08 | 0;
      out[oi3++] = y09 + x09 | 0;
      out[oi3++] = y10 + x10 | 0;
      out[oi3++] = y11 + x11 | 0;
      out[oi3++] = y12 + x12 | 0;
      out[oi3++] = y13 + x13 | 0;
      out[oi3++] = y14 + x14 | 0;
      out[oi3++] = y15 + x15 | 0;
    }
    function hchacha(s2, k5, i3, o32) {
      let x00 = s2[0], x01 = s2[1], x02 = s2[2], x03 = s2[3], x04 = k5[0], x05 = k5[1], x06 = k5[2], x07 = k5[3], x08 = k5[4], x09 = k5[5], x10 = k5[6], x11 = k5[7], x12 = i3[0], x13 = i3[1], x14 = i3[2], x15 = i3[3];
      for (let r2 = 0; r2 < 20; r2 += 2) {
        x00 = x00 + x04 | 0;
        x12 = (0, _arx_ts_1.rotl)(x12 ^ x00, 16);
        x08 = x08 + x12 | 0;
        x04 = (0, _arx_ts_1.rotl)(x04 ^ x08, 12);
        x00 = x00 + x04 | 0;
        x12 = (0, _arx_ts_1.rotl)(x12 ^ x00, 8);
        x08 = x08 + x12 | 0;
        x04 = (0, _arx_ts_1.rotl)(x04 ^ x08, 7);
        x01 = x01 + x05 | 0;
        x13 = (0, _arx_ts_1.rotl)(x13 ^ x01, 16);
        x09 = x09 + x13 | 0;
        x05 = (0, _arx_ts_1.rotl)(x05 ^ x09, 12);
        x01 = x01 + x05 | 0;
        x13 = (0, _arx_ts_1.rotl)(x13 ^ x01, 8);
        x09 = x09 + x13 | 0;
        x05 = (0, _arx_ts_1.rotl)(x05 ^ x09, 7);
        x02 = x02 + x06 | 0;
        x14 = (0, _arx_ts_1.rotl)(x14 ^ x02, 16);
        x10 = x10 + x14 | 0;
        x06 = (0, _arx_ts_1.rotl)(x06 ^ x10, 12);
        x02 = x02 + x06 | 0;
        x14 = (0, _arx_ts_1.rotl)(x14 ^ x02, 8);
        x10 = x10 + x14 | 0;
        x06 = (0, _arx_ts_1.rotl)(x06 ^ x10, 7);
        x03 = x03 + x07 | 0;
        x15 = (0, _arx_ts_1.rotl)(x15 ^ x03, 16);
        x11 = x11 + x15 | 0;
        x07 = (0, _arx_ts_1.rotl)(x07 ^ x11, 12);
        x03 = x03 + x07 | 0;
        x15 = (0, _arx_ts_1.rotl)(x15 ^ x03, 8);
        x11 = x11 + x15 | 0;
        x07 = (0, _arx_ts_1.rotl)(x07 ^ x11, 7);
        x00 = x00 + x05 | 0;
        x15 = (0, _arx_ts_1.rotl)(x15 ^ x00, 16);
        x10 = x10 + x15 | 0;
        x05 = (0, _arx_ts_1.rotl)(x05 ^ x10, 12);
        x00 = x00 + x05 | 0;
        x15 = (0, _arx_ts_1.rotl)(x15 ^ x00, 8);
        x10 = x10 + x15 | 0;
        x05 = (0, _arx_ts_1.rotl)(x05 ^ x10, 7);
        x01 = x01 + x06 | 0;
        x12 = (0, _arx_ts_1.rotl)(x12 ^ x01, 16);
        x11 = x11 + x12 | 0;
        x06 = (0, _arx_ts_1.rotl)(x06 ^ x11, 12);
        x01 = x01 + x06 | 0;
        x12 = (0, _arx_ts_1.rotl)(x12 ^ x01, 8);
        x11 = x11 + x12 | 0;
        x06 = (0, _arx_ts_1.rotl)(x06 ^ x11, 7);
        x02 = x02 + x07 | 0;
        x13 = (0, _arx_ts_1.rotl)(x13 ^ x02, 16);
        x08 = x08 + x13 | 0;
        x07 = (0, _arx_ts_1.rotl)(x07 ^ x08, 12);
        x02 = x02 + x07 | 0;
        x13 = (0, _arx_ts_1.rotl)(x13 ^ x02, 8);
        x08 = x08 + x13 | 0;
        x07 = (0, _arx_ts_1.rotl)(x07 ^ x08, 7);
        x03 = x03 + x04 | 0;
        x14 = (0, _arx_ts_1.rotl)(x14 ^ x03, 16);
        x09 = x09 + x14 | 0;
        x04 = (0, _arx_ts_1.rotl)(x04 ^ x09, 12);
        x03 = x03 + x04 | 0;
        x14 = (0, _arx_ts_1.rotl)(x14 ^ x03, 8);
        x09 = x09 + x14 | 0;
        x04 = (0, _arx_ts_1.rotl)(x04 ^ x09, 7);
      }
      let oi3 = 0;
      o32[oi3++] = x00;
      o32[oi3++] = x01;
      o32[oi3++] = x02;
      o32[oi3++] = x03;
      o32[oi3++] = x12;
      o32[oi3++] = x13;
      o32[oi3++] = x14;
      o32[oi3++] = x15;
    }
    exports.chacha20orig = (0, _arx_ts_1.createCipher)(chachaCore, {
      counterRight: false,
      counterLength: 8,
      allowShortKeys: true
    });
    exports.chacha20 = (0, _arx_ts_1.createCipher)(chachaCore, {
      counterRight: false,
      counterLength: 4,
      allowShortKeys: false
    });
    exports.xchacha20 = (0, _arx_ts_1.createCipher)(chachaCore, {
      counterRight: false,
      counterLength: 8,
      extendNonceFn: hchacha,
      allowShortKeys: false
    });
    exports.chacha8 = (0, _arx_ts_1.createCipher)(chachaCore, {
      counterRight: false,
      counterLength: 4,
      rounds: 8
    });
    exports.chacha12 = (0, _arx_ts_1.createCipher)(chachaCore, {
      counterRight: false,
      counterLength: 4,
      rounds: 12
    });
    var ZEROS16 = new Uint8Array(16);
    var updatePadded = (h4, msg) => {
      h4.update(msg);
      const left = msg.length % 16;
      if (left)
        h4.update(ZEROS16.subarray(left));
    };
    var ZEROS32 = new Uint8Array(32);
    function computeTag(fn3, key, nonce, data2, AAD) {
      const authKey = fn3(key, nonce, ZEROS32);
      const h4 = _poly1305_ts_1.poly1305.create(authKey);
      if (AAD)
        updatePadded(h4, AAD);
      updatePadded(h4, data2);
      const num = (0, utils_ts_1.u64Lengths)(data2.length, AAD ? AAD.length : 0, true);
      h4.update(num);
      const res = h4.digest();
      (0, utils_ts_1.clean)(authKey, num);
      return res;
    }
    var _poly1305_aead = (xorStream) => (key, nonce, AAD) => {
      const tagLength = 16;
      return {
        encrypt(plaintext, output) {
          const plength = plaintext.length;
          output = (0, utils_ts_1.getOutput)(plength + tagLength, output, false);
          output.set(plaintext);
          const oPlain = output.subarray(0, -tagLength);
          xorStream(key, nonce, oPlain, oPlain, 1);
          const tag = computeTag(xorStream, key, nonce, oPlain, AAD);
          output.set(tag, plength);
          (0, utils_ts_1.clean)(tag);
          return output;
        },
        decrypt(ciphertext, output) {
          output = (0, utils_ts_1.getOutput)(ciphertext.length - tagLength, output, false);
          const data2 = ciphertext.subarray(0, -tagLength);
          const passedTag = ciphertext.subarray(-tagLength);
          const tag = computeTag(xorStream, key, nonce, data2, AAD);
          if (!(0, utils_ts_1.equalBytes)(passedTag, tag))
            throw new Error("invalid tag");
          output.set(ciphertext.subarray(0, -tagLength));
          xorStream(key, nonce, output, output, 1);
          (0, utils_ts_1.clean)(tag);
          return output;
        }
      };
    };
    exports._poly1305_aead = _poly1305_aead;
    exports.chacha20poly1305 = (0, utils_ts_1.wrapCipher)({ blockSize: 64, nonceLength: 12, tagLength: 16 }, (0, exports._poly1305_aead)(exports.chacha20));
    exports.xchacha20poly1305 = (0, utils_ts_1.wrapCipher)({ blockSize: 64, nonceLength: 24, tagLength: 16 }, (0, exports._poly1305_aead)(exports.xchacha20));
  }
});

// node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/utils.js
var require_utils4 = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.notImplemented = exports.bitMask = exports.utf8ToBytes = exports.randomBytes = exports.isBytes = exports.hexToBytes = exports.concatBytes = exports.bytesToUtf8 = exports.bytesToHex = exports.anumber = exports.abytes = void 0;
    exports.abool = abool;
    exports._abool2 = _abool2;
    exports._abytes2 = _abytes2;
    exports.numberToHexUnpadded = numberToHexUnpadded;
    exports.hexToNumber = hexToNumber;
    exports.bytesToNumberBE = bytesToNumberBE;
    exports.bytesToNumberLE = bytesToNumberLE;
    exports.numberToBytesBE = numberToBytesBE;
    exports.numberToBytesLE = numberToBytesLE;
    exports.numberToVarBytesBE = numberToVarBytesBE;
    exports.ensureBytes = ensureBytes;
    exports.equalBytes = equalBytes;
    exports.copyBytes = copyBytes;
    exports.asciiToBytes = asciiToBytes;
    exports.inRange = inRange;
    exports.aInRange = aInRange;
    exports.bitLen = bitLen;
    exports.bitGet = bitGet;
    exports.bitSet = bitSet;
    exports.createHmacDrbg = createHmacDrbg;
    exports.validateObject = validateObject;
    exports.isHash = isHash;
    exports._validateObject = _validateObject;
    exports.memoized = memoized;
    var utils_js_1 = require_utils();
    var utils_js_2 = require_utils();
    Object.defineProperty(exports, "abytes", { enumerable: true, get: function() {
      return utils_js_2.abytes;
    } });
    Object.defineProperty(exports, "anumber", { enumerable: true, get: function() {
      return utils_js_2.anumber;
    } });
    Object.defineProperty(exports, "bytesToHex", { enumerable: true, get: function() {
      return utils_js_2.bytesToHex;
    } });
    Object.defineProperty(exports, "bytesToUtf8", { enumerable: true, get: function() {
      return utils_js_2.bytesToUtf8;
    } });
    Object.defineProperty(exports, "concatBytes", { enumerable: true, get: function() {
      return utils_js_2.concatBytes;
    } });
    Object.defineProperty(exports, "hexToBytes", { enumerable: true, get: function() {
      return utils_js_2.hexToBytes;
    } });
    Object.defineProperty(exports, "isBytes", { enumerable: true, get: function() {
      return utils_js_2.isBytes;
    } });
    Object.defineProperty(exports, "randomBytes", { enumerable: true, get: function() {
      return utils_js_2.randomBytes;
    } });
    Object.defineProperty(exports, "utf8ToBytes", { enumerable: true, get: function() {
      return utils_js_2.utf8ToBytes;
    } });
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    function abool(title, value) {
      if (typeof value !== "boolean")
        throw new Error(title + " boolean expected, got " + value);
    }
    function _abool2(value, title = "") {
      if (typeof value !== "boolean") {
        const prefix = title && `"${title}"`;
        throw new Error(prefix + "expected boolean, got type=" + typeof value);
      }
      return value;
    }
    function _abytes2(value, length, title = "") {
      const bytes2 = (0, utils_js_1.isBytes)(value);
      const len = value?.length;
      const needsLen = length !== void 0;
      if (!bytes2 || needsLen && len !== length) {
        const prefix = title && `"${title}" `;
        const ofLen = needsLen ? ` of length ${length}` : "";
        const got = bytes2 ? `length=${len}` : `type=${typeof value}`;
        throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
      }
      return value;
    }
    function numberToHexUnpadded(num) {
      const hex2 = num.toString(16);
      return hex2.length & 1 ? "0" + hex2 : hex2;
    }
    function hexToNumber(hex2) {
      if (typeof hex2 !== "string")
        throw new Error("hex string expected, got " + typeof hex2);
      return hex2 === "" ? _0n : BigInt("0x" + hex2);
    }
    function bytesToNumberBE(bytes2) {
      return hexToNumber((0, utils_js_1.bytesToHex)(bytes2));
    }
    function bytesToNumberLE(bytes2) {
      (0, utils_js_1.abytes)(bytes2);
      return hexToNumber((0, utils_js_1.bytesToHex)(Uint8Array.from(bytes2).reverse()));
    }
    function numberToBytesBE(n2, len) {
      return (0, utils_js_1.hexToBytes)(n2.toString(16).padStart(len * 2, "0"));
    }
    function numberToBytesLE(n2, len) {
      return numberToBytesBE(n2, len).reverse();
    }
    function numberToVarBytesBE(n2) {
      return (0, utils_js_1.hexToBytes)(numberToHexUnpadded(n2));
    }
    function ensureBytes(title, hex2, expectedLength) {
      let res;
      if (typeof hex2 === "string") {
        try {
          res = (0, utils_js_1.hexToBytes)(hex2);
        } catch (e) {
          throw new Error(title + " must be hex string or Uint8Array, cause: " + e);
        }
      } else if ((0, utils_js_1.isBytes)(hex2)) {
        res = Uint8Array.from(hex2);
      } else {
        throw new Error(title + " must be hex string or Uint8Array");
      }
      const len = res.length;
      if (typeof expectedLength === "number" && len !== expectedLength)
        throw new Error(title + " of length " + expectedLength + " expected, got " + len);
      return res;
    }
    function equalBytes(a2, b5) {
      if (a2.length !== b5.length)
        return false;
      let diff = 0;
      for (let i3 = 0; i3 < a2.length; i3++)
        diff |= a2[i3] ^ b5[i3];
      return diff === 0;
    }
    function copyBytes(bytes2) {
      return Uint8Array.from(bytes2);
    }
    function asciiToBytes(ascii) {
      return Uint8Array.from(ascii, (c3, i3) => {
        const charCode = c3.charCodeAt(0);
        if (c3.length !== 1 || charCode > 127) {
          throw new Error(`string contains non-ASCII character "${ascii[i3]}" with code ${charCode} at position ${i3}`);
        }
        return charCode;
      });
    }
    var isPosBig = (n2) => typeof n2 === "bigint" && _0n <= n2;
    function inRange(n2, min, max) {
      return isPosBig(n2) && isPosBig(min) && isPosBig(max) && min <= n2 && n2 < max;
    }
    function aInRange(title, n2, min, max) {
      if (!inRange(n2, min, max))
        throw new Error("expected valid " + title + ": " + min + " <= n < " + max + ", got " + n2);
    }
    function bitLen(n2) {
      let len;
      for (len = 0; n2 > _0n; n2 >>= _1n, len += 1)
        ;
      return len;
    }
    function bitGet(n2, pos) {
      return n2 >> BigInt(pos) & _1n;
    }
    function bitSet(n2, pos, value) {
      return n2 | (value ? _1n : _0n) << BigInt(pos);
    }
    var bitMask = (n2) => (_1n << BigInt(n2)) - _1n;
    exports.bitMask = bitMask;
    function createHmacDrbg(hashLen, qByteLen, hmacFn) {
      if (typeof hashLen !== "number" || hashLen < 2)
        throw new Error("hashLen must be a number");
      if (typeof qByteLen !== "number" || qByteLen < 2)
        throw new Error("qByteLen must be a number");
      if (typeof hmacFn !== "function")
        throw new Error("hmacFn must be a function");
      const u8n = (len) => new Uint8Array(len);
      const u8of = (byte) => Uint8Array.of(byte);
      let v9 = u8n(hashLen);
      let k5 = u8n(hashLen);
      let i3 = 0;
      const reset = () => {
        v9.fill(1);
        k5.fill(0);
        i3 = 0;
      };
      const h4 = (...b5) => hmacFn(k5, v9, ...b5);
      const reseed = (seed = u8n(0)) => {
        k5 = h4(u8of(0), seed);
        v9 = h4();
        if (seed.length === 0)
          return;
        k5 = h4(u8of(1), seed);
        v9 = h4();
      };
      const gen = () => {
        if (i3++ >= 1e3)
          throw new Error("drbg: tried 1000 values");
        let len = 0;
        const out = [];
        while (len < qByteLen) {
          v9 = h4();
          const sl = v9.slice();
          out.push(sl);
          len += v9.length;
        }
        return (0, utils_js_1.concatBytes)(...out);
      };
      const genUntil = (seed, pred) => {
        reset();
        reseed(seed);
        let res = void 0;
        while (!(res = pred(gen())))
          reseed();
        reset();
        return res;
      };
      return genUntil;
    }
    var validatorFns = {
      bigint: (val) => typeof val === "bigint",
      function: (val) => typeof val === "function",
      boolean: (val) => typeof val === "boolean",
      string: (val) => typeof val === "string",
      stringOrUint8Array: (val) => typeof val === "string" || (0, utils_js_1.isBytes)(val),
      isSafeInteger: (val) => Number.isSafeInteger(val),
      array: (val) => Array.isArray(val),
      field: (val, object) => object.Fp.isValid(val),
      hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
    };
    function validateObject(object, validators, optValidators = {}) {
      const checkField = (fieldName, type, isOptional) => {
        const checkVal = validatorFns[type];
        if (typeof checkVal !== "function")
          throw new Error("invalid validator function");
        const val = object[fieldName];
        if (isOptional && val === void 0)
          return;
        if (!checkVal(val, object)) {
          throw new Error("param " + String(fieldName) + " is invalid. Expected " + type + ", got " + val);
        }
      };
      for (const [fieldName, type] of Object.entries(validators))
        checkField(fieldName, type, false);
      for (const [fieldName, type] of Object.entries(optValidators))
        checkField(fieldName, type, true);
      return object;
    }
    function isHash(val) {
      return typeof val === "function" && Number.isSafeInteger(val.outputLen);
    }
    function _validateObject(object, fields, optFields = {}) {
      if (!object || typeof object !== "object")
        throw new Error("expected valid options object");
      function checkField(fieldName, expectedType, isOpt) {
        const val = object[fieldName];
        if (isOpt && val === void 0)
          return;
        const current = typeof val;
        if (current !== expectedType || val === null)
          throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
      }
      Object.entries(fields).forEach(([k5, v9]) => checkField(k5, v9, false));
      Object.entries(optFields).forEach(([k5, v9]) => checkField(k5, v9, true));
    }
    var notImplemented = () => {
      throw new Error("not implemented");
    };
    exports.notImplemented = notImplemented;
    function memoized(fn3) {
      const map = /* @__PURE__ */ new WeakMap();
      return (arg, ...args) => {
        const val = map.get(arg);
        if (val !== void 0)
          return val;
        const computed = fn3(arg, ...args);
        map.set(arg, computed);
        return computed;
      };
    }
  }
});

// node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/abstract/modular.js
var require_modular = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/abstract/modular.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isNegativeLE = void 0;
    exports.mod = mod;
    exports.pow = pow;
    exports.pow2 = pow2;
    exports.invert = invert;
    exports.tonelliShanks = tonelliShanks;
    exports.FpSqrt = FpSqrt;
    exports.validateField = validateField;
    exports.FpPow = FpPow;
    exports.FpInvertBatch = FpInvertBatch;
    exports.FpDiv = FpDiv;
    exports.FpLegendre = FpLegendre;
    exports.FpIsSquare = FpIsSquare;
    exports.nLength = nLength;
    exports.Field = Field;
    exports.FpSqrtOdd = FpSqrtOdd;
    exports.FpSqrtEven = FpSqrtEven;
    exports.hashToPrivateScalar = hashToPrivateScalar;
    exports.getFieldBytesLength = getFieldBytesLength;
    exports.getMinHashLength = getMinHashLength;
    exports.mapHashToField = mapHashToField;
    var utils_ts_1 = require_utils4();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _4n = BigInt(4);
    var _5n = BigInt(5);
    var _7n = BigInt(7);
    var _8n = BigInt(8);
    var _9n = BigInt(9);
    var _16n = BigInt(16);
    function mod(a2, b5) {
      const result = a2 % b5;
      return result >= _0n ? result : b5 + result;
    }
    function pow(num, power, modulo2) {
      return FpPow(Field(modulo2), num, power);
    }
    function pow2(x3, power, modulo2) {
      let res = x3;
      while (power-- > _0n) {
        res *= res;
        res %= modulo2;
      }
      return res;
    }
    function invert(number, modulo2) {
      if (number === _0n)
        throw new Error("invert: expected non-zero number");
      if (modulo2 <= _0n)
        throw new Error("invert: expected positive modulus, got " + modulo2);
      let a2 = mod(number, modulo2);
      let b5 = modulo2;
      let x3 = _0n, y4 = _1n, u4 = _1n, v9 = _0n;
      while (a2 !== _0n) {
        const q2 = b5 / a2;
        const r2 = b5 % a2;
        const m3 = x3 - u4 * q2;
        const n2 = y4 - v9 * q2;
        b5 = a2, a2 = r2, x3 = u4, y4 = v9, u4 = m3, v9 = n2;
      }
      const gcd2 = b5;
      if (gcd2 !== _1n)
        throw new Error("invert: does not exist");
      return mod(x3, modulo2);
    }
    function assertIsSquare(Fp, root, n2) {
      if (!Fp.eql(Fp.sqr(root), n2))
        throw new Error("Cannot find square root");
    }
    function sqrt3mod4(Fp, n2) {
      const p1div4 = (Fp.ORDER + _1n) / _4n;
      const root = Fp.pow(n2, p1div4);
      assertIsSquare(Fp, root, n2);
      return root;
    }
    function sqrt5mod8(Fp, n2) {
      const p5div8 = (Fp.ORDER - _5n) / _8n;
      const n22 = Fp.mul(n2, _2n);
      const v9 = Fp.pow(n22, p5div8);
      const nv = Fp.mul(n2, v9);
      const i3 = Fp.mul(Fp.mul(nv, _2n), v9);
      const root = Fp.mul(nv, Fp.sub(i3, Fp.ONE));
      assertIsSquare(Fp, root, n2);
      return root;
    }
    function sqrt9mod16(P5) {
      const Fp_ = Field(P5);
      const tn3 = tonelliShanks(P5);
      const c1 = tn3(Fp_, Fp_.neg(Fp_.ONE));
      const c22 = tn3(Fp_, c1);
      const c3 = tn3(Fp_, Fp_.neg(c1));
      const c4 = (P5 + _7n) / _16n;
      return (Fp, n2) => {
        let tv1 = Fp.pow(n2, c4);
        let tv2 = Fp.mul(tv1, c1);
        const tv3 = Fp.mul(tv1, c22);
        const tv4 = Fp.mul(tv1, c3);
        const e1 = Fp.eql(Fp.sqr(tv2), n2);
        const e2 = Fp.eql(Fp.sqr(tv3), n2);
        tv1 = Fp.cmov(tv1, tv2, e1);
        tv2 = Fp.cmov(tv4, tv3, e2);
        const e3 = Fp.eql(Fp.sqr(tv2), n2);
        const root = Fp.cmov(tv1, tv2, e3);
        assertIsSquare(Fp, root, n2);
        return root;
      };
    }
    function tonelliShanks(P5) {
      if (P5 < _3n)
        throw new Error("sqrt is not defined for small field");
      let Q3 = P5 - _1n;
      let S3 = 0;
      while (Q3 % _2n === _0n) {
        Q3 /= _2n;
        S3++;
      }
      let Z3 = _2n;
      const _Fp = Field(P5);
      while (FpLegendre(_Fp, Z3) === 1) {
        if (Z3++ > 1e3)
          throw new Error("Cannot find square root: probably non-prime P");
      }
      if (S3 === 1)
        return sqrt3mod4;
      let cc2 = _Fp.pow(Z3, Q3);
      const Q1div2 = (Q3 + _1n) / _2n;
      return function tonelliSlow(Fp, n2) {
        if (Fp.is0(n2))
          return n2;
        if (FpLegendre(Fp, n2) !== 1)
          throw new Error("Cannot find square root");
        let M5 = S3;
        let c3 = Fp.mul(Fp.ONE, cc2);
        let t = Fp.pow(n2, Q3);
        let R6 = Fp.pow(n2, Q1div2);
        while (!Fp.eql(t, Fp.ONE)) {
          if (Fp.is0(t))
            return Fp.ZERO;
          let i3 = 1;
          let t_tmp = Fp.sqr(t);
          while (!Fp.eql(t_tmp, Fp.ONE)) {
            i3++;
            t_tmp = Fp.sqr(t_tmp);
            if (i3 === M5)
              throw new Error("Cannot find square root");
          }
          const exponent = _1n << BigInt(M5 - i3 - 1);
          const b5 = Fp.pow(c3, exponent);
          M5 = i3;
          c3 = Fp.sqr(b5);
          t = Fp.mul(t, c3);
          R6 = Fp.mul(R6, b5);
        }
        return R6;
      };
    }
    function FpSqrt(P5) {
      if (P5 % _4n === _3n)
        return sqrt3mod4;
      if (P5 % _8n === _5n)
        return sqrt5mod8;
      if (P5 % _16n === _9n)
        return sqrt9mod16(P5);
      return tonelliShanks(P5);
    }
    var isNegativeLE = (num, modulo2) => (mod(num, modulo2) & _1n) === _1n;
    exports.isNegativeLE = isNegativeLE;
    var FIELD_FIELDS = [
      "create",
      "isValid",
      "is0",
      "neg",
      "inv",
      "sqrt",
      "sqr",
      "eql",
      "add",
      "sub",
      "mul",
      "pow",
      "div",
      "addN",
      "subN",
      "mulN",
      "sqrN"
    ];
    function validateField(field) {
      const initial = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "number",
        BITS: "number"
      };
      const opts = FIELD_FIELDS.reduce((map, val) => {
        map[val] = "function";
        return map;
      }, initial);
      (0, utils_ts_1._validateObject)(field, opts);
      return field;
    }
    function FpPow(Fp, num, power) {
      if (power < _0n)
        throw new Error("invalid exponent, negatives unsupported");
      if (power === _0n)
        return Fp.ONE;
      if (power === _1n)
        return num;
      let p4 = Fp.ONE;
      let d3 = num;
      while (power > _0n) {
        if (power & _1n)
          p4 = Fp.mul(p4, d3);
        d3 = Fp.sqr(d3);
        power >>= _1n;
      }
      return p4;
    }
    function FpInvertBatch(Fp, nums, passZero = false) {
      const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : void 0);
      const multipliedAcc = nums.reduce((acc, num, i3) => {
        if (Fp.is0(num))
          return acc;
        inverted[i3] = acc;
        return Fp.mul(acc, num);
      }, Fp.ONE);
      const invertedAcc = Fp.inv(multipliedAcc);
      nums.reduceRight((acc, num, i3) => {
        if (Fp.is0(num))
          return acc;
        inverted[i3] = Fp.mul(acc, inverted[i3]);
        return Fp.mul(acc, num);
      }, invertedAcc);
      return inverted;
    }
    function FpDiv(Fp, lhs, rhs) {
      return Fp.mul(lhs, typeof rhs === "bigint" ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));
    }
    function FpLegendre(Fp, n2) {
      const p1mod2 = (Fp.ORDER - _1n) / _2n;
      const powered = Fp.pow(n2, p1mod2);
      const yes = Fp.eql(powered, Fp.ONE);
      const zero = Fp.eql(powered, Fp.ZERO);
      const no3 = Fp.eql(powered, Fp.neg(Fp.ONE));
      if (!yes && !zero && !no3)
        throw new Error("invalid Legendre symbol result");
      return yes ? 1 : zero ? 0 : -1;
    }
    function FpIsSquare(Fp, n2) {
      const l3 = FpLegendre(Fp, n2);
      return l3 === 1;
    }
    function nLength(n2, nBitLength) {
      if (nBitLength !== void 0)
        (0, utils_ts_1.anumber)(nBitLength);
      const _nBitLength = nBitLength !== void 0 ? nBitLength : n2.toString(2).length;
      const nByteLength = Math.ceil(_nBitLength / 8);
      return { nBitLength: _nBitLength, nByteLength };
    }
    function Field(ORDER, bitLenOrOpts, isLE = false, opts = {}) {
      if (ORDER <= _0n)
        throw new Error("invalid field: expected ORDER > 0, got " + ORDER);
      let _nbitLength = void 0;
      let _sqrt = void 0;
      let modFromBytes = false;
      let allowedLengths = void 0;
      if (typeof bitLenOrOpts === "object" && bitLenOrOpts != null) {
        if (opts.sqrt || isLE)
          throw new Error("cannot specify opts in two arguments");
        const _opts = bitLenOrOpts;
        if (_opts.BITS)
          _nbitLength = _opts.BITS;
        if (_opts.sqrt)
          _sqrt = _opts.sqrt;
        if (typeof _opts.isLE === "boolean")
          isLE = _opts.isLE;
        if (typeof _opts.modFromBytes === "boolean")
          modFromBytes = _opts.modFromBytes;
        allowedLengths = _opts.allowedLengths;
      } else {
        if (typeof bitLenOrOpts === "number")
          _nbitLength = bitLenOrOpts;
        if (opts.sqrt)
          _sqrt = opts.sqrt;
      }
      const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);
      if (BYTES > 2048)
        throw new Error("invalid field: expected ORDER of <= 2048 bytes");
      let sqrtP;
      const f6 = Object.freeze({
        ORDER,
        isLE,
        BITS,
        BYTES,
        MASK: (0, utils_ts_1.bitMask)(BITS),
        ZERO: _0n,
        ONE: _1n,
        allowedLengths,
        create: (num) => mod(num, ORDER),
        isValid: (num) => {
          if (typeof num !== "bigint")
            throw new Error("invalid field element: expected bigint, got " + typeof num);
          return _0n <= num && num < ORDER;
        },
        is0: (num) => num === _0n,
        // is valid and invertible
        isValidNot0: (num) => !f6.is0(num) && f6.isValid(num),
        isOdd: (num) => (num & _1n) === _1n,
        neg: (num) => mod(-num, ORDER),
        eql: (lhs, rhs) => lhs === rhs,
        sqr: (num) => mod(num * num, ORDER),
        add: (lhs, rhs) => mod(lhs + rhs, ORDER),
        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
        pow: (num, power) => FpPow(f6, num, power),
        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
        // Same as above, but doesn't normalize
        sqrN: (num) => num * num,
        addN: (lhs, rhs) => lhs + rhs,
        subN: (lhs, rhs) => lhs - rhs,
        mulN: (lhs, rhs) => lhs * rhs,
        inv: (num) => invert(num, ORDER),
        sqrt: _sqrt || ((n2) => {
          if (!sqrtP)
            sqrtP = FpSqrt(ORDER);
          return sqrtP(f6, n2);
        }),
        toBytes: (num) => isLE ? (0, utils_ts_1.numberToBytesLE)(num, BYTES) : (0, utils_ts_1.numberToBytesBE)(num, BYTES),
        fromBytes: (bytes2, skipValidation = true) => {
          if (allowedLengths) {
            if (!allowedLengths.includes(bytes2.length) || bytes2.length > BYTES) {
              throw new Error("Field.fromBytes: expected " + allowedLengths + " bytes, got " + bytes2.length);
            }
            const padded = new Uint8Array(BYTES);
            padded.set(bytes2, isLE ? 0 : padded.length - bytes2.length);
            bytes2 = padded;
          }
          if (bytes2.length !== BYTES)
            throw new Error("Field.fromBytes: expected " + BYTES + " bytes, got " + bytes2.length);
          let scalar = isLE ? (0, utils_ts_1.bytesToNumberLE)(bytes2) : (0, utils_ts_1.bytesToNumberBE)(bytes2);
          if (modFromBytes)
            scalar = mod(scalar, ORDER);
          if (!skipValidation) {
            if (!f6.isValid(scalar))
              throw new Error("invalid field element: outside of range 0..ORDER");
          }
          return scalar;
        },
        // TODO: we don't need it here, move out to separate fn
        invertBatch: (lst) => FpInvertBatch(f6, lst),
        // We can't move this out because Fp6, Fp12 implement it
        // and it's unclear what to return in there.
        cmov: (a2, b5, c3) => c3 ? b5 : a2
      });
      return Object.freeze(f6);
    }
    function FpSqrtOdd(Fp, elm) {
      if (!Fp.isOdd)
        throw new Error("Field doesn't have isOdd");
      const root = Fp.sqrt(elm);
      return Fp.isOdd(root) ? root : Fp.neg(root);
    }
    function FpSqrtEven(Fp, elm) {
      if (!Fp.isOdd)
        throw new Error("Field doesn't have isOdd");
      const root = Fp.sqrt(elm);
      return Fp.isOdd(root) ? Fp.neg(root) : root;
    }
    function hashToPrivateScalar(hash2, groupOrder, isLE = false) {
      hash2 = (0, utils_ts_1.ensureBytes)("privateHash", hash2);
      const hashLen = hash2.length;
      const minLen = nLength(groupOrder).nByteLength + 8;
      if (minLen < 24 || hashLen < minLen || hashLen > 1024)
        throw new Error("hashToPrivateScalar: expected " + minLen + "-1024 bytes of input, got " + hashLen);
      const num = isLE ? (0, utils_ts_1.bytesToNumberLE)(hash2) : (0, utils_ts_1.bytesToNumberBE)(hash2);
      return mod(num, groupOrder - _1n) + _1n;
    }
    function getFieldBytesLength(fieldOrder) {
      if (typeof fieldOrder !== "bigint")
        throw new Error("field order must be bigint");
      const bitLength = fieldOrder.toString(2).length;
      return Math.ceil(bitLength / 8);
    }
    function getMinHashLength(fieldOrder) {
      const length = getFieldBytesLength(fieldOrder);
      return length + Math.ceil(length / 2);
    }
    function mapHashToField(key, fieldOrder, isLE = false) {
      const len = key.length;
      const fieldLen = getFieldBytesLength(fieldOrder);
      const minLen = getMinHashLength(fieldOrder);
      if (len < 16 || len < minLen || len > 1024)
        throw new Error("expected " + minLen + "-1024 bytes of input, got " + len);
      const num = isLE ? (0, utils_ts_1.bytesToNumberLE)(key) : (0, utils_ts_1.bytesToNumberBE)(key);
      const reduced = mod(num, fieldOrder - _1n) + _1n;
      return isLE ? (0, utils_ts_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_ts_1.numberToBytesBE)(reduced, fieldLen);
    }
  }
});

// node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/abstract/curve.js
var require_curve = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/abstract/curve.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wNAF = void 0;
    exports.negateCt = negateCt;
    exports.normalizeZ = normalizeZ;
    exports.mulEndoUnsafe = mulEndoUnsafe;
    exports.pippenger = pippenger;
    exports.precomputeMSMUnsafe = precomputeMSMUnsafe;
    exports.validateBasic = validateBasic;
    exports._createCurveFields = _createCurveFields;
    var utils_ts_1 = require_utils4();
    var modular_ts_1 = require_modular();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    function negateCt(condition, item) {
      const neg = item.negate();
      return condition ? neg : item;
    }
    function normalizeZ(c3, points) {
      const invertedZs = (0, modular_ts_1.FpInvertBatch)(c3.Fp, points.map((p4) => p4.Z));
      return points.map((p4, i3) => c3.fromAffine(p4.toAffine(invertedZs[i3])));
    }
    function validateW(W3, bits) {
      if (!Number.isSafeInteger(W3) || W3 <= 0 || W3 > bits)
        throw new Error("invalid window size, expected [1.." + bits + "], got W=" + W3);
    }
    function calcWOpts(W3, scalarBits) {
      validateW(W3, scalarBits);
      const windows = Math.ceil(scalarBits / W3) + 1;
      const windowSize = 2 ** (W3 - 1);
      const maxNumber = 2 ** W3;
      const mask = (0, utils_ts_1.bitMask)(W3);
      const shiftBy = BigInt(W3);
      return { windows, windowSize, mask, maxNumber, shiftBy };
    }
    function calcOffsets(n2, window2, wOpts) {
      const { windowSize, mask, maxNumber, shiftBy } = wOpts;
      let wbits = Number(n2 & mask);
      let nextN = n2 >> shiftBy;
      if (wbits > windowSize) {
        wbits -= maxNumber;
        nextN += _1n;
      }
      const offsetStart = window2 * windowSize;
      const offset = offsetStart + Math.abs(wbits) - 1;
      const isZero2 = wbits === 0;
      const isNeg = wbits < 0;
      const isNegF = window2 % 2 !== 0;
      const offsetF = offsetStart;
      return { nextN, offset, isZero: isZero2, isNeg, isNegF, offsetF };
    }
    function validateMSMPoints(points, c3) {
      if (!Array.isArray(points))
        throw new Error("array expected");
      points.forEach((p4, i3) => {
        if (!(p4 instanceof c3))
          throw new Error("invalid point at index " + i3);
      });
    }
    function validateMSMScalars(scalars, field) {
      if (!Array.isArray(scalars))
        throw new Error("array of scalars expected");
      scalars.forEach((s2, i3) => {
        if (!field.isValid(s2))
          throw new Error("invalid scalar at index " + i3);
      });
    }
    var pointPrecomputes = /* @__PURE__ */ new WeakMap();
    var pointWindowSizes = /* @__PURE__ */ new WeakMap();
    function getW(P5) {
      return pointWindowSizes.get(P5) || 1;
    }
    function assert0(n2) {
      if (n2 !== _0n)
        throw new Error("invalid wNAF");
    }
    var wNAF = class {
      // Parametrized with a given Point class (not individual point)
      constructor(Point, bits) {
        this.BASE = Point.BASE;
        this.ZERO = Point.ZERO;
        this.Fn = Point.Fn;
        this.bits = bits;
      }
      // non-const time multiplication ladder
      _unsafeLadder(elm, n2, p4 = this.ZERO) {
        let d3 = elm;
        while (n2 > _0n) {
          if (n2 & _1n)
            p4 = p4.add(d3);
          d3 = d3.double();
          n2 >>= _1n;
        }
        return p4;
      }
      /**
       * Creates a wNAF precomputation window. Used for caching.
       * Default window size is set by `utils.precompute()` and is equal to 8.
       * Number of precomputed points depends on the curve size:
       * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
       * - 𝑊 is the window size
       * - 𝑛 is the bitlength of the curve order.
       * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
       * @param point Point instance
       * @param W window size
       * @returns precomputed point tables flattened to a single array
       */
      precomputeWindow(point, W3) {
        const { windows, windowSize } = calcWOpts(W3, this.bits);
        const points = [];
        let p4 = point;
        let base = p4;
        for (let window2 = 0; window2 < windows; window2++) {
          base = p4;
          points.push(base);
          for (let i3 = 1; i3 < windowSize; i3++) {
            base = base.add(p4);
            points.push(base);
          }
          p4 = base.double();
        }
        return points;
      }
      /**
       * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
       * More compact implementation:
       * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
       * @returns real and fake (for const-time) points
       */
      wNAF(W3, precomputes, n2) {
        if (!this.Fn.isValid(n2))
          throw new Error("invalid scalar");
        let p4 = this.ZERO;
        let f6 = this.BASE;
        const wo3 = calcWOpts(W3, this.bits);
        for (let window2 = 0; window2 < wo3.windows; window2++) {
          const { nextN, offset, isZero: isZero2, isNeg, isNegF, offsetF } = calcOffsets(n2, window2, wo3);
          n2 = nextN;
          if (isZero2) {
            f6 = f6.add(negateCt(isNegF, precomputes[offsetF]));
          } else {
            p4 = p4.add(negateCt(isNeg, precomputes[offset]));
          }
        }
        assert0(n2);
        return { p: p4, f: f6 };
      }
      /**
       * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
       * @param acc accumulator point to add result of multiplication
       * @returns point
       */
      wNAFUnsafe(W3, precomputes, n2, acc = this.ZERO) {
        const wo3 = calcWOpts(W3, this.bits);
        for (let window2 = 0; window2 < wo3.windows; window2++) {
          if (n2 === _0n)
            break;
          const { nextN, offset, isZero: isZero2, isNeg } = calcOffsets(n2, window2, wo3);
          n2 = nextN;
          if (isZero2) {
            continue;
          } else {
            const item = precomputes[offset];
            acc = acc.add(isNeg ? item.negate() : item);
          }
        }
        assert0(n2);
        return acc;
      }
      getPrecomputes(W3, point, transform) {
        let comp = pointPrecomputes.get(point);
        if (!comp) {
          comp = this.precomputeWindow(point, W3);
          if (W3 !== 1) {
            if (typeof transform === "function")
              comp = transform(comp);
            pointPrecomputes.set(point, comp);
          }
        }
        return comp;
      }
      cached(point, scalar, transform) {
        const W3 = getW(point);
        return this.wNAF(W3, this.getPrecomputes(W3, point, transform), scalar);
      }
      unsafe(point, scalar, transform, prev) {
        const W3 = getW(point);
        if (W3 === 1)
          return this._unsafeLadder(point, scalar, prev);
        return this.wNAFUnsafe(W3, this.getPrecomputes(W3, point, transform), scalar, prev);
      }
      // We calculate precomputes for elliptic curve point multiplication
      // using windowed method. This specifies window size and
      // stores precomputed values. Usually only base point would be precomputed.
      createCache(P5, W3) {
        validateW(W3, this.bits);
        pointWindowSizes.set(P5, W3);
        pointPrecomputes.delete(P5);
      }
      hasCache(elm) {
        return getW(elm) !== 1;
      }
    };
    exports.wNAF = wNAF;
    function mulEndoUnsafe(Point, point, k1, k22) {
      let acc = point;
      let p1 = Point.ZERO;
      let p22 = Point.ZERO;
      while (k1 > _0n || k22 > _0n) {
        if (k1 & _1n)
          p1 = p1.add(acc);
        if (k22 & _1n)
          p22 = p22.add(acc);
        acc = acc.double();
        k1 >>= _1n;
        k22 >>= _1n;
      }
      return { p1, p2: p22 };
    }
    function pippenger(c3, fieldN, points, scalars) {
      validateMSMPoints(points, c3);
      validateMSMScalars(scalars, fieldN);
      const plength = points.length;
      const slength = scalars.length;
      if (plength !== slength)
        throw new Error("arrays of points and scalars must have equal length");
      const zero = c3.ZERO;
      const wbits = (0, utils_ts_1.bitLen)(BigInt(plength));
      let windowSize = 1;
      if (wbits > 12)
        windowSize = wbits - 3;
      else if (wbits > 4)
        windowSize = wbits - 2;
      else if (wbits > 0)
        windowSize = 2;
      const MASK = (0, utils_ts_1.bitMask)(windowSize);
      const buckets = new Array(Number(MASK) + 1).fill(zero);
      const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
      let sum = zero;
      for (let i3 = lastBits; i3 >= 0; i3 -= windowSize) {
        buckets.fill(zero);
        for (let j3 = 0; j3 < slength; j3++) {
          const scalar = scalars[j3];
          const wbits2 = Number(scalar >> BigInt(i3) & MASK);
          buckets[wbits2] = buckets[wbits2].add(points[j3]);
        }
        let resI = zero;
        for (let j3 = buckets.length - 1, sumI = zero; j3 > 0; j3--) {
          sumI = sumI.add(buckets[j3]);
          resI = resI.add(sumI);
        }
        sum = sum.add(resI);
        if (i3 !== 0)
          for (let j3 = 0; j3 < windowSize; j3++)
            sum = sum.double();
      }
      return sum;
    }
    function precomputeMSMUnsafe(c3, fieldN, points, windowSize) {
      validateW(windowSize, fieldN.BITS);
      validateMSMPoints(points, c3);
      const zero = c3.ZERO;
      const tableSize = 2 ** windowSize - 1;
      const chunks = Math.ceil(fieldN.BITS / windowSize);
      const MASK = (0, utils_ts_1.bitMask)(windowSize);
      const tables = points.map((p4) => {
        const res = [];
        for (let i3 = 0, acc = p4; i3 < tableSize; i3++) {
          res.push(acc);
          acc = acc.add(p4);
        }
        return res;
      });
      return (scalars) => {
        validateMSMScalars(scalars, fieldN);
        if (scalars.length > points.length)
          throw new Error("array of scalars must be smaller than array of points");
        let res = zero;
        for (let i3 = 0; i3 < chunks; i3++) {
          if (res !== zero)
            for (let j3 = 0; j3 < windowSize; j3++)
              res = res.double();
          const shiftBy = BigInt(chunks * windowSize - (i3 + 1) * windowSize);
          for (let j3 = 0; j3 < scalars.length; j3++) {
            const n2 = scalars[j3];
            const curr = Number(n2 >> shiftBy & MASK);
            if (!curr)
              continue;
            res = res.add(tables[j3][curr - 1]);
          }
        }
        return res;
      };
    }
    function validateBasic(curve) {
      (0, modular_ts_1.validateField)(curve.Fp);
      (0, utils_ts_1.validateObject)(curve, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
      }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
      });
      return Object.freeze({
        ...(0, modular_ts_1.nLength)(curve.n, curve.nBitLength),
        ...curve,
        ...{ p: curve.Fp.ORDER }
      });
    }
    function createField(order, field, isLE) {
      if (field) {
        if (field.ORDER !== order)
          throw new Error("Field.ORDER must match order: Fp == p, Fn == n");
        (0, modular_ts_1.validateField)(field);
        return field;
      } else {
        return (0, modular_ts_1.Field)(order, { isLE });
      }
    }
    function _createCurveFields(type, CURVE, curveOpts = {}, FpFnLE) {
      if (FpFnLE === void 0)
        FpFnLE = type === "edwards";
      if (!CURVE || typeof CURVE !== "object")
        throw new Error(`expected valid ${type} CURVE object`);
      for (const p4 of ["p", "n", "h"]) {
        const val = CURVE[p4];
        if (!(typeof val === "bigint" && val > _0n))
          throw new Error(`CURVE.${p4} must be positive bigint`);
      }
      const Fp = createField(CURVE.p, curveOpts.Fp, FpFnLE);
      const Fn3 = createField(CURVE.n, curveOpts.Fn, FpFnLE);
      const _b = type === "weierstrass" ? "b" : "d";
      const params = ["Gx", "Gy", "a", _b];
      for (const p4 of params) {
        if (!Fp.isValid(CURVE[p4]))
          throw new Error(`CURVE.${p4} must be valid field element of CURVE.Fp`);
      }
      CURVE = Object.freeze(Object.assign({}, CURVE));
      return { CURVE, Fp, Fn: Fn3 };
    }
  }
});

// node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/abstract/edwards.js
var require_edwards = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/abstract/edwards.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PrimeEdwardsPoint = void 0;
    exports.edwards = edwards;
    exports.eddsa = eddsa;
    exports.twistedEdwards = twistedEdwards;
    var utils_ts_1 = require_utils4();
    var curve_ts_1 = require_curve();
    var modular_ts_1 = require_modular();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _8n = BigInt(8);
    function isEdValidXY(Fp, CURVE, x3, y4) {
      const x22 = Fp.sqr(x3);
      const y22 = Fp.sqr(y4);
      const left = Fp.add(Fp.mul(CURVE.a, x22), y22);
      const right = Fp.add(Fp.ONE, Fp.mul(CURVE.d, Fp.mul(x22, y22)));
      return Fp.eql(left, right);
    }
    function edwards(params, extraOpts = {}) {
      const validated = (0, curve_ts_1._createCurveFields)("edwards", params, extraOpts, extraOpts.FpFnLE);
      const { Fp, Fn: Fn3 } = validated;
      let CURVE = validated.CURVE;
      const { h: cofactor } = CURVE;
      (0, utils_ts_1._validateObject)(extraOpts, {}, { uvRatio: "function" });
      const MASK = _2n << BigInt(Fn3.BYTES * 8) - _1n;
      const modP = (n2) => Fp.create(n2);
      const uvRatio = extraOpts.uvRatio || ((u4, v9) => {
        try {
          return { isValid: true, value: Fp.sqrt(Fp.div(u4, v9)) };
        } catch (e) {
          return { isValid: false, value: _0n };
        }
      });
      if (!isEdValidXY(Fp, CURVE, CURVE.Gx, CURVE.Gy))
        throw new Error("bad curve params: generator point");
      function acoord(title, n2, banZero = false) {
        const min = banZero ? _1n : _0n;
        (0, utils_ts_1.aInRange)("coordinate " + title, n2, min, MASK);
        return n2;
      }
      function aextpoint(other) {
        if (!(other instanceof Point))
          throw new Error("ExtendedPoint expected");
      }
      const toAffineMemo = (0, utils_ts_1.memoized)((p4, iz) => {
        const { X: X3, Y: Y6, Z: Z3 } = p4;
        const is0 = p4.is0();
        if (iz == null)
          iz = is0 ? _8n : Fp.inv(Z3);
        const x3 = modP(X3 * iz);
        const y4 = modP(Y6 * iz);
        const zz = Fp.mul(Z3, iz);
        if (is0)
          return { x: _0n, y: _1n };
        if (zz !== _1n)
          throw new Error("invZ was invalid");
        return { x: x3, y: y4 };
      });
      const assertValidMemo = (0, utils_ts_1.memoized)((p4) => {
        const { a: a2, d: d3 } = CURVE;
        if (p4.is0())
          throw new Error("bad point: ZERO");
        const { X: X3, Y: Y6, Z: Z3, T: T4 } = p4;
        const X22 = modP(X3 * X3);
        const Y22 = modP(Y6 * Y6);
        const Z22 = modP(Z3 * Z3);
        const Z4 = modP(Z22 * Z22);
        const aX2 = modP(X22 * a2);
        const left = modP(Z22 * modP(aX2 + Y22));
        const right = modP(Z4 + modP(d3 * modP(X22 * Y22)));
        if (left !== right)
          throw new Error("bad point: equation left != right (1)");
        const XY = modP(X3 * Y6);
        const ZT = modP(Z3 * T4);
        if (XY !== ZT)
          throw new Error("bad point: equation left != right (2)");
        return true;
      });
      class Point {
        constructor(X3, Y6, Z3, T4) {
          this.X = acoord("x", X3);
          this.Y = acoord("y", Y6);
          this.Z = acoord("z", Z3, true);
          this.T = acoord("t", T4);
          Object.freeze(this);
        }
        static CURVE() {
          return CURVE;
        }
        static fromAffine(p4) {
          if (p4 instanceof Point)
            throw new Error("extended point not allowed");
          const { x: x3, y: y4 } = p4 || {};
          acoord("x", x3);
          acoord("y", y4);
          return new Point(x3, y4, _1n, modP(x3 * y4));
        }
        // Uses algo from RFC8032 5.1.3.
        static fromBytes(bytes2, zip215 = false) {
          const len = Fp.BYTES;
          const { a: a2, d: d3 } = CURVE;
          bytes2 = (0, utils_ts_1.copyBytes)((0, utils_ts_1._abytes2)(bytes2, len, "point"));
          (0, utils_ts_1._abool2)(zip215, "zip215");
          const normed = (0, utils_ts_1.copyBytes)(bytes2);
          const lastByte = bytes2[len - 1];
          normed[len - 1] = lastByte & ~128;
          const y4 = (0, utils_ts_1.bytesToNumberLE)(normed);
          const max = zip215 ? MASK : Fp.ORDER;
          (0, utils_ts_1.aInRange)("point.y", y4, _0n, max);
          const y22 = modP(y4 * y4);
          const u4 = modP(y22 - _1n);
          const v9 = modP(d3 * y22 - a2);
          let { isValid, value: x3 } = uvRatio(u4, v9);
          if (!isValid)
            throw new Error("bad point: invalid y coordinate");
          const isXOdd = (x3 & _1n) === _1n;
          const isLastByteOdd = (lastByte & 128) !== 0;
          if (!zip215 && x3 === _0n && isLastByteOdd)
            throw new Error("bad point: x=0 and x_0=1");
          if (isLastByteOdd !== isXOdd)
            x3 = modP(-x3);
          return Point.fromAffine({ x: x3, y: y4 });
        }
        static fromHex(bytes2, zip215 = false) {
          return Point.fromBytes((0, utils_ts_1.ensureBytes)("point", bytes2), zip215);
        }
        get x() {
          return this.toAffine().x;
        }
        get y() {
          return this.toAffine().y;
        }
        precompute(windowSize = 8, isLazy = true) {
          wnaf.createCache(this, windowSize);
          if (!isLazy)
            this.multiply(_2n);
          return this;
        }
        // Useful in fromAffine() - not for fromBytes(), which always created valid points.
        assertValidity() {
          assertValidMemo(this);
        }
        // Compare one point to another.
        equals(other) {
          aextpoint(other);
          const { X: X1, Y: Y1, Z: Z1 } = this;
          const { X: X22, Y: Y22, Z: Z22 } = other;
          const X1Z2 = modP(X1 * Z22);
          const X2Z1 = modP(X22 * Z1);
          const Y1Z2 = modP(Y1 * Z22);
          const Y2Z1 = modP(Y22 * Z1);
          return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
        }
        is0() {
          return this.equals(Point.ZERO);
        }
        negate() {
          return new Point(modP(-this.X), this.Y, this.Z, modP(-this.T));
        }
        // Fast algo for doubling Extended Point.
        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
        // Cost: 4M + 4S + 1*a + 6add + 1*2.
        double() {
          const { a: a2 } = CURVE;
          const { X: X1, Y: Y1, Z: Z1 } = this;
          const A5 = modP(X1 * X1);
          const B4 = modP(Y1 * Y1);
          const C5 = modP(_2n * modP(Z1 * Z1));
          const D3 = modP(a2 * A5);
          const x1y1 = X1 + Y1;
          const E5 = modP(modP(x1y1 * x1y1) - A5 - B4);
          const G6 = D3 + B4;
          const F6 = G6 - C5;
          const H3 = D3 - B4;
          const X3 = modP(E5 * F6);
          const Y32 = modP(G6 * H3);
          const T32 = modP(E5 * H3);
          const Z3 = modP(F6 * G6);
          return new Point(X3, Y32, Z3, T32);
        }
        // Fast algo for adding 2 Extended Points.
        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
        // Cost: 9M + 1*a + 1*d + 7add.
        add(other) {
          aextpoint(other);
          const { a: a2, d: d3 } = CURVE;
          const { X: X1, Y: Y1, Z: Z1, T: T1 } = this;
          const { X: X22, Y: Y22, Z: Z22, T: T22 } = other;
          const A5 = modP(X1 * X22);
          const B4 = modP(Y1 * Y22);
          const C5 = modP(T1 * d3 * T22);
          const D3 = modP(Z1 * Z22);
          const E5 = modP((X1 + Y1) * (X22 + Y22) - A5 - B4);
          const F6 = D3 - C5;
          const G6 = D3 + C5;
          const H3 = modP(B4 - a2 * A5);
          const X3 = modP(E5 * F6);
          const Y32 = modP(G6 * H3);
          const T32 = modP(E5 * H3);
          const Z3 = modP(F6 * G6);
          return new Point(X3, Y32, Z3, T32);
        }
        subtract(other) {
          return this.add(other.negate());
        }
        // Constant-time multiplication.
        multiply(scalar) {
          if (!Fn3.isValidNot0(scalar))
            throw new Error("invalid scalar: expected 1 <= sc < curve.n");
          const { p: p4, f: f6 } = wnaf.cached(this, scalar, (p5) => (0, curve_ts_1.normalizeZ)(Point, p5));
          return (0, curve_ts_1.normalizeZ)(Point, [p4, f6])[0];
        }
        // Non-constant-time multiplication. Uses double-and-add algorithm.
        // It's faster, but should only be used when you don't care about
        // an exposed private key e.g. sig verification.
        // Does NOT allow scalars higher than CURVE.n.
        // Accepts optional accumulator to merge with multiply (important for sparse scalars)
        multiplyUnsafe(scalar, acc = Point.ZERO) {
          if (!Fn3.isValid(scalar))
            throw new Error("invalid scalar: expected 0 <= sc < curve.n");
          if (scalar === _0n)
            return Point.ZERO;
          if (this.is0() || scalar === _1n)
            return this;
          return wnaf.unsafe(this, scalar, (p4) => (0, curve_ts_1.normalizeZ)(Point, p4), acc);
        }
        // Checks if point is of small order.
        // If you add something to small order point, you will have "dirty"
        // point with torsion component.
        // Multiplies point by cofactor and checks if the result is 0.
        isSmallOrder() {
          return this.multiplyUnsafe(cofactor).is0();
        }
        // Multiplies point by curve order and checks if the result is 0.
        // Returns `false` is the point is dirty.
        isTorsionFree() {
          return wnaf.unsafe(this, CURVE.n).is0();
        }
        // Converts Extended point to default (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        toAffine(invertedZ) {
          return toAffineMemo(this, invertedZ);
        }
        clearCofactor() {
          if (cofactor === _1n)
            return this;
          return this.multiplyUnsafe(cofactor);
        }
        toBytes() {
          const { x: x3, y: y4 } = this.toAffine();
          const bytes2 = Fp.toBytes(y4);
          bytes2[bytes2.length - 1] |= x3 & _1n ? 128 : 0;
          return bytes2;
        }
        toHex() {
          return (0, utils_ts_1.bytesToHex)(this.toBytes());
        }
        toString() {
          return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
        }
        // TODO: remove
        get ex() {
          return this.X;
        }
        get ey() {
          return this.Y;
        }
        get ez() {
          return this.Z;
        }
        get et() {
          return this.T;
        }
        static normalizeZ(points) {
          return (0, curve_ts_1.normalizeZ)(Point, points);
        }
        static msm(points, scalars) {
          return (0, curve_ts_1.pippenger)(Point, Fn3, points, scalars);
        }
        _setWindowSize(windowSize) {
          this.precompute(windowSize);
        }
        toRawBytes() {
          return this.toBytes();
        }
      }
      Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));
      Point.ZERO = new Point(_0n, _1n, _1n, _0n);
      Point.Fp = Fp;
      Point.Fn = Fn3;
      const wnaf = new curve_ts_1.wNAF(Point, Fn3.BITS);
      Point.BASE.precompute(8);
      return Point;
    }
    var PrimeEdwardsPoint = class {
      constructor(ep) {
        this.ep = ep;
      }
      // Static methods that must be implemented by subclasses
      static fromBytes(_bytes) {
        (0, utils_ts_1.notImplemented)();
      }
      static fromHex(_hex) {
        (0, utils_ts_1.notImplemented)();
      }
      get x() {
        return this.toAffine().x;
      }
      get y() {
        return this.toAffine().y;
      }
      // Common implementations
      clearCofactor() {
        return this;
      }
      assertValidity() {
        this.ep.assertValidity();
      }
      toAffine(invertedZ) {
        return this.ep.toAffine(invertedZ);
      }
      toHex() {
        return (0, utils_ts_1.bytesToHex)(this.toBytes());
      }
      toString() {
        return this.toHex();
      }
      isTorsionFree() {
        return true;
      }
      isSmallOrder() {
        return false;
      }
      add(other) {
        this.assertSame(other);
        return this.init(this.ep.add(other.ep));
      }
      subtract(other) {
        this.assertSame(other);
        return this.init(this.ep.subtract(other.ep));
      }
      multiply(scalar) {
        return this.init(this.ep.multiply(scalar));
      }
      multiplyUnsafe(scalar) {
        return this.init(this.ep.multiplyUnsafe(scalar));
      }
      double() {
        return this.init(this.ep.double());
      }
      negate() {
        return this.init(this.ep.negate());
      }
      precompute(windowSize, isLazy) {
        return this.init(this.ep.precompute(windowSize, isLazy));
      }
      /** @deprecated use `toBytes` */
      toRawBytes() {
        return this.toBytes();
      }
    };
    exports.PrimeEdwardsPoint = PrimeEdwardsPoint;
    function eddsa(Point, cHash, eddsaOpts = {}) {
      if (typeof cHash !== "function")
        throw new Error('"hash" function param is required');
      (0, utils_ts_1._validateObject)(eddsaOpts, {}, {
        adjustScalarBytes: "function",
        randomBytes: "function",
        domain: "function",
        prehash: "function",
        mapToCurve: "function"
      });
      const { prehash } = eddsaOpts;
      const { BASE, Fp, Fn: Fn3 } = Point;
      const randomBytes = eddsaOpts.randomBytes || utils_ts_1.randomBytes;
      const adjustScalarBytes = eddsaOpts.adjustScalarBytes || ((bytes2) => bytes2);
      const domain = eddsaOpts.domain || ((data2, ctx, phflag) => {
        (0, utils_ts_1._abool2)(phflag, "phflag");
        if (ctx.length || phflag)
          throw new Error("Contexts/pre-hash are not supported");
        return data2;
      });
      function modN_LE(hash2) {
        return Fn3.create((0, utils_ts_1.bytesToNumberLE)(hash2));
      }
      function getPrivateScalar(key) {
        const len = lengths.secretKey;
        key = (0, utils_ts_1.ensureBytes)("private key", key, len);
        const hashed = (0, utils_ts_1.ensureBytes)("hashed private key", cHash(key), 2 * len);
        const head = adjustScalarBytes(hashed.slice(0, len));
        const prefix = hashed.slice(len, 2 * len);
        const scalar = modN_LE(head);
        return { head, prefix, scalar };
      }
      function getExtendedPublicKey(secretKey) {
        const { head, prefix, scalar } = getPrivateScalar(secretKey);
        const point = BASE.multiply(scalar);
        const pointBytes = point.toBytes();
        return { head, prefix, scalar, point, pointBytes };
      }
      function getPublicKey(secretKey) {
        return getExtendedPublicKey(secretKey).pointBytes;
      }
      function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {
        const msg = (0, utils_ts_1.concatBytes)(...msgs);
        return modN_LE(cHash(domain(msg, (0, utils_ts_1.ensureBytes)("context", context), !!prehash)));
      }
      function sign2(msg, secretKey, options = {}) {
        msg = (0, utils_ts_1.ensureBytes)("message", msg);
        if (prehash)
          msg = prehash(msg);
        const { prefix, scalar, pointBytes } = getExtendedPublicKey(secretKey);
        const r2 = hashDomainToScalar(options.context, prefix, msg);
        const R6 = BASE.multiply(r2).toBytes();
        const k5 = hashDomainToScalar(options.context, R6, pointBytes, msg);
        const s2 = Fn3.create(r2 + k5 * scalar);
        if (!Fn3.isValid(s2))
          throw new Error("sign failed: invalid s");
        const rs2 = (0, utils_ts_1.concatBytes)(R6, Fn3.toBytes(s2));
        return (0, utils_ts_1._abytes2)(rs2, lengths.signature, "result");
      }
      const verifyOpts = { zip215: true };
      function verify(sig, msg, publicKey, options = verifyOpts) {
        const { context, zip215 } = options;
        const len = lengths.signature;
        sig = (0, utils_ts_1.ensureBytes)("signature", sig, len);
        msg = (0, utils_ts_1.ensureBytes)("message", msg);
        publicKey = (0, utils_ts_1.ensureBytes)("publicKey", publicKey, lengths.publicKey);
        if (zip215 !== void 0)
          (0, utils_ts_1._abool2)(zip215, "zip215");
        if (prehash)
          msg = prehash(msg);
        const mid = len / 2;
        const r2 = sig.subarray(0, mid);
        const s2 = (0, utils_ts_1.bytesToNumberLE)(sig.subarray(mid, len));
        let A5, R6, SB;
        try {
          A5 = Point.fromBytes(publicKey, zip215);
          R6 = Point.fromBytes(r2, zip215);
          SB = BASE.multiplyUnsafe(s2);
        } catch (error) {
          return false;
        }
        if (!zip215 && A5.isSmallOrder())
          return false;
        const k5 = hashDomainToScalar(context, R6.toBytes(), A5.toBytes(), msg);
        const RkA = R6.add(A5.multiplyUnsafe(k5));
        return RkA.subtract(SB).clearCofactor().is0();
      }
      const _size = Fp.BYTES;
      const lengths = {
        secretKey: _size,
        publicKey: _size,
        signature: 2 * _size,
        seed: _size
      };
      function randomSecretKey(seed = randomBytes(lengths.seed)) {
        return (0, utils_ts_1._abytes2)(seed, lengths.seed, "seed");
      }
      function keygen(seed) {
        const secretKey = utils2.randomSecretKey(seed);
        return { secretKey, publicKey: getPublicKey(secretKey) };
      }
      function isValidSecretKey(key) {
        return (0, utils_ts_1.isBytes)(key) && key.length === Fn3.BYTES;
      }
      function isValidPublicKey(key, zip215) {
        try {
          return !!Point.fromBytes(key, zip215);
        } catch (error) {
          return false;
        }
      }
      const utils2 = {
        getExtendedPublicKey,
        randomSecretKey,
        isValidSecretKey,
        isValidPublicKey,
        /**
         * Converts ed public key to x public key. Uses formula:
         * - ed25519:
         *   - `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`
         *   - `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`
         * - ed448:
         *   - `(u, v) = ((y-1)/(y+1), sqrt(156324)*u/x)`
         *   - `(x, y) = (sqrt(156324)*u/v, (1+u)/(1-u))`
         */
        toMontgomery(publicKey) {
          const { y: y4 } = Point.fromBytes(publicKey);
          const size = lengths.publicKey;
          const is25519 = size === 32;
          if (!is25519 && size !== 57)
            throw new Error("only defined for 25519 and 448");
          const u4 = is25519 ? Fp.div(_1n + y4, _1n - y4) : Fp.div(y4 - _1n, y4 + _1n);
          return Fp.toBytes(u4);
        },
        toMontgomerySecret(secretKey) {
          const size = lengths.secretKey;
          (0, utils_ts_1._abytes2)(secretKey, size);
          const hashed = cHash(secretKey.subarray(0, size));
          return adjustScalarBytes(hashed).subarray(0, size);
        },
        /** @deprecated */
        randomPrivateKey: randomSecretKey,
        /** @deprecated */
        precompute(windowSize = 8, point = Point.BASE) {
          return point.precompute(windowSize, false);
        }
      };
      return Object.freeze({
        keygen,
        getPublicKey,
        sign: sign2,
        verify,
        utils: utils2,
        Point,
        lengths
      });
    }
    function _eddsa_legacy_opts_to_new(c3) {
      const CURVE = {
        a: c3.a,
        d: c3.d,
        p: c3.Fp.ORDER,
        n: c3.n,
        h: c3.h,
        Gx: c3.Gx,
        Gy: c3.Gy
      };
      const Fp = c3.Fp;
      const Fn3 = (0, modular_ts_1.Field)(CURVE.n, c3.nBitLength, true);
      const curveOpts = { Fp, Fn: Fn3, uvRatio: c3.uvRatio };
      const eddsaOpts = {
        randomBytes: c3.randomBytes,
        adjustScalarBytes: c3.adjustScalarBytes,
        domain: c3.domain,
        prehash: c3.prehash,
        mapToCurve: c3.mapToCurve
      };
      return { CURVE, curveOpts, hash: c3.hash, eddsaOpts };
    }
    function _eddsa_new_output_to_legacy(c3, eddsa2) {
      const Point = eddsa2.Point;
      const legacy = Object.assign({}, eddsa2, {
        ExtendedPoint: Point,
        CURVE: c3,
        nBitLength: Point.Fn.BITS,
        nByteLength: Point.Fn.BYTES
      });
      return legacy;
    }
    function twistedEdwards(c3) {
      const { CURVE, curveOpts, hash: hash2, eddsaOpts } = _eddsa_legacy_opts_to_new(c3);
      const Point = edwards(CURVE, curveOpts);
      const EDDSA = eddsa(Point, hash2, eddsaOpts);
      return _eddsa_new_output_to_legacy(c3, EDDSA);
    }
  }
});

// node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/abstract/hash-to-curve.js
var require_hash_to_curve = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/abstract/hash-to-curve.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._DST_scalar = void 0;
    exports.expand_message_xmd = expand_message_xmd;
    exports.expand_message_xof = expand_message_xof;
    exports.hash_to_field = hash_to_field;
    exports.isogenyMap = isogenyMap;
    exports.createHasher = createHasher;
    var utils_ts_1 = require_utils4();
    var modular_ts_1 = require_modular();
    var os2ip = utils_ts_1.bytesToNumberBE;
    function i2osp(value, length) {
      anum(value);
      anum(length);
      if (value < 0 || value >= 1 << 8 * length)
        throw new Error("invalid I2OSP input: " + value);
      const res = Array.from({ length }).fill(0);
      for (let i3 = length - 1; i3 >= 0; i3--) {
        res[i3] = value & 255;
        value >>>= 8;
      }
      return new Uint8Array(res);
    }
    function strxor(a2, b5) {
      const arr = new Uint8Array(a2.length);
      for (let i3 = 0; i3 < a2.length; i3++) {
        arr[i3] = a2[i3] ^ b5[i3];
      }
      return arr;
    }
    function anum(item) {
      if (!Number.isSafeInteger(item))
        throw new Error("number expected");
    }
    function normDST(DST) {
      if (!(0, utils_ts_1.isBytes)(DST) && typeof DST !== "string")
        throw new Error("DST must be Uint8Array or string");
      return typeof DST === "string" ? (0, utils_ts_1.utf8ToBytes)(DST) : DST;
    }
    function expand_message_xmd(msg, DST, lenInBytes, H3) {
      (0, utils_ts_1.abytes)(msg);
      anum(lenInBytes);
      DST = normDST(DST);
      if (DST.length > 255)
        DST = H3((0, utils_ts_1.concatBytes)((0, utils_ts_1.utf8ToBytes)("H2C-OVERSIZE-DST-"), DST));
      const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H3;
      const ell = Math.ceil(lenInBytes / b_in_bytes);
      if (lenInBytes > 65535 || ell > 255)
        throw new Error("expand_message_xmd: invalid lenInBytes");
      const DST_prime = (0, utils_ts_1.concatBytes)(DST, i2osp(DST.length, 1));
      const Z_pad = i2osp(0, r_in_bytes);
      const l_i_b_str = i2osp(lenInBytes, 2);
      const b5 = new Array(ell);
      const b_0 = H3((0, utils_ts_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
      b5[0] = H3((0, utils_ts_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
      for (let i3 = 1; i3 <= ell; i3++) {
        const args = [strxor(b_0, b5[i3 - 1]), i2osp(i3 + 1, 1), DST_prime];
        b5[i3] = H3((0, utils_ts_1.concatBytes)(...args));
      }
      const pseudo_random_bytes = (0, utils_ts_1.concatBytes)(...b5);
      return pseudo_random_bytes.slice(0, lenInBytes);
    }
    function expand_message_xof(msg, DST, lenInBytes, k5, H3) {
      (0, utils_ts_1.abytes)(msg);
      anum(lenInBytes);
      DST = normDST(DST);
      if (DST.length > 255) {
        const dkLen = Math.ceil(2 * k5 / 8);
        DST = H3.create({ dkLen }).update((0, utils_ts_1.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(DST).digest();
      }
      if (lenInBytes > 65535 || DST.length > 255)
        throw new Error("expand_message_xof: invalid lenInBytes");
      return H3.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
    }
    function hash_to_field(msg, count, options) {
      (0, utils_ts_1._validateObject)(options, {
        p: "bigint",
        m: "number",
        k: "number",
        hash: "function"
      });
      const { p: p4, k: k5, m: m3, hash: hash2, expand, DST } = options;
      if (!(0, utils_ts_1.isHash)(options.hash))
        throw new Error("expected valid hash");
      (0, utils_ts_1.abytes)(msg);
      anum(count);
      const log2p = p4.toString(2).length;
      const L3 = Math.ceil((log2p + k5) / 8);
      const len_in_bytes = count * m3 * L3;
      let prb;
      if (expand === "xmd") {
        prb = expand_message_xmd(msg, DST, len_in_bytes, hash2);
      } else if (expand === "xof") {
        prb = expand_message_xof(msg, DST, len_in_bytes, k5, hash2);
      } else if (expand === "_internal_pass") {
        prb = msg;
      } else {
        throw new Error('expand must be "xmd" or "xof"');
      }
      const u4 = new Array(count);
      for (let i3 = 0; i3 < count; i3++) {
        const e = new Array(m3);
        for (let j3 = 0; j3 < m3; j3++) {
          const elm_offset = L3 * (j3 + i3 * m3);
          const tv = prb.subarray(elm_offset, elm_offset + L3);
          e[j3] = (0, modular_ts_1.mod)(os2ip(tv), p4);
        }
        u4[i3] = e;
      }
      return u4;
    }
    function isogenyMap(field, map) {
      const coeff = map.map((i3) => Array.from(i3).reverse());
      return (x3, y4) => {
        const [xn3, xd, yn3, yd] = coeff.map((val) => val.reduce((acc, i3) => field.add(field.mul(acc, x3), i3)));
        const [xd_inv, yd_inv] = (0, modular_ts_1.FpInvertBatch)(field, [xd, yd], true);
        x3 = field.mul(xn3, xd_inv);
        y4 = field.mul(y4, field.mul(yn3, yd_inv));
        return { x: x3, y: y4 };
      };
    }
    exports._DST_scalar = (0, utils_ts_1.utf8ToBytes)("HashToScalar-");
    function createHasher(Point, mapToCurve, defaults) {
      if (typeof mapToCurve !== "function")
        throw new Error("mapToCurve() must be defined");
      function map(num) {
        return Point.fromAffine(mapToCurve(num));
      }
      function clear(initial) {
        const P5 = initial.clearCofactor();
        if (P5.equals(Point.ZERO))
          return Point.ZERO;
        P5.assertValidity();
        return P5;
      }
      return {
        defaults,
        hashToCurve(msg, options) {
          const opts = Object.assign({}, defaults, options);
          const u4 = hash_to_field(msg, 2, opts);
          const u0 = map(u4[0]);
          const u1 = map(u4[1]);
          return clear(u0.add(u1));
        },
        encodeToCurve(msg, options) {
          const optsDst = defaults.encodeDST ? { DST: defaults.encodeDST } : {};
          const opts = Object.assign({}, defaults, optsDst, options);
          const u4 = hash_to_field(msg, 1, opts);
          const u0 = map(u4[0]);
          return clear(u0);
        },
        /** See {@link H2CHasher} */
        mapToCurve(scalars) {
          if (!Array.isArray(scalars))
            throw new Error("expected array of bigints");
          for (const i3 of scalars)
            if (typeof i3 !== "bigint")
              throw new Error("expected array of bigints");
          return clear(map(scalars));
        },
        // hash_to_scalar can produce 0: https://www.rfc-editor.org/errata/eid8393
        // RFC 9380, draft-irtf-cfrg-bbs-signatures-08
        hashToScalar(msg, options) {
          const N2 = Point.Fn.ORDER;
          const opts = Object.assign({}, defaults, { p: N2, m: 1, DST: exports._DST_scalar }, options);
          return hash_to_field(msg, 1, opts)[0][0];
        }
      };
    }
  }
});

// node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/abstract/montgomery.js
var require_montgomery = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/abstract/montgomery.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.montgomery = montgomery;
    var utils_ts_1 = require_utils4();
    var modular_ts_1 = require_modular();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    function validateOpts(curve) {
      (0, utils_ts_1._validateObject)(curve, {
        adjustScalarBytes: "function",
        powPminus2: "function"
      });
      return Object.freeze({ ...curve });
    }
    function montgomery(curveDef) {
      const CURVE = validateOpts(curveDef);
      const { P: P5, type, adjustScalarBytes, powPminus2, randomBytes: rand } = CURVE;
      const is25519 = type === "x25519";
      if (!is25519 && type !== "x448")
        throw new Error("invalid type");
      const randomBytes_ = rand || utils_ts_1.randomBytes;
      const montgomeryBits = is25519 ? 255 : 448;
      const fieldLen = is25519 ? 32 : 56;
      const Gu = is25519 ? BigInt(9) : BigInt(5);
      const a24 = is25519 ? BigInt(121665) : BigInt(39081);
      const minScalar = is25519 ? _2n ** BigInt(254) : _2n ** BigInt(447);
      const maxAdded = is25519 ? BigInt(8) * _2n ** BigInt(251) - _1n : BigInt(4) * _2n ** BigInt(445) - _1n;
      const maxScalar = minScalar + maxAdded + _1n;
      const modP = (n2) => (0, modular_ts_1.mod)(n2, P5);
      const GuBytes = encodeU(Gu);
      function encodeU(u4) {
        return (0, utils_ts_1.numberToBytesLE)(modP(u4), fieldLen);
      }
      function decodeU(u4) {
        const _u = (0, utils_ts_1.ensureBytes)("u coordinate", u4, fieldLen);
        if (is25519)
          _u[31] &= 127;
        return modP((0, utils_ts_1.bytesToNumberLE)(_u));
      }
      function decodeScalar(scalar) {
        return (0, utils_ts_1.bytesToNumberLE)(adjustScalarBytes((0, utils_ts_1.ensureBytes)("scalar", scalar, fieldLen)));
      }
      function scalarMult(scalar, u4) {
        const pu = montgomeryLadder(decodeU(u4), decodeScalar(scalar));
        if (pu === _0n)
          throw new Error("invalid private or public key received");
        return encodeU(pu);
      }
      function scalarMultBase(scalar) {
        return scalarMult(scalar, GuBytes);
      }
      function cswap(swap, x_2, x_3) {
        const dummy = modP(swap * (x_2 - x_3));
        x_2 = modP(x_2 - dummy);
        x_3 = modP(x_3 + dummy);
        return { x_2, x_3 };
      }
      function montgomeryLadder(u4, scalar) {
        (0, utils_ts_1.aInRange)("u", u4, _0n, P5);
        (0, utils_ts_1.aInRange)("scalar", scalar, minScalar, maxScalar);
        const k5 = scalar;
        const x_1 = u4;
        let x_2 = _1n;
        let z_2 = _0n;
        let x_3 = u4;
        let z_3 = _1n;
        let swap = _0n;
        for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {
          const k_t = k5 >> t & _1n;
          swap ^= k_t;
          ({ x_2, x_3 } = cswap(swap, x_2, x_3));
          ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
          swap = k_t;
          const A5 = x_2 + z_2;
          const AA = modP(A5 * A5);
          const B4 = x_2 - z_2;
          const BB = modP(B4 * B4);
          const E5 = AA - BB;
          const C5 = x_3 + z_3;
          const D3 = x_3 - z_3;
          const DA = modP(D3 * A5);
          const CB = modP(C5 * B4);
          const dacb = DA + CB;
          const da_cb = DA - CB;
          x_3 = modP(dacb * dacb);
          z_3 = modP(x_1 * modP(da_cb * da_cb));
          x_2 = modP(AA * BB);
          z_2 = modP(E5 * (AA + modP(a24 * E5)));
        }
        ({ x_2, x_3 } = cswap(swap, x_2, x_3));
        ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
        const z22 = powPminus2(z_2);
        return modP(x_2 * z22);
      }
      const lengths = {
        secretKey: fieldLen,
        publicKey: fieldLen,
        seed: fieldLen
      };
      const randomSecretKey = (seed = randomBytes_(fieldLen)) => {
        (0, utils_ts_1.abytes)(seed, lengths.seed);
        return seed;
      };
      function keygen(seed) {
        const secretKey = randomSecretKey(seed);
        return { secretKey, publicKey: scalarMultBase(secretKey) };
      }
      const utils2 = {
        randomSecretKey,
        randomPrivateKey: randomSecretKey
      };
      return {
        keygen,
        getSharedSecret: (secretKey, publicKey) => scalarMult(secretKey, publicKey),
        getPublicKey: (secretKey) => scalarMultBase(secretKey),
        scalarMult,
        scalarMultBase,
        utils: utils2,
        GuBytes: GuBytes.slice(),
        lengths
      };
    }
  }
});

// node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/ed25519.js
var require_ed25519 = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/ed25519.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hash_to_ristretto255 = exports.hashToRistretto255 = exports.encodeToCurve = exports.hashToCurve = exports.RistrettoPoint = exports.edwardsToMontgomery = exports.ED25519_TORSION_SUBGROUP = exports.ristretto255_hasher = exports.ristretto255 = exports.ed25519_hasher = exports.x25519 = exports.ed25519ph = exports.ed25519ctx = exports.ed25519 = void 0;
    exports.edwardsToMontgomeryPub = edwardsToMontgomeryPub;
    exports.edwardsToMontgomeryPriv = edwardsToMontgomeryPriv;
    var sha2_js_1 = require_sha2();
    var utils_js_1 = require_utils();
    var curve_ts_1 = require_curve();
    var edwards_ts_1 = require_edwards();
    var hash_to_curve_ts_1 = require_hash_to_curve();
    var modular_ts_1 = require_modular();
    var montgomery_ts_1 = require_montgomery();
    var utils_ts_1 = require_utils4();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _5n = BigInt(5);
    var _8n = BigInt(8);
    var ed25519_CURVE_p = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed");
    var ed25519_CURVE = (() => ({
      p: ed25519_CURVE_p,
      n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),
      h: _8n,
      a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),
      d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),
      Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),
      Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")
    }))();
    function ed25519_pow_2_252_3(x3) {
      const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
      const P5 = ed25519_CURVE_p;
      const x22 = x3 * x3 % P5;
      const b22 = x22 * x3 % P5;
      const b42 = (0, modular_ts_1.pow2)(b22, _2n, P5) * b22 % P5;
      const b5 = (0, modular_ts_1.pow2)(b42, _1n, P5) * x3 % P5;
      const b10 = (0, modular_ts_1.pow2)(b5, _5n, P5) * b5 % P5;
      const b20 = (0, modular_ts_1.pow2)(b10, _10n, P5) * b10 % P5;
      const b40 = (0, modular_ts_1.pow2)(b20, _20n, P5) * b20 % P5;
      const b80 = (0, modular_ts_1.pow2)(b40, _40n, P5) * b40 % P5;
      const b160 = (0, modular_ts_1.pow2)(b80, _80n, P5) * b80 % P5;
      const b240 = (0, modular_ts_1.pow2)(b160, _80n, P5) * b80 % P5;
      const b250 = (0, modular_ts_1.pow2)(b240, _10n, P5) * b10 % P5;
      const pow_p_5_8 = (0, modular_ts_1.pow2)(b250, _2n, P5) * x3 % P5;
      return { pow_p_5_8, b2: b22 };
    }
    function adjustScalarBytes(bytes2) {
      bytes2[0] &= 248;
      bytes2[31] &= 127;
      bytes2[31] |= 64;
      return bytes2;
    }
    var ED25519_SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
    function uvRatio(u4, v9) {
      const P5 = ed25519_CURVE_p;
      const v32 = (0, modular_ts_1.mod)(v9 * v9 * v9, P5);
      const v72 = (0, modular_ts_1.mod)(v32 * v32 * v9, P5);
      const pow = ed25519_pow_2_252_3(u4 * v72).pow_p_5_8;
      let x3 = (0, modular_ts_1.mod)(u4 * v32 * pow, P5);
      const vx2 = (0, modular_ts_1.mod)(v9 * x3 * x3, P5);
      const root1 = x3;
      const root2 = (0, modular_ts_1.mod)(x3 * ED25519_SQRT_M1, P5);
      const useRoot1 = vx2 === u4;
      const useRoot2 = vx2 === (0, modular_ts_1.mod)(-u4, P5);
      const noRoot = vx2 === (0, modular_ts_1.mod)(-u4 * ED25519_SQRT_M1, P5);
      if (useRoot1)
        x3 = root1;
      if (useRoot2 || noRoot)
        x3 = root2;
      if ((0, modular_ts_1.isNegativeLE)(x3, P5))
        x3 = (0, modular_ts_1.mod)(-x3, P5);
      return { isValid: useRoot1 || useRoot2, value: x3 };
    }
    var Fp = (() => (0, modular_ts_1.Field)(ed25519_CURVE.p, { isLE: true }))();
    var Fn3 = (() => (0, modular_ts_1.Field)(ed25519_CURVE.n, { isLE: true }))();
    var ed25519Defaults = (() => ({
      ...ed25519_CURVE,
      Fp,
      hash: sha2_js_1.sha512,
      adjustScalarBytes,
      // dom2
      // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
      // Constant-time, u/√v
      uvRatio
    }))();
    exports.ed25519 = (() => (0, edwards_ts_1.twistedEdwards)(ed25519Defaults))();
    function ed25519_domain(data2, ctx, phflag) {
      if (ctx.length > 255)
        throw new Error("Context is too big");
      return (0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)("SigEd25519 no Ed25519 collisions"), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data2);
    }
    exports.ed25519ctx = (() => (0, edwards_ts_1.twistedEdwards)({
      ...ed25519Defaults,
      domain: ed25519_domain
    }))();
    exports.ed25519ph = (() => (0, edwards_ts_1.twistedEdwards)(Object.assign({}, ed25519Defaults, {
      domain: ed25519_domain,
      prehash: sha2_js_1.sha512
    })))();
    exports.x25519 = (() => {
      const P5 = Fp.ORDER;
      return (0, montgomery_ts_1.montgomery)({
        P: P5,
        type: "x25519",
        powPminus2: (x3) => {
          const { pow_p_5_8, b2: b22 } = ed25519_pow_2_252_3(x3);
          return (0, modular_ts_1.mod)((0, modular_ts_1.pow2)(pow_p_5_8, _3n, P5) * b22, P5);
        },
        adjustScalarBytes
      });
    })();
    var ELL2_C1 = (() => (ed25519_CURVE_p + _3n) / _8n)();
    var ELL2_C2 = (() => Fp.pow(_2n, ELL2_C1))();
    var ELL2_C3 = (() => Fp.sqrt(Fp.neg(Fp.ONE)))();
    function map_to_curve_elligator2_curve25519(u4) {
      const ELL2_C4 = (ed25519_CURVE_p - _5n) / _8n;
      const ELL2_J = BigInt(486662);
      let tv1 = Fp.sqr(u4);
      tv1 = Fp.mul(tv1, _2n);
      let xd = Fp.add(tv1, Fp.ONE);
      let x1n = Fp.neg(ELL2_J);
      let tv2 = Fp.sqr(xd);
      let gxd = Fp.mul(tv2, xd);
      let gx1 = Fp.mul(tv1, ELL2_J);
      gx1 = Fp.mul(gx1, x1n);
      gx1 = Fp.add(gx1, tv2);
      gx1 = Fp.mul(gx1, x1n);
      let tv3 = Fp.sqr(gxd);
      tv2 = Fp.sqr(tv3);
      tv3 = Fp.mul(tv3, gxd);
      tv3 = Fp.mul(tv3, gx1);
      tv2 = Fp.mul(tv2, tv3);
      let y11 = Fp.pow(tv2, ELL2_C4);
      y11 = Fp.mul(y11, tv3);
      let y12 = Fp.mul(y11, ELL2_C3);
      tv2 = Fp.sqr(y11);
      tv2 = Fp.mul(tv2, gxd);
      let e1 = Fp.eql(tv2, gx1);
      let y1 = Fp.cmov(y12, y11, e1);
      let x2n = Fp.mul(x1n, tv1);
      let y21 = Fp.mul(y11, u4);
      y21 = Fp.mul(y21, ELL2_C2);
      let y22 = Fp.mul(y21, ELL2_C3);
      let gx2 = Fp.mul(gx1, tv1);
      tv2 = Fp.sqr(y21);
      tv2 = Fp.mul(tv2, gxd);
      let e2 = Fp.eql(tv2, gx2);
      let y23 = Fp.cmov(y22, y21, e2);
      tv2 = Fp.sqr(y1);
      tv2 = Fp.mul(tv2, gxd);
      let e3 = Fp.eql(tv2, gx1);
      let xn3 = Fp.cmov(x2n, x1n, e3);
      let y4 = Fp.cmov(y23, y1, e3);
      let e4 = Fp.isOdd(y4);
      y4 = Fp.cmov(y4, Fp.neg(y4), e3 !== e4);
      return { xMn: xn3, xMd: xd, yMn: y4, yMd: _1n };
    }
    var ELL2_C1_EDWARDS = (() => (0, modular_ts_1.FpSqrtEven)(Fp, Fp.neg(BigInt(486664))))();
    function map_to_curve_elligator2_edwards25519(u4) {
      const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u4);
      let xn3 = Fp.mul(xMn, yMd);
      xn3 = Fp.mul(xn3, ELL2_C1_EDWARDS);
      let xd = Fp.mul(xMd, yMn);
      let yn3 = Fp.sub(xMn, xMd);
      let yd = Fp.add(xMn, xMd);
      let tv1 = Fp.mul(xd, yd);
      let e = Fp.eql(tv1, Fp.ZERO);
      xn3 = Fp.cmov(xn3, Fp.ZERO, e);
      xd = Fp.cmov(xd, Fp.ONE, e);
      yn3 = Fp.cmov(yn3, Fp.ONE, e);
      yd = Fp.cmov(yd, Fp.ONE, e);
      const [xd_inv, yd_inv] = (0, modular_ts_1.FpInvertBatch)(Fp, [xd, yd], true);
      return { x: Fp.mul(xn3, xd_inv), y: Fp.mul(yn3, yd_inv) };
    }
    exports.ed25519_hasher = (() => (0, hash_to_curve_ts_1.createHasher)(exports.ed25519.Point, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {
      DST: "edwards25519_XMD:SHA-512_ELL2_RO_",
      encodeDST: "edwards25519_XMD:SHA-512_ELL2_NU_",
      p: ed25519_CURVE_p,
      m: 1,
      k: 128,
      expand: "xmd",
      hash: sha2_js_1.sha512
    }))();
    var SQRT_M1 = ED25519_SQRT_M1;
    var SQRT_AD_MINUS_ONE = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
    var INVSQRT_A_MINUS_D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
    var ONE_MINUS_D_SQ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
    var D_MINUS_ONE_SQ = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
    var invertSqrt = (number) => uvRatio(_1n, number);
    var MAX_255B = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    var bytes255ToNumberLE = (bytes2) => exports.ed25519.Point.Fp.create((0, utils_ts_1.bytesToNumberLE)(bytes2) & MAX_255B);
    function calcElligatorRistrettoMap(r0) {
      const { d: d3 } = ed25519_CURVE;
      const P5 = ed25519_CURVE_p;
      const mod = (n2) => Fp.create(n2);
      const r2 = mod(SQRT_M1 * r0 * r0);
      const Ns3 = mod((r2 + _1n) * ONE_MINUS_D_SQ);
      let c3 = BigInt(-1);
      const D3 = mod((c3 - d3 * r2) * mod(r2 + d3));
      let { isValid: Ns_D_is_sq, value: s2 } = uvRatio(Ns3, D3);
      let s_ = mod(s2 * r0);
      if (!(0, modular_ts_1.isNegativeLE)(s_, P5))
        s_ = mod(-s_);
      if (!Ns_D_is_sq)
        s2 = s_;
      if (!Ns_D_is_sq)
        c3 = r2;
      const Nt3 = mod(c3 * (r2 - _1n) * D_MINUS_ONE_SQ - D3);
      const s22 = s2 * s2;
      const W0 = mod((s2 + s2) * D3);
      const W1 = mod(Nt3 * SQRT_AD_MINUS_ONE);
      const W22 = mod(_1n - s22);
      const W3 = mod(_1n + s22);
      return new exports.ed25519.Point(mod(W0 * W3), mod(W22 * W1), mod(W1 * W3), mod(W0 * W22));
    }
    function ristretto255_map(bytes2) {
      (0, utils_js_1.abytes)(bytes2, 64);
      const r1 = bytes255ToNumberLE(bytes2.subarray(0, 32));
      const R1 = calcElligatorRistrettoMap(r1);
      const r2 = bytes255ToNumberLE(bytes2.subarray(32, 64));
      const R22 = calcElligatorRistrettoMap(r2);
      return new _RistrettoPoint(R1.add(R22));
    }
    var _RistrettoPoint = class __RistrettoPoint extends edwards_ts_1.PrimeEdwardsPoint {
      constructor(ep) {
        super(ep);
      }
      static fromAffine(ap) {
        return new __RistrettoPoint(exports.ed25519.Point.fromAffine(ap));
      }
      assertSame(other) {
        if (!(other instanceof __RistrettoPoint))
          throw new Error("RistrettoPoint expected");
      }
      init(ep) {
        return new __RistrettoPoint(ep);
      }
      /** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */
      static hashToCurve(hex2) {
        return ristretto255_map((0, utils_ts_1.ensureBytes)("ristrettoHash", hex2, 64));
      }
      static fromBytes(bytes2) {
        (0, utils_js_1.abytes)(bytes2, 32);
        const { a: a2, d: d3 } = ed25519_CURVE;
        const P5 = ed25519_CURVE_p;
        const mod = (n2) => Fp.create(n2);
        const s2 = bytes255ToNumberLE(bytes2);
        if (!(0, utils_ts_1.equalBytes)(Fp.toBytes(s2), bytes2) || (0, modular_ts_1.isNegativeLE)(s2, P5))
          throw new Error("invalid ristretto255 encoding 1");
        const s22 = mod(s2 * s2);
        const u1 = mod(_1n + a2 * s22);
        const u22 = mod(_1n - a2 * s22);
        const u1_2 = mod(u1 * u1);
        const u2_2 = mod(u22 * u22);
        const v9 = mod(a2 * d3 * u1_2 - u2_2);
        const { isValid, value: I3 } = invertSqrt(mod(v9 * u2_2));
        const Dx = mod(I3 * u22);
        const Dy = mod(I3 * Dx * v9);
        let x3 = mod((s2 + s2) * Dx);
        if ((0, modular_ts_1.isNegativeLE)(x3, P5))
          x3 = mod(-x3);
        const y4 = mod(u1 * Dy);
        const t = mod(x3 * y4);
        if (!isValid || (0, modular_ts_1.isNegativeLE)(t, P5) || y4 === _0n)
          throw new Error("invalid ristretto255 encoding 2");
        return new __RistrettoPoint(new exports.ed25519.Point(x3, y4, _1n, t));
      }
      /**
       * Converts ristretto-encoded string to ristretto point.
       * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).
       * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
       */
      static fromHex(hex2) {
        return __RistrettoPoint.fromBytes((0, utils_ts_1.ensureBytes)("ristrettoHex", hex2, 32));
      }
      static msm(points, scalars) {
        return (0, curve_ts_1.pippenger)(__RistrettoPoint, exports.ed25519.Point.Fn, points, scalars);
      }
      /**
       * Encodes ristretto point to Uint8Array.
       * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).
       */
      toBytes() {
        let { X: X3, Y: Y6, Z: Z3, T: T4 } = this.ep;
        const P5 = ed25519_CURVE_p;
        const mod = (n2) => Fp.create(n2);
        const u1 = mod(mod(Z3 + Y6) * mod(Z3 - Y6));
        const u22 = mod(X3 * Y6);
        const u2sq = mod(u22 * u22);
        const { value: invsqrt } = invertSqrt(mod(u1 * u2sq));
        const D1 = mod(invsqrt * u1);
        const D22 = mod(invsqrt * u22);
        const zInv = mod(D1 * D22 * T4);
        let D3;
        if ((0, modular_ts_1.isNegativeLE)(T4 * zInv, P5)) {
          let _x = mod(Y6 * SQRT_M1);
          let _y = mod(X3 * SQRT_M1);
          X3 = _x;
          Y6 = _y;
          D3 = mod(D1 * INVSQRT_A_MINUS_D);
        } else {
          D3 = D22;
        }
        if ((0, modular_ts_1.isNegativeLE)(X3 * zInv, P5))
          Y6 = mod(-Y6);
        let s2 = mod((Z3 - Y6) * D3);
        if ((0, modular_ts_1.isNegativeLE)(s2, P5))
          s2 = mod(-s2);
        return Fp.toBytes(s2);
      }
      /**
       * Compares two Ristretto points.
       * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).
       */
      equals(other) {
        this.assertSame(other);
        const { X: X1, Y: Y1 } = this.ep;
        const { X: X22, Y: Y22 } = other.ep;
        const mod = (n2) => Fp.create(n2);
        const one = mod(X1 * Y22) === mod(Y1 * X22);
        const two = mod(Y1 * Y22) === mod(X1 * X22);
        return one || two;
      }
      is0() {
        return this.equals(__RistrettoPoint.ZERO);
      }
    };
    _RistrettoPoint.BASE = (() => new _RistrettoPoint(exports.ed25519.Point.BASE))();
    _RistrettoPoint.ZERO = (() => new _RistrettoPoint(exports.ed25519.Point.ZERO))();
    _RistrettoPoint.Fp = /* @__PURE__ */ (() => Fp)();
    _RistrettoPoint.Fn = /* @__PURE__ */ (() => Fn3)();
    exports.ristretto255 = { Point: _RistrettoPoint };
    exports.ristretto255_hasher = {
      hashToCurve(msg, options) {
        const DST = options?.DST || "ristretto255_XMD:SHA-512_R255MAP_RO_";
        const xmd = (0, hash_to_curve_ts_1.expand_message_xmd)(msg, DST, 64, sha2_js_1.sha512);
        return ristretto255_map(xmd);
      },
      hashToScalar(msg, options = { DST: hash_to_curve_ts_1._DST_scalar }) {
        const xmd = (0, hash_to_curve_ts_1.expand_message_xmd)(msg, options.DST, 64, sha2_js_1.sha512);
        return Fn3.create((0, utils_ts_1.bytesToNumberLE)(xmd));
      }
    };
    exports.ED25519_TORSION_SUBGROUP = [
      "0100000000000000000000000000000000000000000000000000000000000000",
      "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
      "0000000000000000000000000000000000000000000000000000000000000080",
      "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
      "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
      "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
      "0000000000000000000000000000000000000000000000000000000000000000",
      "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"
    ];
    function edwardsToMontgomeryPub(edwardsPub) {
      return exports.ed25519.utils.toMontgomery((0, utils_ts_1.ensureBytes)("pub", edwardsPub));
    }
    exports.edwardsToMontgomery = edwardsToMontgomeryPub;
    function edwardsToMontgomeryPriv(edwardsPriv) {
      return exports.ed25519.utils.toMontgomerySecret((0, utils_ts_1.ensureBytes)("pub", edwardsPriv));
    }
    exports.RistrettoPoint = _RistrettoPoint;
    exports.hashToCurve = (() => exports.ed25519_hasher.hashToCurve)();
    exports.encodeToCurve = (() => exports.ed25519_hasher.encodeToCurve)();
    exports.hashToRistretto255 = (() => exports.ristretto255_hasher.hashToCurve)();
    exports.hash_to_ristretto255 = (() => exports.ristretto255_hasher.hashToCurve)();
  }
});

// node_modules/.pnpm/hash-wasm@4.12.0/node_modules/hash-wasm/dist/index.esm.js
var index_esm_exports = {};
__export(index_esm_exports, {
  adler32: () => adler32,
  argon2Verify: () => argon2Verify,
  argon2d: () => argon2d,
  argon2i: () => argon2i,
  argon2id: () => argon2id,
  bcrypt: () => bcrypt,
  bcryptVerify: () => bcryptVerify,
  blake2b: () => blake2b,
  blake2s: () => blake2s,
  blake3: () => blake3,
  crc32: () => crc32,
  crc64: () => crc64,
  createAdler32: () => createAdler32,
  createBLAKE2b: () => createBLAKE2b,
  createBLAKE2s: () => createBLAKE2s,
  createBLAKE3: () => createBLAKE3,
  createCRC32: () => createCRC32,
  createCRC64: () => createCRC64,
  createHMAC: () => createHMAC,
  createKeccak: () => createKeccak,
  createMD4: () => createMD4,
  createMD5: () => createMD5,
  createRIPEMD160: () => createRIPEMD160,
  createSHA1: () => createSHA1,
  createSHA224: () => createSHA224,
  createSHA256: () => createSHA256,
  createSHA3: () => createSHA3,
  createSHA384: () => createSHA384,
  createSHA512: () => createSHA512,
  createSM3: () => createSM3,
  createWhirlpool: () => createWhirlpool,
  createXXHash128: () => createXXHash128,
  createXXHash3: () => createXXHash3,
  createXXHash32: () => createXXHash32,
  createXXHash64: () => createXXHash64,
  keccak: () => keccak,
  md4: () => md4,
  md5: () => md52,
  pbkdf2: () => pbkdf2,
  ripemd160: () => ripemd160,
  scrypt: () => scrypt,
  sha1: () => sha12,
  sha224: () => sha224,
  sha256: () => sha256,
  sha3: () => sha3,
  sha384: () => sha384,
  sha512: () => sha512,
  sm3: () => sm3,
  whirlpool: () => whirlpool,
  xxhash128: () => xxhash128,
  xxhash3: () => xxhash3,
  xxhash32: () => xxhash32,
  xxhash64: () => xxhash64
});
function __awaiter5(thisArg, _arguments, P5, generator) {
  function adopt(value) {
    return value instanceof P5 ? value : new P5(function(resolve) {
      resolve(value);
    });
  }
  return new (P5 || (P5 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function getGlobal() {
  if (typeof globalThis !== "undefined")
    return globalThis;
  if (typeof self !== "undefined")
    return self;
  if (typeof window !== "undefined")
    return window;
  return global;
}
function intArrayToString(arr, len) {
  return String.fromCharCode(...arr.subarray(0, len));
}
function hexCharCodesToInt(a2, b5) {
  return (a2 & 15) + (a2 >> 6 | a2 >> 3 & 8) << 4 | (b5 & 15) + (b5 >> 6 | b5 >> 3 & 8);
}
function writeHexToUInt8(buf, str2) {
  const size = str2.length >> 1;
  for (let i3 = 0; i3 < size; i3++) {
    const index = i3 << 1;
    buf[i3] = hexCharCodesToInt(str2.charCodeAt(index), str2.charCodeAt(index + 1));
  }
}
function hexStringEqualsUInt8(str2, buf) {
  if (str2.length !== buf.length * 2) {
    return false;
  }
  for (let i3 = 0; i3 < buf.length; i3++) {
    const strIndex = i3 << 1;
    if (buf[i3] !== hexCharCodesToInt(str2.charCodeAt(strIndex), str2.charCodeAt(strIndex + 1))) {
      return false;
    }
  }
  return true;
}
function getDigestHex(tmpBuffer, input, hashLength) {
  let p4 = 0;
  for (let i3 = 0; i3 < hashLength; i3++) {
    let nibble = input[i3] >>> 4;
    tmpBuffer[p4++] = nibble > 9 ? nibble + alpha : nibble + digit;
    nibble = input[i3] & 15;
    tmpBuffer[p4++] = nibble > 9 ? nibble + alpha : nibble + digit;
  }
  return String.fromCharCode.apply(null, tmpBuffer);
}
function encodeBase64(data2, pad = true) {
  const len = data2.length;
  const extraBytes = len % 3;
  const parts = [];
  const len2 = len - extraBytes;
  for (let i3 = 0; i3 < len2; i3 += 3) {
    const tmp = (data2[i3] << 16 & 16711680) + (data2[i3 + 1] << 8 & 65280) + (data2[i3 + 2] & 255);
    const triplet = base64Chars.charAt(tmp >> 18 & 63) + base64Chars.charAt(tmp >> 12 & 63) + base64Chars.charAt(tmp >> 6 & 63) + base64Chars.charAt(tmp & 63);
    parts.push(triplet);
  }
  if (extraBytes === 1) {
    const tmp = data2[len - 1];
    const a2 = base64Chars.charAt(tmp >> 2);
    const b5 = base64Chars.charAt(tmp << 4 & 63);
    parts.push(`${a2}${b5}`);
    if (pad) {
      parts.push("==");
    }
  } else if (extraBytes === 2) {
    const tmp = (data2[len - 2] << 8) + data2[len - 1];
    const a2 = base64Chars.charAt(tmp >> 10);
    const b5 = base64Chars.charAt(tmp >> 4 & 63);
    const c3 = base64Chars.charAt(tmp << 2 & 63);
    parts.push(`${a2}${b5}${c3}`);
    if (pad) {
      parts.push("=");
    }
  }
  return parts.join("");
}
function getDecodeBase64Length(data2) {
  let bufferLength = Math.floor(data2.length * 0.75);
  const len = data2.length;
  if (data2[len - 1] === "=") {
    bufferLength -= 1;
    if (data2[len - 2] === "=") {
      bufferLength -= 1;
    }
  }
  return bufferLength;
}
function decodeBase64(data2) {
  const bufferLength = getDecodeBase64Length(data2);
  const len = data2.length;
  const bytes2 = new Uint8Array(bufferLength);
  let p4 = 0;
  for (let i3 = 0; i3 < len; i3 += 4) {
    const encoded1 = base64Lookup[data2.charCodeAt(i3)];
    const encoded2 = base64Lookup[data2.charCodeAt(i3 + 1)];
    const encoded3 = base64Lookup[data2.charCodeAt(i3 + 2)];
    const encoded4 = base64Lookup[data2.charCodeAt(i3 + 3)];
    bytes2[p4] = encoded1 << 2 | encoded2 >> 4;
    p4 += 1;
    bytes2[p4] = (encoded2 & 15) << 4 | encoded3 >> 2;
    p4 += 1;
    bytes2[p4] = (encoded3 & 3) << 6 | encoded4 & 63;
    p4 += 1;
  }
  return bytes2;
}
function WASMInterface(binary, hashLength) {
  return __awaiter5(this, void 0, void 0, function* () {
    let wasmInstance = null;
    let memoryView = null;
    let initialized = false;
    if (typeof WebAssembly === "undefined") {
      throw new Error("WebAssembly is not supported in this environment!");
    }
    const writeMemory = (data2, offset = 0) => {
      memoryView.set(data2, offset);
    };
    const getMemory = () => memoryView;
    const getExports = () => wasmInstance.exports;
    const setMemorySize = (totalSize) => {
      wasmInstance.exports.Hash_SetMemorySize(totalSize);
      const arrayOffset = wasmInstance.exports.Hash_GetBuffer();
      const memoryBuffer = wasmInstance.exports.memory.buffer;
      memoryView = new Uint8Array(memoryBuffer, arrayOffset, totalSize);
    };
    const getStateSize = () => {
      const view = new DataView(wasmInstance.exports.memory.buffer);
      const stateSize = view.getUint32(wasmInstance.exports.STATE_SIZE, true);
      return stateSize;
    };
    const loadWASMPromise = wasmMutex.dispatch(() => __awaiter5(this, void 0, void 0, function* () {
      if (!wasmModuleCache.has(binary.name)) {
        const asm = decodeBase64(binary.data);
        const promise = WebAssembly.compile(asm);
        wasmModuleCache.set(binary.name, promise);
      }
      const module = yield wasmModuleCache.get(binary.name);
      wasmInstance = yield WebAssembly.instantiate(module, {
        // env: {
        //   emscripten_memcpy_big: (dest, src, num) => {
        //     const memoryBuffer = wasmInstance.exports.memory.buffer;
        //     const memView = new Uint8Array(memoryBuffer, 0);
        //     memView.set(memView.subarray(src, src + num), dest);
        //   },
        //   print_memory: (offset, len) => {
        //     const memoryBuffer = wasmInstance.exports.memory.buffer;
        //     const memView = new Uint8Array(memoryBuffer, 0);
        //     console.log('print_int32', memView.subarray(offset, offset + len));
        //   },
        // },
      });
    }));
    const setupInterface = () => __awaiter5(this, void 0, void 0, function* () {
      if (!wasmInstance) {
        yield loadWASMPromise;
      }
      const arrayOffset = wasmInstance.exports.Hash_GetBuffer();
      const memoryBuffer = wasmInstance.exports.memory.buffer;
      memoryView = new Uint8Array(memoryBuffer, arrayOffset, MAX_HEAP);
    });
    const init = (bits = null) => {
      initialized = true;
      wasmInstance.exports.Hash_Init(bits);
    };
    const updateUInt8Array = (data2) => {
      let read = 0;
      while (read < data2.length) {
        const chunk = data2.subarray(read, read + MAX_HEAP);
        read += chunk.length;
        memoryView.set(chunk);
        wasmInstance.exports.Hash_Update(chunk.length);
      }
    };
    const update = (data2) => {
      if (!initialized) {
        throw new Error("update() called before init()");
      }
      const Uint8Buffer = getUInt8Buffer(data2);
      updateUInt8Array(Uint8Buffer);
    };
    const digestChars = new Uint8Array(hashLength * 2);
    const digest = (outputType, padding2 = null) => {
      if (!initialized) {
        throw new Error("digest() called before init()");
      }
      initialized = false;
      wasmInstance.exports.Hash_Final(padding2);
      if (outputType === "binary") {
        return memoryView.slice(0, hashLength);
      }
      return getDigestHex(digestChars, memoryView, hashLength);
    };
    const save = () => {
      if (!initialized) {
        throw new Error("save() can only be called after init() and before digest()");
      }
      const stateOffset = wasmInstance.exports.Hash_GetState();
      const stateLength = getStateSize();
      const memoryBuffer = wasmInstance.exports.memory.buffer;
      const internalState = new Uint8Array(memoryBuffer, stateOffset, stateLength);
      const prefixedState = new Uint8Array(WASM_FUNC_HASH_LENGTH + stateLength);
      writeHexToUInt8(prefixedState, binary.hash);
      prefixedState.set(internalState, WASM_FUNC_HASH_LENGTH);
      return prefixedState;
    };
    const load = (state) => {
      if (!(state instanceof Uint8Array)) {
        throw new Error("load() expects an Uint8Array generated by save()");
      }
      const stateOffset = wasmInstance.exports.Hash_GetState();
      const stateLength = getStateSize();
      const overallLength = WASM_FUNC_HASH_LENGTH + stateLength;
      const memoryBuffer = wasmInstance.exports.memory.buffer;
      if (state.length !== overallLength) {
        throw new Error(`Bad state length (expected ${overallLength} bytes, got ${state.length})`);
      }
      if (!hexStringEqualsUInt8(binary.hash, state.subarray(0, WASM_FUNC_HASH_LENGTH))) {
        throw new Error("This state was written by an incompatible hash implementation");
      }
      const internalState = state.subarray(WASM_FUNC_HASH_LENGTH);
      new Uint8Array(memoryBuffer, stateOffset, stateLength).set(internalState);
      initialized = true;
    };
    const isDataShort = (data2) => {
      if (typeof data2 === "string") {
        return data2.length < MAX_HEAP / 4;
      }
      return data2.byteLength < MAX_HEAP;
    };
    let canSimplify = isDataShort;
    switch (binary.name) {
      case "argon2":
      case "scrypt":
        canSimplify = () => true;
        break;
      case "blake2b":
      case "blake2s":
        canSimplify = (data2, initParam) => initParam <= 512 && isDataShort(data2);
        break;
      case "blake3":
        canSimplify = (data2, initParam) => initParam === 0 && isDataShort(data2);
        break;
      case "xxhash64":
      // cannot simplify
      case "xxhash3":
      case "xxhash128":
      case "crc64":
        canSimplify = () => false;
        break;
    }
    const calculate = (data2, initParam = null, digestParam = null) => {
      if (!canSimplify(data2, initParam)) {
        init(initParam);
        update(data2);
        return digest("hex", digestParam);
      }
      const buffer = getUInt8Buffer(data2);
      memoryView.set(buffer);
      wasmInstance.exports.Hash_Calculate(buffer.length, initParam, digestParam);
      return getDigestHex(digestChars, memoryView, hashLength);
    };
    yield setupInterface();
    return {
      getMemory,
      writeMemory,
      getExports,
      setMemorySize,
      init,
      update,
      digest,
      save,
      load,
      calculate,
      hashLength
    };
  });
}
function lockedCreate(mutex2, binary, hashLength) {
  return __awaiter5(this, void 0, void 0, function* () {
    const unlock = yield mutex2.lock();
    const wasm2 = yield WASMInterface(binary, hashLength);
    unlock();
    return wasm2;
  });
}
function adler32(data2) {
  if (wasmCache$l === null) {
    return lockedCreate(mutex$l, wasmJson$l, 4).then((wasm2) => {
      wasmCache$l = wasm2;
      return wasmCache$l.calculate(data2);
    });
  }
  try {
    const hash2 = wasmCache$l.calculate(data2);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createAdler32() {
  return WASMInterface(wasmJson$l, 4).then((wasm2) => {
    wasm2.init();
    const obj = {
      init: () => {
        wasm2.init();
        return obj;
      },
      update: (data2) => {
        wasm2.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm2.digest(outputType),
      save: () => wasm2.save(),
      load: (data2) => {
        wasm2.load(data2);
        return obj;
      },
      blockSize: 4,
      digestSize: 4
    };
    return obj;
  });
}
function validateBits$4(bits) {
  if (!Number.isInteger(bits) || bits < 8 || bits > 512 || bits % 8 !== 0) {
    return new Error("Invalid variant! Valid values: 8, 16, ..., 512");
  }
  return null;
}
function getInitParam$1(outputBits, keyBits) {
  return outputBits | keyBits << 16;
}
function blake2b(data2, bits = 512, key = null) {
  if (validateBits$4(bits)) {
    return Promise.reject(validateBits$4(bits));
  }
  let keyBuffer = null;
  let initParam = bits;
  if (key !== null) {
    keyBuffer = getUInt8Buffer(key);
    if (keyBuffer.length > 64) {
      return Promise.reject(new Error("Max key length is 64 bytes"));
    }
    initParam = getInitParam$1(bits, keyBuffer.length);
  }
  const hashLength = bits / 8;
  if (wasmCache$k === null || wasmCache$k.hashLength !== hashLength) {
    return lockedCreate(mutex$k, wasmJson$j, hashLength).then((wasm2) => {
      wasmCache$k = wasm2;
      if (initParam > 512) {
        wasmCache$k.writeMemory(keyBuffer);
      }
      return wasmCache$k.calculate(data2, initParam);
    });
  }
  try {
    if (initParam > 512) {
      wasmCache$k.writeMemory(keyBuffer);
    }
    const hash2 = wasmCache$k.calculate(data2, initParam);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createBLAKE2b(bits = 512, key = null) {
  if (validateBits$4(bits)) {
    return Promise.reject(validateBits$4(bits));
  }
  let keyBuffer = null;
  let initParam = bits;
  if (key !== null) {
    keyBuffer = getUInt8Buffer(key);
    if (keyBuffer.length > 64) {
      return Promise.reject(new Error("Max key length is 64 bytes"));
    }
    initParam = getInitParam$1(bits, keyBuffer.length);
  }
  const outputSize = bits / 8;
  return WASMInterface(wasmJson$j, outputSize).then((wasm2) => {
    if (initParam > 512) {
      wasm2.writeMemory(keyBuffer);
    }
    wasm2.init(initParam);
    const obj = {
      init: initParam > 512 ? () => {
        wasm2.writeMemory(keyBuffer);
        wasm2.init(initParam);
        return obj;
      } : () => {
        wasm2.init(initParam);
        return obj;
      },
      update: (data2) => {
        wasm2.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm2.digest(outputType),
      save: () => wasm2.save(),
      load: (data2) => {
        wasm2.load(data2);
        return obj;
      },
      blockSize: 128,
      digestSize: outputSize
    };
    return obj;
  });
}
function encodeResult(salt, options, res) {
  const parameters = [
    `m=${options.memorySize}`,
    `t=${options.iterations}`,
    `p=${options.parallelism}`
  ].join(",");
  return `$argon2${options.hashType}$v=19$${parameters}$${encodeBase64(salt, false)}$${encodeBase64(res, false)}`;
}
function int32LE(x3) {
  uint32View.setInt32(0, x3, true);
  return new Uint8Array(uint32View.buffer);
}
function hashFunc(blake512, buf, len) {
  return __awaiter5(this, void 0, void 0, function* () {
    if (len <= 64) {
      const blake = yield createBLAKE2b(len * 8);
      blake.update(int32LE(len));
      blake.update(buf);
      return blake.digest("binary");
    }
    const r2 = Math.ceil(len / 32) - 2;
    const ret = new Uint8Array(len);
    blake512.init();
    blake512.update(int32LE(len));
    blake512.update(buf);
    let vp = blake512.digest("binary");
    ret.set(vp.subarray(0, 32), 0);
    for (let i3 = 1; i3 < r2; i3++) {
      blake512.init();
      blake512.update(vp);
      vp = blake512.digest("binary");
      ret.set(vp.subarray(0, 32), i3 * 32);
    }
    const partialBytesNeeded = len - 32 * r2;
    let blakeSmall;
    if (partialBytesNeeded === 64) {
      blakeSmall = blake512;
      blakeSmall.init();
    } else {
      blakeSmall = yield createBLAKE2b(partialBytesNeeded * 8);
    }
    blakeSmall.update(vp);
    vp = blakeSmall.digest("binary");
    ret.set(vp.subarray(0, partialBytesNeeded), r2 * 32);
    return ret;
  });
}
function getHashType(type) {
  switch (type) {
    case "d":
      return 0;
    case "i":
      return 1;
    default:
      return 2;
  }
}
function argon2Internal(options) {
  return __awaiter5(this, void 0, void 0, function* () {
    var _a2;
    const { parallelism, iterations, hashLength } = options;
    const password = getUInt8Buffer(options.password);
    const salt = getUInt8Buffer(options.salt);
    const version = 19;
    const hashType = getHashType(options.hashType);
    const { memorySize } = options;
    const secret = getUInt8Buffer((_a2 = options.secret) !== null && _a2 !== void 0 ? _a2 : "");
    const [argon2Interface, blake512] = yield Promise.all([
      WASMInterface(wasmJson$k, 1024),
      createBLAKE2b(512)
    ]);
    argon2Interface.setMemorySize(memorySize * 1024 + 1024);
    const initVector = new Uint8Array(24);
    const initVectorView = new DataView(initVector.buffer);
    initVectorView.setInt32(0, parallelism, true);
    initVectorView.setInt32(4, hashLength, true);
    initVectorView.setInt32(8, memorySize, true);
    initVectorView.setInt32(12, iterations, true);
    initVectorView.setInt32(16, version, true);
    initVectorView.setInt32(20, hashType, true);
    argon2Interface.writeMemory(initVector, memorySize * 1024);
    blake512.init();
    blake512.update(initVector);
    blake512.update(int32LE(password.length));
    blake512.update(password);
    blake512.update(int32LE(salt.length));
    blake512.update(salt);
    blake512.update(int32LE(secret.length));
    blake512.update(secret);
    blake512.update(int32LE(0));
    const segments = Math.floor(memorySize / (parallelism * 4));
    const lanes = segments * 4;
    const param = new Uint8Array(72);
    const H0 = blake512.digest("binary");
    param.set(H0);
    for (let lane = 0; lane < parallelism; lane++) {
      param.set(int32LE(0), 64);
      param.set(int32LE(lane), 68);
      let position = lane * lanes;
      let chunk = yield hashFunc(blake512, param, 1024);
      argon2Interface.writeMemory(chunk, position * 1024);
      position += 1;
      param.set(int32LE(1), 64);
      chunk = yield hashFunc(blake512, param, 1024);
      argon2Interface.writeMemory(chunk, position * 1024);
    }
    const C5 = new Uint8Array(1024);
    writeHexToUInt8(C5, argon2Interface.calculate(new Uint8Array([]), memorySize));
    const res = yield hashFunc(blake512, C5, hashLength);
    if (options.outputType === "hex") {
      const digestChars = new Uint8Array(hashLength * 2);
      return getDigestHex(digestChars, res, hashLength);
    }
    if (options.outputType === "encoded") {
      return encodeResult(salt, options, res);
    }
    return res;
  });
}
function argon2i(options) {
  return __awaiter5(this, void 0, void 0, function* () {
    validateOptions$3(options);
    return argon2Internal(Object.assign(Object.assign({}, options), { hashType: "i" }));
  });
}
function argon2id(options) {
  return __awaiter5(this, void 0, void 0, function* () {
    validateOptions$3(options);
    return argon2Internal(Object.assign(Object.assign({}, options), { hashType: "id" }));
  });
}
function argon2d(options) {
  return __awaiter5(this, void 0, void 0, function* () {
    validateOptions$3(options);
    return argon2Internal(Object.assign(Object.assign({}, options), { hashType: "d" }));
  });
}
function argon2Verify(options) {
  return __awaiter5(this, void 0, void 0, function* () {
    validateVerifyOptions$1(options);
    const params = getHashParameters(options.password, options.hash, options.secret);
    validateOptions$3(params);
    const hashStart = options.hash.lastIndexOf("$") + 1;
    const result = yield argon2Internal(params);
    return result.substring(hashStart) === options.hash.substring(hashStart);
  });
}
function validateBits$3(bits) {
  if (!Number.isInteger(bits) || bits < 8 || bits > 256 || bits % 8 !== 0) {
    return new Error("Invalid variant! Valid values: 8, 16, ..., 256");
  }
  return null;
}
function getInitParam(outputBits, keyBits) {
  return outputBits | keyBits << 16;
}
function blake2s(data2, bits = 256, key = null) {
  if (validateBits$3(bits)) {
    return Promise.reject(validateBits$3(bits));
  }
  let keyBuffer = null;
  let initParam = bits;
  if (key !== null) {
    keyBuffer = getUInt8Buffer(key);
    if (keyBuffer.length > 32) {
      return Promise.reject(new Error("Max key length is 32 bytes"));
    }
    initParam = getInitParam(bits, keyBuffer.length);
  }
  const hashLength = bits / 8;
  if (wasmCache$j === null || wasmCache$j.hashLength !== hashLength) {
    return lockedCreate(mutex$j, wasmJson$i, hashLength).then((wasm2) => {
      wasmCache$j = wasm2;
      if (initParam > 512) {
        wasmCache$j.writeMemory(keyBuffer);
      }
      return wasmCache$j.calculate(data2, initParam);
    });
  }
  try {
    if (initParam > 512) {
      wasmCache$j.writeMemory(keyBuffer);
    }
    const hash2 = wasmCache$j.calculate(data2, initParam);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createBLAKE2s(bits = 256, key = null) {
  if (validateBits$3(bits)) {
    return Promise.reject(validateBits$3(bits));
  }
  let keyBuffer = null;
  let initParam = bits;
  if (key !== null) {
    keyBuffer = getUInt8Buffer(key);
    if (keyBuffer.length > 32) {
      return Promise.reject(new Error("Max key length is 32 bytes"));
    }
    initParam = getInitParam(bits, keyBuffer.length);
  }
  const outputSize = bits / 8;
  return WASMInterface(wasmJson$i, outputSize).then((wasm2) => {
    if (initParam > 512) {
      wasm2.writeMemory(keyBuffer);
    }
    wasm2.init(initParam);
    const obj = {
      init: initParam > 512 ? () => {
        wasm2.writeMemory(keyBuffer);
        wasm2.init(initParam);
        return obj;
      } : () => {
        wasm2.init(initParam);
        return obj;
      },
      update: (data2) => {
        wasm2.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm2.digest(outputType),
      save: () => wasm2.save(),
      load: (data2) => {
        wasm2.load(data2);
        return obj;
      },
      blockSize: 64,
      digestSize: outputSize
    };
    return obj;
  });
}
function validateBits$2(bits) {
  if (!Number.isInteger(bits) || bits < 8 || bits % 8 !== 0) {
    return new Error("Invalid variant! Valid values: 8, 16, ...");
  }
  return null;
}
function blake3(data2, bits = 256, key = null) {
  if (validateBits$2(bits)) {
    return Promise.reject(validateBits$2(bits));
  }
  let keyBuffer = null;
  let initParam = 0;
  if (key !== null) {
    keyBuffer = getUInt8Buffer(key);
    if (keyBuffer.length !== 32) {
      return Promise.reject(new Error("Key length must be exactly 32 bytes"));
    }
    initParam = 32;
  }
  const hashLength = bits / 8;
  const digestParam = hashLength;
  if (wasmCache$i === null || wasmCache$i.hashLength !== hashLength) {
    return lockedCreate(mutex$i, wasmJson$h, hashLength).then((wasm2) => {
      wasmCache$i = wasm2;
      if (initParam === 32) {
        wasmCache$i.writeMemory(keyBuffer);
      }
      return wasmCache$i.calculate(data2, initParam, digestParam);
    });
  }
  try {
    if (initParam === 32) {
      wasmCache$i.writeMemory(keyBuffer);
    }
    const hash2 = wasmCache$i.calculate(data2, initParam, digestParam);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createBLAKE3(bits = 256, key = null) {
  if (validateBits$2(bits)) {
    return Promise.reject(validateBits$2(bits));
  }
  let keyBuffer = null;
  let initParam = 0;
  if (key !== null) {
    keyBuffer = getUInt8Buffer(key);
    if (keyBuffer.length !== 32) {
      return Promise.reject(new Error("Key length must be exactly 32 bytes"));
    }
    initParam = 32;
  }
  const outputSize = bits / 8;
  const digestParam = outputSize;
  return WASMInterface(wasmJson$h, outputSize).then((wasm2) => {
    if (initParam === 32) {
      wasm2.writeMemory(keyBuffer);
    }
    wasm2.init(initParam);
    const obj = {
      init: initParam === 32 ? () => {
        wasm2.writeMemory(keyBuffer);
        wasm2.init(initParam);
        return obj;
      } : () => {
        wasm2.init(initParam);
        return obj;
      },
      update: (data2) => {
        wasm2.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm2.digest(outputType, digestParam),
      save: () => wasm2.save(),
      load: (data2) => {
        wasm2.load(data2);
        return obj;
      },
      blockSize: 64,
      digestSize: outputSize
    };
    return obj;
  });
}
function validatePoly(poly) {
  if (!Number.isInteger(poly) || poly < 0 || poly > 4294967295) {
    return new Error("Polynomial must be a valid 32-bit long unsigned integer");
  }
  return null;
}
function crc32(data2, polynomial = 3988292384) {
  if (validatePoly(polynomial)) {
    return Promise.reject(validatePoly(polynomial));
  }
  if (wasmCache$h === null) {
    return lockedCreate(mutex$h, wasmJson$g, 4).then((wasm2) => {
      wasmCache$h = wasm2;
      return wasmCache$h.calculate(data2, polynomial);
    });
  }
  try {
    const hash2 = wasmCache$h.calculate(data2, polynomial);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createCRC32(polynomial = 3988292384) {
  if (validatePoly(polynomial)) {
    return Promise.reject(validatePoly(polynomial));
  }
  return WASMInterface(wasmJson$g, 4).then((wasm2) => {
    wasm2.init(polynomial);
    const obj = {
      init: () => {
        wasm2.init(polynomial);
        return obj;
      },
      update: (data2) => {
        wasm2.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm2.digest(outputType),
      save: () => wasm2.save(),
      load: (data2) => {
        wasm2.load(data2);
        return obj;
      },
      blockSize: 4,
      digestSize: 4
    };
    return obj;
  });
}
function parsePoly(poly) {
  const errText = "Polynomial must be provided as a 16 char long hex string";
  if (typeof poly !== "string" || poly.length !== 16) {
    return { hi: 0, lo: 0, err: new Error(errText) };
  }
  const hi2 = Number(`0x${poly.slice(0, 8)}`);
  const lo2 = Number(`0x${poly.slice(8)}`);
  if (Number.isNaN(hi2) || Number.isNaN(lo2)) {
    return { hi: hi2, lo: lo2, err: new Error(errText) };
  }
  return { hi: hi2, lo: lo2, err: null };
}
function writePoly(arr, lo2, hi2) {
  const buffer = new DataView(arr);
  buffer.setUint32(0, lo2, true);
  buffer.setUint32(4, hi2, true);
}
function crc64(data2, polynomial = "c96c5795d7870f42") {
  const { hi: hi2, lo: lo2, err } = parsePoly(polynomial);
  if (err !== null) {
    return Promise.reject(err);
  }
  if (wasmCache$g === null) {
    return lockedCreate(mutex$g, wasmJson$f, 8).then((wasm2) => {
      wasmCache$g = wasm2;
      writePoly(polyBuffer.buffer, lo2, hi2);
      wasmCache$g.writeMemory(polyBuffer);
      return wasmCache$g.calculate(data2);
    });
  }
  try {
    writePoly(polyBuffer.buffer, lo2, hi2);
    wasmCache$g.writeMemory(polyBuffer);
    const hash2 = wasmCache$g.calculate(data2);
    return Promise.resolve(hash2);
  } catch (err2) {
    return Promise.reject(err2);
  }
}
function createCRC64(polynomial = "c96c5795d7870f42") {
  const { hi: hi2, lo: lo2, err } = parsePoly(polynomial);
  if (err !== null) {
    return Promise.reject(err);
  }
  return WASMInterface(wasmJson$f, 8).then((wasm2) => {
    const instanceBuffer = new Uint8Array(8);
    writePoly(instanceBuffer.buffer, lo2, hi2);
    wasm2.writeMemory(instanceBuffer);
    wasm2.init();
    const obj = {
      init: () => {
        wasm2.writeMemory(instanceBuffer);
        wasm2.init();
        return obj;
      },
      update: (data2) => {
        wasm2.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm2.digest(outputType),
      save: () => wasm2.save(),
      load: (data2) => {
        wasm2.load(data2);
        return obj;
      },
      blockSize: 8,
      digestSize: 8
    };
    return obj;
  });
}
function md4(data2) {
  if (wasmCache$f === null) {
    return lockedCreate(mutex$f, wasmJson$e, 16).then((wasm2) => {
      wasmCache$f = wasm2;
      return wasmCache$f.calculate(data2);
    });
  }
  try {
    const hash2 = wasmCache$f.calculate(data2);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createMD4() {
  return WASMInterface(wasmJson$e, 16).then((wasm2) => {
    wasm2.init();
    const obj = {
      init: () => {
        wasm2.init();
        return obj;
      },
      update: (data2) => {
        wasm2.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm2.digest(outputType),
      save: () => wasm2.save(),
      load: (data2) => {
        wasm2.load(data2);
        return obj;
      },
      blockSize: 64,
      digestSize: 16
    };
    return obj;
  });
}
function md52(data2) {
  if (wasmCache$e === null) {
    return lockedCreate(mutex$e, wasmJson$d, 16).then((wasm2) => {
      wasmCache$e = wasm2;
      return wasmCache$e.calculate(data2);
    });
  }
  try {
    const hash2 = wasmCache$e.calculate(data2);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createMD5() {
  return WASMInterface(wasmJson$d, 16).then((wasm2) => {
    wasm2.init();
    const obj = {
      init: () => {
        wasm2.init();
        return obj;
      },
      update: (data2) => {
        wasm2.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm2.digest(outputType),
      save: () => wasm2.save(),
      load: (data2) => {
        wasm2.load(data2);
        return obj;
      },
      blockSize: 64,
      digestSize: 16
    };
    return obj;
  });
}
function sha12(data2) {
  if (wasmCache$d === null) {
    return lockedCreate(mutex$d, wasmJson$c, 20).then((wasm2) => {
      wasmCache$d = wasm2;
      return wasmCache$d.calculate(data2);
    });
  }
  try {
    const hash2 = wasmCache$d.calculate(data2);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createSHA1() {
  return WASMInterface(wasmJson$c, 20).then((wasm2) => {
    wasm2.init();
    const obj = {
      init: () => {
        wasm2.init();
        return obj;
      },
      update: (data2) => {
        wasm2.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm2.digest(outputType),
      save: () => wasm2.save(),
      load: (data2) => {
        wasm2.load(data2);
        return obj;
      },
      blockSize: 64,
      digestSize: 20
    };
    return obj;
  });
}
function validateBits$1(bits) {
  if (![224, 256, 384, 512].includes(bits)) {
    return new Error("Invalid variant! Valid values: 224, 256, 384, 512");
  }
  return null;
}
function sha3(data2, bits = 512) {
  if (validateBits$1(bits)) {
    return Promise.reject(validateBits$1(bits));
  }
  const hashLength = bits / 8;
  if (wasmCache$c === null || wasmCache$c.hashLength !== hashLength) {
    return lockedCreate(mutex$c, wasmJson$b, hashLength).then((wasm2) => {
      wasmCache$c = wasm2;
      return wasmCache$c.calculate(data2, bits, 6);
    });
  }
  try {
    const hash2 = wasmCache$c.calculate(data2, bits, 6);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createSHA3(bits = 512) {
  if (validateBits$1(bits)) {
    return Promise.reject(validateBits$1(bits));
  }
  const outputSize = bits / 8;
  return WASMInterface(wasmJson$b, outputSize).then((wasm2) => {
    wasm2.init(bits);
    const obj = {
      init: () => {
        wasm2.init(bits);
        return obj;
      },
      update: (data2) => {
        wasm2.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm2.digest(outputType, 6),
      save: () => wasm2.save(),
      load: (data2) => {
        wasm2.load(data2);
        return obj;
      },
      blockSize: 200 - 2 * outputSize,
      digestSize: outputSize
    };
    return obj;
  });
}
function validateBits(bits) {
  if (![224, 256, 384, 512].includes(bits)) {
    return new Error("Invalid variant! Valid values: 224, 256, 384, 512");
  }
  return null;
}
function keccak(data2, bits = 512) {
  if (validateBits(bits)) {
    return Promise.reject(validateBits(bits));
  }
  const hashLength = bits / 8;
  if (wasmCache$b === null || wasmCache$b.hashLength !== hashLength) {
    return lockedCreate(mutex$b, wasmJson$b, hashLength).then((wasm2) => {
      wasmCache$b = wasm2;
      return wasmCache$b.calculate(data2, bits, 1);
    });
  }
  try {
    const hash2 = wasmCache$b.calculate(data2, bits, 1);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createKeccak(bits = 512) {
  if (validateBits(bits)) {
    return Promise.reject(validateBits(bits));
  }
  const outputSize = bits / 8;
  return WASMInterface(wasmJson$b, outputSize).then((wasm2) => {
    wasm2.init(bits);
    const obj = {
      init: () => {
        wasm2.init(bits);
        return obj;
      },
      update: (data2) => {
        wasm2.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm2.digest(outputType, 1),
      save: () => wasm2.save(),
      load: (data2) => {
        wasm2.load(data2);
        return obj;
      },
      blockSize: 200 - 2 * outputSize,
      digestSize: outputSize
    };
    return obj;
  });
}
function sha224(data2) {
  if (wasmCache$a === null) {
    return lockedCreate(mutex$a, wasmJson$a, 28).then((wasm2) => {
      wasmCache$a = wasm2;
      return wasmCache$a.calculate(data2, 224);
    });
  }
  try {
    const hash2 = wasmCache$a.calculate(data2, 224);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createSHA224() {
  return WASMInterface(wasmJson$a, 28).then((wasm2) => {
    wasm2.init(224);
    const obj = {
      init: () => {
        wasm2.init(224);
        return obj;
      },
      update: (data2) => {
        wasm2.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm2.digest(outputType),
      save: () => wasm2.save(),
      load: (data2) => {
        wasm2.load(data2);
        return obj;
      },
      blockSize: 64,
      digestSize: 28
    };
    return obj;
  });
}
function sha256(data2) {
  if (wasmCache$9 === null) {
    return lockedCreate(mutex$9, wasmJson$a, 32).then((wasm2) => {
      wasmCache$9 = wasm2;
      return wasmCache$9.calculate(data2, 256);
    });
  }
  try {
    const hash2 = wasmCache$9.calculate(data2, 256);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createSHA256() {
  return WASMInterface(wasmJson$a, 32).then((wasm2) => {
    wasm2.init(256);
    const obj = {
      init: () => {
        wasm2.init(256);
        return obj;
      },
      update: (data2) => {
        wasm2.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm2.digest(outputType),
      save: () => wasm2.save(),
      load: (data2) => {
        wasm2.load(data2);
        return obj;
      },
      blockSize: 64,
      digestSize: 32
    };
    return obj;
  });
}
function sha384(data2) {
  if (wasmCache$8 === null) {
    return lockedCreate(mutex$8, wasmJson$9, 48).then((wasm2) => {
      wasmCache$8 = wasm2;
      return wasmCache$8.calculate(data2, 384);
    });
  }
  try {
    const hash2 = wasmCache$8.calculate(data2, 384);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createSHA384() {
  return WASMInterface(wasmJson$9, 48).then((wasm2) => {
    wasm2.init(384);
    const obj = {
      init: () => {
        wasm2.init(384);
        return obj;
      },
      update: (data2) => {
        wasm2.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm2.digest(outputType),
      save: () => wasm2.save(),
      load: (data2) => {
        wasm2.load(data2);
        return obj;
      },
      blockSize: 128,
      digestSize: 48
    };
    return obj;
  });
}
function sha512(data2) {
  if (wasmCache$7 === null) {
    return lockedCreate(mutex$7, wasmJson$9, 64).then((wasm2) => {
      wasmCache$7 = wasm2;
      return wasmCache$7.calculate(data2, 512);
    });
  }
  try {
    const hash2 = wasmCache$7.calculate(data2, 512);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createSHA512() {
  return WASMInterface(wasmJson$9, 64).then((wasm2) => {
    wasm2.init(512);
    const obj = {
      init: () => {
        wasm2.init(512);
        return obj;
      },
      update: (data2) => {
        wasm2.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm2.digest(outputType),
      save: () => wasm2.save(),
      load: (data2) => {
        wasm2.load(data2);
        return obj;
      },
      blockSize: 128,
      digestSize: 64
    };
    return obj;
  });
}
function validateSeed$3(seed) {
  if (!Number.isInteger(seed) || seed < 0 || seed > 4294967295) {
    return new Error("Seed must be a valid 32-bit long unsigned integer.");
  }
  return null;
}
function xxhash32(data2, seed = 0) {
  if (validateSeed$3(seed)) {
    return Promise.reject(validateSeed$3(seed));
  }
  if (wasmCache$6 === null) {
    return lockedCreate(mutex$6, wasmJson$8, 4).then((wasm2) => {
      wasmCache$6 = wasm2;
      return wasmCache$6.calculate(data2, seed);
    });
  }
  try {
    const hash2 = wasmCache$6.calculate(data2, seed);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createXXHash32(seed = 0) {
  if (validateSeed$3(seed)) {
    return Promise.reject(validateSeed$3(seed));
  }
  return WASMInterface(wasmJson$8, 4).then((wasm2) => {
    wasm2.init(seed);
    const obj = {
      init: () => {
        wasm2.init(seed);
        return obj;
      },
      update: (data2) => {
        wasm2.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm2.digest(outputType),
      save: () => wasm2.save(),
      load: (data2) => {
        wasm2.load(data2);
        return obj;
      },
      blockSize: 16,
      digestSize: 4
    };
    return obj;
  });
}
function validateSeed$2(seed) {
  if (!Number.isInteger(seed) || seed < 0 || seed > 4294967295) {
    return new Error("Seed must be given as two valid 32-bit long unsigned integers (lo + high).");
  }
  return null;
}
function writeSeed$2(arr, low, high) {
  const buffer = new DataView(arr);
  buffer.setUint32(0, low, true);
  buffer.setUint32(4, high, true);
}
function xxhash64(data2, seedLow = 0, seedHigh = 0) {
  if (validateSeed$2(seedLow)) {
    return Promise.reject(validateSeed$2(seedLow));
  }
  if (validateSeed$2(seedHigh)) {
    return Promise.reject(validateSeed$2(seedHigh));
  }
  if (wasmCache$5 === null) {
    return lockedCreate(mutex$5, wasmJson$7, 8).then((wasm2) => {
      wasmCache$5 = wasm2;
      writeSeed$2(seedBuffer$2.buffer, seedLow, seedHigh);
      wasmCache$5.writeMemory(seedBuffer$2);
      return wasmCache$5.calculate(data2);
    });
  }
  try {
    writeSeed$2(seedBuffer$2.buffer, seedLow, seedHigh);
    wasmCache$5.writeMemory(seedBuffer$2);
    const hash2 = wasmCache$5.calculate(data2);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createXXHash64(seedLow = 0, seedHigh = 0) {
  if (validateSeed$2(seedLow)) {
    return Promise.reject(validateSeed$2(seedLow));
  }
  if (validateSeed$2(seedHigh)) {
    return Promise.reject(validateSeed$2(seedHigh));
  }
  return WASMInterface(wasmJson$7, 8).then((wasm2) => {
    const instanceBuffer = new Uint8Array(8);
    writeSeed$2(instanceBuffer.buffer, seedLow, seedHigh);
    wasm2.writeMemory(instanceBuffer);
    wasm2.init();
    const obj = {
      init: () => {
        wasm2.writeMemory(instanceBuffer);
        wasm2.init();
        return obj;
      },
      update: (data2) => {
        wasm2.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm2.digest(outputType),
      save: () => wasm2.save(),
      load: (data2) => {
        wasm2.load(data2);
        return obj;
      },
      blockSize: 32,
      digestSize: 8
    };
    return obj;
  });
}
function validateSeed$1(seed) {
  if (!Number.isInteger(seed) || seed < 0 || seed > 4294967295) {
    return new Error("Seed must be given as two valid 32-bit long unsigned integers (lo + high).");
  }
  return null;
}
function writeSeed$1(arr, low, high) {
  const buffer = new DataView(arr);
  buffer.setUint32(0, low, true);
  buffer.setUint32(4, high, true);
}
function xxhash3(data2, seedLow = 0, seedHigh = 0) {
  if (validateSeed$1(seedLow)) {
    return Promise.reject(validateSeed$1(seedLow));
  }
  if (validateSeed$1(seedHigh)) {
    return Promise.reject(validateSeed$1(seedHigh));
  }
  if (wasmCache$4 === null) {
    return lockedCreate(mutex$4, wasmJson$6, 8).then((wasm2) => {
      wasmCache$4 = wasm2;
      writeSeed$1(seedBuffer$1.buffer, seedLow, seedHigh);
      wasmCache$4.writeMemory(seedBuffer$1);
      return wasmCache$4.calculate(data2);
    });
  }
  try {
    writeSeed$1(seedBuffer$1.buffer, seedLow, seedHigh);
    wasmCache$4.writeMemory(seedBuffer$1);
    const hash2 = wasmCache$4.calculate(data2);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createXXHash3(seedLow = 0, seedHigh = 0) {
  if (validateSeed$1(seedLow)) {
    return Promise.reject(validateSeed$1(seedLow));
  }
  if (validateSeed$1(seedHigh)) {
    return Promise.reject(validateSeed$1(seedHigh));
  }
  return WASMInterface(wasmJson$6, 8).then((wasm2) => {
    const instanceBuffer = new Uint8Array(8);
    writeSeed$1(instanceBuffer.buffer, seedLow, seedHigh);
    wasm2.writeMemory(instanceBuffer);
    wasm2.init();
    const obj = {
      init: () => {
        wasm2.writeMemory(instanceBuffer);
        wasm2.init();
        return obj;
      },
      update: (data2) => {
        wasm2.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm2.digest(outputType),
      save: () => wasm2.save(),
      load: (data2) => {
        wasm2.load(data2);
        return obj;
      },
      blockSize: 512,
      digestSize: 8
    };
    return obj;
  });
}
function validateSeed(seed) {
  if (!Number.isInteger(seed) || seed < 0 || seed > 4294967295) {
    return new Error("Seed must be given as two valid 32-bit long unsigned integers (lo + high).");
  }
  return null;
}
function writeSeed(arr, low, high) {
  const buffer = new DataView(arr);
  buffer.setUint32(0, low, true);
  buffer.setUint32(4, high, true);
}
function xxhash128(data2, seedLow = 0, seedHigh = 0) {
  if (validateSeed(seedLow)) {
    return Promise.reject(validateSeed(seedLow));
  }
  if (validateSeed(seedHigh)) {
    return Promise.reject(validateSeed(seedHigh));
  }
  if (wasmCache$3 === null) {
    return lockedCreate(mutex$3, wasmJson$5, 16).then((wasm2) => {
      wasmCache$3 = wasm2;
      writeSeed(seedBuffer.buffer, seedLow, seedHigh);
      wasmCache$3.writeMemory(seedBuffer);
      return wasmCache$3.calculate(data2);
    });
  }
  try {
    writeSeed(seedBuffer.buffer, seedLow, seedHigh);
    wasmCache$3.writeMemory(seedBuffer);
    const hash2 = wasmCache$3.calculate(data2);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createXXHash128(seedLow = 0, seedHigh = 0) {
  if (validateSeed(seedLow)) {
    return Promise.reject(validateSeed(seedLow));
  }
  if (validateSeed(seedHigh)) {
    return Promise.reject(validateSeed(seedHigh));
  }
  return WASMInterface(wasmJson$5, 16).then((wasm2) => {
    const instanceBuffer = new Uint8Array(8);
    writeSeed(instanceBuffer.buffer, seedLow, seedHigh);
    wasm2.writeMemory(instanceBuffer);
    wasm2.init();
    const obj = {
      init: () => {
        wasm2.writeMemory(instanceBuffer);
        wasm2.init();
        return obj;
      },
      update: (data2) => {
        wasm2.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm2.digest(outputType),
      save: () => wasm2.save(),
      load: (data2) => {
        wasm2.load(data2);
        return obj;
      },
      blockSize: 512,
      digestSize: 16
    };
    return obj;
  });
}
function ripemd160(data2) {
  if (wasmCache$2 === null) {
    return lockedCreate(mutex$2, wasmJson$4, 20).then((wasm2) => {
      wasmCache$2 = wasm2;
      return wasmCache$2.calculate(data2);
    });
  }
  try {
    const hash2 = wasmCache$2.calculate(data2);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createRIPEMD160() {
  return WASMInterface(wasmJson$4, 20).then((wasm2) => {
    wasm2.init();
    const obj = {
      init: () => {
        wasm2.init();
        return obj;
      },
      update: (data2) => {
        wasm2.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm2.digest(outputType),
      save: () => wasm2.save(),
      load: (data2) => {
        wasm2.load(data2);
        return obj;
      },
      blockSize: 64,
      digestSize: 20
    };
    return obj;
  });
}
function calculateKeyBuffer(hasher, key) {
  const { blockSize } = hasher;
  const buf = getUInt8Buffer(key);
  if (buf.length > blockSize) {
    hasher.update(buf);
    const uintArr = hasher.digest("binary");
    hasher.init();
    return uintArr;
  }
  return new Uint8Array(buf.buffer, buf.byteOffset, buf.length);
}
function calculateHmac(hasher, key) {
  hasher.init();
  const { blockSize } = hasher;
  const keyBuf = calculateKeyBuffer(hasher, key);
  const keyBuffer = new Uint8Array(blockSize);
  keyBuffer.set(keyBuf);
  const opad = new Uint8Array(blockSize);
  for (let i3 = 0; i3 < blockSize; i3++) {
    const v9 = keyBuffer[i3];
    opad[i3] = v9 ^ 92;
    keyBuffer[i3] = v9 ^ 54;
  }
  hasher.update(keyBuffer);
  const obj = {
    init: () => {
      hasher.init();
      hasher.update(keyBuffer);
      return obj;
    },
    update: (data2) => {
      hasher.update(data2);
      return obj;
    },
    digest: ((outputType) => {
      const uintArr = hasher.digest("binary");
      hasher.init();
      hasher.update(opad);
      hasher.update(uintArr);
      return hasher.digest(outputType);
    }),
    save: () => {
      throw new Error("save() not supported");
    },
    load: () => {
      throw new Error("load() not supported");
    },
    blockSize: hasher.blockSize,
    digestSize: hasher.digestSize
  };
  return obj;
}
function createHMAC(hash2, key) {
  if (!hash2 || !hash2.then) {
    throw new Error('Invalid hash function is provided! Usage: createHMAC(createMD5(), "key").');
  }
  return hash2.then((hasher) => calculateHmac(hasher, key));
}
function calculatePBKDF2(digest, salt, iterations, hashLength, outputType) {
  return __awaiter5(this, void 0, void 0, function* () {
    const DK = new Uint8Array(hashLength);
    const block1 = new Uint8Array(salt.length + 4);
    const block1View = new DataView(block1.buffer);
    const saltBuffer = getUInt8Buffer(salt);
    const saltUIntBuffer = new Uint8Array(saltBuffer.buffer, saltBuffer.byteOffset, saltBuffer.length);
    block1.set(saltUIntBuffer);
    let destPos = 0;
    const hLen = digest.digestSize;
    const l3 = Math.ceil(hashLength / hLen);
    let T4 = null;
    let U4 = null;
    for (let i3 = 1; i3 <= l3; i3++) {
      block1View.setUint32(salt.length, i3);
      digest.init();
      digest.update(block1);
      T4 = digest.digest("binary");
      U4 = T4.slice();
      for (let j3 = 1; j3 < iterations; j3++) {
        digest.init();
        digest.update(U4);
        U4 = digest.digest("binary");
        for (let k5 = 0; k5 < hLen; k5++) {
          T4[k5] ^= U4[k5];
        }
      }
      DK.set(T4.subarray(0, hashLength - destPos), destPos);
      destPos += hLen;
    }
    if (outputType === "binary") {
      return DK;
    }
    const digestChars = new Uint8Array(hashLength * 2);
    return getDigestHex(digestChars, DK, hashLength);
  });
}
function pbkdf2(options) {
  return __awaiter5(this, void 0, void 0, function* () {
    validateOptions$2(options);
    const hmac = yield createHMAC(options.hashFunction, options.password);
    return calculatePBKDF2(hmac, options.salt, options.iterations, options.hashLength, options.outputType);
  });
}
function scryptInternal(options) {
  return __awaiter5(this, void 0, void 0, function* () {
    const { costFactor, blockSize, parallelism, hashLength } = options;
    const SHA256Hasher = createSHA256();
    const blockData = yield pbkdf2({
      password: options.password,
      salt: options.salt,
      iterations: 1,
      hashLength: 128 * blockSize * parallelism,
      hashFunction: SHA256Hasher,
      outputType: "binary"
    });
    const scryptInterface = yield WASMInterface(wasmJson$3, 0);
    const VSize = 128 * blockSize * costFactor;
    const XYSize = 256 * blockSize;
    scryptInterface.setMemorySize(blockData.length + VSize + XYSize);
    scryptInterface.writeMemory(blockData, 0);
    scryptInterface.getExports().scrypt(blockSize, costFactor, parallelism);
    const expensiveSalt = scryptInterface.getMemory().subarray(0, 128 * blockSize * parallelism);
    const outputData = yield pbkdf2({
      password: options.password,
      salt: expensiveSalt,
      iterations: 1,
      hashLength,
      hashFunction: SHA256Hasher,
      outputType: "binary"
    });
    if (options.outputType === "hex") {
      const digestChars = new Uint8Array(hashLength * 2);
      return getDigestHex(digestChars, outputData, hashLength);
    }
    return outputData;
  });
}
function scrypt(options) {
  return __awaiter5(this, void 0, void 0, function* () {
    validateOptions$1(options);
    return scryptInternal(options);
  });
}
function bcryptInternal(options) {
  return __awaiter5(this, void 0, void 0, function* () {
    const { costFactor, password, salt } = options;
    const bcryptInterface = yield WASMInterface(wasmJson$2, 0);
    bcryptInterface.writeMemory(getUInt8Buffer(salt), 0);
    const passwordBuffer = getUInt8Buffer(password);
    bcryptInterface.writeMemory(passwordBuffer, 16);
    const shouldEncode = options.outputType === "encoded" ? 1 : 0;
    bcryptInterface.getExports().bcrypt(passwordBuffer.length, costFactor, shouldEncode);
    const memory = bcryptInterface.getMemory();
    if (options.outputType === "encoded") {
      return intArrayToString(memory, 60);
    }
    if (options.outputType === "hex") {
      const digestChars = new Uint8Array(24 * 2);
      return getDigestHex(digestChars, memory, 24);
    }
    return memory.slice(0, 24);
  });
}
function bcrypt(options) {
  return __awaiter5(this, void 0, void 0, function* () {
    validateOptions(options);
    return bcryptInternal(options);
  });
}
function bcryptVerify(options) {
  return __awaiter5(this, void 0, void 0, function* () {
    validateVerifyOptions(options);
    const { hash: hash2, password } = options;
    const bcryptInterface = yield WASMInterface(wasmJson$2, 0);
    bcryptInterface.writeMemory(getUInt8Buffer(hash2), 0);
    const passwordBuffer = getUInt8Buffer(password);
    bcryptInterface.writeMemory(passwordBuffer, 60);
    return !!bcryptInterface.getExports().bcrypt_verify(passwordBuffer.length);
  });
}
function whirlpool(data2) {
  if (wasmCache$1 === null) {
    return lockedCreate(mutex$1, wasmJson$1, 64).then((wasm2) => {
      wasmCache$1 = wasm2;
      return wasmCache$1.calculate(data2);
    });
  }
  try {
    const hash2 = wasmCache$1.calculate(data2);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createWhirlpool() {
  return WASMInterface(wasmJson$1, 64).then((wasm2) => {
    wasm2.init();
    const obj = {
      init: () => {
        wasm2.init();
        return obj;
      },
      update: (data2) => {
        wasm2.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm2.digest(outputType),
      save: () => wasm2.save(),
      load: (data2) => {
        wasm2.load(data2);
        return obj;
      },
      blockSize: 64,
      digestSize: 64
    };
    return obj;
  });
}
function sm3(data2) {
  if (wasmCache === null) {
    return lockedCreate(mutex, wasmJson, 32).then((wasm2) => {
      wasmCache = wasm2;
      return wasmCache.calculate(data2);
    });
  }
  try {
    const hash2 = wasmCache.calculate(data2);
    return Promise.resolve(hash2);
  } catch (err) {
    return Promise.reject(err);
  }
}
function createSM3() {
  return WASMInterface(wasmJson, 32).then((wasm2) => {
    wasm2.init();
    const obj = {
      init: () => {
        wasm2.init();
        return obj;
      },
      update: (data2) => {
        wasm2.update(data2);
        return obj;
      },
      // biome-ignore lint/suspicious/noExplicitAny: Conflict with IHasher type
      digest: (outputType) => wasm2.digest(outputType),
      save: () => wasm2.save(),
      load: (data2) => {
        wasm2.load(data2);
        return obj;
      },
      blockSize: 64,
      digestSize: 32
    };
    return obj;
  });
}
var name$l, data$l, hash$l, wasmJson$l, Mutex, _a, globalObject, nodeBuffer, textEncoder, alpha, digit, getUInt8Buffer, base64Chars, base64Lookup, MAX_HEAP, WASM_FUNC_HASH_LENGTH, wasmMutex, wasmModuleCache, mutex$l, wasmCache$l, name$k, data$k, hash$k, wasmJson$k, name$j, data$j, hash$j, wasmJson$j, mutex$k, wasmCache$k, uint32View, validateOptions$3, getHashParameters, validateVerifyOptions$1, name$i, data$i, hash$i, wasmJson$i, mutex$j, wasmCache$j, name$h, data$h, hash$h, wasmJson$h, mutex$i, wasmCache$i, name$g, data$g, hash$g, wasmJson$g, mutex$h, wasmCache$h, name$f, data$f, hash$f, wasmJson$f, mutex$g, wasmCache$g, polyBuffer, name$e, data$e, hash$e, wasmJson$e, mutex$f, wasmCache$f, name$d, data$d, hash$d, wasmJson$d, mutex$e, wasmCache$e, name$c, data$c, hash$c, wasmJson$c, mutex$d, wasmCache$d, name$b, data$b, hash$b, wasmJson$b, mutex$c, wasmCache$c, mutex$b, wasmCache$b, name$a, data$a, hash$a, wasmJson$a, mutex$a, wasmCache$a, mutex$9, wasmCache$9, name$9, data$9, hash$9, wasmJson$9, mutex$8, wasmCache$8, mutex$7, wasmCache$7, name$8, data$8, hash$8, wasmJson$8, mutex$6, wasmCache$6, name$7, data$7, hash$7, wasmJson$7, mutex$5, wasmCache$5, seedBuffer$2, name$6, data$6, hash$6, wasmJson$6, mutex$4, wasmCache$4, seedBuffer$1, name$5, data$5, hash$5, wasmJson$5, mutex$3, wasmCache$3, seedBuffer, name$4, data$4, hash$4, wasmJson$4, mutex$2, wasmCache$2, validateOptions$2, name$3, data$3, hash$3, wasmJson$3, isPowerOfTwo, validateOptions$1, name$2, data$2, hash$2, wasmJson$2, validateOptions, validateHashCharacters, validateVerifyOptions, name$1, data$1, hash$1, wasmJson$1, mutex$1, wasmCache$1, name, data, hash, wasmJson, mutex, wasmCache;
var init_index_esm = __esm({
  "node_modules/.pnpm/hash-wasm@4.12.0/node_modules/hash-wasm/dist/index.esm.js"() {
    name$l = "adler32";
    data$l = "AGFzbQEAAAABDANgAAF/YAAAYAF/AAMHBgABAgEAAgUEAQECAgYOAn8BQYCJBQt/AEGACAsHcAgGbWVtb3J5AgAOSGFzaF9HZXRCdWZmZXIAAAlIYXNoX0luaXQAAQtIYXNoX1VwZGF0ZQACCkhhc2hfRmluYWwAAw1IYXNoX0dldFN0YXRlAAQOSGFzaF9DYWxjdWxhdGUABQpTVEFURV9TSVpFAwEK6wkGBQBBgAkLCgBBAEEBNgKECAvjCAEHf0EAKAKECCIBQf//A3EhAiABQRB2IQMCQAJAIABBAUcNACACQQAtAIAJaiIBQY+AfGogASABQfD/A0sbIgEgA2oiBEEQdCIFQYCAPGogBSAEQfD/A0sbIAFyIQEMAQsCQAJAAkACQAJAIABBEEkNAEGACSEGIABBsCtJDQFBgAkhBgNAQQAhBQNAIAYgBWoiASgCACIEQf8BcSACaiICIANqIAIgBEEIdkH/AXFqIgJqIAIgBEEQdkH/AXFqIgJqIAIgBEEYdmoiAmogAiABQQRqKAIAIgRB/wFxaiICaiACIARBCHZB/wFxaiICaiACIARBEHZB/wFxaiICaiACIARBGHZqIgJqIAIgAUEIaigCACIEQf8BcWoiAmogAiAEQQh2Qf8BcWoiAmogAiAEQRB2Qf8BcWoiAmogAiAEQRh2aiIEaiAEIAFBDGooAgAiAUH/AXFqIgRqIAQgAUEIdkH/AXFqIgRqIAQgAUEQdkH/AXFqIgRqIAQgAUEYdmoiAmohAyAFQRBqIgVBsCtHDQALIANB8f8DcCEDIAJB8f8DcCECIAZBsCtqIQYgAEHQVGoiAEGvK0sNAAsgAEUNBCAAQQ9LDQEMAgsCQCAARQ0AAkACQCAAQQNxIgUNAEGACSEBIAAhBAwBCyAAQXxxIQRBACEBA0AgAiABQYAJai0AAGoiAiADaiEDIAUgAUEBaiIBRw0ACyAFQYAJaiEBCyAAQQRJDQADQCACIAEtAABqIgUgAS0AAWoiBiABLQACaiIAIAFBA2otAABqIgIgACAGIAUgA2pqamohAyABQQRqIQEgBEF8aiIEDQALCyACQY+AfGogAiACQfD/A0sbIANB8f8DcEEQdHIhAQwECwNAIAYoAgAiAUH/AXEgAmoiBCADaiAEIAFBCHZB/wFxaiIEaiAEIAFBEHZB/wFxaiIEaiAEIAFBGHZqIgRqIAQgBkEEaigCACIBQf8BcWoiBGogBCABQQh2Qf8BcWoiBGogBCABQRB2Qf8BcWoiBGogBCABQRh2aiIEaiAEIAZBCGooAgAiAUH/AXFqIgRqIAQgAUEIdkH/AXFqIgRqIAQgAUEQdkH/AXFqIgRqIAQgAUEYdmoiBGogBCAGQQxqKAIAIgFB/wFxaiIEaiAEIAFBCHZB/wFxaiIEaiAEIAFBEHZB/wFxaiIEaiAEIAFBGHZqIgJqIQMgBkEQaiEGIABBcGoiAEEPSw0ACyAARQ0BCyAAQX9qIQcCQCAAQQNxIgVFDQAgAEF8cSEAIAUhBCAGIQEDQCACIAEtAABqIgIgA2ohAyABQQFqIQEgBEF/aiIEDQALIAYgBWohBgsgB0EDSQ0AA0AgAiAGLQAAaiIBIAYtAAFqIgQgBi0AAmoiBSAGQQNqLQAAaiICIAUgBCABIANqampqIQMgBkEEaiEGIABBfGoiAA0ACwsgA0Hx/wNwIQMgAkHx/wNwIQILIAIgA0EQdHIhAQtBACABNgKECAsxAQF/QQBBACgChAgiAEEYdCAAQYD+A3FBCHRyIABBCHZBgP4DcSAAQRh2cnI2AoAJCwUAQYQICzsAQQBBATYChAggABACQQBBACgChAgiAEEYdCAAQYD+A3FBCHRyIABBCHZBgP4DcSAAQRh2cnI2AoAJCwsVAgBBgAgLBAQAAAAAQYQICwQBAAAA";
    hash$l = "02ddbd17";
    wasmJson$l = {
      name: name$l,
      data: data$l,
      hash: hash$l
    };
    Mutex = class {
      constructor() {
        this.mutex = Promise.resolve();
      }
      lock() {
        let begin = () => {
        };
        this.mutex = this.mutex.then(() => new Promise(begin));
        return new Promise((res) => {
          begin = res;
        });
      }
      dispatch(fn3) {
        return __awaiter5(this, void 0, void 0, function* () {
          const unlock = yield this.lock();
          try {
            return yield Promise.resolve(fn3());
          } finally {
            unlock();
          }
        });
      }
    };
    globalObject = getGlobal();
    nodeBuffer = (_a = globalObject.Buffer) !== null && _a !== void 0 ? _a : null;
    textEncoder = globalObject.TextEncoder ? new globalObject.TextEncoder() : null;
    alpha = "a".charCodeAt(0) - 10;
    digit = "0".charCodeAt(0);
    getUInt8Buffer = nodeBuffer !== null ? (data2) => {
      if (typeof data2 === "string") {
        const buf = nodeBuffer.from(data2, "utf8");
        return new Uint8Array(buf.buffer, buf.byteOffset, buf.length);
      }
      if (nodeBuffer.isBuffer(data2)) {
        return new Uint8Array(data2.buffer, data2.byteOffset, data2.length);
      }
      if (ArrayBuffer.isView(data2)) {
        return new Uint8Array(data2.buffer, data2.byteOffset, data2.byteLength);
      }
      throw new Error("Invalid data type!");
    } : (data2) => {
      if (typeof data2 === "string") {
        return textEncoder.encode(data2);
      }
      if (ArrayBuffer.isView(data2)) {
        return new Uint8Array(data2.buffer, data2.byteOffset, data2.byteLength);
      }
      throw new Error("Invalid data type!");
    };
    base64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    base64Lookup = new Uint8Array(256);
    for (let i3 = 0; i3 < base64Chars.length; i3++) {
      base64Lookup[base64Chars.charCodeAt(i3)] = i3;
    }
    MAX_HEAP = 16 * 1024;
    WASM_FUNC_HASH_LENGTH = 4;
    wasmMutex = new Mutex();
    wasmModuleCache = /* @__PURE__ */ new Map();
    mutex$l = new Mutex();
    wasmCache$l = null;
    name$k = "argon2";
    data$k = "AGFzbQEAAAABKQVgAX8Bf2AAAX9gEH9/f39/f39/f39/f39/f38AYAR/f39/AGACf38AAwYFAAECAwQFBgEBAoCAAgYIAX8BQZCoBAsHQQQGbWVtb3J5AgASSGFzaF9TZXRNZW1vcnlTaXplAAAOSGFzaF9HZXRCdWZmZXIAAQ5IYXNoX0NhbGN1bGF0ZQAECvEyBVgBAn9BACEBAkAgAEEAKAKICCICRg0AAkAgACACayIAQRB2IABBgIB8cSAASWoiAEAAQX9HDQBB/wHADwtBACEBQQBBACkDiAggAEEQdK18NwOICAsgAcALcAECfwJAQQAoAoAIIgANAEEAPwBBEHQiADYCgAhBACgCiAgiAUGAgCBGDQACQEGAgCAgAWsiAEEQdiAAQYCAfHEgAElqIgBAAEF/Rw0AQQAPC0EAQQApA4gIIABBEHStfDcDiAhBACgCgAghAAsgAAvcDgECfiAAIAQpAwAiECAAKQMAIhF8IBFCAYZC/v///x+DIBBC/////w+DfnwiEDcDACAMIBAgDCkDAIVCIIkiEDcDACAIIBAgCCkDACIRfCARQgGGQv7///8fgyAQQv////8Pg358IhA3AwAgBCAQIAQpAwCFQiiJIhA3AwAgACAQIAApAwAiEXwgEEL/////D4MgEUIBhkL+////H4N+fCIQNwMAIAwgECAMKQMAhUIwiSIQNwMAIAggECAIKQMAIhF8IBBC/////w+DIBFCAYZC/v///x+DfnwiEDcDACAEIBAgBCkDAIVCAYk3AwAgASAFKQMAIhAgASkDACIRfCARQgGGQv7///8fgyAQQv////8Pg358IhA3AwAgDSAQIA0pAwCFQiCJIhA3AwAgCSAQIAkpAwAiEXwgEUIBhkL+////H4MgEEL/////D4N+fCIQNwMAIAUgECAFKQMAhUIoiSIQNwMAIAEgECABKQMAIhF8IBBC/////w+DIBFCAYZC/v///x+DfnwiEDcDACANIBAgDSkDAIVCMIkiEDcDACAJIBAgCSkDACIRfCAQQv////8PgyARQgGGQv7///8fg358IhA3AwAgBSAQIAUpAwCFQgGJNwMAIAIgBikDACIQIAIpAwAiEXwgEUIBhkL+////H4MgEEL/////D4N+fCIQNwMAIA4gECAOKQMAhUIgiSIQNwMAIAogECAKKQMAIhF8IBFCAYZC/v///x+DIBBC/////w+DfnwiEDcDACAGIBAgBikDAIVCKIkiEDcDACACIBAgAikDACIRfCAQQv////8PgyARQgGGQv7///8fg358IhA3AwAgDiAQIA4pAwCFQjCJIhA3AwAgCiAQIAopAwAiEXwgEEL/////D4MgEUIBhkL+////H4N+fCIQNwMAIAYgECAGKQMAhUIBiTcDACADIAcpAwAiECADKQMAIhF8IBFCAYZC/v///x+DIBBC/////w+DfnwiEDcDACAPIBAgDykDAIVCIIkiEDcDACALIBAgCykDACIRfCARQgGGQv7///8fgyAQQv////8Pg358IhA3AwAgByAQIAcpAwCFQiiJIhA3AwAgAyAQIAMpAwAiEXwgEEL/////D4MgEUIBhkL+////H4N+fCIQNwMAIA8gECAPKQMAhUIwiSIQNwMAIAsgECALKQMAIhF8IBBC/////w+DIBFCAYZC/v///x+DfnwiEDcDACAHIBAgBykDAIVCAYk3AwAgACAFKQMAIhAgACkDACIRfCARQgGGQv7///8fgyAQQv////8Pg358IhA3AwAgDyAQIA8pAwCFQiCJIhA3AwAgCiAQIAopAwAiEXwgEUIBhkL+////H4MgEEL/////D4N+fCIQNwMAIAUgECAFKQMAhUIoiSIQNwMAIAAgECAAKQMAIhF8IBBC/////w+DIBFCAYZC/v///x+DfnwiEDcDACAPIBAgDykDAIVCMIkiEDcDACAKIBAgCikDACIRfCAQQv////8PgyARQgGGQv7///8fg358IhA3AwAgBSAQIAUpAwCFQgGJNwMAIAEgBikDACIQIAEpAwAiEXwgEUIBhkL+////H4MgEEL/////D4N+fCIQNwMAIAwgECAMKQMAhUIgiSIQNwMAIAsgECALKQMAIhF8IBFCAYZC/v///x+DIBBC/////w+DfnwiEDcDACAGIBAgBikDAIVCKIkiEDcDACABIBAgASkDACIRfCAQQv////8PgyARQgGGQv7///8fg358IhA3AwAgDCAQIAwpAwCFQjCJIhA3AwAgCyAQIAspAwAiEXwgEEL/////D4MgEUIBhkL+////H4N+fCIQNwMAIAYgECAGKQMAhUIBiTcDACACIAcpAwAiECACKQMAIhF8IBFCAYZC/v///x+DIBBC/////w+DfnwiEDcDACANIBAgDSkDAIVCIIkiEDcDACAIIBAgCCkDACIRfCARQgGGQv7///8fgyAQQv////8Pg358IhA3AwAgByAQIAcpAwCFQiiJIhA3AwAgAiAQIAIpAwAiEXwgEEL/////D4MgEUIBhkL+////H4N+fCIQNwMAIA0gECANKQMAhUIwiSIQNwMAIAggECAIKQMAIhF8IBBC/////w+DIBFCAYZC/v///x+DfnwiEDcDACAHIBAgBykDAIVCAYk3AwAgAyAEKQMAIhAgAykDACIRfCARQgGGQv7///8fgyAQQv////8Pg358IhA3AwAgDiAQIA4pAwCFQiCJIhA3AwAgCSAQIAkpAwAiEXwgEUIBhkL+////H4MgEEL/////D4N+fCIQNwMAIAQgECAEKQMAhUIoiSIQNwMAIAMgECADKQMAIhF8IBBC/////w+DIBFCAYZC/v///x+DfnwiEDcDACAOIBAgDikDAIVCMIkiEDcDACAJIBAgCSkDACIRfCAQQv////8PgyARQgGGQv7///8fg358IhA3AwAgBCAQIAQpAwCFQgGJNwMAC98aAQN/QQAhBEEAIAIpAwAgASkDAIU3A5AIQQAgAikDCCABKQMIhTcDmAhBACACKQMQIAEpAxCFNwOgCEEAIAIpAxggASkDGIU3A6gIQQAgAikDICABKQMghTcDsAhBACACKQMoIAEpAyiFNwO4CEEAIAIpAzAgASkDMIU3A8AIQQAgAikDOCABKQM4hTcDyAhBACACKQNAIAEpA0CFNwPQCEEAIAIpA0ggASkDSIU3A9gIQQAgAikDUCABKQNQhTcD4AhBACACKQNYIAEpA1iFNwPoCEEAIAIpA2AgASkDYIU3A/AIQQAgAikDaCABKQNohTcD+AhBACACKQNwIAEpA3CFNwOACUEAIAIpA3ggASkDeIU3A4gJQQAgAikDgAEgASkDgAGFNwOQCUEAIAIpA4gBIAEpA4gBhTcDmAlBACACKQOQASABKQOQAYU3A6AJQQAgAikDmAEgASkDmAGFNwOoCUEAIAIpA6ABIAEpA6ABhTcDsAlBACACKQOoASABKQOoAYU3A7gJQQAgAikDsAEgASkDsAGFNwPACUEAIAIpA7gBIAEpA7gBhTcDyAlBACACKQPAASABKQPAAYU3A9AJQQAgAikDyAEgASkDyAGFNwPYCUEAIAIpA9ABIAEpA9ABhTcD4AlBACACKQPYASABKQPYAYU3A+gJQQAgAikD4AEgASkD4AGFNwPwCUEAIAIpA+gBIAEpA+gBhTcD+AlBACACKQPwASABKQPwAYU3A4AKQQAgAikD+AEgASkD+AGFNwOICkEAIAIpA4ACIAEpA4AChTcDkApBACACKQOIAiABKQOIAoU3A5gKQQAgAikDkAIgASkDkAKFNwOgCkEAIAIpA5gCIAEpA5gChTcDqApBACACKQOgAiABKQOgAoU3A7AKQQAgAikDqAIgASkDqAKFNwO4CkEAIAIpA7ACIAEpA7AChTcDwApBACACKQO4AiABKQO4AoU3A8gKQQAgAikDwAIgASkDwAKFNwPQCkEAIAIpA8gCIAEpA8gChTcD2ApBACACKQPQAiABKQPQAoU3A+AKQQAgAikD2AIgASkD2AKFNwPoCkEAIAIpA+ACIAEpA+AChTcD8ApBACACKQPoAiABKQPoAoU3A/gKQQAgAikD8AIgASkD8AKFNwOAC0EAIAIpA/gCIAEpA/gChTcDiAtBACACKQOAAyABKQOAA4U3A5ALQQAgAikDiAMgASkDiAOFNwOYC0EAIAIpA5ADIAEpA5ADhTcDoAtBACACKQOYAyABKQOYA4U3A6gLQQAgAikDoAMgASkDoAOFNwOwC0EAIAIpA6gDIAEpA6gDhTcDuAtBACACKQOwAyABKQOwA4U3A8ALQQAgAikDuAMgASkDuAOFNwPIC0EAIAIpA8ADIAEpA8ADhTcD0AtBACACKQPIAyABKQPIA4U3A9gLQQAgAikD0AMgASkD0AOFNwPgC0EAIAIpA9gDIAEpA9gDhTcD6AtBACACKQPgAyABKQPgA4U3A/ALQQAgAikD6AMgASkD6AOFNwP4C0EAIAIpA/ADIAEpA/ADhTcDgAxBACACKQP4AyABKQP4A4U3A4gMQQAgAikDgAQgASkDgASFNwOQDEEAIAIpA4gEIAEpA4gEhTcDmAxBACACKQOQBCABKQOQBIU3A6AMQQAgAikDmAQgASkDmASFNwOoDEEAIAIpA6AEIAEpA6AEhTcDsAxBACACKQOoBCABKQOoBIU3A7gMQQAgAikDsAQgASkDsASFNwPADEEAIAIpA7gEIAEpA7gEhTcDyAxBACACKQPABCABKQPABIU3A9AMQQAgAikDyAQgASkDyASFNwPYDEEAIAIpA9AEIAEpA9AEhTcD4AxBACACKQPYBCABKQPYBIU3A+gMQQAgAikD4AQgASkD4ASFNwPwDEEAIAIpA+gEIAEpA+gEhTcD+AxBACACKQPwBCABKQPwBIU3A4ANQQAgAikD+AQgASkD+ASFNwOIDUEAIAIpA4AFIAEpA4AFhTcDkA1BACACKQOIBSABKQOIBYU3A5gNQQAgAikDkAUgASkDkAWFNwOgDUEAIAIpA5gFIAEpA5gFhTcDqA1BACACKQOgBSABKQOgBYU3A7ANQQAgAikDqAUgASkDqAWFNwO4DUEAIAIpA7AFIAEpA7AFhTcDwA1BACACKQO4BSABKQO4BYU3A8gNQQAgAikDwAUgASkDwAWFNwPQDUEAIAIpA8gFIAEpA8gFhTcD2A1BACACKQPQBSABKQPQBYU3A+ANQQAgAikD2AUgASkD2AWFNwPoDUEAIAIpA+AFIAEpA+AFhTcD8A1BACACKQPoBSABKQPoBYU3A/gNQQAgAikD8AUgASkD8AWFNwOADkEAIAIpA/gFIAEpA/gFhTcDiA5BACACKQOABiABKQOABoU3A5AOQQAgAikDiAYgASkDiAaFNwOYDkEAIAIpA5AGIAEpA5AGhTcDoA5BACACKQOYBiABKQOYBoU3A6gOQQAgAikDoAYgASkDoAaFNwOwDkEAIAIpA6gGIAEpA6gGhTcDuA5BACACKQOwBiABKQOwBoU3A8AOQQAgAikDuAYgASkDuAaFNwPIDkEAIAIpA8AGIAEpA8AGhTcD0A5BACACKQPIBiABKQPIBoU3A9gOQQAgAikD0AYgASkD0AaFNwPgDkEAIAIpA9gGIAEpA9gGhTcD6A5BACACKQPgBiABKQPgBoU3A/AOQQAgAikD6AYgASkD6AaFNwP4DkEAIAIpA/AGIAEpA/AGhTcDgA9BACACKQP4BiABKQP4BoU3A4gPQQAgAikDgAcgASkDgAeFNwOQD0EAIAIpA4gHIAEpA4gHhTcDmA9BACACKQOQByABKQOQB4U3A6APQQAgAikDmAcgASkDmAeFNwOoD0EAIAIpA6AHIAEpA6AHhTcDsA9BACACKQOoByABKQOoB4U3A7gPQQAgAikDsAcgASkDsAeFNwPAD0EAIAIpA7gHIAEpA7gHhTcDyA9BACACKQPAByABKQPAB4U3A9APQQAgAikDyAcgASkDyAeFNwPYD0EAIAIpA9AHIAEpA9AHhTcD4A9BACACKQPYByABKQPYB4U3A+gPQQAgAikD4AcgASkD4AeFNwPwD0EAIAIpA+gHIAEpA+gHhTcD+A9BACACKQPwByABKQPwB4U3A4AQQQAgAikD+AcgASkD+AeFNwOIEEGQCEGYCEGgCEGoCEGwCEG4CEHACEHICEHQCEHYCEHgCEHoCEHwCEH4CEGACUGICRACQZAJQZgJQaAJQagJQbAJQbgJQcAJQcgJQdAJQdgJQeAJQegJQfAJQfgJQYAKQYgKEAJBkApBmApBoApBqApBsApBuApBwApByApB0ApB2ApB4ApB6ApB8ApB+ApBgAtBiAsQAkGQC0GYC0GgC0GoC0GwC0G4C0HAC0HIC0HQC0HYC0HgC0HoC0HwC0H4C0GADEGIDBACQZAMQZgMQaAMQagMQbAMQbgMQcAMQcgMQdAMQdgMQeAMQegMQfAMQfgMQYANQYgNEAJBkA1BmA1BoA1BqA1BsA1BuA1BwA1ByA1B0A1B2A1B4A1B6A1B8A1B+A1BgA5BiA4QAkGQDkGYDkGgDkGoDkGwDkG4DkHADkHIDkHQDkHYDkHgDkHoDkHwDkH4DkGAD0GIDxACQZAPQZgPQaAPQagPQbAPQbgPQcAPQcgPQdAPQdgPQeAPQegPQfAPQfgPQYAQQYgQEAJBkAhBmAhBkAlBmAlBkApBmApBkAtBmAtBkAxBmAxBkA1BmA1BkA5BmA5BkA9BmA8QAkGgCEGoCEGgCUGoCUGgCkGoCkGgC0GoC0GgDEGoDEGgDUGoDUGgDkGoDkGgD0GoDxACQbAIQbgIQbAJQbgJQbAKQbgKQbALQbgLQbAMQbgMQbANQbgNQbAOQbgOQbAPQbgPEAJBwAhByAhBwAlByAlBwApByApBwAtByAtBwAxByAxBwA1ByA1BwA5ByA5BwA9ByA8QAkHQCEHYCEHQCUHYCUHQCkHYCkHQC0HYC0HQDEHYDEHQDUHYDUHQDkHYDkHQD0HYDxACQeAIQegIQeAJQegJQeAKQegKQeALQegLQeAMQegMQeANQegNQeAOQegOQeAPQegPEAJB8AhB+AhB8AlB+AlB8ApB+ApB8AtB+AtB8AxB+AxB8A1B+A1B8A5B+A5B8A9B+A8QAkGACUGICUGACkGICkGAC0GIC0GADEGIDEGADUGIDUGADkGIDkGAD0GID0GAEEGIEBACAkACQCADRQ0AA0AgACAEaiIDIAIgBGoiBSkDACABIARqIgYpAwCFIARBkAhqKQMAhSADKQMAhTcDACADQQhqIgMgBUEIaikDACAGQQhqKQMAhSAEQZgIaikDAIUgAykDAIU3AwAgBEEQaiIEQYAIRw0ADAILC0EAIQQDQCAAIARqIgMgAiAEaiIFKQMAIAEgBGoiBikDAIUgBEGQCGopAwCFNwMAIANBCGogBUEIaikDACAGQQhqKQMAhSAEQZgIaikDAIU3AwAgBEEQaiIEQYAIRw0ACwsL5QcMBX8BfgR/An4BfwF+AX8Bfgd/AX4DfwF+AkBBACgCgAgiAiABQQp0aiIDKAIIIAFHDQAgAygCDCEEIAMoAgAhBUEAIAMoAhQiBq03A7gQQQAgBK0iBzcDsBBBACAFIAEgBUECdG4iCGwiCUECdK03A6gQAkACQAJAAkAgBEUNAEF/IQogBUUNASAIQQNsIQsgCEECdCIErSEMIAWtIQ0gBkF/akECSSEOQgAhDwNAQQAgDzcDkBAgD6chEEIAIRFBACEBA0BBACARNwOgECAPIBGEUCIDIA5xIRIgBkEBRiAPUCITIAZBAkYgEUICVHFxciEUQX8gAUEBakEDcSAIbEF/aiATGyEVIAEgEHIhFiABIAhsIRcgA0EBdCEYQgAhGQNAQQBCADcDwBBBACAZNwOYECAYIQECQCASRQ0AQQBCATcDwBBBkBhBkBBBkCBBABADQZAYQZAYQZAgQQAQA0ECIQELAkAgASAITw0AIAQgGaciGmwgF2ogAWohAwNAIANBACAEIAEbQQAgEVAiGxtqQX9qIRwCQAJAIBQNAEEAKAKACCICIBxBCnQiHGohCgwBCwJAIAFB/wBxIgINAEEAQQApA8AQQgF8NwPAEEGQGEGQEEGQIEEAEANBkBhBkBhBkCBBABADCyAcQQp0IRwgAkEDdEGQGGohCkEAKAKACCECCyACIANBCnRqIAIgHGogAiAKKQMAIh1CIIinIAVwIBogFhsiHCAEbCABIAFBACAZIBytUSIcGyIKIBsbIBdqIAogC2ogExsgAUUgHHJrIhsgFWqtIB1C/////w+DIh0gHX5CIIggG61+QiCIfSAMgqdqQQp0akEBEAMgA0EBaiEDIAggAUEBaiIBRw0ACwsgGUIBfCIZIA1SDQALIBFCAXwiEachASARQgRSDQALIA9CAXwiDyAHUg0AC0EAKAKACCECCyAJQQx0QYB4aiEXIAVBf2oiCkUNAgwBC0EAQgM3A6AQQQAgBEF/aq03A5AQQYB4IRcLIAIgF2ohGyAIQQx0IQhBACEcA0AgCCAcQQFqIhxsQYB4aiEEQQAhAQNAIBsgAWoiAyADKQMAIAIgBCABamopAwCFNwMAIANBCGoiAyADKQMAIAIgBCABQQhyamopAwCFNwMAIAFBCGohAyABQRBqIQEgA0H4B0kNAAsgHCAKRw0ACwsgAiAXaiEbQXghAQNAIAIgAWoiA0EIaiAbIAFqIgRBCGopAwA3AwAgA0EQaiAEQRBqKQMANwMAIANBGGogBEEYaikDADcDACADQSBqIARBIGopAwA3AwAgAUEgaiIBQfgHSQ0ACwsL";
    hash$k = "e4cdc523";
    wasmJson$k = {
      name: name$k,
      data: data$k,
      hash: hash$k
    };
    name$j = "blake2b";
    data$j = "AGFzbQEAAAABEQRgAAF/YAJ/fwBgAX8AYAAAAwoJAAECAwECAgABBQQBAQICBg4CfwFBsIsFC38AQYAICwdwCAZtZW1vcnkCAA5IYXNoX0dldEJ1ZmZlcgAACkhhc2hfRmluYWwAAwlIYXNoX0luaXQABQtIYXNoX1VwZGF0ZQAGDUhhc2hfR2V0U3RhdGUABw5IYXNoX0NhbGN1bGF0ZQAIClNUQVRFX1NJWkUDAQrTOAkFAEGACQvrAgIFfwF+AkAgAUEBSA0AAkACQAJAIAFBgAFBACgC4IoBIgJrIgNKDQAgASEEDAELQQBBADYC4IoBAkAgAkH/AEoNACACQeCJAWohBSAAIQRBACEGA0AgBSAELQAAOgAAIARBAWohBCAFQQFqIQUgAyAGQQFqIgZB/wFxSg0ACwtBAEEAKQPAiQEiB0KAAXw3A8CJAUEAQQApA8iJASAHQv9+Vq18NwPIiQFB4IkBEAIgACADaiEAAkAgASADayIEQYEBSA0AIAIgAWohBQNAQQBBACkDwIkBIgdCgAF8NwPAiQFBAEEAKQPIiQEgB0L/flatfDcDyIkBIAAQAiAAQYABaiEAIAVBgH9qIgVBgAJLDQALIAVBgH9qIQQMAQsgBEEATA0BC0EAIQUDQCAFQQAoAuCKAWpB4IkBaiAAIAVqLQAAOgAAIAQgBUEBaiIFQf8BcUoNAAsLQQBBACgC4IoBIARqNgLgigELC78uASR+QQBBACkD0IkBQQApA7CJASIBQQApA5CJAXwgACkDICICfCIDhULr+obav7X2wR+FQiCJIgRCq/DT9K/uvLc8fCIFIAGFQiiJIgYgA3wgACkDKCIBfCIHIASFQjCJIgggBXwiCSAGhUIBiSIKQQApA8iJAUEAKQOoiQEiBEEAKQOIiQF8IAApAxAiA3wiBYVCn9j52cKR2oKbf4VCIIkiC0K7zqqm2NDrs7t/fCIMIASFQiiJIg0gBXwgACkDGCIEfCIOfCAAKQNQIgV8Ig9BACkDwIkBQQApA6CJASIQQQApA4CJASIRfCAAKQMAIgZ8IhKFQtGFmu/6z5SH0QCFQiCJIhNCiJLznf/M+YTqAHwiFCAQhUIoiSIVIBJ8IAApAwgiEHwiFiAThUIwiSIXhUIgiSIYQQApA9iJAUEAKQO4iQEiE0EAKQOYiQF8IAApAzAiEnwiGYVC+cL4m5Gjs/DbAIVCIIkiGkLx7fT4paf9p6V/fCIbIBOFQiiJIhwgGXwgACkDOCITfCIZIBqFQjCJIhogG3wiG3wiHSAKhUIoiSIeIA98IAApA1giCnwiDyAYhUIwiSIYIB18Ih0gDiALhUIwiSIOIAx8Ih8gDYVCAYkiDCAWfCAAKQNAIgt8Ig0gGoVCIIkiFiAJfCIaIAyFQiiJIiAgDXwgACkDSCIJfCIhIBaFQjCJIhYgGyAchUIBiSIMIAd8IAApA2AiB3wiDSAOhUIgiSIOIBcgFHwiFHwiFyAMhUIoiSIbIA18IAApA2giDHwiHCAOhUIwiSIOIBd8IhcgG4VCAYkiGyAZIBQgFYVCAYkiFHwgACkDcCINfCIVIAiFQiCJIhkgH3wiHyAUhUIoiSIUIBV8IAApA3giCHwiFXwgDHwiIoVCIIkiI3wiJCAbhUIoiSIbICJ8IBJ8IiIgFyAYIBUgGYVCMIkiFSAffCIZIBSFQgGJIhQgIXwgDXwiH4VCIIkiGHwiFyAUhUIoiSIUIB98IAV8Ih8gGIVCMIkiGCAXfCIXIBSFQgGJIhR8IAF8IiEgFiAafCIWIBUgHSAehUIBiSIaIBx8IAl8IhyFQiCJIhV8Ih0gGoVCKIkiGiAcfCAIfCIcIBWFQjCJIhWFQiCJIh4gGSAOIBYgIIVCAYkiFiAPfCACfCIPhUIgiSIOfCIZIBaFQiiJIhYgD3wgC3wiDyAOhUIwiSIOIBl8Ihl8IiAgFIVCKIkiFCAhfCAEfCIhIB6FQjCJIh4gIHwiICAiICOFQjCJIiIgJHwiIyAbhUIBiSIbIBx8IAp8IhwgDoVCIIkiDiAXfCIXIBuFQiiJIhsgHHwgE3wiHCAOhUIwiSIOIBkgFoVCAYkiFiAffCAQfCIZICKFQiCJIh8gFSAdfCIVfCIdIBaFQiiJIhYgGXwgB3wiGSAfhUIwiSIfIB18Ih0gFoVCAYkiFiAVIBqFQgGJIhUgD3wgBnwiDyAYhUIgiSIYICN8IhogFYVCKIkiFSAPfCADfCIPfCAHfCIihUIgiSIjfCIkIBaFQiiJIhYgInwgBnwiIiAjhUIwiSIjICR8IiQgFoVCAYkiFiAOIBd8Ig4gDyAYhUIwiSIPICAgFIVCAYkiFCAZfCAKfCIXhUIgiSIYfCIZIBSFQiiJIhQgF3wgC3wiF3wgBXwiICAPIBp8Ig8gHyAOIBuFQgGJIg4gIXwgCHwiGoVCIIkiG3wiHyAOhUIoiSIOIBp8IAx8IhogG4VCMIkiG4VCIIkiISAdIB4gDyAVhUIBiSIPIBx8IAF8IhWFQiCJIhx8Ih0gD4VCKIkiDyAVfCADfCIVIByFQjCJIhwgHXwiHXwiHiAWhUIoiSIWICB8IA18IiAgIYVCMIkiISAefCIeIBogFyAYhUIwiSIXIBl8IhggFIVCAYkiFHwgCXwiGSAchUIgiSIaICR8IhwgFIVCKIkiFCAZfCACfCIZIBqFQjCJIhogHSAPhUIBiSIPICJ8IAR8Ih0gF4VCIIkiFyAbIB98Iht8Ih8gD4VCKIkiDyAdfCASfCIdIBeFQjCJIhcgH3wiHyAPhUIBiSIPIBsgDoVCAYkiDiAVfCATfCIVICOFQiCJIhsgGHwiGCAOhUIoiSIOIBV8IBB8IhV8IAx8IiKFQiCJIiN8IiQgD4VCKIkiDyAifCAHfCIiICOFQjCJIiMgJHwiJCAPhUIBiSIPIBogHHwiGiAVIBuFQjCJIhUgHiAWhUIBiSIWIB18IAR8IhuFQiCJIhx8Ih0gFoVCKIkiFiAbfCAQfCIbfCABfCIeIBUgGHwiFSAXIBogFIVCAYkiFCAgfCATfCIYhUIgiSIXfCIaIBSFQiiJIhQgGHwgCXwiGCAXhUIwiSIXhUIgiSIgIB8gISAVIA6FQgGJIg4gGXwgCnwiFYVCIIkiGXwiHyAOhUIoiSIOIBV8IA18IhUgGYVCMIkiGSAffCIffCIhIA+FQiiJIg8gHnwgBXwiHiAghUIwiSIgICF8IiEgGyAchUIwiSIbIB18IhwgFoVCAYkiFiAYfCADfCIYIBmFQiCJIhkgJHwiHSAWhUIoiSIWIBh8IBJ8IhggGYVCMIkiGSAfIA6FQgGJIg4gInwgAnwiHyAbhUIgiSIbIBcgGnwiF3wiGiAOhUIoiSIOIB98IAZ8Ih8gG4VCMIkiGyAafCIaIA6FQgGJIg4gFSAXIBSFQgGJIhR8IAh8IhUgI4VCIIkiFyAcfCIcIBSFQiiJIhQgFXwgC3wiFXwgBXwiIoVCIIkiI3wiJCAOhUIoiSIOICJ8IAh8IiIgGiAgIBUgF4VCMIkiFSAcfCIXIBSFQgGJIhQgGHwgCXwiGIVCIIkiHHwiGiAUhUIoiSIUIBh8IAZ8IhggHIVCMIkiHCAafCIaIBSFQgGJIhR8IAR8IiAgGSAdfCIZIBUgISAPhUIBiSIPIB98IAN8Ih2FQiCJIhV8Ih8gD4VCKIkiDyAdfCACfCIdIBWFQjCJIhWFQiCJIiEgFyAbIBkgFoVCAYkiFiAefCABfCIZhUIgiSIbfCIXIBaFQiiJIhYgGXwgE3wiGSAbhUIwiSIbIBd8Ihd8Ih4gFIVCKIkiFCAgfCAMfCIgICGFQjCJIiEgHnwiHiAiICOFQjCJIiIgJHwiIyAOhUIBiSIOIB18IBJ8Ih0gG4VCIIkiGyAafCIaIA6FQiiJIg4gHXwgC3wiHSAbhUIwiSIbIBcgFoVCAYkiFiAYfCANfCIXICKFQiCJIhggFSAffCIVfCIfIBaFQiiJIhYgF3wgEHwiFyAYhUIwiSIYIB98Ih8gFoVCAYkiFiAVIA+FQgGJIg8gGXwgCnwiFSAchUIgiSIZICN8IhwgD4VCKIkiDyAVfCAHfCIVfCASfCIihUIgiSIjfCIkIBaFQiiJIhYgInwgBXwiIiAjhUIwiSIjICR8IiQgFoVCAYkiFiAbIBp8IhogFSAZhUIwiSIVIB4gFIVCAYkiFCAXfCADfCIXhUIgiSIZfCIbIBSFQiiJIhQgF3wgB3wiF3wgAnwiHiAVIBx8IhUgGCAaIA6FQgGJIg4gIHwgC3wiGoVCIIkiGHwiHCAOhUIoiSIOIBp8IAR8IhogGIVCMIkiGIVCIIkiICAfICEgFSAPhUIBiSIPIB18IAZ8IhWFQiCJIh18Ih8gD4VCKIkiDyAVfCAKfCIVIB2FQjCJIh0gH3wiH3wiISAWhUIoiSIWIB58IAx8Ih4gIIVCMIkiICAhfCIhIBogFyAZhUIwiSIXIBt8IhkgFIVCAYkiFHwgEHwiGiAdhUIgiSIbICR8Ih0gFIVCKIkiFCAafCAJfCIaIBuFQjCJIhsgHyAPhUIBiSIPICJ8IBN8Ih8gF4VCIIkiFyAYIBx8Ihh8IhwgD4VCKIkiDyAffCABfCIfIBeFQjCJIhcgHHwiHCAPhUIBiSIPIBggDoVCAYkiDiAVfCAIfCIVICOFQiCJIhggGXwiGSAOhUIoiSIOIBV8IA18IhV8IA18IiKFQiCJIiN8IiQgD4VCKIkiDyAifCAMfCIiICOFQjCJIiMgJHwiJCAPhUIBiSIPIBsgHXwiGyAVIBiFQjCJIhUgISAWhUIBiSIWIB98IBB8IhiFQiCJIh18Ih8gFoVCKIkiFiAYfCAIfCIYfCASfCIhIBUgGXwiFSAXIBsgFIVCAYkiFCAefCAHfCIZhUIgiSIXfCIbIBSFQiiJIhQgGXwgAXwiGSAXhUIwiSIXhUIgiSIeIBwgICAVIA6FQgGJIg4gGnwgAnwiFYVCIIkiGnwiHCAOhUIoiSIOIBV8IAV8IhUgGoVCMIkiGiAcfCIcfCIgIA+FQiiJIg8gIXwgBHwiISAehUIwiSIeICB8IiAgGCAdhUIwiSIYIB98Ih0gFoVCAYkiFiAZfCAGfCIZIBqFQiCJIhogJHwiHyAWhUIoiSIWIBl8IBN8IhkgGoVCMIkiGiAcIA6FQgGJIg4gInwgCXwiHCAYhUIgiSIYIBcgG3wiF3wiGyAOhUIoiSIOIBx8IAN8IhwgGIVCMIkiGCAbfCIbIA6FQgGJIg4gFSAXIBSFQgGJIhR8IAt8IhUgI4VCIIkiFyAdfCIdIBSFQiiJIhQgFXwgCnwiFXwgBHwiIoVCIIkiI3wiJCAOhUIoiSIOICJ8IAl8IiIgGyAeIBUgF4VCMIkiFSAdfCIXIBSFQgGJIhQgGXwgDHwiGYVCIIkiHXwiGyAUhUIoiSIUIBl8IAp8IhkgHYVCMIkiHSAbfCIbIBSFQgGJIhR8IAN8Ih4gGiAffCIaIBUgICAPhUIBiSIPIBx8IAd8IhyFQiCJIhV8Ih8gD4VCKIkiDyAcfCAQfCIcIBWFQjCJIhWFQiCJIiAgFyAYIBogFoVCAYkiFiAhfCATfCIahUIgiSIYfCIXIBaFQiiJIhYgGnwgDXwiGiAYhUIwiSIYIBd8Ihd8IiEgFIVCKIkiFCAefCAFfCIeICCFQjCJIiAgIXwiISAiICOFQjCJIiIgJHwiIyAOhUIBiSIOIBx8IAt8IhwgGIVCIIkiGCAbfCIbIA6FQiiJIg4gHHwgEnwiHCAYhUIwiSIYIBcgFoVCAYkiFiAZfCABfCIXICKFQiCJIhkgFSAffCIVfCIfIBaFQiiJIhYgF3wgBnwiFyAZhUIwiSIZIB98Ih8gFoVCAYkiFiAVIA+FQgGJIg8gGnwgCHwiFSAdhUIgiSIaICN8Ih0gD4VCKIkiDyAVfCACfCIVfCANfCIihUIgiSIjfCIkIBaFQiiJIhYgInwgCXwiIiAjhUIwiSIjICR8IiQgFoVCAYkiFiAYIBt8IhggFSAahUIwiSIVICEgFIVCAYkiFCAXfCASfCIXhUIgiSIafCIbIBSFQiiJIhQgF3wgCHwiF3wgB3wiISAVIB18IhUgGSAYIA6FQgGJIg4gHnwgBnwiGIVCIIkiGXwiHSAOhUIoiSIOIBh8IAt8IhggGYVCMIkiGYVCIIkiHiAfICAgFSAPhUIBiSIPIBx8IAp8IhWFQiCJIhx8Ih8gD4VCKIkiDyAVfCAEfCIVIByFQjCJIhwgH3wiH3wiICAWhUIoiSIWICF8IAN8IiEgHoVCMIkiHiAgfCIgIBggFyAahUIwiSIXIBt8IhogFIVCAYkiFHwgBXwiGCAchUIgiSIbICR8IhwgFIVCKIkiFCAYfCABfCIYIBuFQjCJIhsgHyAPhUIBiSIPICJ8IAx8Ih8gF4VCIIkiFyAZIB18Ihl8Ih0gD4VCKIkiDyAffCATfCIfIBeFQjCJIhcgHXwiHSAPhUIBiSIPIBkgDoVCAYkiDiAVfCAQfCIVICOFQiCJIhkgGnwiGiAOhUIoiSIOIBV8IAJ8IhV8IBN8IiKFQiCJIiN8IiQgD4VCKIkiDyAifCASfCIiICOFQjCJIiMgJHwiJCAPhUIBiSIPIBsgHHwiGyAVIBmFQjCJIhUgICAWhUIBiSIWIB98IAt8IhmFQiCJIhx8Ih8gFoVCKIkiFiAZfCACfCIZfCAJfCIgIBUgGnwiFSAXIBsgFIVCAYkiFCAhfCAFfCIahUIgiSIXfCIbIBSFQiiJIhQgGnwgA3wiGiAXhUIwiSIXhUIgiSIhIB0gHiAVIA6FQgGJIg4gGHwgEHwiFYVCIIkiGHwiHSAOhUIoiSIOIBV8IAF8IhUgGIVCMIkiGCAdfCIdfCIeIA+FQiiJIg8gIHwgDXwiICAhhUIwiSIhIB58Ih4gGSAchUIwiSIZIB98IhwgFoVCAYkiFiAafCAIfCIaIBiFQiCJIhggJHwiHyAWhUIoiSIWIBp8IAp8IhogGIVCMIkiGCAdIA6FQgGJIg4gInwgBHwiHSAZhUIgiSIZIBcgG3wiF3wiGyAOhUIoiSIOIB18IAd8Ih0gGYVCMIkiGSAbfCIbIA6FQgGJIg4gFSAXIBSFQgGJIhR8IAx8IhUgI4VCIIkiFyAcfCIcIBSFQiiJIhQgFXwgBnwiFXwgEnwiIoVCIIkiI3wiJCAOhUIoiSIOICJ8IBN8IiIgGyAhIBUgF4VCMIkiFSAcfCIXIBSFQgGJIhQgGnwgBnwiGoVCIIkiHHwiGyAUhUIoiSIUIBp8IBB8IhogHIVCMIkiHCAbfCIbIBSFQgGJIhR8IA18IiEgGCAffCIYIBUgHiAPhUIBiSIPIB18IAJ8Ih2FQiCJIhV8Ih4gD4VCKIkiDyAdfCABfCIdIBWFQjCJIhWFQiCJIh8gFyAZIBggFoVCAYkiFiAgfCADfCIYhUIgiSIZfCIXIBaFQiiJIhYgGHwgBHwiGCAZhUIwiSIZIBd8Ihd8IiAgFIVCKIkiFCAhfCAIfCIhIB+FQjCJIh8gIHwiICAiICOFQjCJIiIgJHwiIyAOhUIBiSIOIB18IAd8Ih0gGYVCIIkiGSAbfCIbIA6FQiiJIg4gHXwgDHwiHSAZhUIwiSIZIBcgFoVCAYkiFiAafCALfCIXICKFQiCJIhogFSAefCIVfCIeIBaFQiiJIhYgF3wgCXwiFyAahUIwiSIaIB58Ih4gFoVCAYkiFiAVIA+FQgGJIg8gGHwgBXwiFSAchUIgiSIYICN8IhwgD4VCKIkiDyAVfCAKfCIVfCACfCIChUIgiSIifCIjIBaFQiiJIhYgAnwgC3wiAiAihUIwiSILICN8IiIgFoVCAYkiFiAZIBt8IhkgFSAYhUIwiSIVICAgFIVCAYkiFCAXfCANfCINhUIgiSIXfCIYIBSFQiiJIhQgDXwgBXwiBXwgEHwiECAVIBx8Ig0gGiAZIA6FQgGJIg4gIXwgDHwiDIVCIIkiFXwiGSAOhUIoiSIOIAx8IBJ8IhIgFYVCMIkiDIVCIIkiFSAeIB8gDSAPhUIBiSINIB18IAl8IgmFQiCJIg98IhogDYVCKIkiDSAJfCAIfCIJIA+FQjCJIgggGnwiD3wiGiAWhUIoiSIWIBB8IAd8IhAgEYUgDCAZfCIHIA6FQgGJIgwgCXwgCnwiCiALhUIgiSILIAUgF4VCMIkiBSAYfCIJfCIOIAyFQiiJIgwgCnwgE3wiEyALhUIwiSIKIA58IguFNwOAiQFBACADIAYgDyANhUIBiSINIAJ8fCICIAWFQiCJIgUgB3wiBiANhUIoiSIHIAJ8fCICQQApA4iJAYUgBCABIBIgCSAUhUIBiSIDfHwiASAIhUIgiSISICJ8IgkgA4VCKIkiAyABfHwiASAShUIwiSIEIAl8IhKFNwOIiQFBACATQQApA5CJAYUgECAVhUIwiSIQIBp8IhOFNwOQiQFBACABQQApA5iJAYUgAiAFhUIwiSICIAZ8IgGFNwOYiQFBACASIAOFQgGJQQApA6CJAYUgAoU3A6CJAUEAIBMgFoVCAYlBACkDqIkBhSAKhTcDqIkBQQAgASAHhUIBiUEAKQOwiQGFIASFNwOwiQFBACALIAyFQgGJQQApA7iJAYUgEIU3A7iJAQvdAgUBfwF+AX8BfgJ/IwBBwABrIgAkAAJAQQApA9CJAUIAUg0AQQBBACkDwIkBIgFBACgC4IoBIgKsfCIDNwPAiQFBAEEAKQPIiQEgAyABVK18NwPIiQECQEEALQDoigFFDQBBAEJ/NwPYiQELQQBCfzcD0IkBAkAgAkH/AEoNAEEAIQQDQCACIARqQeCJAWpBADoAACAEQQFqIgRBgAFBACgC4IoBIgJrSA0ACwtB4IkBEAIgAEEAKQOAiQE3AwAgAEEAKQOIiQE3AwggAEEAKQOQiQE3AxAgAEEAKQOYiQE3AxggAEEAKQOgiQE3AyAgAEEAKQOoiQE3AyggAEEAKQOwiQE3AzAgAEEAKQO4iQE3AzhBACgC5IoBIgVBAUgNAEEAIQRBACECA0AgBEGACWogACAEai0AADoAACAEQQFqIQQgBSACQQFqIgJB/wFxSg0ACwsgAEHAAGokAAv9AwMBfwF+AX8jAEGAAWsiAiQAQQBBgQI7AfKKAUEAIAE6APGKAUEAIAA6APCKAUGQfiEAA0AgAEGAiwFqQgA3AAAgAEH4igFqQgA3AAAgAEHwigFqQgA3AAAgAEEYaiIADQALQQAhAEEAQQApA/CKASIDQoiS853/zPmE6gCFNwOAiQFBAEEAKQP4igFCu86qptjQ67O7f4U3A4iJAUEAQQApA4CLAUKr8NP0r+68tzyFNwOQiQFBAEEAKQOIiwFC8e30+KWn/aelf4U3A5iJAUEAQQApA5CLAULRhZrv+s+Uh9EAhTcDoIkBQQBBACkDmIsBQp/Y+dnCkdqCm3+FNwOoiQFBAEEAKQOgiwFC6/qG2r+19sEfhTcDsIkBQQBBACkDqIsBQvnC+JuRo7Pw2wCFNwO4iQFBACADp0H/AXE2AuSKAQJAIAFBAUgNACACQgA3A3ggAkIANwNwIAJCADcDaCACQgA3A2AgAkIANwNYIAJCADcDUCACQgA3A0ggAkIANwNAIAJCADcDOCACQgA3AzAgAkIANwMoIAJCADcDICACQgA3AxggAkIANwMQIAJCADcDCCACQgA3AwBBACEEA0AgAiAAaiAAQYAJai0AADoAACAAQQFqIQAgBEEBaiIEQf8BcSABSA0ACyACQYABEAELIAJBgAFqJAALEgAgAEEDdkH/P3EgAEEQdhAECwkAQYAJIAAQAQsGAEGAiQELGwAgAUEDdkH/P3EgAUEQdhAEQYAJIAAQARADCwsLAQBBgAgLBPAAAAA=";
    hash$j = "c6f286e6";
    wasmJson$j = {
      name: name$j,
      data: data$j,
      hash: hash$j
    };
    mutex$k = new Mutex();
    wasmCache$k = null;
    uint32View = new DataView(new ArrayBuffer(4));
    validateOptions$3 = (options) => {
      var _a2;
      if (!options || typeof options !== "object") {
        throw new Error("Invalid options parameter. It requires an object.");
      }
      if (!options.password) {
        throw new Error("Password must be specified");
      }
      options.password = getUInt8Buffer(options.password);
      if (options.password.length < 1) {
        throw new Error("Password must be specified");
      }
      if (!options.salt) {
        throw new Error("Salt must be specified");
      }
      options.salt = getUInt8Buffer(options.salt);
      if (options.salt.length < 8) {
        throw new Error("Salt should be at least 8 bytes long");
      }
      options.secret = getUInt8Buffer((_a2 = options.secret) !== null && _a2 !== void 0 ? _a2 : "");
      if (!Number.isInteger(options.iterations) || options.iterations < 1) {
        throw new Error("Iterations should be a positive number");
      }
      if (!Number.isInteger(options.parallelism) || options.parallelism < 1) {
        throw new Error("Parallelism should be a positive number");
      }
      if (!Number.isInteger(options.hashLength) || options.hashLength < 4) {
        throw new Error("Hash length should be at least 4 bytes.");
      }
      if (!Number.isInteger(options.memorySize)) {
        throw new Error("Memory size should be specified.");
      }
      if (options.memorySize < 8 * options.parallelism) {
        throw new Error("Memory size should be at least 8 * parallelism.");
      }
      if (options.outputType === void 0) {
        options.outputType = "hex";
      }
      if (!["hex", "binary", "encoded"].includes(options.outputType)) {
        throw new Error(`Insupported output type ${options.outputType}. Valid values: ['hex', 'binary', 'encoded']`);
      }
    };
    getHashParameters = (password, encoded, secret) => {
      const regex = /^\$argon2(id|i|d)\$v=([0-9]+)\$((?:[mtp]=[0-9]+,){2}[mtp]=[0-9]+)\$([A-Za-z0-9+/]+)\$([A-Za-z0-9+/]+)$/;
      const match = encoded.match(regex);
      if (!match) {
        throw new Error("Invalid hash");
      }
      const [, hashType, version, parameters, salt, hash2] = match;
      if (version !== "19") {
        throw new Error(`Unsupported version: ${version}`);
      }
      const parsedParameters = {};
      const paramMap = { m: "memorySize", p: "parallelism", t: "iterations" };
      for (const x3 of parameters.split(",")) {
        const [n2, v9] = x3.split("=");
        parsedParameters[paramMap[n2]] = Number(v9);
      }
      return Object.assign(Object.assign({}, parsedParameters), {
        password,
        secret,
        hashType,
        salt: decodeBase64(salt),
        hashLength: getDecodeBase64Length(hash2),
        outputType: "encoded"
      });
    };
    validateVerifyOptions$1 = (options) => {
      if (!options || typeof options !== "object") {
        throw new Error("Invalid options parameter. It requires an object.");
      }
      if (options.hash === void 0 || typeof options.hash !== "string") {
        throw new Error("Hash should be specified");
      }
    };
    name$i = "blake2s";
    data$i = "AGFzbQEAAAABEQRgAAF/YAJ/fwBgAX8AYAAAAwkIAAECAwICAAEFBAEBAgIGDgJ/AUGgigULfwBBgAgLB3AIBm1lbW9yeQIADkhhc2hfR2V0QnVmZmVyAAAKSGFzaF9GaW5hbAADCUhhc2hfSW5pdAAEC0hhc2hfVXBkYXRlAAUNSGFzaF9HZXRTdGF0ZQAGDkhhc2hfQ2FsY3VsYXRlAAcKU1RBVEVfU0laRQMBCr4yCAUAQYAJC6gFAQZ/AkAgAUEBSA0AAkACQAJAIAFBwABBACgC8IkBIgJrIgNKDQAgASEDDAELQQBBADYC8IkBAkAgAkHAAEYNACACQbCJAWohBAJAAkAgA0EHcSIFDQAgACEGIAMhBwwBCyAFIQcgACEGA0AgBCAGLQAAOgAAIARBAWohBCAGQQFqIQYgB0F/aiIHDQALQcAAIAIgBWprIQcLIAJBR2pBB0kNAANAIAQgBi0AADoAACAEIAYtAAE6AAEgBCAGLQACOgACIAQgBi0AAzoAAyAEIAYtAAQ6AAQgBCAGLQAFOgAFIAQgBi0ABjoABiAEIAYtAAc6AAcgBEEIaiEEIAZBCGohBiAHQXhqIgcNAAsLQQAhBEEAQQAoAqCJASIGQcAAajYCoIkBQQBBACgCpIkBIAZBv39LajYCpIkBQbCJARACIAAgA2ohAAJAIAEgA2siA0HBAEgNACACIAFqIQQDQEEAQQAoAqCJASIGQcAAajYCoIkBQQBBACgCpIkBIAZBv39LajYCpIkBIAAQAiAAQcAAaiEAIAQiBkFAaiIEQYABSw0ACyAGQYB/aiEDQQAoAvCJASECDAELQQAoAvCJASECIANFDQELIANBf2ohASACQbCJAWohBAJAAkAgA0EHcSIGDQAgAyEHDAELIANBeHEhBwNAIAQgAC0AADoAACAEQQFqIQQgAEEBaiEAIAZBf2oiBg0ACwsCQCABQQdJDQADQCAEIAAtAAA6AAAgBCAALQABOgABIAQgAC0AAjoAAiAEIAAtAAM6AAMgBCAALQAEOgAEIAQgAC0ABToABSAEIAAtAAY6AAYgBCAALQAHOgAHIARBCGohBCAAQQhqIQAgB0F4aiIHDQALC0EAKALwiQEhAiADIQQLQQAgAiAEajYC8IkBCwuXJwoBfgF/An4CfwF+B38DfgZ/AX4Sf0EAQQApA5iJASIBpyICQQApA4iJASIDp2ogACkDECIEpyIFaiIGQQApA6iJAUKrs4/8kaOz8NsAhSIHp3NBEHciCEHy5rvjA2oiCSACc0EUdyIKIAZqIARCIIinIgJqIgsgCHNBGHciDCAJaiINIApzQRl3Ig5BACkDkIkBIgRCIIinIghBACkDgIkBIg9CIIinaiAAKQMIIhCnIgZqIglBACkDoIkBQv+kuYjFkdqCm3+FIhFCIIinc0EQdyISQYXdntt7aiITIAhzQRR3IhQgCWogEEIgiKciCGoiFWogACkDKCIQpyIJaiIWIASnIhcgD6dqIAApAwAiGKciCmoiGSARp3NBEHciGkHnzKfQBmoiGyAXc0EUdyIcIBlqIBhCIIinIhdqIh0gGnNBGHciHnNBEHciHyABQiCIpyIaIANCIIinaiAAKQMYIgGnIhlqIiAgB0IgiKdzQRB3IiFBuuq/qnpqIiIgGnNBFHciIyAgaiABQiCIpyIaaiIgICFzQRh3IiEgImoiImoiJCAOc0EUdyIlIBZqIBBCIIinIg5qIhYgH3NBGHciHyAkaiIkIBUgEnNBGHciFSATaiImIBRzQRl3IhMgHWogACkDICIBpyISaiIUICFzQRB3Ih0gDWoiISATc0EUdyInIBRqIAFCIIinIg1qIhQgHXNBGHciHSAiICNzQRl3IhMgC2ogACkDMCIBpyILaiIiIBVzQRB3IhUgHiAbaiIbaiIeIBNzQRR3IiMgImogAUIgiKciE2oiIiAVc0EYdyIVIB5qIh4gI3NBGXciIyAgIBsgHHNBGXciG2ogACkDOCIBpyIAaiIcIAxzQRB3IiAgJmoiJiAbc0EUdyIbIBxqIAFCIIinIgxqIhxqIBNqIihzQRB3IilqIiogI3NBFHciIyAoaiAZaiIoIB4gHyAcICBzQRh3IhwgJmoiICAbc0EZdyIbIBRqIABqIhRzQRB3Ih9qIh4gG3NBFHciGyAUaiAJaiIUIB9zQRh3Ih8gHmoiHiAbc0EZdyIbaiACaiImIB0gIWoiHSAcICQgJXNBGXciISAiaiANaiIic0EQdyIcaiIkICFzQRR3IiEgImogDGoiIiAcc0EYdyIcc0EQdyIlICAgFSAdICdzQRl3Ih0gFmogBWoiFnNBEHciFWoiICAdc0EUdyIdIBZqIBJqIhYgFXNBGHciFSAgaiIgaiInIBtzQRR3IhsgJmogCGoiJiAlc0EYdyIlICdqIicgKCApc0EYdyIoICpqIikgI3NBGXciIyAiaiAOaiIiIBVzQRB3IhUgHmoiHiAjc0EUdyIjICJqIBpqIiIgFXNBGHciFSAgIB1zQRl3Ih0gFGogF2oiFCAoc0EQdyIgIBwgJGoiHGoiJCAdc0EUdyIdIBRqIAtqIhQgIHNBGHciICAkaiIkIB1zQRl3Ih0gHCAhc0EZdyIcIBZqIApqIhYgH3NBEHciHyApaiIhIBxzQRR3IhwgFmogBmoiFmogC2oiKHNBEHciKWoiKiAdc0EUdyIdIChqIApqIiggKXNBGHciKSAqaiIqIB1zQRl3Ih0gFSAeaiIVIBYgH3NBGHciFiAnIBtzQRl3IhsgFGogDmoiFHNBEHciHmoiHyAbc0EUdyIbIBRqIBJqIhRqIAlqIicgFiAhaiIWICAgFSAjc0EZdyIVICZqIAxqIiFzQRB3IiBqIiMgFXNBFHciFSAhaiATaiIhICBzQRh3IiBzQRB3IiYgJCAlIBYgHHNBGXciFiAiaiACaiIcc0EQdyIiaiIkIBZzQRR3IhYgHGogBmoiHCAic0EYdyIiICRqIiRqIiUgHXNBFHciHSAnaiAAaiInICZzQRh3IiYgJWoiJSAhIBQgHnNBGHciFCAfaiIeIBtzQRl3IhtqIA1qIh8gInNBEHciISAqaiIiIBtzQRR3IhsgH2ogBWoiHyAhc0EYdyIhICQgFnNBGXciFiAoaiAIaiIkIBRzQRB3IhQgICAjaiIgaiIjIBZzQRR3IhYgJGogGWoiJCAUc0EYdyIUICNqIiMgFnNBGXciFiAgIBVzQRl3IhUgHGogGmoiHCApc0EQdyIgIB5qIh4gFXNBFHciFSAcaiAXaiIcaiATaiIoc0EQdyIpaiIqIBZzQRR3IhYgKGogC2oiKCApc0EYdyIpICpqIiogFnNBGXciFiAhICJqIiEgHCAgc0EYdyIcICUgHXNBGXciHSAkaiAIaiIgc0EQdyIiaiIkIB1zQRR3Ih0gIGogF2oiIGogAmoiJSAcIB5qIhwgFCAhIBtzQRl3IhsgJ2ogGmoiHnNBEHciFGoiISAbc0EUdyIbIB5qIA1qIh4gFHNBGHciFHNBEHciJyAjICYgHCAVc0EZdyIVIB9qIA5qIhxzQRB3Ih9qIiMgFXNBFHciFSAcaiAAaiIcIB9zQRh3Ih8gI2oiI2oiJiAWc0EUdyIWICVqIAlqIiUgJ3NBGHciJyAmaiImICAgInNBGHciICAkaiIiIB1zQRl3Ih0gHmogBmoiHiAfc0EQdyIfICpqIiQgHXNBFHciHSAeaiAZaiIeIB9zQRh3Ih8gIyAVc0EZdyIVIChqIAVqIiMgIHNBEHciICAUICFqIhRqIiEgFXNBFHciFSAjaiAKaiIjICBzQRh3IiAgIWoiISAVc0EZdyIVIBwgFCAbc0EZdyIUaiAMaiIbIClzQRB3IhwgImoiIiAUc0EUdyIUIBtqIBJqIhtqIAlqIihzQRB3IilqIiogFXNBFHciFSAoaiAMaiIoICEgJyAbIBxzQRh3IhsgImoiHCAUc0EZdyIUIB5qIA1qIh5zQRB3IiJqIiEgFHNBFHciFCAeaiAKaiIeICJzQRh3IiIgIWoiISAUc0EZdyIUaiAIaiInIB8gJGoiHyAbICYgFnNBGXciFiAjaiAGaiIjc0EQdyIbaiIkIBZzQRR3IhYgI2ogBWoiIyAbc0EYdyIbc0EQdyImIBwgICAfIB1zQRl3Ih0gJWogAmoiH3NBEHciIGoiHCAdc0EUdyIdIB9qIBpqIh8gIHNBGHciICAcaiIcaiIlIBRzQRR3IhQgJ2ogE2oiJyAmc0EYdyImICVqIiUgKCApc0EYdyIoICpqIikgFXNBGXciFSAjaiAZaiIjICBzQRB3IiAgIWoiISAVc0EUdyIVICNqIBJqIiMgIHNBGHciICAcIB1zQRl3IhwgHmogAGoiHSAoc0EQdyIeIBsgJGoiG2oiJCAcc0EUdyIcIB1qIBdqIh0gHnNBGHciHiAkaiIkIBxzQRl3IhwgGyAWc0EZdyIWIB9qIA5qIhsgInNBEHciHyApaiIiIBZzQRR3IhYgG2ogC2oiG2ogGWoiKHNBEHciKWoiKiAcc0EUdyIcIChqIAlqIiggKXNBGHciKSAqaiIqIBxzQRl3IhwgICAhaiIgIBsgH3NBGHciGyAlIBRzQRl3IhQgHWogBmoiHXNBEHciH2oiISAUc0EUdyIUIB1qIAtqIh1qIAVqIiUgGyAiaiIbIB4gICAVc0EZdyIVICdqIBJqIiBzQRB3Ih5qIiIgFXNBFHciFSAgaiAIaiIgIB5zQRh3Ih5zQRB3IicgJCAmIBsgFnNBGXciFiAjaiAKaiIbc0EQdyIjaiIkIBZzQRR3IhYgG2ogDmoiGyAjc0EYdyIjICRqIiRqIiYgHHNBFHciHCAlaiATaiIlICdzQRh3IicgJmoiJiAgIB0gH3NBGHciHSAhaiIfIBRzQRl3IhRqIBdqIiAgI3NBEHciISAqaiIjIBRzQRR3IhQgIGogDWoiICAhc0EYdyIhICQgFnNBGXciFiAoaiAaaiIkIB1zQRB3Ih0gHiAiaiIeaiIiIBZzQRR3IhYgJGogAmoiJCAdc0EYdyIdICJqIiIgFnNBGXciFiAeIBVzQRl3IhUgG2ogDGoiGyApc0EQdyIeIB9qIh8gFXNBFHciFSAbaiAAaiIbaiAAaiIoc0EQdyIpaiIqIBZzQRR3IhYgKGogE2oiKCApc0EYdyIpICpqIiogFnNBGXciFiAhICNqIiEgGyAec0EYdyIbICYgHHNBGXciHCAkaiAXaiIec0EQdyIjaiIkIBxzQRR3IhwgHmogDGoiHmogGWoiJiAbIB9qIhsgHSAhIBRzQRl3IhQgJWogC2oiH3NBEHciHWoiISAUc0EUdyIUIB9qIAJqIh8gHXNBGHciHXNBEHciJSAiICcgGyAVc0EZdyIVICBqIAVqIhtzQRB3IiBqIiIgFXNBFHciFSAbaiAJaiIbICBzQRh3IiAgImoiImoiJyAWc0EUdyIWICZqIAhqIiYgJXNBGHciJSAnaiInIB4gI3NBGHciHiAkaiIjIBxzQRl3IhwgH2ogCmoiHyAgc0EQdyIgICpqIiQgHHNBFHciHCAfaiAaaiIfICBzQRh3IiAgIiAVc0EZdyIVIChqIA1qIiIgHnNBEHciHiAdICFqIh1qIiEgFXNBFHciFSAiaiAGaiIiIB5zQRh3Ih4gIWoiISAVc0EZdyIVIBsgHSAUc0EZdyIUaiASaiIbIClzQRB3Ih0gI2oiIyAUc0EUdyIUIBtqIA5qIhtqIAhqIihzQRB3IilqIiogFXNBFHciFSAoaiANaiIoICEgJSAbIB1zQRh3IhsgI2oiHSAUc0EZdyIUIB9qIBNqIh9zQRB3IiNqIiEgFHNBFHciFCAfaiAOaiIfICNzQRh3IiMgIWoiISAUc0EZdyIUaiAGaiIlICAgJGoiICAbICcgFnNBGXciFiAiaiALaiIic0EQdyIbaiIkIBZzQRR3IhYgImogF2oiIiAbc0EYdyIbc0EQdyInIB0gHiAgIBxzQRl3IhwgJmogGmoiIHNBEHciHmoiHSAcc0EUdyIcICBqIABqIiAgHnNBGHciHiAdaiIdaiImIBRzQRR3IhQgJWogCWoiJSAnc0EYdyInICZqIiYgKCApc0EYdyIoICpqIikgFXNBGXciFSAiaiASaiIiIB5zQRB3Ih4gIWoiISAVc0EUdyIVICJqIBlqIiIgHnNBGHciHiAdIBxzQRl3IhwgH2ogAmoiHSAoc0EQdyIfIBsgJGoiG2oiJCAcc0EUdyIcIB1qIApqIh0gH3NBGHciHyAkaiIkIBxzQRl3IhwgGyAWc0EZdyIWICBqIAxqIhsgI3NBEHciICApaiIjIBZzQRR3IhYgG2ogBWoiG2ogAGoiKHNBEHciKWoiKiAcc0EUdyIcIChqIA1qIiggKXNBGHciKSAqaiIqIBxzQRl3IhwgHiAhaiIeIBsgIHNBGHciGyAmIBRzQRl3IhQgHWogGWoiHXNBEHciIGoiISAUc0EUdyIUIB1qIAxqIh1qIAtqIiYgGyAjaiIbIB8gHiAVc0EZdyIVICVqIApqIh5zQRB3Ih9qIiMgFXNBFHciFSAeaiASaiIeIB9zQRh3Ih9zQRB3IiUgJCAnIBsgFnNBGXciFiAiaiAOaiIbc0EQdyIiaiIkIBZzQRR3IhYgG2ogCGoiGyAic0EYdyIiICRqIiRqIicgHHNBFHciHCAmaiAGaiImICVzQRh3IiUgJ2oiJyAeIB0gIHNBGHciHSAhaiIgIBRzQRl3IhRqIAlqIh4gInNBEHciISAqaiIiIBRzQRR3IhQgHmogAmoiHiAhc0EYdyIhICQgFnNBGXciFiAoaiATaiIkIB1zQRB3Ih0gHyAjaiIfaiIjIBZzQRR3IhYgJGogGmoiJCAdc0EYdyIdICNqIiMgFnNBGXciFiAfIBVzQRl3IhUgG2ogF2oiGyApc0EQdyIfICBqIiAgFXNBFHciFSAbaiAFaiIbaiAaaiIac0EQdyIoaiIpIBZzQRR3IhYgGmogGWoiGSAoc0EYdyIaIClqIiggFnNBGXciFiAhICJqIiEgGyAfc0EYdyIbICcgHHNBGXciHCAkaiASaiISc0EQdyIfaiIiIBxzQRR3IhwgEmogBWoiBWogDWoiEiAbICBqIg0gHSAhIBRzQRl3IhQgJmogCWoiCXNBEHciG2oiHSAUc0EUdyIUIAlqIAZqIgYgG3NBGHciCXNBEHciGyAjICUgDSAVc0EZdyINIB5qIBdqIhdzQRB3IhVqIh4gDXNBFHciDSAXaiACaiICIBVzQRh3IhcgHmoiFWoiHiAWc0EUdyIWIBJqIABqIhKtQiCGIAUgH3NBGHciBSAiaiIAIBxzQRl3IhwgBmogDGoiBiAXc0EQdyIXIChqIgwgHHNBFHciHCAGaiAOaiIGrYQgD4UgAiAJIB1qIgkgFHNBGXciDmogE2oiAiAac0EQdyIaIABqIhMgDnNBFHciDiACaiAKaiICIBpzQRh3IgogE2oiGq1CIIYgFSANc0EZdyINIBlqIAhqIgggBXNBEHciBSAJaiIJIA1zQRR3IhkgCGogC2oiCCAFc0EYdyIFIAlqIgmthIU3A4CJAUEAIAMgAq1CIIYgCK2EhSASIBtzQRh3IgIgHmoiCK1CIIYgBiAXc0EYdyIGIAxqIhethIU3A4iJAUEAIAQgFyAcc0EZd61CIIYgGiAOc0EZd62EhSAFrUIghiACrYSFNwOQiQFBACAJIBlzQRl3rUIghiAIIBZzQRl3rYRBACkDmIkBhSAGrUIghiAKrYSFNwOYiQELnQIBBH8jAEEgayIAJAACQEEAKAKoiQENAEEAQQAoAqCJASIBQQAoAvCJASICaiIDNgKgiQFBAEEAKAKkiQEgAyABSWo2AqSJAQJAQQAtAPiJAUUNAEEAQX82AqyJAQtBAEF/NgKoiQECQCACQT9KDQBBACEBA0AgAiABakGwiQFqQQA6AAAgAUEBaiIBQcAAQQAoAvCJASICa0gNAAsLQbCJARACIABBACkDgIkBNwMAIABBACkDiIkBNwMIIABBACkDkIkBNwMQIABBACkDmIkBNwMYQQAoAvSJASIDQQFIDQBBACEBQQAhAgNAIAFBgAlqIAAgAWotAAA6AAAgAUEBaiEBIAMgAkEBaiICQf8BcUoNAAsLIABBIGokAAuyAwEEfyMAQcAAayIBJABBAEGBAjsBgooBQQAgAEEQdiICOgCBigFBACAAQQN2OgCAigFBiH8hAwJAA0AgA0H4iQFqQQA2AgAgA0UNASADQfyJAWpBADYCACADQQhqIQMMAAsLQQAhA0EAQQAoAoCKASIEQefMp9AGczYCgIkBQQBBACgChIoBQYXdntt7czYChIkBQQBBACgCiIoBQfLmu+MDczYCiIkBQQBBACgCjIoBQbrqv6p6czYCjIkBQQBBACgCkIoBQf+kuYgFczYCkIkBQQBBACgClIoBQYzRldh5czYClIkBQQBBACgCmIoBQauzj/wBczYCmIkBQQAgBEH/AXE2AvSJAUEAQQAoApyKAUGZmoPfBXM2ApyJAQJAIABBgIAESQ0AIAFBOGpCADcDACABQTBqQgA3AwAgAUEoakIANwMAIAFBIGpCADcDACABQRhqQgA3AwAgAUEQakIANwMAIAFCADcDCCABQgA3AwBBACEAA0AgASADaiADQYAJai0AADoAACADQQFqIQMgAiAAQQFqIgBB/wFxSw0ACyABQcAAEAELIAFBwABqJAALCQBBgAkgABABCwYAQYCJAQsPACABEARBgAkgABABEAMLCwsBAEGACAsEfAAAAA==";
    hash$i = "5c0ff166";
    wasmJson$i = {
      name: name$i,
      data: data$i,
      hash: hash$i
    };
    mutex$j = new Mutex();
    wasmCache$j = null;
    name$h = "blake3";
    data$h = "AGFzbQEAAAABMQdgAAF/YAl/f39+f39/f38AYAZ/f39/fn8AYAF/AGADf39/AGABfgBgBX9/fn9/AX8DDg0AAQIDBAUGAwMDAwAEBQQBAQICBg4CfwFBgJgFC38AQYAICwdwCAZtZW1vcnkCAA5IYXNoX0dldEJ1ZmZlcgAACUhhc2hfSW5pdAAIC0hhc2hfVXBkYXRlAAkKSGFzaF9GaW5hbAAKDUhhc2hfR2V0U3RhdGUACw5IYXNoX0NhbGN1bGF0ZQAMClNUQVRFX1NJWkUDAQqQWw0FAEGACQufAwIDfwV+IwBB4ABrIgkkAAJAIAFFDQAgByAFciEKIAdBACACQQFGGyAGciAFciELIARBAEetIQwDQCAAKAIAIQcgCUEAKQOAiQE3AwAgCUEAKQOIiQE3AwggCUEAKQOQiQE3AxAgCUEAKQOYiQE3AxggCUEgaiAJIAdBwAAgAyALEAIgCSAJKQNAIAkpAyCFIg03AwAgCSAJKQNIIAkpAyiFIg43AwggCSAJKQNQIAkpAzCFIg83AxAgCSAJKQNYIAkpAziFIhA3AxggB0HAAGohByACIQQCQANAIAUhBgJAAkAgBEF/aiIEDgIDAAELIAohBgsgCUEgaiAJIAdBwAAgAyAGEAIgCSAJKQNAIAkpAyCFIg03AwAgCSAJKQNIIAkpAyiFIg43AwggCSAJKQNQIAkpAzCFIg83AxAgCSAJKQNYIAkpAziFIhA3AxggB0HAAGohBwwACwsgCCAQNwMYIAggDzcDECAIIA43AwggCCANNwMAIAhBIGohCCAAQQRqIQAgAyAMfCEDIAFBf2oiAQ0ACwsgCUHgAGokAAv4GwIMfh9/IAIpAyghBiACKQM4IQcgAikDMCEIIAIpAxAhCSACKQMgIQogAikDACELIAIpAwghDCACKQMYIQ0gACABKQMAIg43AwAgACABKQMIIg83AwggACABKQMQIhA3AxAgACAPQiCIpyANpyICaiABKQMYIhFCIIinIhJqIhMgDUIgiKciAWogEyAFc0EQdyIUQbrqv6p6aiIVIBJzQRR3IhZqIhcgDqcgC6ciBWogEKciE2oiGCALQiCIpyISaiAYIASnc0EQdyIYQefMp9AGaiIZIBNzQRR3IhNqIhogGHNBGHciGyAZaiIcIBNzQRl3Ih1qIAenIhNqIh4gB0IgiKciGGogHiAPpyAJpyIZaiARpyIfaiIgIAlCIIinIiFqICAgA3NBEHciA0Hy5rvjA2oiICAfc0EUdyIfaiIiIANzQRh3IiNzQRB3IiQgDkIgiKcgDKciA2ogEEIgiKciJWoiJiAMQiCIpyIeaiAmIARCIIinc0EQdyImQYXdntt7aiInICVzQRR3IiVqIiggJnNBGHciJiAnaiInaiIpIB1zQRR3Ih1qIiogGWogFyAUc0EYdyIrIBVqIiwgFnNBGXciFiAiaiAIpyIUaiIXIAhCIIinIhVqIBcgJnNBEHciFyAcaiIcIBZzQRR3IhZqIiIgF3NBGHciJiAcaiItIBZzQRl3Ii5qIhwgFWogJyAlc0EZdyIlIBpqIAqnIhZqIhogCkIgiKciF2ogGiArc0EQdyIaICMgIGoiIGoiIyAlc0EUdyIlaiInIBpzQRh3IisgHHNBEHciLyAgIB9zQRl3Ih8gKGogBqciGmoiICAGQiCIpyIcaiAgIBtzQRB3IhsgLGoiICAfc0EUdyIfaiIoIBtzQRh3IhsgIGoiIGoiLCAuc0EUdyIuaiIwICcgA2ogKiAkc0EYdyIkIClqIicgHXNBGXciHWoiKSACaiAbIClzQRB3IhsgLWoiKSAdc0EUdyIdaiIqIBtzQRh3IhsgKWoiKSAdc0EZdyIdaiAYaiItIBZqIC0gIiABaiAgIB9zQRl3Ih9qIiAgBWogJCAgc0EQdyIgICsgI2oiImoiIyAfc0EUdyIfaiIkICBzQRh3IiBzQRB3IisgKCAeaiAiICVzQRl3IiJqIiUgGmogJiAlc0EQdyIlICdqIiYgInNBFHciImoiJyAlc0EYdyIlICZqIiZqIiggHXNBFHciHWoiLSABaiAwIC9zQRh3Ii8gLGoiLCAuc0EZdyIuICRqIBdqIiQgE2ogJCAlc0EQdyIkIClqIiUgLnNBFHciKWoiLiAkc0EYdyIkICVqIiUgKXNBGXciKWoiMCATaiAmICJzQRl3IiIgKmogEmoiJiAcaiAmIC9zQRB3IiYgICAjaiIgaiIjICJzQRR3IiJqIiogJnNBGHciJiAwc0EQdyIvICAgH3NBGXciHyAnaiAUaiIgICFqICAgG3NBEHciGyAsaiIgIB9zQRR3Ih9qIicgG3NBGHciGyAgaiIgaiIsIClzQRR3IilqIjAgKiAeaiAtICtzQRh3IiogKGoiKCAdc0EZdyIdaiIrIBlqIBsgK3NBEHciGyAlaiIlIB1zQRR3Ih1qIisgG3NBGHciGyAlaiIlIB1zQRl3Ih1qIBZqIi0gEmogLSAuIBVqICAgH3NBGXciH2oiICADaiAqICBzQRB3IiAgJiAjaiIjaiImIB9zQRR3Ih9qIiogIHNBGHciIHNBEHciLSAnIBpqICMgInNBGXciImoiIyAUaiAkICNzQRB3IiMgKGoiJCAic0EUdyIiaiInICNzQRh3IiMgJGoiJGoiKCAdc0EUdyIdaiIuIBVqIDAgL3NBGHciLyAsaiIsIClzQRl3IikgKmogHGoiKiAYaiAqICNzQRB3IiMgJWoiJSApc0EUdyIpaiIqICNzQRh3IiMgJWoiJSApc0EZdyIpaiIwIBhqICQgInNBGXciIiAraiACaiIkICFqICQgL3NBEHciJCAgICZqIiBqIiYgInNBFHciImoiKyAkc0EYdyIkIDBzQRB3Ii8gICAfc0EZdyIfICdqIBdqIiAgBWogICAbc0EQdyIbICxqIiAgH3NBFHciH2oiJyAbc0EYdyIbICBqIiBqIiwgKXNBFHciKWoiMCArIBpqIC4gLXNBGHciKyAoaiIoIB1zQRl3Ih1qIi0gAWogGyAtc0EQdyIbICVqIiUgHXNBFHciHWoiLSAbc0EYdyIbICVqIiUgHXNBGXciHWogEmoiLiACaiAuICogE2ogICAfc0EZdyIfaiIgIB5qICsgIHNBEHciICAkICZqIiRqIiYgH3NBFHciH2oiKiAgc0EYdyIgc0EQdyIrICcgFGogJCAic0EZdyIiaiIkIBdqICMgJHNBEHciIyAoaiIkICJzQRR3IiJqIicgI3NBGHciIyAkaiIkaiIoIB1zQRR3Ih1qIi4gE2ogMCAvc0EYdyIvICxqIiwgKXNBGXciKSAqaiAhaiIqIBZqICogI3NBEHciIyAlaiIlIClzQRR3IilqIiogI3NBGHciIyAlaiIlIClzQRl3IilqIjAgFmogJCAic0EZdyIiIC1qIBlqIiQgBWogJCAvc0EQdyIkICAgJmoiIGoiJiAic0EUdyIiaiItICRzQRh3IiQgMHNBEHciLyAgIB9zQRl3Ih8gJ2ogHGoiICADaiAgIBtzQRB3IhsgLGoiICAfc0EUdyIfaiInIBtzQRh3IhsgIGoiIGoiLCApc0EUdyIpaiIwIC9zQRh3Ii8gLGoiLCApc0EZdyIpICogGGogICAfc0EZdyIfaiIgIBpqIC4gK3NBGHciKiAgc0EQdyIgICQgJmoiJGoiJiAfc0EUdyIfaiIraiAFaiIuIBJqIC4gJyAXaiAkICJzQRl3IiJqIiQgHGogIyAkc0EQdyIjICogKGoiJGoiJyAic0EUdyIiaiIoICNzQRh3IiNzQRB3IiogLSAUaiAkIB1zQRl3Ih1qIiQgFWogGyAkc0EQdyIbICVqIiQgHXNBFHciHWoiJSAbc0EYdyIbICRqIiRqIi0gKXNBFHciKWoiLiAWaiArICBzQRh3IiAgJmoiJiAfc0EZdyIfIChqICFqIiggHmogKCAbc0EQdyIbICxqIiggH3NBFHciH2oiKyAbc0EYdyIbIChqIiggH3NBGXciH2oiLCAUaiAwICQgHXNBGXciHWogAmoiJCAZaiAkICBzQRB3IiAgIyAnaiIjaiIkIB1zQRR3Ih1qIicgIHNBGHciICAsc0EQdyIsICMgInNBGXciIiAlaiABaiIjIANqICMgL3NBEHciIyAmaiIlICJzQRR3IiJqIiYgI3NBGHciIyAlaiIlaiIvIB9zQRR3Ih9qIjAgLHNBGHciLCAvaiIvIB9zQRl3Ih8gKyAcaiAlICJzQRl3IiJqIiUgIWogLiAqc0EYdyIqICVzQRB3IiUgICAkaiIgaiIkICJzQRR3IiJqIitqIAVqIi4gGmogLiAmIBdqICAgHXNBGXciHWoiICATaiAbICBzQRB3IhsgKiAtaiIgaiImIB1zQRR3Ih1qIiogG3NBGHciG3NBEHciLSAnIBhqICAgKXNBGXciIGoiJyASaiAjICdzQRB3IiMgKGoiJyAgc0EUdyIgaiIoICNzQRh3IiMgJ2oiJ2oiKSAfc0EUdyIfaiIuICFqICsgJXNBGHciISAkaiIkICJzQRl3IiIgKmogFWoiJSAeaiAlICNzQRB3IiMgL2oiJSAic0EUdyIiaiIqICNzQRh3IiMgJWoiJSAic0EZdyIiaiIrIAVqICcgIHNBGXciBSAwaiADaiIgIAJqICAgIXNBEHciISAbICZqIhtqIiAgBXNBFHciBWoiJiAhc0EYdyIhICtzQRB3IicgKCAbIB1zQRl3IhtqIBlqIh0gAWogHSAsc0EQdyIdICRqIiQgG3NBFHciG2oiKCAdc0EYdyIdICRqIiRqIisgInNBFHciImoiLCAnc0EYdyInICtqIisgInNBGXciIiAqIBxqICQgG3NBGXciHGoiGyAYaiAuIC1zQRh3IhggG3NBEHciGyAhICBqIiFqIiAgHHNBFHciHGoiJGogE2oiEyAaaiATICggFmogISAFc0EZdyIFaiIhIAJqICMgIXNBEHciAiAYIClqIhhqIiEgBXNBFHciBWoiFiACc0EYdyICc0EQdyITICYgEmogGCAfc0EZdyISaiIYIBdqIB0gGHNBEHciGCAlaiIXIBJzQRR3IhJqIhogGHNBGHciGCAXaiIXaiIdICJzQRR3Ih9qIiI2AgAgACAXIBJzQRl3IhIgLGogA2oiAyAUaiADICQgG3NBGHciFHNBEHciAyACICFqIgJqIiEgEnNBFHciEmoiFyADc0EYdyIDNgIwIAAgFiAUICBqIhQgHHNBGXciHGogAWoiASAVaiABIBhzQRB3IgEgK2oiGCAcc0EUdyIVaiIWIAFzQRh3IgEgGGoiGCAVc0EZdzYCECAAIBc2AgQgACACIAVzQRl3IgIgGmogHmoiBSAZaiAFICdzQRB3IgUgFGoiGSACc0EUdyICaiIeIAVzQRh3IgU2AjQgACAFIBlqIgU2AiAgACAiIBNzQRh3IhMgHWoiGSAfc0EZdzYCFCAAIBg2AiQgACAeNgIIIAAgATYCOCAAIAMgIWoiASASc0EZdzYCGCAAIBk2AiggACAWNgIMIAAgEzYCPCAAIAUgAnNBGXc2AhwgACABNgIsC6USCwN/BH4CfwF+AX8EfgJ/AX4CfwF+BH8jAEHQAmsiASQAAkAgAEUNAAJAAkBBAC0AiYoBQQZ0QQAtAIiKAWoiAg0AQYAJIQMMAQtBoIkBQYAJQYAIIAJrIgIgACACIABJGyICEAQgACACayIARQ0BIAFBoAFqQQApA9CJATcDACABQagBakEAKQPYiQE3AwAgAUEAKQOgiQEiBDcDcCABQQApA6iJASIFNwN4IAFBACkDsIkBIgY3A4ABIAFBACkDuIkBIgc3A4gBIAFBACkDyIkBNwOYAUEALQCKigEhCEEALQCJigEhCUEAKQPAiQEhCkEALQCIigEhCyABQbABakEAKQPgiQE3AwAgAUG4AWpBACkD6IkBNwMAIAFBwAFqQQApA/CJATcDACABQcgBakEAKQP4iQE3AwAgAUHQAWpBACkDgIoBNwMAIAEgCzoA2AEgASAKNwOQASABIAggCUVyQQJyIgg6ANkBIAEgBzcD+AEgASAGNwPwASABIAU3A+gBIAEgBDcD4AEgASABQeABaiABQZgBaiALIAogCEH/AXEQAiABKQMgIQQgASkDACEFIAEpAyghBiABKQMIIQcgASkDMCEMIAEpAxAhDSABKQM4IQ4gASkDGCEPIAoQBUEAQgA3A4CKAUEAQgA3A/iJAUEAQgA3A/CJAUEAQgA3A+iJAUEAQgA3A+CJAUEAQgA3A9iJAUEAQgA3A9CJAUEAQgA3A8iJAUEAQQApA4CJATcDoIkBQQBBACkDiIkBNwOoiQFBAEEAKQOQiQE3A7CJAUEAQQApA5iJATcDuIkBQQBBAC0AkIoBIgtBAWo6AJCKAUEAQQApA8CJAUIBfDcDwIkBIAtBBXQiC0GpigFqIA4gD4U3AwAgC0GhigFqIAwgDYU3AwAgC0GZigFqIAYgB4U3AwAgC0GRigFqIAQgBYU3AwBBAEEAOwGIigEgAkGACWohAwsCQCAAQYEISQ0AQQApA8CJASEEIAFBKGohEANAIARCCoYhCkIBIABBAXKteUI/hYanIQIDQCACIhFBAXYhAiAKIBFBf2qtg0IAUg0ACyARQQp2rSESAkACQCARQYAISw0AIAFBADsB2AEgAUIANwPQASABQgA3A8gBIAFCADcDwAEgAUIANwO4ASABQgA3A7ABIAFCADcDqAEgAUIANwOgASABQgA3A5gBIAFBACkDgIkBNwNwIAFBACkDiIkBNwN4IAFBACkDkIkBNwOAASABQQAtAIqKAToA2gEgAUEAKQOYiQE3A4gBIAEgBDcDkAEgAUHwAGogAyAREAQgASABKQNwIgQ3AwAgASABKQN4IgU3AwggASABKQOAASIGNwMQIAEgASkDiAEiBzcDGCABIAEpA5gBNwMoIAEgASkDoAE3AzAgASABKQOoATcDOCABLQDaASECIAEtANkBIQsgASkDkAEhCiABIAEtANgBIgg6AGggASAKNwMgIAEgASkDsAE3A0AgASABKQO4ATcDSCABIAEpA8ABNwNQIAEgASkDyAE3A1ggASABKQPQATcDYCABIAIgC0VyQQJyIgI6AGkgASAHNwO4AiABIAY3A7ACIAEgBTcDqAIgASAENwOgAiABQeABaiABQaACaiAQIAggCiACQf8BcRACIAEpA4ACIQQgASkD4AEhBSABKQOIAiEGIAEpA+gBIQcgASkDkAIhDCABKQPwASENIAEpA5gCIQ4gASkD+AEhDyAKEAVBAEEALQCQigEiAkEBajoAkIoBIAJBBXQiAkGpigFqIA4gD4U3AwAgAkGhigFqIAwgDYU3AwAgAkGZigFqIAYgB4U3AwAgAkGRigFqIAQgBYU3AwAMAQsCQAJAIAMgESAEQQAtAIqKASICIAEQBiITQQJLDQAgASkDGCEKIAEpAxAhBCABKQMIIQUgASkDACEGDAELIAJBBHIhFEEAKQOYiQEhDUEAKQOQiQEhDkEAKQOIiQEhD0EAKQOAiQEhFQNAIBNBfmoiFkEBdiIXQQFqIhhBA3EhCEEAIQkCQCAWQQZJDQAgGEH8////B3EhGUEAIQkgAUHIAmohAiABIQsDQCACIAs2AgAgAkEMaiALQcABajYCACACQQhqIAtBgAFqNgIAIAJBBGogC0HAAGo2AgAgC0GAAmohCyACQRBqIQIgGSAJQQRqIglHDQALCwJAIAhFDQAgASAJQQZ0aiECIAFByAJqIAlBAnRqIQsDQCALIAI2AgAgAkHAAGohAiALQQRqIQsgCEF/aiIIDQALCyABQcgCaiELIAFBoAJqIQIgGCEIA0AgCygCACEJIAEgDTcD+AEgASAONwPwASABIA83A+gBIAEgFTcD4AEgAUHwAGogAUHgAWogCUHAAEIAIBQQAiABKQOQASEKIAEpA3AhBCABKQOYASEFIAEpA3ghBiABKQOgASEHIAEpA4ABIQwgAkEYaiABKQOoASABKQOIAYU3AwAgAkEQaiAHIAyFNwMAIAJBCGogBSAGhTcDACACIAogBIU3AwAgAkEgaiECIAtBBGohCyAIQX9qIggNAAsCQAJAIBZBfnFBAmogE0kNACAYIRMMAQsgAUGgAmogGEEFdGoiAiABIBhBBnRqIgspAwA3AwAgAiALKQMINwMIIAIgCykDEDcDECACIAspAxg3AxggF0ECaiETCyABIAEpA6ACIgY3AwAgASABKQOoAiIFNwMIIAEgASkDsAIiBDcDECABIAEpA7gCIgo3AxggE0ECSw0ACwsgASkDICEHIAEpAyghDCABKQMwIQ0gASkDOCEOQQApA8CJARAFQQBBAC0AkIoBIgJBAWo6AJCKASACQQV0IgJBqYoBaiAKNwMAIAJBoYoBaiAENwMAIAJBmYoBaiAFNwMAIAJBkYoBaiAGNwMAQQApA8CJASASQgGIfBAFQQBBAC0AkIoBIgJBAWo6AJCKASACQQV0IgJBqYoBaiAONwMAIAJBoYoBaiANNwMAIAJBmYoBaiAMNwMAIAJBkYoBaiAHNwMAC0EAQQApA8CJASASfCIENwPAiQEgAyARaiEDIAAgEWsiAEGACEsNAAsgAEUNAQtBoIkBIAMgABAEQQApA8CJARAFCyABQdACaiQAC4YHAgl/AX4jAEHAAGsiAyQAAkACQCAALQBoIgRFDQACQEHAACAEayIFIAIgBSACSRsiBkUNACAGQQNxIQdBACEFAkAgBkEESQ0AIAAgBGohCCAGQXxxIQlBACEFA0AgCCAFaiIKQShqIAEgBWoiCy0AADoAACAKQSlqIAtBAWotAAA6AAAgCkEqaiALQQJqLQAAOgAAIApBK2ogC0EDai0AADoAACAJIAVBBGoiBUcNAAsLAkAgB0UNACABIAVqIQogBSAEaiAAakEoaiEFA0AgBSAKLQAAOgAAIApBAWohCiAFQQFqIQUgB0F/aiIHDQALCyAALQBoIQQLIAAgBCAGaiIHOgBoIAEgBmohAQJAIAIgBmsiAg0AQQAhAgwCCyADIAAgAEEoakHAACAAKQMgIAAtAGogAEHpAGoiBS0AACIKRXIQAiAAIAMpAyAgAykDAIU3AwAgACADKQMoIAMpAwiFNwMIIAAgAykDMCADKQMQhTcDECAAIAMpAzggAykDGIU3AxggAEEAOgBoIAUgCkEBajoAACAAQeAAakIANwMAIABB2ABqQgA3AwAgAEHQAGpCADcDACAAQcgAakIANwMAIABBwABqQgA3AwAgAEE4akIANwMAIABBMGpCADcDACAAQgA3AygLQQAhByACQcEASQ0AIABB6QBqIgotAAAhBSAALQBqIQsgACkDICEMA0AgAyAAIAFBwAAgDCALIAVB/wFxRXJB/wFxEAIgACADKQMgIAMpAwCFNwMAIAAgAykDKCADKQMIhTcDCCAAIAMpAzAgAykDEIU3AxAgACADKQM4IAMpAxiFNwMYIAogBUEBaiIFOgAAIAFBwABqIQEgAkFAaiICQcAASw0ACwsCQEHAACAHQf8BcSIGayIFIAIgBSACSRsiCUUNACAJQQNxIQtBACEFAkAgCUEESQ0AIAAgBmohByAJQfwAcSEIQQAhBQNAIAcgBWoiAkEoaiABIAVqIgotAAA6AAAgAkEpaiAKQQFqLQAAOgAAIAJBKmogCkECai0AADoAACACQStqIApBA2otAAA6AAAgCCAFQQRqIgVHDQALCwJAIAtFDQAgASAFaiEBIAUgBmogAGpBKGohBQNAIAUgAS0AADoAACABQQFqIQEgBUEBaiEFIAtBf2oiCw0ACwsgAC0AaCEHCyAAIAcgCWo6AGggA0HAAGokAAveAwQFfwN+BX8GfiMAQdABayIBJAACQCAAe6ciAkEALQCQigEiA08NAEEALQCKigFBBHIhBCABQShqIQVBACkDmIkBIQBBACkDkIkBIQZBACkDiIkBIQdBACkDgIkBIQggAyEJA0AgASAANwMYIAEgBjcDECABIAc3AwggASAINwMAIAEgA0EFdCIDQdGJAWoiCikDADcDKCABIANB2YkBaiILKQMANwMwIAEgA0HhiQFqIgwpAwA3AzggASADQemJAWoiDSkDADcDQCABIANB8YkBaikDADcDSCABIANB+YkBaikDADcDUCABIANBgYoBaikDADcDWCADQYmKAWopAwAhDiABQcAAOgBoIAEgDjcDYCABQgA3AyAgASAEOgBpIAEgADcDiAEgASAGNwOAASABIAc3A3ggASAINwNwIAFBkAFqIAFB8ABqIAVBwABCACAEQf8BcRACIAEpA7ABIQ4gASkDkAEhDyABKQO4ASEQIAEpA5gBIREgASkDwAEhEiABKQOgASETIA0gASkDyAEgASkDqAGFNwMAIAwgEiAThTcDACALIBAgEYU3AwAgCiAOIA+FNwMAIAlBf2oiCUH/AXEiAyACSw0AC0EAIAk6AJCKAQsgAUHQAWokAAvHCQIKfwV+IwBB4AJrIgUkAAJAAkAgAUGACEsNACAFIAA2AvwBIAVB/AFqIAFBgAhGIgZBECACQQEgA0EBQQIgBBABIAZBCnQiByABTw0BIAVB4ABqIgZCADcDACAFQdgAaiIIQgA3AwAgBUHQAGoiCUIANwMAIAVByABqIgpCADcDACAFQcAAaiILQgA3AwAgBUE4aiIMQgA3AwAgBUEwaiINQgA3AwAgBSADOgBqIAVCADcDKCAFQQA7AWggBUEAKQOAiQE3AwAgBUEAKQOIiQE3AwggBUEAKQOQiQE3AxAgBUEAKQOYiQE3AxggBSABQYAIRiIOrSACfDcDICAFIAAgB2pBACABIA4bEAQgBUGIAWpBMGogDSkDADcDACAFQYgBakE4aiAMKQMANwMAIAUgBSkDACIPNwOIASAFIAUpAwgiEDcDkAEgBSAFKQMQIhE3A5gBIAUgBSkDGCISNwOgASAFIAUpAyg3A7ABIAUtAGohACAFLQBpIQcgBSkDICECIAUtAGghASAFQYgBakHAAGogCykDADcDACAFQYgBakHIAGogCikDADcDACAFQYgBakHQAGogCSkDADcDACAFQYgBakHYAGogCCkDADcDACAFQYgBakHgAGogBikDADcDACAFIAE6APABIAUgAjcDqAEgBSAAIAdFckECciIAOgDxASAFIBI3A5gCIAUgETcDkAIgBSAQNwOIAiAFIA83A4ACIAVBoAJqIAVBgAJqIAVBsAFqIAEgAiAAQf8BcRACIAUpA8ACIQIgBSkDoAIhDyAFKQPIAiEQIAUpA6gCIREgBSkD0AIhEiAFKQOwAiETIAQgDkEFdGoiASAFKQPYAiAFKQO4AoU3AxggASASIBOFNwMQIAEgECARhTcDCCABIAIgD4U3AwBBAkEBIA4bIQYMAQsgAEIBIAFBf2pBCnZBAXKteUI/hYYiD6dBCnQiDiACIAMgBRAGIQcgACAOaiABIA5rIA9C////AYMgAnwgAyAFQcAAQSAgDkGACEsbahAGIQECQCAHQQFHDQAgBCAFKQMANwMAIAQgBSkDCDcDCCAEIAUpAxA3AxAgBCAFKQMYNwMYIAQgBSkDIDcDICAEIAUpAyg3AyggBCAFKQMwNwMwIAQgBSkDODcDOEECIQYMAQtBACEGQQAhAAJAIAEgB2oiCUECSQ0AIAlBfmoiCkEBdkEBaiIGQQNxIQ5BACEHAkAgCkEGSQ0AIAZB/P///wdxIQhBACEHIAVBiAFqIQEgBSEAA0AgASAANgIAIAFBDGogAEHAAWo2AgAgAUEIaiAAQYABajYCACABQQRqIABBwABqNgIAIABBgAJqIQAgAUEQaiEBIAggB0EEaiIHRw0ACwsgCkF+cSEIAkAgDkUNACAFIAdBBnRqIQEgBUGIAWogB0ECdGohAANAIAAgATYCACABQcAAaiEBIABBBGohACAOQX9qIg4NAAsLIAhBAmohAAsgBUGIAWogBkEBQgBBACADQQRyQQBBACAEEAEgACAJTw0AIAQgBkEFdGoiASAFIAZBBnRqIgApAwA3AwAgASAAKQMINwMIIAEgACkDEDcDECABIAApAxg3AxggBkEBaiEGCyAFQeACaiQAIAYLrRAIAn8EfgF/AX4EfwR+BH8EfiMAQfABayIBJAACQCAARQ0AAkBBAC0AkIoBIgINACABQTBqQQApA9CJATcDACABQThqQQApA9iJATcDACABQQApA6CJASIDNwMAIAFBACkDqIkBIgQ3AwggAUEAKQOwiQEiBTcDECABQQApA7iJASIGNwMYIAFBACkDyIkBNwMoQQAtAIqKASECQQAtAImKASEHQQApA8CJASEIQQAtAIiKASEJIAFBwABqQQApA+CJATcDACABQcgAakEAKQPoiQE3AwAgAUHQAGpBACkD8IkBNwMAIAFB2ABqQQApA/iJATcDACABQeAAakEAKQOAigE3AwAgASAJOgBoIAEgCDcDICABIAIgB0VyIgJBAnI6AGkgAUEoaiEKQgAhCEGACSELIAJBCnJB/wFxIQwDQCABQbABaiABIAogCUH/AXEgCCAMEAIgASABKQPQASINIAEpA7ABhTcDcCABIAEpA9gBIg4gASkDuAGFNwN4IAEgASkD4AEiDyABKQPAAYU3A4ABIAEgASkD6AEiECAGhTcDqAEgASAPIAWFNwOgASABIA4gBIU3A5gBIAEgDSADhTcDkAEgASAQIAEpA8gBhTcDiAEgAEHAACAAQcAASRsiEUF/aiESAkACQCARQQdxIhMNACABQfAAaiECIAshByARIRQMAQsgEUH4AHEhFCABQfAAaiECIAshBwNAIAcgAi0AADoAACAHQQFqIQcgAkEBaiECIBNBf2oiEw0ACwsCQCASQQdJDQADQCAHIAIpAAA3AAAgB0EIaiEHIAJBCGohAiAUQXhqIhQNAAsLIAhCAXwhCCALIBFqIQsgACARayIADQAMAgsLAkACQAJAQQAtAImKASIHQQZ0QQBBAC0AiIoBIhFrRg0AIAEgEToAaCABQQApA4CKATcDYCABQQApA/iJATcDWCABQQApA/CJATcDUCABQQApA+iJATcDSCABQQApA+CJATcDQCABQQApA9iJATcDOCABQQApA9CJATcDMCABQQApA8iJATcDKCABQQApA8CJASIINwMgIAFBACkDuIkBIgM3AxggAUEAKQOwiQEiBDcDECABQQApA6iJASIFNwMIIAFBACkDoIkBIgY3AwAgAUEALQCKigEiEyAHRXJBAnIiCzoAaSATQQRyIRNBACkDmIkBIQ1BACkDkIkBIQ5BACkDiIkBIQ9BACkDgIkBIRAMAQtBwAAhESABQcAAOgBoQgAhCCABQgA3AyAgAUEAKQOYiQEiDTcDGCABQQApA5CJASIONwMQIAFBACkDiIkBIg83AwggAUEAKQOAiQEiEDcDACABQQAtAIqKAUEEciITOgBpIAEgAkF+aiICQQV0IgdByYoBaikDADcDYCABIAdBwYoBaikDADcDWCABIAdBuYoBaikDADcDUCABIAdBsYoBaikDADcDSCABIAdBqYoBaikDADcDQCABIAdBoYoBaikDADcDOCABIAdBmYoBaikDADcDMCABIAdBkYoBaikDADcDKCATIQsgECEGIA8hBSAOIQQgDSEDIAJFDQELIAJBf2oiB0EFdCIUQZGKAWopAwAhFSAUQZmKAWopAwAhFiAUQaGKAWopAwAhFyAUQamKAWopAwAhGCABIAM3A4gBIAEgBDcDgAEgASAFNwN4IAEgBjcDcCABQbABaiABQfAAaiABQShqIhQgESAIIAtB/wFxEAIgASATOgBpIAFBwAA6AGggASAYNwNAIAEgFzcDOCABIBY3AzAgASAVNwMoIAFCADcDICABIA03AxggASAONwMQIAEgDzcDCCABIBA3AwAgASABKQPoASABKQPIAYU3A2AgASABKQPgASABKQPAAYU3A1ggASABKQPYASABKQO4AYU3A1AgASABKQPQASABKQOwAYU3A0ggB0UNACACQQV0QemJAWohAiATQf8BcSERA0AgAkFoaikDACEIIAJBcGopAwAhAyACQXhqKQMAIQQgAikDACEFIAEgDTcDiAEgASAONwOAASABIA83A3ggASAQNwNwIAFBsAFqIAFB8ABqIBRBwABCACAREAIgASATOgBpIAFBwAA6AGggASAFNwNAIAEgBDcDOCABIAM3AzAgASAINwMoIAFCADcDICABIA03AxggASAONwMQIAEgDzcDCCABIBA3AwAgASABKQPoASABKQPIAYU3A2AgASABKQPgASABKQPAAYU3A1ggASABKQPYASABKQO4AYU3A1AgASABKQPQASABKQOwAYU3A0ggAkFgaiECIAdBf2oiBw0ACwsgAUEoaiEJQgAhCEGACSELIBNBCHJB/wFxIQoDQCABQbABaiABIAlBwAAgCCAKEAIgASABKQPQASIDIAEpA7ABhTcDcCABIAEpA9gBIgQgASkDuAGFNwN4IAEgASkD4AEiBSABKQPAAYU3A4ABIAEgDSABKQPoASIGhTcDqAEgASAOIAWFNwOgASABIA8gBIU3A5gBIAEgECADhTcDkAEgASAGIAEpA8gBhTcDiAEgAEHAACAAQcAASRsiEUF/aiESAkACQCARQQdxIhMNACABQfAAaiECIAshByARIRQMAQsgEUH4AHEhFCABQfAAaiECIAshBwNAIAcgAi0AADoAACAHQQFqIQcgAkEBaiECIBNBf2oiEw0ACwsCQCASQQdJDQADQCAHIAIpAAA3AAAgB0EIaiEHIAJBCGohAiAUQXhqIhQNAAsLIAhCAXwhCCALIBFqIQsgACARayIADQALCyABQfABaiQAC6MCAQR+AkACQCAAQSBGDQBCq7OP/JGjs/DbACEBQv+kuYjFkdqCm38hAkLy5rvjo6f9p6V/IQNC58yn0NbQ67O7fyEEQQAhAAwBC0EAKQOYCSEBQQApA5AJIQJBACkDiAkhA0EAKQOACSEEQRAhAAtBACAAOgCKigFBAEIANwOAigFBAEIANwP4iQFBAEIANwPwiQFBAEIANwPoiQFBAEIANwPgiQFBAEIANwPYiQFBAEIANwPQiQFBAEIANwPIiQFBAEIANwPAiQFBACABNwO4iQFBACACNwOwiQFBACADNwOoiQFBACAENwOgiQFBACABNwOYiQFBACACNwOQiQFBACADNwOIiQFBACAENwOAiQFBAEEAOgCQigFBAEEAOwGIigELBgAgABADCwYAIAAQBwsGAEGAiQELqwIBBH4CQAJAIAFBIEYNAEKrs4/8kaOz8NsAIQNC/6S5iMWR2oKbfyEEQvLmu+Ojp/2npX8hBULnzKfQ1tDrs7t/IQZBACEBDAELQQApA5gJIQNBACkDkAkhBEEAKQOICSEFQQApA4AJIQZBECEBC0EAIAE6AIqKAUEAQgA3A4CKAUEAQgA3A/iJAUEAQgA3A/CJAUEAQgA3A+iJAUEAQgA3A+CJAUEAQgA3A9iJAUEAQgA3A9CJAUEAQgA3A8iJAUEAQgA3A8CJAUEAIAM3A7iJAUEAIAQ3A7CJAUEAIAU3A6iJAUEAIAY3A6CJAUEAIAM3A5iJAUEAIAQ3A5CJAUEAIAU3A4iJAUEAIAY3A4CJAUEAQQA6AJCKAUEAQQA7AYiKASAAEAMgAhAHCwsLAQBBgAgLBHgHAAA=";
    hash$h = "215d875f";
    wasmJson$h = {
      name: name$h,
      data: data$h,
      hash: hash$h
    };
    mutex$i = new Mutex();
    wasmCache$i = null;
    name$g = "crc32";
    data$g = "AGFzbQEAAAABEQRgAAF/YAF/AGAAAGACf38AAwgHAAEBAQIAAwUEAQECAgYOAn8BQZDJBQt/AEGACAsHcAgGbWVtb3J5AgAOSGFzaF9HZXRCdWZmZXIAAAlIYXNoX0luaXQAAgtIYXNoX1VwZGF0ZQADCkhhc2hfRmluYWwABA1IYXNoX0dldFN0YXRlAAUOSGFzaF9DYWxjdWxhdGUABgpTVEFURV9TSVpFAwEKkggHBQBBgAkLwwMBA39BgIkBIQFBACECA0AgAUEAQQBBAEEAQQBBAEEAQQAgAkEBcWsgAHEgAkEBdnMiA0EBcWsgAHEgA0EBdnMiA0EBcWsgAHEgA0EBdnMiA0EBcWsgAHEgA0EBdnMiA0EBcWsgAHEgA0EBdnMiA0EBcWsgAHEgA0EBdnMiA0EBcWsgAHEgA0EBdnMiA0EBcWsgAHEgA0EBdnM2AgAgAUEEaiEBIAJBAWoiAkGAAkcNAAtBACEAA0AgAEGEkQFqIABBhIkBaigCACICQf8BcUECdEGAiQFqKAIAIAJBCHZzIgI2AgAgAEGEmQFqIAJB/wFxQQJ0QYCJAWooAgAgAkEIdnMiAjYCACAAQYShAWogAkH/AXFBAnRBgIkBaigCACACQQh2cyICNgIAIABBhKkBaiACQf8BcUECdEGAiQFqKAIAIAJBCHZzIgI2AgAgAEGEsQFqIAJB/wFxQQJ0QYCJAWooAgAgAkEIdnMiAjYCACAAQYS5AWogAkH/AXFBAnRBgIkBaigCACACQQh2cyICNgIAIABBhMEBaiACQf8BcUECdEGAiQFqKAIAIAJBCHZzNgIAIABBBGoiAEH8B0cNAAsLJwACQEEAKAKAyQEgAEYNACAAEAFBACAANgKAyQELQQBBADYChMkBC4gDAQN/QQAoAoTJAUF/cyEBQYAJIQICQCAAQQhJDQBBgAkhAgNAIAJBBGooAgAiA0EOdkH8B3FBgJEBaigCACADQRZ2QfwHcUGAiQFqKAIAcyADQQZ2QfwHcUGAmQFqKAIAcyADQf8BcUECdEGAoQFqKAIAcyACKAIAIAFzIgFBFnZB/AdxQYCpAWooAgBzIAFBDnZB/AdxQYCxAWooAgBzIAFBBnZB/AdxQYC5AWooAgBzIAFB/wFxQQJ0QYDBAWooAgBzIQEgAkEIaiECIABBeGoiAEEHSw0ACwsCQCAARQ0AAkACQCAAQQFxDQAgACEDDAELIAFB/wFxIAItAABzQQJ0QYCJAWooAgAgAUEIdnMhASACQQFqIQIgAEF/aiEDCyAAQQFGDQADQCABQf8BcSACLQAAc0ECdEGAiQFqKAIAIAFBCHZzIgFB/wFxIAJBAWotAABzQQJ0QYCJAWooAgAgAUEIdnMhASACQQJqIQIgA0F+aiIDDQALC0EAIAFBf3M2AoTJAQsyAQF/QQBBACgChMkBIgBBGHQgAEGA/gNxQQh0ciAAQQh2QYD+A3EgAEEYdnJyNgKACQsGAEGEyQELWQACQEEAKAKAyQEgAUYNACABEAFBACABNgKAyQELQQBBADYChMkBIAAQA0EAQQAoAoTJASIBQRh0IAFBgP4DcUEIdHIgAUEIdkGA/gNxIAFBGHZycjYCgAkLCwsBAEGACAsEBAAAAA==";
    hash$g = "d2eba587";
    wasmJson$g = {
      name: name$g,
      data: data$g,
      hash: hash$g
    };
    mutex$h = new Mutex();
    wasmCache$h = null;
    name$f = "crc64";
    data$f = "AGFzbQEAAAABDANgAAF/YAAAYAF/AAMHBgABAgEAAQUEAQECAgYOAn8BQZCJBgt/AEGACAsHcAgGbWVtb3J5AgAOSGFzaF9HZXRCdWZmZXIAAAlIYXNoX0luaXQAAQtIYXNoX1VwZGF0ZQACCkhhc2hfRmluYWwAAw1IYXNoX0dldFN0YXRlAAQOSGFzaF9DYWxjdWxhdGUABQpTVEFURV9TSVpFAwEKgwgGBQBBgAkL9QMDAX4BfwJ+AkBBACkDgIkCQQApA4AJIgBRDQBBgIkBIQFCACECA0AgAUIAQgBCAEIAQgBCAEIAQgAgAkIBg30gAIMgAkIBiIUiA0IBg30gAIMgA0IBiIUiA0IBg30gAIMgA0IBiIUiA0IBg30gAIMgA0IBiIUiA0IBg30gAIMgA0IBiIUiA0IBg30gAIMgA0IBiIUiA0IBg30gAIMgA0IBiIUiA0IBg30gAIMgA0IBiIU3AwAgAUEIaiEBIAJCAXwiAkKAAlINAAtBACEBA0AgAUGImQFqIAFBiIkBaikDACICp0H/AXFBA3RBgIkBaikDACACQgiIhSICNwMAIAFBiKkBaiACp0H/AXFBA3RBgIkBaikDACACQgiIhSICNwMAIAFBiLkBaiACp0H/AXFBA3RBgIkBaikDACACQgiIhSICNwMAIAFBiMkBaiACp0H/AXFBA3RBgIkBaikDACACQgiIhSICNwMAIAFBiNkBaiACp0H/AXFBA3RBgIkBaikDACACQgiIhSICNwMAIAFBiOkBaiACp0H/AXFBA3RBgIkBaikDACACQgiIhSICNwMAIAFBiPkBaiACp0H/AXFBA3RBgIkBaikDACACQgiIhTcDACABQQhqIgFB+A9HDQALQQAgADcDgIkCC0EAQgA3A4iJAguUAwIBfgJ/QQApA4iJAkJ/hSEBQYAJIQICQCAAQQhJDQBBgAkhAgNAIAIpAwAgAYUiAUIwiKdB/wFxQQN0QYCZAWopAwAgAUI4iKdBA3RBgIkBaikDAIUgAUIoiKdB/wFxQQN0QYCpAWopAwCFIAFCIIinQf8BcUEDdEGAuQFqKQMAhSABpyIDQRV2QfgPcUGAyQFqKQMAhSADQQ12QfgPcUGA2QFqKQMAhSADQQV2QfgPcUGA6QFqKQMAhSADQf8BcUEDdEGA+QFqKQMAhSEBIAJBCGohAiAAQXhqIgBBB0sNAAsLAkAgAEUNAAJAAkAgAEEBcQ0AIAAhAwwBCyABQv8BgyACMQAAhadBA3RBgIkBaikDACABQgiIhSEBIAJBAWohAiAAQX9qIQMLIABBAUYNAANAIAFC/wGDIAIxAACFp0EDdEGAiQFqKQMAIAFCCIiFIgFC/wGDIAJBAWoxAACFp0EDdEGAiQFqKQMAIAFCCIiFIQEgAkECaiECIANBfmoiAw0ACwtBACABQn+FNwOIiQILZAEBfkEAQQApA4iJAiIAQjiGIABCgP4Dg0IohoQgAEKAgPwHg0IYhiAAQoCAgPgPg0IIhoSEIABCCIhCgICA+A+DIABCGIhCgID8B4OEIABCKIhCgP4DgyAAQjiIhISENwOACQsGAEGIiQILAgALCwsBAEGACAsECAAAAA==";
    hash$f = "c5ac6c16";
    wasmJson$f = {
      name: name$f,
      data: data$f,
      hash: hash$f
    };
    mutex$g = new Mutex();
    wasmCache$g = null;
    polyBuffer = new Uint8Array(8);
    name$e = "md4";
    data$e = "AGFzbQEAAAABEgRgAAF/YAAAYAF/AGACf38BfwMIBwABAgMBAAIFBAEBAgIGDgJ/AUGgigULfwBBgAgLB3AIBm1lbW9yeQIADkhhc2hfR2V0QnVmZmVyAAAJSGFzaF9Jbml0AAELSGFzaF9VcGRhdGUAAgpIYXNoX0ZpbmFsAAQNSGFzaF9HZXRTdGF0ZQAFDkhhc2hfQ2FsY3VsYXRlAAYKU1RBVEVfU0laRQMBCucUBwUAQYAJCy0AQQBC/rnrxemOlZkQNwKQiQFBAEKBxpS6lvHq5m83AoiJAUEAQgA3AoCJAQu+BQEHf0EAQQAoAoCJASIBIABqQf////8BcSICNgKAiQFBAEEAKAKEiQEgAiABSWogAEEddmo2AoSJAQJAAkACQAJAAkACQCABQT9xIgMNAEGACSEEDAELIABBwAAgA2siBUkNASAFQQNxIQZBACEBAkAgA0E/c0EDSQ0AIANBgIkBaiEEIAVB/ABxIQdBACEBA0AgBCABaiICQRhqIAFBgAlqLQAAOgAAIAJBGWogAUGBCWotAAA6AAAgAkEaaiABQYIJai0AADoAACACQRtqIAFBgwlqLQAAOgAAIAcgAUEEaiIBRw0ACwsCQCAGRQ0AIANBmIkBaiECA0AgAiABaiABQYAJai0AADoAACABQQFqIQEgBkF/aiIGDQALC0GYiQFBwAAQAxogACAFayEAIAVBgAlqIQQLIABBwABPDQEgACECDAILIABFDQIgAEEDcSEGQQAhAQJAIABBBEkNACADQYCJAWohBCAAQXxxIQBBACEBA0AgBCABaiICQRhqIAFBgAlqLQAAOgAAIAJBGWogAUGBCWotAAA6AAAgAkEaaiABQYIJai0AADoAACACQRtqIAFBgwlqLQAAOgAAIAAgAUEEaiIBRw0ACwsgBkUNAiADQZiJAWohAgNAIAIgAWogAUGACWotAAA6AAAgAUEBaiEBIAZBf2oiBg0ADAMLCyAAQT9xIQIgBCAAQUBxEAMhBAsgAkUNACACQQNxIQZBACEBAkAgAkEESQ0AIAJBPHEhAEEAIQEDQCABQZiJAWogBCABaiICLQAAOgAAIAFBmYkBaiACQQFqLQAAOgAAIAFBmokBaiACQQJqLQAAOgAAIAFBm4kBaiACQQNqLQAAOgAAIAAgAUEEaiIBRw0ACwsgBkUNAANAIAFBmIkBaiAEIAFqLQAAOgAAIAFBAWohASAGQX9qIgYNAAsLC+sKARd/QQAoApSJASECQQAoApCJASEDQQAoAoyJASEEQQAoAoiJASEFA0AgACgCHCIGIAAoAhQiByAAKAIYIgggACgCECIJIAAoAiwiCiAAKAIoIgsgACgCJCIMIAAoAiAiDSALIAggACgCCCIOIANqIAAoAgQiDyACaiAEIAMgAnNxIAJzIAVqIAAoAgAiEGpBA3ciESAEIANzcSADc2pBB3ciEiARIARzcSAEc2pBC3ciE2ogEiAHaiAJIBFqIAAoAgwiFCAEaiATIBIgEXNxIBFzakETdyIRIBMgEnNxIBJzakEDdyISIBEgE3NxIBNzakEHdyITIBIgEXNxIBFzakELdyIVaiATIAxqIBIgDWogESAGaiAVIBMgEnNxIBJzakETdyIRIBUgE3NxIBNzakEDdyISIBEgFXNxIBVzakEHdyITIBIgEXNxIBFzakELdyIVIAAoAjgiFmogEyAAKAI0IhdqIBIgACgCMCIYaiARIApqIBUgEyASc3EgEnNqQRN3IhIgFSATc3EgE3NqQQN3IhMgEiAVc3EgFXNqQQd3IhUgEyASc3EgEnNqQQt3IhFqIAkgFWogECATaiASIAAoAjwiCWogESAVIBNzcSATc2pBE3ciEiARIBVycSARIBVxcmpBmfOJ1AVqQQN3IhMgEiARcnEgEiARcXJqQZnzidQFakEFdyIRIBMgEnJxIBMgEnFyakGZ84nUBWpBCXciFWogByARaiAPIBNqIBggEmogFSARIBNycSARIBNxcmpBmfOJ1AVqQQ13IhIgFSARcnEgFSARcXJqQZnzidQFakEDdyIRIBIgFXJxIBIgFXFyakGZ84nUBWpBBXciEyARIBJycSARIBJxcmpBmfOJ1AVqQQl3IhVqIAggE2ogDiARaiAXIBJqIBUgEyARcnEgEyARcXJqQZnzidQFakENdyIRIBUgE3JxIBUgE3FyakGZ84nUBWpBA3ciEiARIBVycSARIBVxcmpBmfOJ1AVqQQV3IhMgEiARcnEgEiARcXJqQZnzidQFakEJdyIVaiAGIBNqIBQgEmogFiARaiAVIBMgEnJxIBMgEnFyakGZ84nUBWpBDXciESAVIBNycSAVIBNxcmpBmfOJ1AVqQQN3IhIgESAVcnEgESAVcXJqQZnzidQFakEFdyITIBIgEXJxIBIgEXFyakGZ84nUBWpBCXciFWogECASaiAJIBFqIBUgEyAScnEgEyAScXJqQZnzidQFakENdyIGIBVzIhIgE3NqQaHX5/YGakEDdyIRIAZzIA0gE2ogEiARc2pBodfn9gZqQQl3IhJzakGh1+f2BmpBC3ciE2ogDiARaiATIBJzIBggBmogEiARcyATc2pBodfn9gZqQQ93IhFzakGh1+f2BmpBA3ciFSARcyALIBJqIBEgE3MgFXNqQaHX5/YGakEJdyISc2pBodfn9gZqQQt3IhNqIA8gFWogEyAScyAWIBFqIBIgFXMgE3NqQaHX5/YGakEPdyIRc2pBodfn9gZqQQN3IhUgEXMgDCASaiARIBNzIBVzakGh1+f2BmpBCXciEnNqQaHX5/YGakELdyITaiAUIBVqIBMgEnMgFyARaiASIBVzIBNzakGh1+f2BmpBD3ciEXNqQaHX5/YGakEDdyIVIBFzIAogEmogESATcyAVc2pBodfn9gZqQQl3IhJzakGh1+f2BmpBC3ciEyADaiEDIAkgEWogEiAVcyATc2pBodfn9gZqQQ93IARqIQQgEiACaiECIBUgBWohBSAAQcAAaiEAIAFBQGoiAQ0AC0EAIAI2ApSJAUEAIAM2ApCJAUEAIAQ2AoyJAUEAIAU2AoiJASAAC8gDAQV/QQAoAoCJAUE/cSIAQZiJAWpBgAE6AAAgAEEBaiEBAkACQAJAAkAgAEE/cyICQQdLDQAgAkUNASABQZiJAWpBADoAACACQQFGDQEgAEGaiQFqQQA6AAAgAkECRg0BIABBm4kBakEAOgAAIAJBA0YNASAAQZyJAWpBADoAACACQQRGDQEgAEGdiQFqQQA6AAAgAkEFRg0BIABBnokBakEAOgAAIAJBBkYNASAAQZ+JAWpBADoAAAwBCyACQQhGDQJBNiAAayIDIQQCQCACQQNxIgBFDQBBACAAayEEQQAhAANAIABBz4kBakEAOgAAIAQgAEF/aiIARw0ACyADIABqIQQLIANBA0kNAgwBC0GYiQFBwAAQAxpBACEBQTchBAsgAUGAiQFqIQBBfyECA0AgACAEakEVakEANgAAIABBfGohACAEIAJBBGoiAkcNAAsLQQBBACgChIkBNgLUiQFBAEEAKAKAiQEiAEEVdjoA04kBQQAgAEENdjoA0okBQQAgAEEFdjoA0YkBQQAgAEEDdCIAOgDQiQFBACAANgKAiQFBmIkBQcAAEAMaQQBBACkCiIkBNwOACUEAQQApApCJATcDiAkLBgBBgIkBCzMAQQBC/rnrxemOlZkQNwKQiQFBAEKBxpS6lvHq5m83AoiJAUEAQgA3AoCJASAAEAIQBAsLCwEAQYAICwSYAAAA";
    hash$e = "bd8ce7c7";
    wasmJson$e = {
      name: name$e,
      data: data$e,
      hash: hash$e
    };
    mutex$f = new Mutex();
    wasmCache$f = null;
    name$d = "md5";
    data$d = "AGFzbQEAAAABEgRgAAF/YAAAYAF/AGACf38BfwMIBwABAgMBAAIFBAEBAgIGDgJ/AUGgigULfwBBgAgLB3AIBm1lbW9yeQIADkhhc2hfR2V0QnVmZmVyAAAJSGFzaF9Jbml0AAELSGFzaF9VcGRhdGUAAgpIYXNoX0ZpbmFsAAQNSGFzaF9HZXRTdGF0ZQAFDkhhc2hfQ2FsY3VsYXRlAAYKU1RBVEVfU0laRQMBCoMaBwUAQYAJCy0AQQBC/rnrxemOlZkQNwKQiQFBAEKBxpS6lvHq5m83AoiJAUEAQgA3AoCJAQu+BQEHf0EAQQAoAoCJASIBIABqQf////8BcSICNgKAiQFBAEEAKAKEiQEgAiABSWogAEEddmo2AoSJAQJAAkACQAJAAkACQCABQT9xIgMNAEGACSEEDAELIABBwAAgA2siBUkNASAFQQNxIQZBACEBAkAgA0E/c0EDSQ0AIANBgIkBaiEEIAVB/ABxIQdBACEBA0AgBCABaiICQRhqIAFBgAlqLQAAOgAAIAJBGWogAUGBCWotAAA6AAAgAkEaaiABQYIJai0AADoAACACQRtqIAFBgwlqLQAAOgAAIAcgAUEEaiIBRw0ACwsCQCAGRQ0AIANBmIkBaiECA0AgAiABaiABQYAJai0AADoAACABQQFqIQEgBkF/aiIGDQALC0GYiQFBwAAQAxogACAFayEAIAVBgAlqIQQLIABBwABPDQEgACECDAILIABFDQIgAEEDcSEGQQAhAQJAIABBBEkNACADQYCJAWohBCAAQXxxIQBBACEBA0AgBCABaiICQRhqIAFBgAlqLQAAOgAAIAJBGWogAUGBCWotAAA6AAAgAkEaaiABQYIJai0AADoAACACQRtqIAFBgwlqLQAAOgAAIAAgAUEEaiIBRw0ACwsgBkUNAiADQZiJAWohAgNAIAIgAWogAUGACWotAAA6AAAgAUEBaiEBIAZBf2oiBg0ADAMLCyAAQT9xIQIgBCAAQUBxEAMhBAsgAkUNACACQQNxIQZBACEBAkAgAkEESQ0AIAJBPHEhAEEAIQEDQCABQZiJAWogBCABaiICLQAAOgAAIAFBmYkBaiACQQFqLQAAOgAAIAFBmokBaiACQQJqLQAAOgAAIAFBm4kBaiACQQNqLQAAOgAAIAAgAUEEaiIBRw0ACwsgBkUNAANAIAFBmIkBaiAEIAFqLQAAOgAAIAFBAWohASAGQX9qIgYNAAsLC4cQARl/QQAoApSJASECQQAoApCJASEDQQAoAoyJASEEQQAoAoiJASEFA0AgACgCCCIGIAAoAhgiByAAKAIoIgggACgCOCIJIAAoAjwiCiAAKAIMIgsgACgCHCIMIAAoAiwiDSAMIAsgCiANIAkgCCAHIAMgBmogAiAAKAIEIg5qIAUgBCACIANzcSACc2ogACgCACIPakH4yKq7fWpBB3cgBGoiECAEIANzcSADc2pB1u6exn5qQQx3IBBqIhEgECAEc3EgBHNqQdvhgaECakERdyARaiISaiAAKAIUIhMgEWogACgCECIUIBBqIAQgC2ogEiARIBBzcSAQc2pB7p33jXxqQRZ3IBJqIhAgEiARc3EgEXNqQa+f8Kt/akEHdyAQaiIRIBAgEnNxIBJzakGqjJ+8BGpBDHcgEWoiEiARIBBzcSAQc2pBk4zBwXpqQRF3IBJqIhVqIAAoAiQiFiASaiAAKAIgIhcgEWogDCAQaiAVIBIgEXNxIBFzakGBqppqakEWdyAVaiIQIBUgEnNxIBJzakHYsYLMBmpBB3cgEGoiESAQIBVzcSAVc2pBr++T2nhqQQx3IBFqIhIgESAQc3EgEHNqQbG3fWpBEXcgEmoiFWogACgCNCIYIBJqIAAoAjAiGSARaiANIBBqIBUgEiARc3EgEXNqQb6v88p4akEWdyAVaiIQIBUgEnNxIBJzakGiosDcBmpBB3cgEGoiESAQIBVzcSAVc2pBk+PhbGpBDHcgEWoiFSARIBBzcSAQc2pBjofls3pqQRF3IBVqIhJqIAcgFWogDiARaiAKIBBqIBIgFSARc3EgEXNqQaGQ0M0EakEWdyASaiIQIBJzIBVxIBJzakHiyviwf2pBBXcgEGoiESAQcyAScSAQc2pBwOaCgnxqQQl3IBFqIhIgEXMgEHEgEXNqQdG0+bICakEOdyASaiIVaiAIIBJqIBMgEWogDyAQaiAVIBJzIBFxIBJzakGqj9vNfmpBFHcgFWoiECAVcyAScSAVc2pB3aC8sX1qQQV3IBBqIhEgEHMgFXEgEHNqQdOokBJqQQl3IBFqIhIgEXMgEHEgEXNqQYHNh8V9akEOdyASaiIVaiAJIBJqIBYgEWogFCAQaiAVIBJzIBFxIBJzakHI98++fmpBFHcgFWoiECAVcyAScSAVc2pB5puHjwJqQQV3IBBqIhEgEHMgFXEgEHNqQdaP3Jl8akEJdyARaiISIBFzIBBxIBFzakGHm9Smf2pBDncgEmoiFWogBiASaiAYIBFqIBcgEGogFSAScyARcSASc2pB7anoqgRqQRR3IBVqIhAgFXMgEnEgFXNqQYXSj896akEFdyAQaiIRIBBzIBVxIBBzakH4x75nakEJdyARaiISIBFzIBBxIBFzakHZhby7BmpBDncgEmoiFWogFyASaiATIBFqIBkgEGogFSAScyARcSASc2pBipmp6XhqQRR3IBVqIhAgFXMiFSASc2pBwvJoakEEdyAQaiIRIBVzakGB7ce7eGpBC3cgEWoiEiARcyIaIBBzakGiwvXsBmpBEHcgEmoiFWogFCASaiAOIBFqIAkgEGogFSAac2pBjPCUb2pBF3cgFWoiECAVcyIVIBJzakHE1PulempBBHcgEGoiESAVc2pBqZ/73gRqQQt3IBFqIhIgEXMiCSAQc2pB4JbttX9qQRB3IBJqIhVqIA8gEmogGCARaiAIIBBqIBUgCXNqQfD4/vV7akEXdyAVaiIQIBVzIhUgEnNqQcb97cQCakEEdyAQaiIRIBVzakH6z4TVfmpBC3cgEWoiEiARcyIIIBBzakGF4bynfWpBEHcgEmoiFWogGSASaiAWIBFqIAcgEGogFSAIc2pBhbqgJGpBF3cgFWoiESAVcyIQIBJzakG5oNPOfWpBBHcgEWoiEiAQc2pB5bPutn5qQQt3IBJqIhUgEnMiByARc2pB+PmJ/QFqQRB3IBVqIhBqIAwgFWogDyASaiAGIBFqIBAgB3NqQeWssaV8akEXdyAQaiIRIBVBf3NyIBBzakHExKShf2pBBncgEWoiEiAQQX9zciARc2pBl/+rmQRqQQp3IBJqIhAgEUF/c3IgEnNqQafH0Nx6akEPdyAQaiIVaiALIBBqIBkgEmogEyARaiAVIBJBf3NyIBBzakG5wM5kakEVdyAVaiIRIBBBf3NyIBVzakHDs+2qBmpBBncgEWoiECAVQX9zciARc2pBkpmz+HhqQQp3IBBqIhIgEUF/c3IgEHNqQf3ov39qQQ93IBJqIhVqIAogEmogFyAQaiAOIBFqIBUgEEF/c3IgEnNqQdG7kax4akEVdyAVaiIQIBJBf3NyIBVzakHP/KH9BmpBBncgEGoiESAVQX9zciAQc2pB4M2zcWpBCncgEWoiEiAQQX9zciARc2pBlIaFmHpqQQ93IBJqIhVqIA0gEmogFCARaiAYIBBqIBUgEUF/c3IgEnNqQaGjoPAEakEVdyAVaiIQIBJBf3NyIBVzakGC/c26f2pBBncgEGoiESAVQX9zciAQc2pBteTr6XtqQQp3IBFqIhIgEEF/c3IgEXNqQbul39YCakEPdyASaiIVIARqIBYgEGogFSARQX9zciASc2pBkaeb3H5qQRV3aiEEIBUgA2ohAyASIAJqIQIgESAFaiEFIABBwABqIQAgAUFAaiIBDQALQQAgAjYClIkBQQAgAzYCkIkBQQAgBDYCjIkBQQAgBTYCiIkBIAALyAMBBX9BACgCgIkBQT9xIgBBmIkBakGAAToAACAAQQFqIQECQAJAAkACQCAAQT9zIgJBB0sNACACRQ0BIAFBmIkBakEAOgAAIAJBAUYNASAAQZqJAWpBADoAACACQQJGDQEgAEGbiQFqQQA6AAAgAkEDRg0BIABBnIkBakEAOgAAIAJBBEYNASAAQZ2JAWpBADoAACACQQVGDQEgAEGeiQFqQQA6AAAgAkEGRg0BIABBn4kBakEAOgAADAELIAJBCEYNAkE2IABrIgMhBAJAIAJBA3EiAEUNAEEAIABrIQRBACEAA0AgAEHPiQFqQQA6AAAgBCAAQX9qIgBHDQALIAMgAGohBAsgA0EDSQ0CDAELQZiJAUHAABADGkEAIQFBNyEECyABQYCJAWohAEF/IQIDQCAAIARqQRVqQQA2AAAgAEF8aiEAIAQgAkEEaiICRw0ACwtBAEEAKAKEiQE2AtSJAUEAQQAoAoCJASIAQRV2OgDTiQFBACAAQQ12OgDSiQFBACAAQQV2OgDRiQFBACAAQQN0IgA6ANCJAUEAIAA2AoCJAUGYiQFBwAAQAxpBAEEAKQKIiQE3A4AJQQBBACkCkIkBNwOICQsGAEGAiQELMwBBAEL+uevF6Y6VmRA3ApCJAUEAQoHGlLqW8ermbzcCiIkBQQBCADcCgIkBIAAQAhAECwsLAQBBgAgLBJgAAAA=";
    hash$d = "e6508e4b";
    wasmJson$d = {
      name: name$d,
      data: data$d,
      hash: hash$d
    };
    mutex$e = new Mutex();
    wasmCache$e = null;
    name$c = "sha1";
    data$c = "AGFzbQEAAAABEQRgAAF/YAF/AGAAAGACf38AAwkIAAECAwECAAEFBAEBAgIGDgJ/AUHgiQULfwBBgAgLB3AIBm1lbW9yeQIADkhhc2hfR2V0QnVmZmVyAAAJSGFzaF9Jbml0AAILSGFzaF9VcGRhdGUABApIYXNoX0ZpbmFsAAUNSGFzaF9HZXRTdGF0ZQAGDkhhc2hfQ2FsY3VsYXRlAAcKU1RBVEVfU0laRQMBCpoqCAUAQYAJC68iCgF+An8BfgF/AX4DfwF+AX8Bfkd/QQAgACkDECIBQiCIpyICQRh0IAJBgP4DcUEIdHIgAUIoiKdBgP4DcSABQjiIp3JyIgMgACkDCCIEQiCIpyICQRh0IAJBgP4DcUEIdHIgBEIoiKdBgP4DcSAEQjiIp3JyIgVzIAApAygiBkIgiKciAkEYdCACQYD+A3FBCHRyIAZCKIinQYD+A3EgBkI4iKdyciIHcyAEpyICQRh0IAJBgP4DcUEIdHIgAkEIdkGA/gNxIAJBGHZyciIIIAApAwAiBKciAkEYdCACQYD+A3FBCHRyIAJBCHZBgP4DcSACQRh2cnIiCXMgACkDICIKpyICQRh0IAJBgP4DcUEIdHIgAkEIdkGA/gNxIAJBGHZyciILcyAAKQMwIgxCIIinIgJBGHQgAkGA/gNxQQh0ciAMQiiIp0GA/gNxIAxCOIincnIiAnNBAXciDXNBAXciDiAFIARCIIinIg9BGHQgD0GA/gNxQQh0ciAEQiiIp0GA/gNxIARCOIincnIiEHMgCkIgiKciD0EYdCAPQYD+A3FBCHRyIApCKIinQYD+A3EgCkI4iKdyciIRcyAAKQM4IgSnIg9BGHQgD0GA/gNxQQh0ciAPQQh2QYD+A3EgD0EYdnJyIg9zQQF3IhJzIAcgEXMgEnMgCyAAKQMYIgqnIgBBGHQgAEGA/gNxQQh0ciAAQQh2QYD+A3EgAEEYdnJyIhNzIA9zIA5zQQF3IgBzQQF3IhRzIA0gD3MgAHMgAiAHcyAOcyAGpyIVQRh0IBVBgP4DcUEIdHIgFUEIdkGA/gNxIBVBGHZyciIWIAtzIA1zIApCIIinIhVBGHQgFUGA/gNxQQh0ciAKQiiIp0GA/gNxIApCOIincnIiFyADcyACcyABpyIVQRh0IBVBgP4DcUEIdHIgFUEIdkGA/gNxIBVBGHZyciIYIAhzIBZzIARCIIinIhVBGHQgFUGA/gNxQQh0ciAEQiiIp0GA/gNxIARCOIincnIiFXNBAXciGXNBAXciGnNBAXciG3NBAXciHHNBAXciHXNBAXciHiASIBVzIBEgF3MgFXMgEyAYcyAMpyIfQRh0IB9BgP4DcUEIdHIgH0EIdkGA/gNxIB9BGHZyciIgcyASc0EBdyIfc0EBdyIhcyAPICBzIB9zIBRzQQF3IiJzQQF3IiNzIBQgIXMgI3MgACAfcyAicyAec0EBdyIkc0EBdyIlcyAdICJzICRzIBwgFHMgHnMgGyAAcyAdcyAaIA5zIBxzIBkgDXMgG3MgFSACcyAacyAgIBZzIBlzICFzQQF3IiZzQQF3IidzQQF3IihzQQF3IilzQQF3IipzQQF3IitzQQF3IixzQQF3Ii0gIyAncyAhIBpzICdzIB8gGXMgJnMgI3NBAXciLnNBAXciL3MgIiAmcyAucyAlc0EBdyIwc0EBdyIxcyAlIC9zIDFzICQgLnMgMHMgLXNBAXciMnNBAXciM3MgLCAwcyAycyArICVzIC1zICogJHMgLHMgKSAecyArcyAoIB1zICpzICcgHHMgKXMgJiAbcyAocyAvc0EBdyI0c0EBdyI1c0EBdyI2c0EBdyI3c0EBdyI4c0EBdyI5c0EBdyI6c0EBdyI7IDEgNXMgLyApcyA1cyAuIChzIDRzIDFzQQF3IjxzQQF3Ij1zIDAgNHMgPHMgM3NBAXciPnNBAXciP3MgMyA9cyA/cyAyIDxzID5zIDtzQQF3IkBzQQF3IkFzIDogPnMgQHMgOSAzcyA7cyA4IDJzIDpzIDcgLXMgOXMgNiAscyA4cyA1ICtzIDdzIDQgKnMgNnMgPXNBAXciQnNBAXciQ3NBAXciRHNBAXciRXNBAXciRnNBAXciR3NBAXciSHNBAXciSSA+IEJzIDwgNnMgQnMgP3NBAXciSnMgQXNBAXciSyA9IDdzIENzIEpzQQF3IkwgRCA5IDIgMSA0ICkgHSAUIB8gFSAWQQAoAoCJASJNQQV3QQAoApCJASJOaiAJakEAKAKMiQEiT0EAKAKIiQEiCXNBACgChIkBIlBxIE9zakGZ84nUBWoiUUEedyJSIANqIFBBHnciAyAFaiBPIAMgCXMgTXEgCXNqIBBqIFFBBXdqQZnzidQFaiIQIFIgTUEedyIFc3EgBXNqIAkgCGogUSADIAVzcSADc2ogEEEFd2pBmfOJ1AVqIlFBBXdqQZnzidQFaiJTIFFBHnciAyAQQR53IghzcSAIc2ogBSAYaiBRIAggUnNxIFJzaiBTQQV3akGZ84nUBWoiBUEFd2pBmfOJ1AVqIhhBHnciUmogU0EedyIWIAtqIAggE2ogBSAWIANzcSADc2ogGEEFd2pBmfOJ1AVqIgggUiAFQR53IgtzcSALc2ogAyAXaiAYIAsgFnNxIBZzaiAIQQV3akGZ84nUBWoiBUEFd2pBmfOJ1AVqIhMgBUEedyIWIAhBHnciA3NxIANzaiALIBFqIAUgAyBSc3EgUnNqIBNBBXdqQZnzidQFaiIRQQV3akGZ84nUBWoiUkEedyILaiACIBNBHnciFWogByADaiARIBUgFnNxIBZzaiBSQQV3akGZ84nUBWoiByALIBFBHnciAnNxIAJzaiAgIBZqIFIgAiAVc3EgFXNqIAdBBXdqQZnzidQFaiIRQQV3akGZ84nUBWoiFiARQR53IhUgB0EedyIHc3EgB3NqIA8gAmogESAHIAtzcSALc2ogFkEFd2pBmfOJ1AVqIgtBBXdqQZnzidQFaiIRQR53IgJqIBIgFWogESALQR53Ig8gFkEedyISc3EgEnNqIA0gB2ogCyASIBVzcSAVc2ogEUEFd2pBmfOJ1AVqIg1BBXdqQZnzidQFaiIVQR53Ih8gDUEedyIHcyAZIBJqIA0gAiAPc3EgD3NqIBVBBXdqQZnzidQFaiINc2ogDiAPaiAVIAcgAnNxIAJzaiANQQV3akGZ84nUBWoiAkEFd2pBodfn9gZqIg5BHnciD2ogACAfaiACQR53IgAgDUEedyINcyAOc2ogGiAHaiANIB9zIAJzaiAOQQV3akGh1+f2BmoiAkEFd2pBodfn9gZqIg5BHnciEiACQR53IhRzICEgDWogDyAAcyACc2ogDkEFd2pBodfn9gZqIgJzaiAbIABqIBQgD3MgDnNqIAJBBXdqQaHX5/YGaiIAQQV3akGh1+f2BmoiDUEedyIOaiAcIBJqIABBHnciDyACQR53IgJzIA1zaiAmIBRqIAIgEnMgAHNqIA1BBXdqQaHX5/YGaiIAQQV3akGh1+f2BmoiDUEedyISIABBHnciFHMgIiACaiAOIA9zIABzaiANQQV3akGh1+f2BmoiAHNqICcgD2ogFCAOcyANc2ogAEEFd2pBodfn9gZqIgJBBXdqQaHX5/YGaiINQR53Ig5qICggEmogAkEedyIPIABBHnciAHMgDXNqICMgFGogACAScyACc2ogDUEFd2pBodfn9gZqIgJBBXdqQaHX5/YGaiINQR53IhIgAkEedyIUcyAeIABqIA4gD3MgAnNqIA1BBXdqQaHX5/YGaiIAc2ogLiAPaiAUIA5zIA1zaiAAQQV3akGh1+f2BmoiAkEFd2pBodfn9gZqIg1BHnciDmogKiAAQR53IgBqIA4gAkEedyIPcyAkIBRqIAAgEnMgAnNqIA1BBXdqQaHX5/YGaiIUc2ogLyASaiAPIABzIA1zaiAUQQV3akGh1+f2BmoiDUEFd2pBodfn9gZqIgAgDUEedyICciAUQR53IhJxIAAgAnFyaiAlIA9qIBIgDnMgDXNqIABBBXdqQaHX5/YGaiINQQV3akHc+e74eGoiDkEedyIPaiA1IABBHnciAGogKyASaiANIAByIAJxIA0gAHFyaiAOQQV3akHc+e74eGoiEiAPciANQR53Ig1xIBIgD3FyaiAwIAJqIA4gDXIgAHEgDiANcXJqIBJBBXdqQdz57vh4aiIAQQV3akHc+e74eGoiAiAAQR53Ig5yIBJBHnciEnEgAiAOcXJqICwgDWogACASciAPcSAAIBJxcmogAkEFd2pB3Pnu+HhqIgBBBXdqQdz57vh4aiINQR53Ig9qIDwgAkEedyICaiA2IBJqIAAgAnIgDnEgACACcXJqIA1BBXdqQdz57vh4aiISIA9yIABBHnciAHEgEiAPcXJqIC0gDmogDSAAciACcSANIABxcmogEkEFd2pB3Pnu+HhqIgJBBXdqQdz57vh4aiINIAJBHnciDnIgEkEedyIScSANIA5xcmogNyAAaiACIBJyIA9xIAIgEnFyaiANQQV3akHc+e74eGoiAEEFd2pB3Pnu+HhqIgJBHnciD2ogMyANQR53Ig1qID0gEmogACANciAOcSAAIA1xcmogAkEFd2pB3Pnu+HhqIhIgD3IgAEEedyIAcSASIA9xcmogOCAOaiACIAByIA1xIAIgAHFyaiASQQV3akHc+e74eGoiAkEFd2pB3Pnu+HhqIg0gAkEedyIOciASQR53IhJxIA0gDnFyaiBCIABqIAIgEnIgD3EgAiAScXJqIA1BBXdqQdz57vh4aiIAQQV3akHc+e74eGoiAkEedyIPaiBDIA5qIAIgAEEedyIUciANQR53Ig1xIAIgFHFyaiA+IBJqIAAgDXIgDnEgACANcXJqIAJBBXdqQdz57vh4aiIAQQV3akHc+e74eGoiAkEedyISIABBHnciDnMgOiANaiAAIA9yIBRxIAAgD3FyaiACQQV3akHc+e74eGoiAHNqID8gFGogAiAOciAPcSACIA5xcmogAEEFd2pB3Pnu+HhqIgJBBXdqQdaDi9N8aiINQR53Ig9qIEogEmogAkEedyIUIABBHnciAHMgDXNqIDsgDmogACAScyACc2ogDUEFd2pB1oOL03xqIgJBBXdqQdaDi9N8aiINQR53Ig4gAkEedyIScyBFIABqIA8gFHMgAnNqIA1BBXdqQdaDi9N8aiIAc2ogQCAUaiASIA9zIA1zaiAAQQV3akHWg4vTfGoiAkEFd2pB1oOL03xqIg1BHnciD2ogQSAOaiACQR53IhQgAEEedyIAcyANc2ogRiASaiAAIA5zIAJzaiANQQV3akHWg4vTfGoiAkEFd2pB1oOL03xqIg1BHnciDiACQR53IhJzIEIgOHMgRHMgTHNBAXciFSAAaiAPIBRzIAJzaiANQQV3akHWg4vTfGoiAHNqIEcgFGogEiAPcyANc2ogAEEFd2pB1oOL03xqIgJBBXdqQdaDi9N8aiINQR53Ig9qIEggDmogAkEedyIUIABBHnciAHMgDXNqIEMgOXMgRXMgFXNBAXciGSASaiAAIA5zIAJzaiANQQV3akHWg4vTfGoiAkEFd2pB1oOL03xqIg1BHnciDiACQR53IhJzID8gQ3MgTHMgS3NBAXciGiAAaiAPIBRzIAJzaiANQQV3akHWg4vTfGoiAHNqIEQgOnMgRnMgGXNBAXciGyAUaiASIA9zIA1zaiAAQQV3akHWg4vTfGoiAkEFd2pB1oOL03xqIg1BHnciDyBOajYCkIkBQQAgTyBKIERzIBVzIBpzQQF3IhQgEmogAEEedyIAIA5zIAJzaiANQQV3akHWg4vTfGoiEkEedyIVajYCjIkBQQAgCSBFIDtzIEdzIBtzQQF3IA5qIAJBHnciAiAAcyANc2ogEkEFd2pB1oOL03xqIg1BHndqNgKIiQFBACBQIEAgSnMgS3MgSXNBAXcgAGogDyACcyASc2ogDUEFd2pB1oOL03xqIgBqNgKEiQFBACBNIEwgRXMgGXMgFHNBAXdqIAJqIBUgD3MgDXNqIABBBXdqQdaDi9N8ajYCgIkBCzoAQQBC/rnrxemOlZkQNwKIiQFBAEKBxpS6lvHq5m83AoCJAUEAQvDDy54MNwKQiQFBAEEANgKYiQELqAMBCH9BACECQQBBACgClIkBIgMgAUEDdGoiBDYClIkBQQBBACgCmIkBIAQgA0lqIAFBHXZqNgKYiQECQCADQQN2QT9xIgUgAWpBwABJDQBBwAAgBWsiAkEDcSEGQQAhAwJAIAVBP3NBA0kNACAFQYCJAWohByACQfwAcSEIQQAhAwNAIAcgA2oiBEEcaiAAIANqIgktAAA6AAAgBEEdaiAJQQFqLQAAOgAAIARBHmogCUECai0AADoAACAEQR9qIAlBA2otAAA6AAAgCCADQQRqIgNHDQALCwJAIAZFDQAgACADaiEEIAMgBWpBnIkBaiEDA0AgAyAELQAAOgAAIARBAWohBCADQQFqIQMgBkF/aiIGDQALC0GciQEQASAFQf8AcyEDQQAhBSADIAFPDQADQCAAIAJqEAEgAkH/AGohAyACQcAAaiIEIQIgAyABSQ0ACyAEIQILAkAgASACRg0AIAEgAmshCSAAIAJqIQIgBUGciQFqIQNBACEEA0AgAyACLQAAOgAAIAJBAWohAiADQQFqIQMgCSAEQQFqIgRB/wFxSw0ACwsLCQBBgAkgABADC6YDAQJ/IwBBEGsiACQAIABBgAE6AAcgAEEAKAKYiQEiAUEYdCABQYD+A3FBCHRyIAFBCHZBgP4DcSABQRh2cnI2AAggAEEAKAKUiQEiAUEYdCABQYD+A3FBCHRyIAFBCHZBgP4DcSABQRh2cnI2AAwgAEEHakEBEAMCQEEAKAKUiQFB+ANxQcADRg0AA0AgAEEAOgAHIABBB2pBARADQQAoApSJAUH4A3FBwANHDQALCyAAQQhqQQgQA0EAQQAoAoCJASIBQRh0IAFBgP4DcUEIdHIgAUEIdkGA/gNxIAFBGHZycjYCgAlBAEEAKAKEiQEiAUEYdCABQYD+A3FBCHRyIAFBCHZBgP4DcSABQRh2cnI2AoQJQQBBACgCiIkBIgFBGHQgAUGA/gNxQQh0ciABQQh2QYD+A3EgAUEYdnJyNgKICUEAQQAoAoyJASIBQRh0IAFBgP4DcUEIdHIgAUEIdkGA/gNxIAFBGHZycjYCjAlBAEEAKAKQiQEiAUEYdCABQYD+A3FBCHRyIAFBCHZBgP4DcSABQRh2cnI2ApAJIABBEGokAAsGAEGAiQELQwBBAEL+uevF6Y6VmRA3AoiJAUEAQoHGlLqW8ermbzcCgIkBQQBC8MPLngw3ApCJAUEAQQA2ApiJAUGACSAAEAMQBQsLCwEAQYAICwRcAAAA";
    hash$c = "6b530c24";
    wasmJson$c = {
      name: name$c,
      data: data$c,
      hash: hash$c
    };
    mutex$d = new Mutex();
    wasmCache$d = null;
    name$b = "sha3";
    data$b = "AGFzbQEAAAABFARgAAF/YAF/AGACf38AYAN/f38AAwgHAAEBAgEAAwUEAQECAgYOAn8BQZCNBQt/AEGACAsHcAgGbWVtb3J5AgAOSGFzaF9HZXRCdWZmZXIAAAlIYXNoX0luaXQAAQtIYXNoX1VwZGF0ZQACCkhhc2hfRmluYWwABA1IYXNoX0dldFN0YXRlAAUOSGFzaF9DYWxjdWxhdGUABgpTVEFURV9TSVpFAwEKpBwHBQBBgAoL1wMAQQBCADcDgI0BQQBCADcD+IwBQQBCADcD8IwBQQBCADcD6IwBQQBCADcD4IwBQQBCADcD2IwBQQBCADcD0IwBQQBCADcDyIwBQQBCADcDwIwBQQBCADcDuIwBQQBCADcDsIwBQQBCADcDqIwBQQBCADcDoIwBQQBCADcDmIwBQQBCADcDkIwBQQBCADcDiIwBQQBCADcDgIwBQQBCADcD+IsBQQBCADcD8IsBQQBCADcD6IsBQQBCADcD4IsBQQBCADcD2IsBQQBCADcD0IsBQQBCADcDyIsBQQBCADcDwIsBQQBCADcDuIsBQQBCADcDsIsBQQBCADcDqIsBQQBCADcDoIsBQQBCADcDmIsBQQBCADcDkIsBQQBCADcDiIsBQQBCADcDgIsBQQBCADcD+IoBQQBCADcD8IoBQQBCADcD6IoBQQBCADcD4IoBQQBCADcD2IoBQQBCADcD0IoBQQBCADcDyIoBQQBCADcDwIoBQQBCADcDuIoBQQBCADcDsIoBQQBCADcDqIoBQQBCADcDoIoBQQBCADcDmIoBQQBCADcDkIoBQQBCADcDiIoBQQBCADcDgIoBQQBBwAwgAEEBdGtBA3Y2AoyNAUEAQQA2AoiNAQuMAwEIfwJAQQAoAoiNASIBQQBIDQBBACABIABqQQAoAoyNASICcDYCiI0BAkACQCABDQBBgAohAwwBCwJAIAIgAWsiBCAAIAQgAEkbIgNFDQAgA0EDcSEFQQAhBgJAIANBBEkNACABQYCKAWohByADQXxxIQhBACEGA0AgByAGaiIDQcgBaiAGQYAKai0AADoAACADQckBaiAGQYEKai0AADoAACADQcoBaiAGQYIKai0AADoAACADQcsBaiAGQYMKai0AADoAACAIIAZBBGoiBkcNAAsLIAVFDQAgAUHIiwFqIQMDQCADIAZqIAZBgApqLQAAOgAAIAZBAWohBiAFQX9qIgUNAAsLIAAgBEkNAUHIiwEgAhADIAAgBGshACAEQYAKaiEDCwJAIAAgAkkNAANAIAMgAhADIAMgAmohAyAAIAJrIgAgAk8NAAsLIABFDQBBACECQcgBIQYDQCAGQYCKAWogAyAGakG4fmotAAA6AAAgBkEBaiEGIAAgAkEBaiICQf8BcUsNAAsLC+ALAS1+IAApA0AhAkEAKQPAigEhAyAAKQM4IQRBACkDuIoBIQUgACkDMCEGQQApA7CKASEHIAApAyghCEEAKQOoigEhCSAAKQMgIQpBACkDoIoBIQsgACkDGCEMQQApA5iKASENIAApAxAhDkEAKQOQigEhDyAAKQMIIRBBACkDiIoBIREgACkDACESQQApA4CKASETQQApA8iKASEUAkACQCABQcgASw0AQQApA+iKASEVQQApA/iKASEWQQApA/CKASEXQQApA4CLASEYQQApA9CKASEZQQApA+CKASEaQQApA9iKASEbDAELQQApA+CKASAAKQNghSEaQQApA9iKASAAKQNYhSEbQQApA9CKASAAKQNQhSEZIBQgACkDSIUhFEEAKQPoigEhFUEAKQP4igEhFkEAKQPwigEhF0EAKQOAiwEhGCABQekASQ0AIBggACkDgAGFIRggFiAAKQN4hSEWIBcgACkDcIUhFyAVIAApA2iFIRUgAUGJAUkNAEEAQQApA4iLASAAKQOIAYU3A4iLAQsgAyAChSEcIAUgBIUhHSAHIAaFIQcgCSAIhSEIIAsgCoUhHiANIAyFIQkgDyAOhSEKIBEgEIUhCyATIBKFIQxBACkDuIsBIRBBACkDkIsBIRFBACkDoIsBIRJBACkDsIsBIRNBACkDiIsBIQ1BACkDwIsBIQ5BACkDmIsBIR9BACkDqIsBIQ9BwH4hAANAIB4gByALhSAbhSAYhSAPhUIBiYUgFIUgF4UgH4UgDoUhAiAMIB0gCoUgGoUgDYUgE4VCAYmFIAiFIBmFIBaFIBKFIgMgB4UhICAJIAggDIUgGYUgFoUgEoVCAYmFIByFIBWFIBGFIBCFIgQgDoUhISAcIAogFCAehSAXhSAfhSAOhUIBiYUgHYUgGoUgDYUgE4UiBYVCN4kiIiALIBwgCYUgFYUgEYUgEIVCAYmFIAeFIBuFIBiFIA+FIgYgCoVCPokiI0J/hYMgAyAPhUICiSIkhSEOIBYgAoVCKYkiJSAEIBeFQieJIiZCf4WDICKFIQ8gECAFhUI4iSIQIAYgDYVCD4kiJ0J/hYMgAyAbhUIKiSIohSENIAQgHoVCG4kiKSAoIAggAoVCJIkiKkJ/hYOFIRYgBiAdhUIGiSIrIAMgC4VCAYkiLEJ/hYMgEiAChUISiSIthSEXICsgBCAfhUIIiSIuIBUgBYVCGYkiFUJ/hYOFIRsgBiAThUI9iSIdIAQgFIVCFIkiBCAJIAWFQhyJIghCf4WDhSEUIAggHUJ/hYMgAyAYhUItiSIDhSEcIB0gA0J/hYMgGSAChUIDiSIJhSEdIAQgAyAJQn+Fg4UhByAJIARCf4WDIAiFIQggDCAChSICICFCDokiA0J/hYMgESAFhUIViSIEhSEJIAYgGoVCK4kiBSADIARCf4WDhSEKIAQgBUJ/hYMgIEIsiSIEhSELIABB0AlqKQMAIAUgBEJ/hYOFIAKFIQwgJyAoQn+FgyAqhSIFIRggAyAEIAJCf4WDhSICIR4gKiApQn+FgyAQhSIDIR8gLSAuQn+FgyAVhSIEIRogJiAkICVCf4WDhSIGIRMgFSArQn+FgyAshSIoIRkgIyAmICJCf4WDhSIiIRIgLiAsIC1Cf4WDhSImIRUgJyApIBBCf4WDhSInIREgIyAkQn+FgyAlhSIjIRAgAEEIaiIADQALQQAgDzcDqIsBQQAgBTcDgIsBQQAgGzcD2IoBQQAgBzcDsIoBQQAgCzcDiIoBQQAgDjcDwIsBQQAgAzcDmIsBQQAgFzcD8IoBQQAgFDcDyIoBQQAgAjcDoIoBQQAgBjcDsIsBQQAgDTcDiIsBQQAgBDcD4IoBQQAgHTcDuIoBQQAgCjcDkIoBQQAgIjcDoIsBQQAgFjcD+IoBQQAgKDcD0IoBQQAgCDcDqIoBQQAgDDcDgIoBQQAgIzcDuIsBQQAgJzcDkIsBQQAgJjcD6IoBQQAgHDcDwIoBQQAgCTcDmIoBC/gCAQV/QeQAQQAoAoyNASIBQQF2ayECAkBBACgCiI0BIgNBAEgNACABIQQCQCABIANGDQAgA0HIiwFqIQVBACEDA0AgBSADakEAOgAAIANBAWoiAyABQQAoAoiNASIEa0kNAAsLIARByIsBaiIDIAMtAAAgAHI6AAAgAUHHiwFqIgMgAy0AAEGAAXI6AABByIsBIAEQA0EAQYCAgIB4NgKIjQELAkAgAkEESQ0AIAJBAnYiA0EDcSEFQQAhBAJAIANBf2pBA0kNACADQfz///8DcSEBQQAhA0EAIQQDQCADQYAKaiADQYCKAWooAgA2AgAgA0GECmogA0GEigFqKAIANgIAIANBiApqIANBiIoBaigCADYCACADQYwKaiADQYyKAWooAgA2AgAgA0EQaiEDIAEgBEEEaiIERw0ACwsgBUUNACAFQQJ0IQEgBEECdCEDA0AgA0GACmogA0GAigFqKAIANgIAIANBBGohAyABQXxqIgENAAsLCwYAQYCKAQvRBgEDf0EAQgA3A4CNAUEAQgA3A/iMAUEAQgA3A/CMAUEAQgA3A+iMAUEAQgA3A+CMAUEAQgA3A9iMAUEAQgA3A9CMAUEAQgA3A8iMAUEAQgA3A8CMAUEAQgA3A7iMAUEAQgA3A7CMAUEAQgA3A6iMAUEAQgA3A6CMAUEAQgA3A5iMAUEAQgA3A5CMAUEAQgA3A4iMAUEAQgA3A4CMAUEAQgA3A/iLAUEAQgA3A/CLAUEAQgA3A+iLAUEAQgA3A+CLAUEAQgA3A9iLAUEAQgA3A9CLAUEAQgA3A8iLAUEAQgA3A8CLAUEAQgA3A7iLAUEAQgA3A7CLAUEAQgA3A6iLAUEAQgA3A6CLAUEAQgA3A5iLAUEAQgA3A5CLAUEAQgA3A4iLAUEAQgA3A4CLAUEAQgA3A/iKAUEAQgA3A/CKAUEAQgA3A+iKAUEAQgA3A+CKAUEAQgA3A9iKAUEAQgA3A9CKAUEAQgA3A8iKAUEAQgA3A8CKAUEAQgA3A7iKAUEAQgA3A7CKAUEAQgA3A6iKAUEAQgA3A6CKAUEAQgA3A5iKAUEAQgA3A5CKAUEAQgA3A4iKAUEAQgA3A4CKAUEAQcAMIAFBAXRrQQN2NgKMjQFBAEEANgKIjQEgABACQeQAQQAoAoyNASIAQQF2ayEDAkBBACgCiI0BIgFBAEgNACAAIQQCQCAAIAFGDQAgAUHIiwFqIQVBACEBA0AgBSABakEAOgAAIAFBAWoiASAAQQAoAoiNASIEa0kNAAsLIARByIsBaiIBIAEtAAAgAnI6AAAgAEHHiwFqIgEgAS0AAEGAAXI6AABByIsBIAAQA0EAQYCAgIB4NgKIjQELAkAgA0EESQ0AIANBAnYiAUEDcSEFQQAhBAJAIAFBf2pBA0kNACABQfz///8DcSEAQQAhAUEAIQQDQCABQYAKaiABQYCKAWooAgA2AgAgAUGECmogAUGEigFqKAIANgIAIAFBiApqIAFBiIoBaigCADYCACABQYwKaiABQYyKAWooAgA2AgAgAUEQaiEBIAAgBEEEaiIERw0ACwsgBUUNACAFQQJ0IQAgBEECdCEBA0AgAUGACmogAUGAigFqKAIANgIAIAFBBGohASAAQXxqIgANAAsLCwvYAQEAQYAIC9ABkAEAAAAAAAAAAAAAAAAAAAEAAAAAAAAAgoAAAAAAAACKgAAAAAAAgACAAIAAAACAi4AAAAAAAAABAACAAAAAAIGAAIAAAACACYAAAAAAAICKAAAAAAAAAIgAAAAAAAAACYAAgAAAAAAKAACAAAAAAIuAAIAAAAAAiwAAAAAAAICJgAAAAAAAgAOAAAAAAACAAoAAAAAAAICAAAAAAAAAgAqAAAAAAAAACgAAgAAAAICBgACAAAAAgICAAAAAAACAAQAAgAAAAAAIgACAAAAAgA==";
    hash$b = "fb24e536";
    wasmJson$b = {
      name: name$b,
      data: data$b,
      hash: hash$b
    };
    mutex$c = new Mutex();
    wasmCache$c = null;
    mutex$b = new Mutex();
    wasmCache$b = null;
    name$a = "sha256";
    data$a = "AGFzbQEAAAABEQRgAAF/YAF/AGAAAGACf38AAwgHAAEBAQIAAwUEAQECAgYOAn8BQfCJBQt/AEGACAsHcAgGbWVtb3J5AgAOSGFzaF9HZXRCdWZmZXIAAAlIYXNoX0luaXQAAQtIYXNoX1VwZGF0ZQACCkhhc2hfRmluYWwABA1IYXNoX0dldFN0YXRlAAUOSGFzaF9DYWxjdWxhdGUABgpTVEFURV9TSVpFAwEKnEoHBQBBgAkLnQEAQQBCADcDwIkBQQBBHEEgIABB4AFGIgAbNgLoiQFBAEKnn+anxvST/b5/Qquzj/yRo7Pw2wAgABs3A+CJAUEAQrGWgP6fooWs6ABC/6S5iMWR2oKbfyAAGzcD2IkBQQBCl7rDg5Onlod3QvLmu+Ojp/2npX8gABs3A9CJAUEAQti9loj8oLW+NkLnzKfQ1tDrs7t/IAAbNwPIiQEL7wICAX4Gf0EAQQApA8CJASIBIACtfDcDwIkBAkACQAJAIAGnQT9xIgINAEGACSEDDAELAkBBwAAgAmsiBCAAIAQgAEkbIgNFDQAgA0EDcSEFIAJBgIkBaiEGQQAhAgJAIANBBEkNACADQfwAcSEHQQAhAgNAIAYgAmoiAyACQYAJai0AADoAACADQQFqIAJBgQlqLQAAOgAAIANBAmogAkGCCWotAAA6AAAgA0EDaiACQYMJai0AADoAACAHIAJBBGoiAkcNAAsLIAVFDQADQCAGIAJqIAJBgAlqLQAAOgAAIAJBAWohAiAFQX9qIgUNAAsLIAAgBEkNAUGAiQEQAyAAIARrIQAgBEGACWohAwsCQCAAQcAASQ0AA0AgAxADIANBwABqIQMgAEFAaiIAQT9LDQALCyAARQ0AQQAhAkEAIQUDQCACQYCJAWogAyACai0AADoAACACQQFqIQIgACAFQQFqIgVB/wFxSw0ACwsLoz4BRX9BACAAKAI8IgFBGHQgAUGA/gNxQQh0ciABQQh2QYD+A3EgAUEYdnJyIgFBGXcgAUEOd3MgAUEDdnMgACgCOCICQRh0IAJBgP4DcUEIdHIgAkEIdkGA/gNxIAJBGHZyciICaiAAKAIgIgNBGHQgA0GA/gNxQQh0ciADQQh2QYD+A3EgA0EYdnJyIgRBGXcgBEEOd3MgBEEDdnMgACgCHCIDQRh0IANBgP4DcUEIdHIgA0EIdkGA/gNxIANBGHZyciIFaiAAKAIEIgNBGHQgA0GA/gNxQQh0ciADQQh2QYD+A3EgA0EYdnJyIgZBGXcgBkEOd3MgBkEDdnMgACgCACIDQRh0IANBgP4DcUEIdHIgA0EIdkGA/gNxIANBGHZyciIHaiAAKAIkIgNBGHQgA0GA/gNxQQh0ciADQQh2QYD+A3EgA0EYdnJyIghqIAJBD3cgAkENd3MgAkEKdnNqIgNqIAAoAhgiCUEYdCAJQYD+A3FBCHRyIAlBCHZBgP4DcSAJQRh2cnIiCkEZdyAKQQ53cyAKQQN2cyAAKAIUIglBGHQgCUGA/gNxQQh0ciAJQQh2QYD+A3EgCUEYdnJyIgtqIAJqIAAoAhAiCUEYdCAJQYD+A3FBCHRyIAlBCHZBgP4DcSAJQRh2cnIiDEEZdyAMQQ53cyAMQQN2cyAAKAIMIglBGHQgCUGA/gNxQQh0ciAJQQh2QYD+A3EgCUEYdnJyIg1qIAAoAjAiCUEYdCAJQYD+A3FBCHRyIAlBCHZBgP4DcSAJQRh2cnIiDmogACgCCCIJQRh0IAlBgP4DcUEIdHIgCUEIdkGA/gNxIAlBGHZyciIPQRl3IA9BDndzIA9BA3ZzIAZqIAAoAigiCUEYdCAJQYD+A3FBCHRyIAlBCHZBgP4DcSAJQRh2cnIiEGogAUEPdyABQQ13cyABQQp2c2oiCUEPdyAJQQ13cyAJQQp2c2oiEUEPdyARQQ13cyARQQp2c2oiEkEPdyASQQ13cyASQQp2c2oiE2ogACgCNCIUQRh0IBRBgP4DcUEIdHIgFEEIdkGA/gNxIBRBGHZyciIVQRl3IBVBDndzIBVBA3ZzIA5qIBJqIAAoAiwiAEEYdCAAQYD+A3FBCHRyIABBCHZBgP4DcSAAQRh2cnIiFkEZdyAWQQ53cyAWQQN2cyAQaiARaiAIQRl3IAhBDndzIAhBA3ZzIARqIAlqIAVBGXcgBUEOd3MgBUEDdnMgCmogAWogC0EZdyALQQ53cyALQQN2cyAMaiAVaiANQRl3IA1BDndzIA1BA3ZzIA9qIBZqIANBD3cgA0ENd3MgA0EKdnNqIhRBD3cgFEENd3MgFEEKdnNqIhdBD3cgF0ENd3MgF0EKdnNqIhhBD3cgGEENd3MgGEEKdnNqIhlBD3cgGUENd3MgGUEKdnNqIhpBD3cgGkENd3MgGkEKdnNqIhtBD3cgG0ENd3MgG0EKdnNqIhxBGXcgHEEOd3MgHEEDdnMgAkEZdyACQQ53cyACQQN2cyAVaiAYaiAOQRl3IA5BDndzIA5BA3ZzIBZqIBdqIBBBGXcgEEEOd3MgEEEDdnMgCGogFGogE0EPdyATQQ13cyATQQp2c2oiHUEPdyAdQQ13cyAdQQp2c2oiHkEPdyAeQQ13cyAeQQp2c2oiH2ogE0EZdyATQQ53cyATQQN2cyAYaiADQRl3IANBDndzIANBA3ZzIAFqIBlqIB9BD3cgH0ENd3MgH0EKdnNqIiBqIBJBGXcgEkEOd3MgEkEDdnMgF2ogH2ogEUEZdyARQQ53cyARQQN2cyAUaiAeaiAJQRl3IAlBDndzIAlBA3ZzIANqIB1qIBxBD3cgHEENd3MgHEEKdnNqIiFBD3cgIUENd3MgIUEKdnNqIiJBD3cgIkENd3MgIkEKdnNqIiNBD3cgI0ENd3MgI0EKdnNqIiRqIBtBGXcgG0EOd3MgG0EDdnMgHmogI2ogGkEZdyAaQQ53cyAaQQN2cyAdaiAiaiAZQRl3IBlBDndzIBlBA3ZzIBNqICFqIBhBGXcgGEEOd3MgGEEDdnMgEmogHGogF0EZdyAXQQ53cyAXQQN2cyARaiAbaiAUQRl3IBRBDndzIBRBA3ZzIAlqIBpqICBBD3cgIEENd3MgIEEKdnNqIiVBD3cgJUENd3MgJUEKdnNqIiZBD3cgJkENd3MgJkEKdnNqIidBD3cgJ0ENd3MgJ0EKdnNqIihBD3cgKEENd3MgKEEKdnNqIilBD3cgKUENd3MgKUEKdnNqIipBD3cgKkENd3MgKkEKdnNqIitBGXcgK0EOd3MgK0EDdnMgH0EZdyAfQQ53cyAfQQN2cyAbaiAnaiAeQRl3IB5BDndzIB5BA3ZzIBpqICZqIB1BGXcgHUEOd3MgHUEDdnMgGWogJWogJEEPdyAkQQ13cyAkQQp2c2oiLEEPdyAsQQ13cyAsQQp2c2oiLUEPdyAtQQ13cyAtQQp2c2oiLmogJEEZdyAkQQ53cyAkQQN2cyAnaiAgQRl3ICBBDndzICBBA3ZzIBxqIChqIC5BD3cgLkENd3MgLkEKdnNqIi9qICNBGXcgI0EOd3MgI0EDdnMgJmogLmogIkEZdyAiQQ53cyAiQQN2cyAlaiAtaiAhQRl3ICFBDndzICFBA3ZzICBqICxqICtBD3cgK0ENd3MgK0EKdnNqIjBBD3cgMEENd3MgMEEKdnNqIjFBD3cgMUENd3MgMUEKdnNqIjJBD3cgMkENd3MgMkEKdnNqIjNqICpBGXcgKkEOd3MgKkEDdnMgLWogMmogKUEZdyApQQ53cyApQQN2cyAsaiAxaiAoQRl3IChBDndzIChBA3ZzICRqIDBqICdBGXcgJ0EOd3MgJ0EDdnMgI2ogK2ogJkEZdyAmQQ53cyAmQQN2cyAiaiAqaiAlQRl3ICVBDndzICVBA3ZzICFqIClqIC9BD3cgL0ENd3MgL0EKdnNqIjRBD3cgNEENd3MgNEEKdnNqIjVBD3cgNUENd3MgNUEKdnNqIjZBD3cgNkENd3MgNkEKdnNqIjdBD3cgN0ENd3MgN0EKdnNqIjhBD3cgOEENd3MgOEEKdnNqIjlBD3cgOUENd3MgOUEKdnNqIjogOCA0IC4gLCAhIBsgGSADIA4gBEEAKALYiQEiO0EadyA7QRV3cyA7QQd3c0EAKALkiQEiPGpBACgC4IkBIj1BACgC3IkBIj5zIDtxID1zaiAHakGY36iUBGoiB0EAKALUiQEiP2oiACAMaiA7IA1qID4gD2ogPSAGaiAAID4gO3NxID5zaiAAQRp3IABBFXdzIABBB3dzakGRid2JB2oiQEEAKALQiQEiQWoiDCAAIDtzcSA7c2ogDEEadyAMQRV3cyAMQQd3c2pBz/eDrntqIkJBACgCzIkBIkNqIg0gDCAAc3EgAHNqIA1BGncgDUEVd3MgDUEHd3NqQaW3181+aiJEQQAoAsiJASIAaiIPIA0gDHNxIAxzaiAPQRp3IA9BFXdzIA9BB3dzakHbhNvKA2oiRSBBIEMgAHNxIEMgAHFzIABBHncgAEETd3MgAEEKd3NqIAdqIgZqIgdqIAUgD2ogCiANaiALIAxqIAcgDyANc3EgDXNqIAdBGncgB0EVd3MgB0EHd3NqQfGjxM8FaiIKIAYgAHMgQ3EgBiAAcXMgBkEedyAGQRN3cyAGQQp3c2ogQGoiDGoiBCAHIA9zcSAPc2ogBEEadyAEQRV3cyAEQQd3c2pBpIX+kXlqIgsgDCAGcyAAcSAMIAZxcyAMQR53IAxBE3dzIAxBCndzaiBCaiINaiIPIAQgB3NxIAdzaiAPQRp3IA9BFXdzIA9BB3dzakHVvfHYemoiQCANIAxzIAZxIA0gDHFzIA1BHncgDUETd3MgDUEKd3NqIERqIgZqIgcgDyAEc3EgBHNqIAdBGncgB0EVd3MgB0EHd3NqQZjVnsB9aiJCIAYgDXMgDHEgBiANcXMgBkEedyAGQRN3cyAGQQp3c2ogRWoiDGoiBWogFiAHaiAQIA9qIAggBGogBSAHIA9zcSAPc2ogBUEadyAFQRV3cyAFQQd3c2pBgbaNlAFqIgggDCAGcyANcSAMIAZxcyAMQR53IAxBE3dzIAxBCndzaiAKaiINaiIPIAUgB3NxIAdzaiAPQRp3IA9BFXdzIA9BB3dzakG+i8ahAmoiDiANIAxzIAZxIA0gDHFzIA1BHncgDUETd3MgDUEKd3NqIAtqIgZqIgcgDyAFc3EgBXNqIAdBGncgB0EVd3MgB0EHd3NqQcP7sagFaiIQIAYgDXMgDHEgBiANcXMgBkEedyAGQRN3cyAGQQp3c2ogQGoiDGoiBCAHIA9zcSAPc2ogBEEadyAEQRV3cyAEQQd3c2pB9Lr5lQdqIhYgDCAGcyANcSAMIAZxcyAMQR53IAxBE3dzIAxBCndzaiBCaiINaiIFaiABIARqIAIgB2ogFSAPaiAFIAQgB3NxIAdzaiAFQRp3IAVBFXdzIAVBB3dzakH+4/qGeGoiByANIAxzIAZxIA0gDHFzIA1BHncgDUETd3MgDUEKd3NqIAhqIgFqIgYgBSAEc3EgBHNqIAZBGncgBkEVd3MgBkEHd3NqQaeN8N55aiIEIAEgDXMgDHEgASANcXMgAUEedyABQRN3cyABQQp3c2ogDmoiAmoiDCAGIAVzcSAFc2ogDEEadyAMQRV3cyAMQQd3c2pB9OLvjHxqIgUgAiABcyANcSACIAFxcyACQR53IAJBE3dzIAJBCndzaiAQaiIDaiINIAwgBnNxIAZzaiANQRp3IA1BFXdzIA1BB3dzakHB0+2kfmoiCCADIAJzIAFxIAMgAnFzIANBHncgA0ETd3MgA0EKd3NqIBZqIgFqIg8gF2ogESANaiAUIAxqIAkgBmogDyANIAxzcSAMc2ogD0EadyAPQRV3cyAPQQd3c2pBho/5/X5qIgYgASADcyACcSABIANxcyABQR53IAFBE3dzIAFBCndzaiAHaiICaiIJIA8gDXNxIA1zaiAJQRp3IAlBFXdzIAlBB3dzakHGu4b+AGoiDCACIAFzIANxIAIgAXFzIAJBHncgAkETd3MgAkEKd3NqIARqIgNqIhEgCSAPc3EgD3NqIBFBGncgEUEVd3MgEUEHd3NqQczDsqACaiINIAMgAnMgAXEgAyACcXMgA0EedyADQRN3cyADQQp3c2ogBWoiAWoiFCARIAlzcSAJc2ogFEEadyAUQRV3cyAUQQd3c2pB79ik7wJqIg8gASADcyACcSABIANxcyABQR53IAFBE3dzIAFBCndzaiAIaiICaiIXaiATIBRqIBggEWogEiAJaiAXIBQgEXNxIBFzaiAXQRp3IBdBFXdzIBdBB3dzakGqidLTBGoiGCACIAFzIANxIAIgAXFzIAJBHncgAkETd3MgAkEKd3NqIAZqIgNqIgkgFyAUc3EgFHNqIAlBGncgCUEVd3MgCUEHd3NqQdzTwuUFaiIUIAMgAnMgAXEgAyACcXMgA0EedyADQRN3cyADQQp3c2ogDGoiAWoiESAJIBdzcSAXc2ogEUEadyARQRV3cyARQQd3c2pB2pHmtwdqIhcgASADcyACcSABIANxcyABQR53IAFBE3dzIAFBCndzaiANaiICaiISIBEgCXNxIAlzaiASQRp3IBJBFXdzIBJBB3dzakHSovnBeWoiGSACIAFzIANxIAIgAXFzIAJBHncgAkETd3MgAkEKd3NqIA9qIgNqIhNqIB4gEmogGiARaiAdIAlqIBMgEiARc3EgEXNqIBNBGncgE0EVd3MgE0EHd3NqQe2Mx8F6aiIaIAMgAnMgAXEgAyACcXMgA0EedyADQRN3cyADQQp3c2ogGGoiAWoiCSATIBJzcSASc2ogCUEadyAJQRV3cyAJQQd3c2pByM+MgHtqIhggASADcyACcSABIANxcyABQR53IAFBE3dzIAFBCndzaiAUaiICaiIRIAkgE3NxIBNzaiARQRp3IBFBFXdzIBFBB3dzakHH/+X6e2oiFCACIAFzIANxIAIgAXFzIAJBHncgAkETd3MgAkEKd3NqIBdqIgNqIhIgESAJc3EgCXNqIBJBGncgEkEVd3MgEkEHd3NqQfOXgLd8aiIXIAMgAnMgAXEgAyACcXMgA0EedyADQRN3cyADQQp3c2ogGWoiAWoiE2ogICASaiAcIBFqIB8gCWogEyASIBFzcSARc2ogE0EadyATQRV3cyATQQd3c2pBx6KerX1qIhkgASADcyACcSABIANxcyABQR53IAFBE3dzIAFBCndzaiAaaiICaiIJIBMgEnNxIBJzaiAJQRp3IAlBFXdzIAlBB3dzakHRxqk2aiIaIAIgAXMgA3EgAiABcXMgAkEedyACQRN3cyACQQp3c2ogGGoiA2oiESAJIBNzcSATc2ogEUEadyARQRV3cyARQQd3c2pB59KkoQFqIhggAyACcyABcSADIAJxcyADQR53IANBE3dzIANBCndzaiAUaiIBaiISIBEgCXNxIAlzaiASQRp3IBJBFXdzIBJBB3dzakGFldy9AmoiFCABIANzIAJxIAEgA3FzIAFBHncgAUETd3MgAUEKd3NqIBdqIgJqIhMgI2ogJiASaiAiIBFqICUgCWogEyASIBFzcSARc2ogE0EadyATQRV3cyATQQd3c2pBuMLs8AJqIhcgAiABcyADcSACIAFxcyACQR53IAJBE3dzIAJBCndzaiAZaiIDaiIJIBMgEnNxIBJzaiAJQRp3IAlBFXdzIAlBB3dzakH827HpBGoiGSADIAJzIAFxIAMgAnFzIANBHncgA0ETd3MgA0EKd3NqIBpqIgFqIhEgCSATc3EgE3NqIBFBGncgEUEVd3MgEUEHd3NqQZOa4JkFaiIaIAEgA3MgAnEgASADcXMgAUEedyABQRN3cyABQQp3c2ogGGoiAmoiEiARIAlzcSAJc2ogEkEadyASQRV3cyASQQd3c2pB1OapqAZqIhggAiABcyADcSACIAFxcyACQR53IAJBE3dzIAJBCndzaiAUaiIDaiITaiAoIBJqICQgEWogJyAJaiATIBIgEXNxIBFzaiATQRp3IBNBFXdzIBNBB3dzakG7laizB2oiFCADIAJzIAFxIAMgAnFzIANBHncgA0ETd3MgA0EKd3NqIBdqIgFqIgkgEyASc3EgEnNqIAlBGncgCUEVd3MgCUEHd3NqQa6Si454aiIXIAEgA3MgAnEgASADcXMgAUEedyABQRN3cyABQQp3c2ogGWoiAmoiESAJIBNzcSATc2ogEUEadyARQRV3cyARQQd3c2pBhdnIk3lqIhkgAiABcyADcSACIAFxcyACQR53IAJBE3dzIAJBCndzaiAaaiIDaiISIBEgCXNxIAlzaiASQRp3IBJBFXdzIBJBB3dzakGh0f+VemoiGiADIAJzIAFxIAMgAnFzIANBHncgA0ETd3MgA0EKd3NqIBhqIgFqIhNqICogEmogLSARaiApIAlqIBMgEiARc3EgEXNqIBNBGncgE0EVd3MgE0EHd3NqQcvM6cB6aiIYIAEgA3MgAnEgASADcXMgAUEedyABQRN3cyABQQp3c2ogFGoiAmoiCSATIBJzcSASc2ogCUEadyAJQRV3cyAJQQd3c2pB8JauknxqIhQgAiABcyADcSACIAFxcyACQR53IAJBE3dzIAJBCndzaiAXaiIDaiIRIAkgE3NxIBNzaiARQRp3IBFBFXdzIBFBB3dzakGjo7G7fGoiFyADIAJzIAFxIAMgAnFzIANBHncgA0ETd3MgA0EKd3NqIBlqIgFqIhIgESAJc3EgCXNqIBJBGncgEkEVd3MgEkEHd3NqQZnQy4x9aiIZIAEgA3MgAnEgASADcXMgAUEedyABQRN3cyABQQp3c2ogGmoiAmoiE2ogMCASaiAvIBFqICsgCWogEyASIBFzcSARc2ogE0EadyATQRV3cyATQQd3c2pBpIzktH1qIhogAiABcyADcSACIAFxcyACQR53IAJBE3dzIAJBCndzaiAYaiIDaiIJIBMgEnNxIBJzaiAJQRp3IAlBFXdzIAlBB3dzakGF67igf2oiGCADIAJzIAFxIAMgAnFzIANBHncgA0ETd3MgA0EKd3NqIBRqIgFqIhEgCSATc3EgE3NqIBFBGncgEUEVd3MgEUEHd3NqQfDAqoMBaiIUIAEgA3MgAnEgASADcXMgAUEedyABQRN3cyABQQp3c2ogF2oiAmoiEiARIAlzcSAJc2ogEkEadyASQRV3cyASQQd3c2pBloKTzQFqIhcgAiABcyADcSACIAFxcyACQR53IAJBE3dzIAJBCndzaiAZaiIDaiITIDZqIDIgEmogNSARaiAxIAlqIBMgEiARc3EgEXNqIBNBGncgE0EVd3MgE0EHd3NqQYjY3fEBaiIZIAMgAnMgAXEgAyACcXMgA0EedyADQRN3cyADQQp3c2ogGmoiAWoiCSATIBJzcSASc2ogCUEadyAJQRV3cyAJQQd3c2pBzO6hugJqIhogASADcyACcSABIANxcyABQR53IAFBE3dzIAFBCndzaiAYaiICaiIRIAkgE3NxIBNzaiARQRp3IBFBFXdzIBFBB3dzakG1+cKlA2oiGCACIAFzIANxIAIgAXFzIAJBHncgAkETd3MgAkEKd3NqIBRqIgNqIhIgESAJc3EgCXNqIBJBGncgEkEVd3MgEkEHd3NqQbOZ8MgDaiIUIAMgAnMgAXEgAyACcXMgA0EedyADQRN3cyADQQp3c2ogF2oiAWoiE2ogLEEZdyAsQQ53cyAsQQN2cyAoaiA0aiAzQQ93IDNBDXdzIDNBCnZzaiIXIBJqIDcgEWogMyAJaiATIBIgEXNxIBFzaiATQRp3IBNBFXdzIBNBB3dzakHK1OL2BGoiGyABIANzIAJxIAEgA3FzIAFBHncgAUETd3MgAUEKd3NqIBlqIgJqIgkgEyASc3EgEnNqIAlBGncgCUEVd3MgCUEHd3NqQc+U89wFaiIZIAIgAXMgA3EgAiABcXMgAkEedyACQRN3cyACQQp3c2ogGmoiA2oiESAJIBNzcSATc2ogEUEadyARQRV3cyARQQd3c2pB89+5wQZqIhogAyACcyABcSADIAJxcyADQR53IANBE3dzIANBCndzaiAYaiIBaiISIBEgCXNxIAlzaiASQRp3IBJBFXdzIBJBB3dzakHuhb6kB2oiHCABIANzIAJxIAEgA3FzIAFBHncgAUETd3MgAUEKd3NqIBRqIgJqIhNqIC5BGXcgLkEOd3MgLkEDdnMgKmogNmogLUEZdyAtQQ53cyAtQQN2cyApaiA1aiAXQQ93IBdBDXdzIBdBCnZzaiIUQQ93IBRBDXdzIBRBCnZzaiIYIBJqIDkgEWogFCAJaiATIBIgEXNxIBFzaiATQRp3IBNBFXdzIBNBB3dzakHvxpXFB2oiCSACIAFzIANxIAIgAXFzIAJBHncgAkETd3MgAkEKd3NqIBtqIgNqIhEgEyASc3EgEnNqIBFBGncgEUEVd3MgEUEHd3NqQZTwoaZ4aiIbIAMgAnMgAXEgAyACcXMgA0EedyADQRN3cyADQQp3c2ogGWoiAWoiEiARIBNzcSATc2ogEkEadyASQRV3cyASQQd3c2pBiISc5nhqIhkgASADcyACcSABIANxcyABQR53IAFBE3dzIAFBCndzaiAaaiICaiITIBIgEXNxIBFzaiATQRp3IBNBFXdzIBNBB3dzakH6//uFeWoiGiACIAFzIANxIAIgAXFzIAJBHncgAkETd3MgAkEKd3NqIBxqIgNqIhQgPGo2AuSJAUEAID8gAyACcyABcSADIAJxcyADQR53IANBE3dzIANBCndzaiAJaiIBIANzIAJxIAEgA3FzIAFBHncgAUETd3MgAUEKd3NqIBtqIgIgAXMgA3EgAiABcXMgAkEedyACQRN3cyACQQp3c2ogGWoiAyACcyABcSADIAJxcyADQR53IANBE3dzIANBCndzaiAaaiIJajYC1IkBQQAgPSAvQRl3IC9BDndzIC9BA3ZzICtqIDdqIBhBD3cgGEENd3MgGEEKdnNqIhggEWogFCATIBJzcSASc2ogFEEadyAUQRV3cyAUQQd3c2pB69nBonpqIhkgAWoiEWo2AuCJAUEAIEEgCSADcyACcSAJIANxcyAJQR53IAlBE3dzIAlBCndzaiAZaiIBajYC0IkBQQAgPiAwQRl3IDBBDndzIDBBA3ZzIC9qIBdqIDpBD3cgOkENd3MgOkEKdnNqIBJqIBEgFCATc3EgE3NqIBFBGncgEUEVd3MgEUEHd3NqQffH5vd7aiIXIAJqIhJqNgLciQFBACBDIAEgCXMgA3EgASAJcXMgAUEedyABQRN3cyABQQp3c2ogF2oiAmo2AsyJAUEAIDsgNEEZdyA0QQ53cyA0QQN2cyAwaiA4aiAYQQ93IBhBDXdzIBhBCnZzaiATaiASIBEgFHNxIBRzaiASQRp3IBJBFXdzIBJBB3dzakHy8cWzfGoiESADamo2AtiJAUEAIAAgAiABcyAJcSACIAFxcyACQR53IAJBE3dzIAJBCndzaiARamo2AsiJAQuyBgIEfwF+QQAoAsCJASIAQQJ2QQ9xIgFBAnRBgIkBaiICIAIoAgBBfyAAQQN0IgB0QX9zcUGAASAAdHM2AgACQAJAAkAgAUEOSQ0AAkAgAUEORw0AQQBBADYCvIkBC0GAiQEQA0EAIQIMAQsgAUENRg0BIAFBAWohAgsgAiEDAkBBBiACa0EHcSIARQ0AIAIgAGohAyACQQJ0QYCJAWohAQNAIAFBADYCACABQQRqIQEgAEF/aiIADQALCyACQXlqQQdJDQAgA0ECdCEBA0AgAUGYiQFqQgA3AgAgAUGQiQFqQgA3AgAgAUGIiQFqQgA3AgAgAUGAiQFqQgA3AgAgAUEgaiIBQThHDQALC0EAIQFBAEEAKQPAiQEiBKciAEEbdCAAQQt0QYCA/AdxciAAQQV2QYD+A3EgAEEDdEEYdnJyNgK8iQFBACAEQh2IpyIAQRh0IABBgP4DcUEIdHIgAEEIdkGA/gNxIABBGHZycjYCuIkBQYCJARADQQBBACgC5IkBIgBBGHQgAEGA/gNxQQh0ciAAQQh2QYD+A3EgAEEYdnJyNgLkiQFBAEEAKALgiQEiAEEYdCAAQYD+A3FBCHRyIABBCHZBgP4DcSAAQRh2cnI2AuCJAUEAQQAoAtyJASIAQRh0IABBgP4DcUEIdHIgAEEIdkGA/gNxIABBGHZycjYC3IkBQQBBACgC2IkBIgBBGHQgAEGA/gNxQQh0ciAAQQh2QYD+A3EgAEEYdnJyNgLYiQFBAEEAKALUiQEiAEEYdCAAQYD+A3FBCHRyIABBCHZBgP4DcSAAQRh2cnI2AtSJAUEAQQAoAtCJASIAQRh0IABBgP4DcUEIdHIgAEEIdkGA/gNxIABBGHZycjYC0IkBQQBBACgCzIkBIgBBGHQgAEGA/gNxQQh0ciAAQQh2QYD+A3EgAEEYdnJyNgLMiQFBAEEAKALIiQEiAEEYdCAAQYD+A3FBCHRyIABBCHZBgP4DcSAAQRh2cnI2AsiJAQJAQQAoAuiJASICRQ0AQQAhAANAIAFBgAlqIAFByIkBai0AADoAACABQQFqIQEgAiAAQQFqIgBB/wFxSw0ACwsLBgBBgIkBC6MBAEEAQgA3A8CJAUEAQRxBICABQeABRiIBGzYC6IkBQQBCp5/mp8b0k/2+f0Krs4/8kaOz8NsAIAEbNwPgiQFBAEKxloD+n6KFrOgAQv+kuYjFkdqCm38gARs3A9iJAUEAQpe6w4OTp5aHd0Ly5rvjo6f9p6V/IAEbNwPQiQFBAELYvZaI/KC1vjZC58yn0NbQ67O7fyABGzcDyIkBIAAQAhAECwsLAQBBgAgLBHAAAAA=";
    hash$a = "8c18dd94";
    wasmJson$a = {
      name: name$a,
      data: data$a,
      hash: hash$a
    };
    mutex$a = new Mutex();
    wasmCache$a = null;
    mutex$9 = new Mutex();
    wasmCache$9 = null;
    name$9 = "sha512";
    data$9 = "AGFzbQEAAAABEQRgAAF/YAF/AGAAAGACf38AAwgHAAEBAQIAAwUEAQECAgYOAn8BQdCKBQt/AEGACAsHcAgGbWVtb3J5AgAOSGFzaF9HZXRCdWZmZXIAAAlIYXNoX0luaXQAAQtIYXNoX1VwZGF0ZQACCkhhc2hfRmluYWwABA1IYXNoX0dldFN0YXRlAAUOSGFzaF9DYWxjdWxhdGUABgpTVEFURV9TSVpFAwEKlWgHBQBBgAkLmwIAQQBCADcDgIoBQQBBMEHAACAAQYADRiIAGzYCyIoBQQBCpJ/p99uD0trHAEL5wvibkaOz8NsAIAAbNwPAigFBAEKnn+an1sGLhltC6/qG2r+19sEfIAAbNwO4igFBAEKRquDC9tCS2o5/Qp/Y+dnCkdqCm38gABs3A7CKAUEAQrGWgP7/zMmZ5wBC0YWa7/rPlIfRACAAGzcDqIoBQQBCubK5uI+b+5cVQvHt9Pilp/2npX8gABs3A6CKAUEAQpe6w4Ojq8CskX9Cq/DT9K/uvLc8IAAbNwOYigFBAEKHqvOzo6WKzeIAQrvOqqbY0Ouzu38gABs3A5CKAUEAQti9lojcq+fdS0KIkvOd/8z5hOoAIAAbNwOIigEL8gICAX4Gf0EAQQApA4CKASIBIACtfDcDgIoBAkACQAJAIAGnQf8AcSICDQBBgAkhAwwBCwJAQYABIAJrIgQgACAEIABJGyIDRQ0AIANBA3EhBSACQYCJAWohBkEAIQICQCADQQRJDQAgA0H8AXEhB0EAIQIDQCAGIAJqIgMgAkGACWotAAA6AAAgA0EBaiACQYEJai0AADoAACADQQJqIAJBgglqLQAAOgAAIANBA2ogAkGDCWotAAA6AAAgByACQQRqIgJHDQALCyAFRQ0AA0AgBiACaiACQYAJai0AADoAACACQQFqIQIgBUF/aiIFDQALCyAAIARJDQFBgIkBEAMgACAEayEAIARBgAlqIQMLAkAgAEGAAUkNAANAIAMQAyADQYABaiEDIABBgH9qIgBB/wBLDQALCyAARQ0AQQAhAkEAIQUDQCACQYCJAWogAyACai0AADoAACACQQFqIQIgACAFQQFqIgVB/wFxSw0ACwsL3FYBVn5BACAAKQMIIgFCOIYgAUKA/gODQiiGhCABQoCA/AeDQhiGIAFCgICA+A+DQgiGhIQgAUIIiEKAgID4D4MgAUIYiEKAgPwHg4QgAUIoiEKA/gODIAFCOIiEhIQiAkI/iSACQjiJhSACQgeIhSAAKQMAIgFCOIYgAUKA/gODQiiGhCABQoCA/AeDQhiGIAFCgICA+A+DQgiGhIQgAUIIiEKAgID4D4MgAUIYiEKAgPwHg4QgAUIoiEKA/gODIAFCOIiEhIQiA3wgACkDSCIBQjiGIAFCgP4Dg0IohoQgAUKAgPwHg0IYhiABQoCAgPgPg0IIhoSEIAFCCIhCgICA+A+DIAFCGIhCgID8B4OEIAFCKIhCgP4DgyABQjiIhISEIgR8IAApA3AiAUI4hiABQoD+A4NCKIaEIAFCgID8B4NCGIYgAUKAgID4D4NCCIaEhCABQgiIQoCAgPgPgyABQhiIQoCA/AeDhCABQiiIQoD+A4MgAUI4iISEhCIFQi2JIAVCA4mFIAVCBoiFfCIGQj+JIAZCOImFIAZCB4iFIAApA3giAUI4hiABQoD+A4NCKIaEIAFCgID8B4NCGIYgAUKAgID4D4NCCIaEhCABQgiIQoCAgPgPgyABQhiIQoCA/AeDhCABQiiIQoD+A4MgAUI4iISEhCIHfCAEQj+JIARCOImFIARCB4iFIAApA0AiAUI4hiABQoD+A4NCKIaEIAFCgID8B4NCGIYgAUKAgID4D4NCCIaEhCABQgiIQoCAgPgPgyABQhiIQoCA/AeDhCABQiiIQoD+A4MgAUI4iISEhCIIfCAAKQMQIgFCOIYgAUKA/gODQiiGhCABQoCA/AeDQhiGIAFCgICA+A+DQgiGhIQgAUIIiEKAgID4D4MgAUIYiEKAgPwHg4QgAUIoiEKA/gODIAFCOIiEhIQiCUI/iSAJQjiJhSAJQgeIhSACfCAAKQNQIgFCOIYgAUKA/gODQiiGhCABQoCA/AeDQhiGIAFCgICA+A+DQgiGhIQgAUIIiEKAgID4D4MgAUIYiEKAgPwHg4QgAUIoiEKA/gODIAFCOIiEhIQiCnwgB0ItiSAHQgOJhSAHQgaIhXwiC3wgACkDOCIBQjiGIAFCgP4Dg0IohoQgAUKAgPwHg0IYhiABQoCAgPgPg0IIhoSEIAFCCIhCgICA+A+DIAFCGIhCgID8B4OEIAFCKIhCgP4DgyABQjiIhISEIgxCP4kgDEI4iYUgDEIHiIUgACkDMCIBQjiGIAFCgP4Dg0IohoQgAUKAgPwHg0IYhiABQoCAgPgPg0IIhoSEIAFCCIhCgICA+A+DIAFCGIhCgID8B4OEIAFCKIhCgP4DgyABQjiIhISEIg18IAd8IAApAygiAUI4hiABQoD+A4NCKIaEIAFCgID8B4NCGIYgAUKAgID4D4NCCIaEhCABQgiIQoCAgPgPgyABQhiIQoCA/AeDhCABQiiIQoD+A4MgAUI4iISEhCIOQj+JIA5COImFIA5CB4iFIAApAyAiAUI4hiABQoD+A4NCKIaEIAFCgID8B4NCGIYgAUKAgID4D4NCCIaEhCABQgiIQoCAgPgPgyABQhiIQoCA/AeDhCABQiiIQoD+A4MgAUI4iISEhCIPfCAAKQNoIgFCOIYgAUKA/gODQiiGhCABQoCA/AeDQhiGIAFCgICA+A+DQgiGhIQgAUIIiEKAgID4D4MgAUIYiEKAgPwHg4QgAUIoiEKA/gODIAFCOIiEhIQiEHwgACkDGCIBQjiGIAFCgP4Dg0IohoQgAUKAgPwHg0IYhiABQoCAgPgPg0IIhoSEIAFCCIhCgICA+A+DIAFCGIhCgID8B4OEIAFCKIhCgP4DgyABQjiIhISEIhFCP4kgEUI4iYUgEUIHiIUgCXwgACkDWCIBQjiGIAFCgP4Dg0IohoQgAUKAgPwHg0IYhiABQoCAgPgPg0IIhoSEIAFCCIhCgICA+A+DIAFCGIhCgID8B4OEIAFCKIhCgP4DgyABQjiIhISEIhJ8IAZCLYkgBkIDiYUgBkIGiIV8IhNCLYkgE0IDiYUgE0IGiIV8IhRCLYkgFEIDiYUgFEIGiIV8IhVCLYkgFUIDiYUgFUIGiIV8IhZ8IAVCP4kgBUI4iYUgBUIHiIUgEHwgFXwgACkDYCIBQjiGIAFCgP4Dg0IohoQgAUKAgPwHg0IYhiABQoCAgPgPg0IIhoSEIAFCCIhCgICA+A+DIAFCGIhCgID8B4OEIAFCKIhCgP4DgyABQjiIhISEIhdCP4kgF0I4iYUgF0IHiIUgEnwgFHwgCkI/iSAKQjiJhSAKQgeIhSAEfCATfCAIQj+JIAhCOImFIAhCB4iFIAx8IAZ8IA1CP4kgDUI4iYUgDUIHiIUgDnwgBXwgD0I/iSAPQjiJhSAPQgeIhSARfCAXfCALQi2JIAtCA4mFIAtCBoiFfCIYQi2JIBhCA4mFIBhCBoiFfCIZQi2JIBlCA4mFIBlCBoiFfCIaQi2JIBpCA4mFIBpCBoiFfCIbQi2JIBtCA4mFIBtCBoiFfCIcQi2JIBxCA4mFIBxCBoiFfCIdQi2JIB1CA4mFIB1CBoiFfCIeQj+JIB5COImFIB5CB4iFIAdCP4kgB0I4iYUgB0IHiIUgBXwgGnwgEEI/iSAQQjiJhSAQQgeIhSAXfCAZfCASQj+JIBJCOImFIBJCB4iFIAp8IBh8IBZCLYkgFkIDiYUgFkIGiIV8Ih9CLYkgH0IDiYUgH0IGiIV8IiBCLYkgIEIDiYUgIEIGiIV8IiF8IBZCP4kgFkI4iYUgFkIHiIUgGnwgC0I/iSALQjiJhSALQgeIhSAGfCAbfCAhQi2JICFCA4mFICFCBoiFfCIifCAVQj+JIBVCOImFIBVCB4iFIBl8ICF8IBRCP4kgFEI4iYUgFEIHiIUgGHwgIHwgE0I/iSATQjiJhSATQgeIhSALfCAffCAeQi2JIB5CA4mFIB5CBoiFfCIjQi2JICNCA4mFICNCBoiFfCIkQi2JICRCA4mFICRCBoiFfCIlQi2JICVCA4mFICVCBoiFfCImfCAdQj+JIB1COImFIB1CB4iFICB8ICV8IBxCP4kgHEI4iYUgHEIHiIUgH3wgJHwgG0I/iSAbQjiJhSAbQgeIhSAWfCAjfCAaQj+JIBpCOImFIBpCB4iFIBV8IB58IBlCP4kgGUI4iYUgGUIHiIUgFHwgHXwgGEI/iSAYQjiJhSAYQgeIhSATfCAcfCAiQi2JICJCA4mFICJCBoiFfCInQi2JICdCA4mFICdCBoiFfCIoQi2JIChCA4mFIChCBoiFfCIpQi2JIClCA4mFIClCBoiFfCIqQi2JICpCA4mFICpCBoiFfCIrQi2JICtCA4mFICtCBoiFfCIsQi2JICxCA4mFICxCBoiFfCItQj+JIC1COImFIC1CB4iFICFCP4kgIUI4iYUgIUIHiIUgHXwgKXwgIEI/iSAgQjiJhSAgQgeIhSAcfCAofCAfQj+JIB9COImFIB9CB4iFIBt8ICd8ICZCLYkgJkIDiYUgJkIGiIV8Ii5CLYkgLkIDiYUgLkIGiIV8Ii9CLYkgL0IDiYUgL0IGiIV8IjB8ICZCP4kgJkI4iYUgJkIHiIUgKXwgIkI/iSAiQjiJhSAiQgeIhSAefCAqfCAwQi2JIDBCA4mFIDBCBoiFfCIxfCAlQj+JICVCOImFICVCB4iFICh8IDB8ICRCP4kgJEI4iYUgJEIHiIUgJ3wgL3wgI0I/iSAjQjiJhSAjQgeIhSAifCAufCAtQi2JIC1CA4mFIC1CBoiFfCIyQi2JIDJCA4mFIDJCBoiFfCIzQi2JIDNCA4mFIDNCBoiFfCI0Qi2JIDRCA4mFIDRCBoiFfCI1fCAsQj+JICxCOImFICxCB4iFIC98IDR8ICtCP4kgK0I4iYUgK0IHiIUgLnwgM3wgKkI/iSAqQjiJhSAqQgeIhSAmfCAyfCApQj+JIClCOImFIClCB4iFICV8IC18IChCP4kgKEI4iYUgKEIHiIUgJHwgLHwgJ0I/iSAnQjiJhSAnQgeIhSAjfCArfCAxQi2JIDFCA4mFIDFCBoiFfCI2Qi2JIDZCA4mFIDZCBoiFfCI3Qi2JIDdCA4mFIDdCBoiFfCI4Qi2JIDhCA4mFIDhCBoiFfCI5Qi2JIDlCA4mFIDlCBoiFfCI6Qi2JIDpCA4mFIDpCBoiFfCI7Qi2JIDtCA4mFIDtCBoiFfCI8Qj+JIDxCOImFIDxCB4iFIDBCP4kgMEI4iYUgMEIHiIUgLHwgOHwgL0I/iSAvQjiJhSAvQgeIhSArfCA3fCAuQj+JIC5COImFIC5CB4iFICp8IDZ8IDVCLYkgNUIDiYUgNUIGiIV8Ij1CLYkgPUIDiYUgPUIGiIV8Ij5CLYkgPkIDiYUgPkIGiIV8Ij98IDVCP4kgNUI4iYUgNUIHiIUgOHwgMUI/iSAxQjiJhSAxQgeIhSAtfCA5fCA/Qi2JID9CA4mFID9CBoiFfCJAfCA0Qj+JIDRCOImFIDRCB4iFIDd8ID98IDNCP4kgM0I4iYUgM0IHiIUgNnwgPnwgMkI/iSAyQjiJhSAyQgeIhSAxfCA9fCA8Qi2JIDxCA4mFIDxCBoiFfCJBQi2JIEFCA4mFIEFCBoiFfCJCQi2JIEJCA4mFIEJCBoiFfCJDQi2JIENCA4mFIENCBoiFfCJEfCA7Qj+JIDtCOImFIDtCB4iFID58IEN8IDpCP4kgOkI4iYUgOkIHiIUgPXwgQnwgOUI/iSA5QjiJhSA5QgeIhSA1fCBBfCA4Qj+JIDhCOImFIDhCB4iFIDR8IDx8IDdCP4kgN0I4iYUgN0IHiIUgM3wgO3wgNkI/iSA2QjiJhSA2QgeIhSAyfCA6fCBAQi2JIEBCA4mFIEBCBoiFfCJFQi2JIEVCA4mFIEVCBoiFfCJGQi2JIEZCA4mFIEZCBoiFfCJHQi2JIEdCA4mFIEdCBoiFfCJIQi2JIEhCA4mFIEhCBoiFfCJJQi2JIElCA4mFIElCBoiFfCJKQi2JIEpCA4mFIEpCBoiFfCJLIEkgRSA/ID0gMiAsICogIiAgIBYgBiAXIAhBACkDqIoBIkxCMokgTEIuiYUgTEIXiYVBACkDwIoBIk18QQApA7iKASJOQQApA7CKASJPhSBMgyBOhXwgA3xCotyiuY3zi8XCAHwiA0EAKQOgigEiUHwiASAPfCBMIBF8IE8gCXwgTiACfCABIE8gTIWDIE+FfCABQjKJIAFCLomFIAFCF4mFfELNy72fkpLRm/EAfCJRQQApA5iKASJSfCIJIAEgTIWDIEyFfCAJQjKJIAlCLomFIAlCF4mFfEKv9rTi/vm+4LV/fCJTQQApA5CKASJUfCIPIAkgAYWDIAGFfCAPQjKJIA9CLomFIA9CF4mFfEK8t6eM2PT22ml8IlVBACkDiIoBIgF8IhEgDyAJhYMgCYV8IBFCMokgEUIuiYUgEUIXiYV8Qrjqopq/y7CrOXwiViBSIFQgAYWDIFQgAYOFIAFCJIkgAUIeiYUgAUIZiYV8IAN8IgJ8IgN8IAwgEXwgDSAPfCAOIAl8IAMgESAPhYMgD4V8IANCMokgA0IuiYUgA0IXiYV8Qpmgl7CbvsT42QB8Ig0gAiABhSBUgyACIAGDhSACQiSJIAJCHomFIAJCGYmFfCBRfCIJfCIIIAMgEYWDIBGFfCAIQjKJIAhCLomFIAhCF4mFfEKbn+X4ytTgn5J/fCIOIAkgAoUgAYMgCSACg4UgCUIkiSAJQh6JhSAJQhmJhXwgU3wiD3wiESAIIAOFgyADhXwgEUIyiSARQi6JhSARQheJhXxCmIK2093al46rf3wiUSAPIAmFIAKDIA8gCYOFIA9CJIkgD0IeiYUgD0IZiYV8IFV8IgJ8IgMgESAIhYMgCIV8IANCMokgA0IuiYUgA0IXiYV8QsKEjJiK0+qDWHwiUyACIA+FIAmDIAIgD4OFIAJCJIkgAkIeiYUgAkIZiYV8IFZ8Igl8Igx8IBIgA3wgCiARfCAEIAh8IAwgAyARhYMgEYV8IAxCMokgDEIuiYUgDEIXiYV8Qr7fwauU4NbBEnwiBCAJIAKFIA+DIAkgAoOFIAlCJIkgCUIeiYUgCUIZiYV8IA18Ig98IhEgDCADhYMgA4V8IBFCMokgEUIuiYUgEUIXiYV8Qozlkvfkt+GYJHwiCiAPIAmFIAKDIA8gCYOFIA9CJIkgD0IeiYUgD0IZiYV8IA58IgJ8IgMgESAMhYMgDIV8IANCMokgA0IuiYUgA0IXiYV8QuLp/q+9uJ+G1QB8IhIgAiAPhSAJgyACIA+DhSACQiSJIAJCHomFIAJCGYmFfCBRfCIJfCIIIAMgEYWDIBGFfCAIQjKJIAhCLomFIAhCF4mFfELvku6Tz66X3/IAfCIXIAkgAoUgD4MgCSACg4UgCUIkiSAJQh6JhSAJQhmJhXwgU3wiD3wiDHwgByAIfCAFIAN8IBAgEXwgDCAIIAOFgyADhXwgDEIyiSAMQi6JhSAMQheJhXxCsa3a2OO/rO+Af3wiAyAPIAmFIAKDIA8gCYOFIA9CJIkgD0IeiYUgD0IZiYV8IAR8IgV8IgIgDCAIhYMgCIV8IAJCMokgAkIuiYUgAkIXiYV8QrWknK7y1IHum398IgggBSAPhSAJgyAFIA+DhSAFQiSJIAVCHomFIAVCGYmFfCAKfCIGfCIJIAIgDIWDIAyFfCAJQjKJIAlCLomFIAlCF4mFfEKUzaT7zK78zUF8IgwgBiAFhSAPgyAGIAWDhSAGQiSJIAZCHomFIAZCGYmFfCASfCIHfCIPIAkgAoWDIAKFfCAPQjKJIA9CLomFIA9CF4mFfELSlcX3mbjazWR8IgQgByAGhSAFgyAHIAaDhSAHQiSJIAdCHomFIAdCGYmFfCAXfCIFfCIRIBR8IBggD3wgEyAJfCALIAJ8IBEgDyAJhYMgCYV8IBFCMokgEUIuiYUgEUIXiYV8QuPLvMLj8JHfb3wiAiAFIAeFIAaDIAUgB4OFIAVCJIkgBUIeiYUgBUIZiYV8IAN8IgZ8IgsgESAPhYMgD4V8IAtCMokgC0IuiYUgC0IXiYV8QrWrs9zouOfgD3wiCSAGIAWFIAeDIAYgBYOFIAZCJIkgBkIeiYUgBkIZiYV8IAh8Igd8IhMgCyARhYMgEYV8IBNCMokgE0IuiYUgE0IXiYV8QuW4sr3HuaiGJHwiDyAHIAaFIAWDIAcgBoOFIAdCJIkgB0IeiYUgB0IZiYV8IAx8IgV8IhQgEyALhYMgC4V8IBRCMokgFEIuiYUgFEIXiYV8QvWErMn1jcv0LXwiESAFIAeFIAaDIAUgB4OFIAVCJIkgBUIeiYUgBUIZiYV8IAR8IgZ8Ihh8IBogFHwgFSATfCAZIAt8IBggFCAThYMgE4V8IBhCMokgGEIuiYUgGEIXiYV8QoPJm/WmlaG6ygB8IhYgBiAFhSAHgyAGIAWDhSAGQiSJIAZCHomFIAZCGYmFfCACfCIHfCILIBggFIWDIBSFfCALQjKJIAtCLomFIAtCF4mFfELU94fqy7uq2NwAfCIZIAcgBoUgBYMgByAGg4UgB0IkiSAHQh6JhSAHQhmJhXwgCXwiBXwiEyALIBiFgyAYhXwgE0IyiSATQi6JhSATQheJhXxCtafFmKib4vz2AHwiGCAFIAeFIAaDIAUgB4OFIAVCJIkgBUIeiYUgBUIZiYV8IA98IgZ8IhQgEyALhYMgC4V8IBRCMokgFEIuiYUgFEIXiYV8Qqu/m/OuqpSfmH98IhogBiAFhSAHgyAGIAWDhSAGQiSJIAZCHomFIAZCGYmFfCARfCIHfCIVfCAcIBR8IB8gE3wgGyALfCAVIBQgE4WDIBOFfCAVQjKJIBVCLomFIBVCF4mFfEKQ5NDt0s3xmKh/fCIbIAcgBoUgBYMgByAGg4UgB0IkiSAHQh6JhSAHQhmJhXwgFnwiBXwiCyAVIBSFgyAUhXwgC0IyiSALQi6JhSALQheJhXxCv8Lsx4n5yYGwf3wiFiAFIAeFIAaDIAUgB4OFIAVCJIkgBUIeiYUgBUIZiYV8IBl8IgZ8IhMgCyAVhYMgFYV8IBNCMokgE0IuiYUgE0IXiYV8QuSdvPf7+N+sv398IhkgBiAFhSAHgyAGIAWDhSAGQiSJIAZCHomFIAZCGYmFfCAYfCIHfCIUIBMgC4WDIAuFfCAUQjKJIBRCLomFIBRCF4mFfELCn6Lts/6C8EZ8IhggByAGhSAFgyAHIAaDhSAHQiSJIAdCHomFIAdCGYmFfCAafCIFfCIVfCAeIBR8ICEgE3wgHSALfCAVIBQgE4WDIBOFfCAVQjKJIBVCLomFIBVCF4mFfEKlzqqY+ajk01V8IhogBSAHhSAGgyAFIAeDhSAFQiSJIAVCHomFIAVCGYmFfCAbfCIGfCILIBUgFIWDIBSFfCALQjKJIAtCLomFIAtCF4mFfELvhI6AnuqY5QZ8IhsgBiAFhSAHgyAGIAWDhSAGQiSJIAZCHomFIAZCGYmFfCAWfCIHfCITIAsgFYWDIBWFfCATQjKJIBNCLomFIBNCF4mFfELw3LnQ8KzKlBR8IhYgByAGhSAFgyAHIAaDhSAHQiSJIAdCHomFIAdCGYmFfCAZfCIFfCIUIBMgC4WDIAuFfCAUQjKJIBRCLomFIBRCF4mFfEL838i21NDC2yd8IhkgBSAHhSAGgyAFIAeDhSAFQiSJIAVCHomFIAVCGYmFfCAYfCIGfCIVICh8ICQgFHwgJyATfCAjIAt8IBUgFCAThYMgE4V8IBVCMokgFUIuiYUgFUIXiYV8QqaSm+GFp8iNLnwiGCAGIAWFIAeDIAYgBYOFIAZCJIkgBkIeiYUgBkIZiYV8IBp8Igd8IgsgFSAUhYMgFIV8IAtCMokgC0IuiYUgC0IXiYV8Qu3VkNbFv5uWzQB8IhogByAGhSAFgyAHIAaDhSAHQiSJIAdCHomFIAdCGYmFfCAbfCIFfCITIAsgFYWDIBWFfCATQjKJIBNCLomFIBNCF4mFfELf59bsuaKDnNMAfCIbIAUgB4UgBoMgBSAHg4UgBUIkiSAFQh6JhSAFQhmJhXwgFnwiBnwiFCATIAuFgyALhXwgFEIyiSAUQi6JhSAUQheJhXxC3se93cjqnIXlAHwiFiAGIAWFIAeDIAYgBYOFIAZCJIkgBkIeiYUgBkIZiYV8IBl8Igd8IhV8ICYgFHwgKSATfCAlIAt8IBUgFCAThYMgE4V8IBVCMokgFUIuiYUgFUIXiYV8Qqjl3uOz14K19gB8IhkgByAGhSAFgyAHIAaDhSAHQiSJIAdCHomFIAdCGYmFfCAYfCIFfCILIBUgFIWDIBSFfCALQjKJIAtCLomFIAtCF4mFfELm3ba/5KWy4YF/fCIYIAUgB4UgBoMgBSAHg4UgBUIkiSAFQh6JhSAFQhmJhXwgGnwiBnwiEyALIBWFgyAVhXwgE0IyiSATQi6JhSATQheJhXxCu+qIpNGQi7mSf3wiGiAGIAWFIAeDIAYgBYOFIAZCJIkgBkIeiYUgBkIZiYV8IBt8Igd8IhQgEyALhYMgC4V8IBRCMokgFEIuiYUgFEIXiYV8QuSGxOeUlPrfon98IhsgByAGhSAFgyAHIAaDhSAHQiSJIAdCHomFIAdCGYmFfCAWfCIFfCIVfCAvIBR8ICsgE3wgLiALfCAVIBQgE4WDIBOFfCAVQjKJIBVCLomFIBVCF4mFfEKB4Ijiu8mZjah/fCIWIAUgB4UgBoMgBSAHg4UgBUIkiSAFQh6JhSAFQhmJhXwgGXwiBnwiCyAVIBSFgyAUhXwgC0IyiSALQi6JhSALQheJhXxCka/ih43u4qVCfCIZIAYgBYUgB4MgBiAFg4UgBkIkiSAGQh6JhSAGQhmJhXwgGHwiB3wiEyALIBWFgyAVhXwgE0IyiSATQi6JhSATQheJhXxCsPzSsrC0lLZHfCIYIAcgBoUgBYMgByAGg4UgB0IkiSAHQh6JhSAHQhmJhXwgGnwiBXwiFCATIAuFgyALhXwgFEIyiSAUQi6JhSAUQheJhXxCmKS9t52DuslRfCIaIAUgB4UgBoMgBSAHg4UgBUIkiSAFQh6JhSAFQhmJhXwgG3wiBnwiFXwgMSAUfCAtIBN8IDAgC3wgFSAUIBOFgyAThXwgFUIyiSAVQi6JhSAVQheJhXxCkNKWq8XEwcxWfCIbIAYgBYUgB4MgBiAFg4UgBkIkiSAGQh6JhSAGQhmJhXwgFnwiB3wiCyAVIBSFgyAUhXwgC0IyiSALQi6JhSALQheJhXxCqsDEu9WwjYd0fCIWIAcgBoUgBYMgByAGg4UgB0IkiSAHQh6JhSAHQhmJhXwgGXwiBXwiEyALIBWFgyAVhXwgE0IyiSATQi6JhSATQheJhXxCuKPvlYOOqLUQfCIZIAUgB4UgBoMgBSAHg4UgBUIkiSAFQh6JhSAFQhmJhXwgGHwiBnwiFCATIAuFgyALhXwgFEIyiSAUQi6JhSAUQheJhXxCyKHLxuuisNIZfCIYIAYgBYUgB4MgBiAFg4UgBkIkiSAGQh6JhSAGQhmJhXwgGnwiB3wiFSA0fCA3IBR8IDMgE3wgNiALfCAVIBQgE4WDIBOFfCAVQjKJIBVCLomFIBVCF4mFfELT1oaKhYHbmx58IhogByAGhSAFgyAHIAaDhSAHQiSJIAdCHomFIAdCGYmFfCAbfCIFfCILIBUgFIWDIBSFfCALQjKJIAtCLomFIAtCF4mFfEKZ17v8zemdpCd8IhsgBSAHhSAGgyAFIAeDhSAFQiSJIAVCHomFIAVCGYmFfCAWfCIGfCITIAsgFYWDIBWFfCATQjKJIBNCLomFIBNCF4mFfEKoke2M3pav2DR8IhYgBiAFhSAHgyAGIAWDhSAGQiSJIAZCHomFIAZCGYmFfCAZfCIHfCIUIBMgC4WDIAuFfCAUQjKJIBRCLomFIBRCF4mFfELjtKWuvJaDjjl8IhkgByAGhSAFgyAHIAaDhSAHQiSJIAdCHomFIAdCGYmFfCAYfCIFfCIVfCA5IBR8IDUgE3wgOCALfCAVIBQgE4WDIBOFfCAVQjKJIBVCLomFIBVCF4mFfELLlYaarsmq7M4AfCIYIAUgB4UgBoMgBSAHg4UgBUIkiSAFQh6JhSAFQhmJhXwgGnwiBnwiCyAVIBSFgyAUhXwgC0IyiSALQi6JhSALQheJhXxC88aPu/fJss7bAHwiGiAGIAWFIAeDIAYgBYOFIAZCJIkgBkIeiYUgBkIZiYV8IBt8Igd8IhMgCyAVhYMgFYV8IBNCMokgE0IuiYUgE0IXiYV8QqPxyrW9/puX6AB8IhsgByAGhSAFgyAHIAaDhSAHQiSJIAdCHomFIAdCGYmFfCAWfCIFfCIUIBMgC4WDIAuFfCAUQjKJIBRCLomFIBRCF4mFfEL85b7v5d3gx/QAfCIWIAUgB4UgBoMgBSAHg4UgBUIkiSAFQh6JhSAFQhmJhXwgGXwiBnwiFXwgOyAUfCA+IBN8IDogC3wgFSAUIBOFgyAThXwgFUIyiSAVQi6JhSAVQheJhXxC4N7cmPTt2NL4AHwiGSAGIAWFIAeDIAYgBYOFIAZCJIkgBkIeiYUgBkIZiYV8IBh8Igd8IgsgFSAUhYMgFIV8IAtCMokgC0IuiYUgC0IXiYV8QvLWwo/Kgp7khH98IhggByAGhSAFgyAHIAaDhSAHQiSJIAdCHomFIAdCGYmFfCAafCIFfCITIAsgFYWDIBWFfCATQjKJIBNCLomFIBNCF4mFfELs85DTgcHA44x/fCIaIAUgB4UgBoMgBSAHg4UgBUIkiSAFQh6JhSAFQhmJhXwgG3wiBnwiFCATIAuFgyALhXwgFEIyiSAUQi6JhSAUQheJhXxCqLyMm6L/v9+Qf3wiGyAGIAWFIAeDIAYgBYOFIAZCJIkgBkIeiYUgBkIZiYV8IBZ8Igd8IhV8IEEgFHwgQCATfCA8IAt8IBUgFCAThYMgE4V8IBVCMokgFUIuiYUgFUIXiYV8Qun7ivS9nZuopH98IhYgByAGhSAFgyAHIAaDhSAHQiSJIAdCHomFIAdCGYmFfCAZfCIFfCILIBUgFIWDIBSFfCALQjKJIAtCLomFIAtCF4mFfEKV8pmW+/7o/L5/fCIZIAUgB4UgBoMgBSAHg4UgBUIkiSAFQh6JhSAFQhmJhXwgGHwiBnwiEyALIBWFgyAVhXwgE0IyiSATQi6JhSATQheJhXxCq6bJm66e3rhGfCIYIAYgBYUgB4MgBiAFg4UgBkIkiSAGQh6JhSAGQhmJhXwgGnwiB3wiFCATIAuFgyALhXwgFEIyiSAUQi6JhSAUQheJhXxCnMOZ0e7Zz5NKfCIaIAcgBoUgBYMgByAGg4UgB0IkiSAHQh6JhSAHQhmJhXwgG3wiBXwiFSBHfCBDIBR8IEYgE3wgQiALfCAVIBQgE4WDIBOFfCAVQjKJIBVCLomFIBVCF4mFfEKHhIOO8piuw1F8IhsgBSAHhSAGgyAFIAeDhSAFQiSJIAVCHomFIAVCGYmFfCAWfCIGfCILIBUgFIWDIBSFfCALQjKJIAtCLomFIAtCF4mFfEKe1oPv7Lqf7Wp8IhYgBiAFhSAHgyAGIAWDhSAGQiSJIAZCHomFIAZCGYmFfCAZfCIHfCITIAsgFYWDIBWFfCATQjKJIBNCLomFIBNCF4mFfEL4orvz/u/TvnV8IhkgByAGhSAFgyAHIAaDhSAHQiSJIAdCHomFIAdCGYmFfCAYfCIFfCIUIBMgC4WDIAuFfCAUQjKJIBRCLomFIBRCF4mFfEK6392Qp/WZ+AZ8IhwgBSAHhSAGgyAFIAeDhSAFQiSJIAVCHomFIAVCGYmFfCAafCIGfCIVfCA9Qj+JID1COImFID1CB4iFIDl8IEV8IERCLYkgREIDiYUgREIGiIV8IhggFHwgSCATfCBEIAt8IBUgFCAThYMgE4V8IBVCMokgFUIuiYUgFUIXiYV8QqaxopbauN+xCnwiGiAGIAWFIAeDIAYgBYOFIAZCJIkgBkIeiYUgBkIZiYV8IBt8Igd8IgsgFSAUhYMgFIV8IAtCMokgC0IuiYUgC0IXiYV8Qq6b5PfLgOafEXwiGyAHIAaFIAWDIAcgBoOFIAdCJIkgB0IeiYUgB0IZiYV8IBZ8IgV8IhMgCyAVhYMgFYV8IBNCMokgE0IuiYUgE0IXiYV8QpuO8ZjR5sK4G3wiHSAFIAeFIAaDIAUgB4OFIAVCJIkgBUIeiYUgBUIZiYV8IBl8IgZ8IhQgEyALhYMgC4V8IBRCMokgFEIuiYUgFEIXiYV8QoT7kZjS/t3tKHwiHiAGIAWFIAeDIAYgBYOFIAZCJIkgBkIeiYUgBkIZiYV8IBx8Igd8IhV8ID9CP4kgP0I4iYUgP0IHiIUgO3wgR3wgPkI/iSA+QjiJhSA+QgeIhSA6fCBGfCAYQi2JIBhCA4mFIBhCBoiFfCIWQi2JIBZCA4mFIBZCBoiFfCIZIBR8IEogE3wgFiALfCAVIBQgE4WDIBOFfCAVQjKJIBVCLomFIBVCF4mFfEKTyZyGtO+q5TJ8IgsgByAGhSAFgyAHIAaDhSAHQiSJIAdCHomFIAdCGYmFfCAafCIFfCITIBUgFIWDIBSFfCATQjKJIBNCLomFIBNCF4mFfEK8/aauocGvzzx8IhogBSAHhSAGgyAFIAeDhSAFQiSJIAVCHomFIAVCGYmFfCAbfCIGfCIUIBMgFYWDIBWFfCAUQjKJIBRCLomFIBRCF4mFfELMmsDgyfjZjsMAfCIbIAYgBYUgB4MgBiAFg4UgBkIkiSAGQh6JhSAGQhmJhXwgHXwiB3wiFSAUIBOFgyAThXwgFUIyiSAVQi6JhSAVQheJhXxCtoX52eyX9eLMAHwiHCAHIAaFIAWDIAcgBoOFIAdCJIkgB0IeiYUgB0IZiYV8IB58IgV8IhYgTXw3A8CKAUEAIFAgBSAHhSAGgyAFIAeDhSAFQiSJIAVCHomFIAVCGYmFfCALfCIGIAWFIAeDIAYgBYOFIAZCJIkgBkIeiYUgBkIZiYV8IBp8IgcgBoUgBYMgByAGg4UgB0IkiSAHQh6JhSAHQhmJhXwgG3wiBSAHhSAGgyAFIAeDhSAFQiSJIAVCHomFIAVCGYmFfCAcfCILfDcDoIoBQQAgTiBAQj+JIEBCOImFIEBCB4iFIDx8IEh8IBlCLYkgGUIDiYUgGUIGiIV8IhkgE3wgFiAVIBSFgyAUhXwgFkIyiSAWQi6JhSAWQheJhXxCqvyV48+zyr/ZAHwiGiAGfCITfDcDuIoBQQAgUiALIAWFIAeDIAsgBYOFIAtCJIkgC0IeiYUgC0IZiYV8IBp8IgZ8NwOYigFBACBPIEFCP4kgQUI4iYUgQUIHiIUgQHwgGHwgS0ItiSBLQgOJhSBLQgaIhXwgFHwgEyAWIBWFgyAVhXwgE0IyiSATQi6JhSATQheJhXxC7PXb1rP12+XfAHwiGCAHfCIUfDcDsIoBQQAgVCAGIAuFIAWDIAYgC4OFIAZCJIkgBkIeiYUgBkIZiYV8IBh8Igd8NwOQigFBACBMIEVCP4kgRUI4iYUgRUIHiIUgQXwgSXwgGUItiSAZQgOJhSAZQgaIhXwgFXwgFCATIBaFgyAWhXwgFEIyiSAUQi6JhSAUQheJhXxCl7Cd0sSxhqLsAHwiEyAFfHw3A6iKAUEAIAEgByAGhSALgyAHIAaDhSAHQiSJIAdCHomFIAdCGYmFfCATfHw3A4iKAQvzCQIBfgR/QQApA4CKASIAp0EDdkEPcSIBQQN0QYCJAWoiAiACKQMAQn8gAEIDhiIAhkJ/hYNCgAEgAIaFNwMAIAFBAWohAwJAIAFBDkkNAAJAIANBD0cNAEEAQgA3A/iJAQtBgIkBEANBACEDCyADIQQCQEEHIANrQQdxIgJFDQAgAyACaiEEIANBA3RBgIkBaiEBA0AgAUIANwMAIAFBCGohASACQX9qIgINAAsLAkAgA0F4akEHSQ0AIARBA3QhAQNAIAFBuIkBakIANwMAIAFBsIkBakIANwMAIAFBqIkBakIANwMAIAFBoIkBakIANwMAIAFBmIkBakIANwMAIAFBkIkBakIANwMAIAFBiIkBakIANwMAIAFBgIkBakIANwMAIAFBwABqIgFB+ABHDQALC0EAIQFBAEEAKQOAigEiAEI7hiAAQiuGQoCAgICAgMD/AIOEIABCG4ZCgICAgIDgP4MgAEILhkKAgICA8B+DhIQgAEIFiEKAgID4D4MgAEIViEKAgPwHg4QgAEIliEKA/gODIABCA4ZCOIiEhIQ3A/iJAUGAiQEQA0EAQQApA8CKASIAQjiGIABCgP4Dg0IohoQgAEKAgPwHg0IYhiAAQoCAgPgPg0IIhoSEIABCCIhCgICA+A+DIABCGIhCgID8B4OEIABCKIhCgP4DgyAAQjiIhISENwPAigFBAEEAKQO4igEiAEI4hiAAQoD+A4NCKIaEIABCgID8B4NCGIYgAEKAgID4D4NCCIaEhCAAQgiIQoCAgPgPgyAAQhiIQoCA/AeDhCAAQiiIQoD+A4MgAEI4iISEhDcDuIoBQQBBACkDsIoBIgBCOIYgAEKA/gODQiiGhCAAQoCA/AeDQhiGIABCgICA+A+DQgiGhIQgAEIIiEKAgID4D4MgAEIYiEKAgPwHg4QgAEIoiEKA/gODIABCOIiEhIQ3A7CKAUEAQQApA6iKASIAQjiGIABCgP4Dg0IohoQgAEKAgPwHg0IYhiAAQoCAgPgPg0IIhoSEIABCCIhCgICA+A+DIABCGIhCgID8B4OEIABCKIhCgP4DgyAAQjiIhISENwOoigFBAEEAKQOgigEiAEI4hiAAQoD+A4NCKIaEIABCgID8B4NCGIYgAEKAgID4D4NCCIaEhCAAQgiIQoCAgPgPgyAAQhiIQoCA/AeDhCAAQiiIQoD+A4MgAEI4iISEhDcDoIoBQQBBACkDmIoBIgBCOIYgAEKA/gODQiiGhCAAQoCA/AeDQhiGIABCgICA+A+DQgiGhIQgAEIIiEKAgID4D4MgAEIYiEKAgPwHg4QgAEIoiEKA/gODIABCOIiEhIQ3A5iKAUEAQQApA5CKASIAQjiGIABCgP4Dg0IohoQgAEKAgPwHg0IYhiAAQoCAgPgPg0IIhoSEIABCCIhCgICA+A+DIABCGIhCgID8B4OEIABCKIhCgP4DgyAAQjiIhISENwOQigFBAEEAKQOIigEiAEI4hiAAQoD+A4NCKIaEIABCgID8B4NCGIYgAEKAgID4D4NCCIaEhCAAQgiIQoCAgPgPgyAAQhiIQoCA/AeDhCAAQiiIQoD+A4MgAEI4iISEhDcDiIoBAkBBACgCyIoBIgNFDQBBACECA0AgAUGACWogAUGIigFqLQAAOgAAIAFBAWohASADIAJBAWoiAkH/AXFLDQALCwsGAEGAiQELoQIAQQBCADcDgIoBQQBBMEHAACABQYADRiIBGzYCyIoBQQBCpJ/p99uD0trHAEL5wvibkaOz8NsAIAEbNwPAigFBAEKnn+an1sGLhltC6/qG2r+19sEfIAEbNwO4igFBAEKRquDC9tCS2o5/Qp/Y+dnCkdqCm38gARs3A7CKAUEAQrGWgP7/zMmZ5wBC0YWa7/rPlIfRACABGzcDqIoBQQBCubK5uI+b+5cVQvHt9Pilp/2npX8gARs3A6CKAUEAQpe6w4Ojq8CskX9Cq/DT9K/uvLc8IAEbNwOYigFBAEKHqvOzo6WKzeIAQrvOqqbY0Ouzu38gARs3A5CKAUEAQti9lojcq+fdS0KIkvOd/8z5hOoAIAEbNwOIigEgABACEAQLCwsBAEGACAsE0AAAAA==";
    hash$9 = "f2e40eb1";
    wasmJson$9 = {
      name: name$9,
      data: data$9,
      hash: hash$9
    };
    mutex$8 = new Mutex();
    wasmCache$8 = null;
    mutex$7 = new Mutex();
    wasmCache$7 = null;
    name$8 = "xxhash32";
    data$8 = "AGFzbQEAAAABEQRgAAF/YAF/AGAAAGACf38AAwcGAAEBAgADBQQBAQICBg4CfwFBsIkFC38AQYAICwdwCAZtZW1vcnkCAA5IYXNoX0dldEJ1ZmZlcgAACUhhc2hfSW5pdAABC0hhc2hfVXBkYXRlAAIKSGFzaF9GaW5hbAADDUhhc2hfR2V0U3RhdGUABA5IYXNoX0NhbGN1bGF0ZQAFClNUQVRFX1NJWkUDAQrvEQYFAEGACQtNAEEAQgA3A6iJAUEAIAA2AoiJAUEAIABBz4yijgZqNgKMiQFBACAAQfeUr694ajYChIkBQQAgAEGoiI2hAmo2AoCJAUEAQQA2AqCJAQu4CAEHfwJAIABFDQBBAEEAKQOoiQEgAK18NwOoiQECQEEAKAKgiQEiASAAakEPSw0AAkACQCAAQQNxIgINAEGACSEDIAAhBAwBCyAAQXxxIQRBgAkhAwNAQQBBACgCoIkBIgVBAWo2AqCJASAFQZCJAWogAy0AADoAACADQQFqIQMgAkF/aiICDQALCyAAQQRJDQEDQEEAQQAoAqCJASICQQFqNgKgiQEgAkGQiQFqIAMtAAA6AAAgA0EBai0AACECQQBBACgCoIkBIgVBAWo2AqCJASAFQZCJAWogAjoAACADQQJqLQAAIQJBAEEAKAKgiQEiBUEBajYCoIkBIAVBkIkBaiACOgAAIANBA2otAAAhAkEAQQAoAqCJASIFQQFqNgKgiQEgBUGQiQFqIAI6AAAgA0EEaiEDIARBfGoiBA0ADAILCyAAQfAIaiEGAkACQCABDQBBACgCjIkBIQJBACgCiIkBIQVBACgChIkBIQRBACgCgIkBIQFBgAkhAwwBC0GACSEDAkAgAUEPSw0AQYAJIQMCQAJAQQAgAWtBA3EiBA0AIAEhBQwBCyABIQIDQEEAIAJBAWoiBTYCoIkBIAJBkIkBaiADLQAAOgAAIANBAWohAyAFIQIgBEF/aiIEDQALCyABQXNqQQNJDQBBACEEA0AgAyAEaiIBLQAAIQdBACAFIARqIgJBAWo2AqCJASACQZCJAWogBzoAACABQQFqLQAAIQdBACACQQJqNgKgiQEgAkGRiQFqIAc6AAAgAUECai0AACEHQQAgAkEDajYCoIkBIAJBkokBaiAHOgAAIAFBA2otAAAhAUEAIAJBBGo2AqCJASACQZOJAWogAToAACAFIARBBGoiBGpBEEcNAAsgAyAEaiEDC0EAQQAoApCJAUH3lK+veGxBACgCgIkBakENd0Gx893xeWwiATYCgIkBQQBBACgClIkBQfeUr694bEEAKAKEiQFqQQ13QbHz3fF5bCIENgKEiQFBAEEAKAKYiQFB95Svr3hsQQAoAoiJAWpBDXdBsfPd8XlsIgU2AoiJAUEAQQAoApyJAUH3lK+veGxBACgCjIkBakENd0Gx893xeWwiAjYCjIkBCyAAQYAJaiEAAkAgAyAGSw0AA0AgAygCAEH3lK+veGwgAWpBDXdBsfPd8XlsIQEgA0EMaigCAEH3lK+veGwgAmpBDXdBsfPd8XlsIQIgA0EIaigCAEH3lK+veGwgBWpBDXdBsfPd8XlsIQUgA0EEaigCAEH3lK+veGwgBGpBDXdBsfPd8XlsIQQgA0EQaiIDIAZNDQALC0EAIAI2AoyJAUEAIAU2AoiJAUEAIAQ2AoSJAUEAIAE2AoCJAUEAIAAgA2s2AqCJASAAIANGDQBBACECA0AgAkGQiQFqIAMgAmotAAA6AAAgAkEBaiICQQAoAqCJAUkNAAsLC4MEAgF+Bn9BACkDqIkBIgCnIQECQAJAIABCEFQNAEEAKAKEiQFBB3dBACgCgIkBQQF3akEAKAKIiQFBDHdqQQAoAoyJAUESd2ohAgwBC0EAKAKIiQFBsc/ZsgFqIQILIAIgAWohAkGQiQEhA0GUiQEhAQJAQQAoAqCJASIEQZCJAWoiBUGUiQFJDQBBkIkBIQMCQCAEQXxqIgZBBHENAEEAKAKQiQFBvdzKlXxsIAJqQRF3Qa/W074CbCECQZiJASEBQZSJASEDIAZBBEkNAQsDQCABKAIAQb3cypV8bCADKAIAQb3cypV8bCACakERd0Gv1tO+AmxqQRF3Qa/W074CbCECIAFBBGohAyABQQhqIgEgBU0NAAsgAUF8aiEDCwJAIAMgBUYNACAEQY+JAWohBgJAAkAgBCADa0EBcQ0AIAMhAQwBCyADQQFqIQEgAy0AAEGxz9myAWwgAmpBC3dBsfPd8XlsIQILIAYgA0YNAANAIAFBAWotAABBsc/ZsgFsIAEtAABBsc/ZsgFsIAJqQQt3QbHz3fF5bGpBC3dBsfPd8XlsIQIgAUECaiIBIAVHDQALC0EAIAJBD3YgAnNB95Svr3hsIgFBDXYgAXNBvdzKlXxsIgFBEHYgAXMiAkEYdCACQYD+A3FBCHRyIAFBCHZBgP4DcSABQRh2cnKtNwOACQsGAEGAiQEL0gQCAX4Ef0EAQgA3A6iJAUEAIAE2AoiJAUEAIAFBz4yijgZqNgKMiQFBACABQfeUr694ajYChIkBQQAgAUGoiI2hAmo2AoCJAUEAQQA2AqCJASAAEAJBACkDqIkBIgKnIQECQAJAIAJCEFQNAEEAKAKEiQFBB3dBACgCgIkBQQF3akEAKAKIiQFBDHdqQQAoAoyJAUESd2ohAAwBC0EAKAKIiQFBsc/ZsgFqIQALIAAgAWohAEGQiQEhA0GUiQEhAQJAQQAoAqCJASIEQZCJAWoiBUGUiQFJDQBBkIkBIQMCQCAEQXxqIgZBBHENAEEAKAKQiQFBvdzKlXxsIABqQRF3Qa/W074CbCEAQZiJASEBQZSJASEDIAZBBEkNAQsDQCABKAIAQb3cypV8bCADKAIAQb3cypV8bCAAakERd0Gv1tO+AmxqQRF3Qa/W074CbCEAIAFBBGohAyABQQhqIgEgBU0NAAsgAUF8aiEDCwJAIAMgBUYNACAEQY+JAWohBgJAAkAgBCADa0EBcQ0AIAMhAQwBCyADQQFqIQEgAy0AAEGxz9myAWwgAGpBC3dBsfPd8XlsIQALIAYgA0YNAANAIAFBAWotAABBsc/ZsgFsIAEtAABBsc/ZsgFsIABqQQt3QbHz3fF5bGpBC3dBsfPd8XlsIQAgAUECaiIBIAVHDQALC0EAIABBD3YgAHNB95Svr3hsIgFBDXYgAXNBvdzKlXxsIgFBEHYgAXMiAEEYdCAAQYD+A3FBCHRyIAFBCHZBgP4DcSABQRh2cnKtNwOACQsLCwEAQYAICwQwAAAA";
    hash$8 = "4bb12485";
    wasmJson$8 = {
      name: name$8,
      data: data$8,
      hash: hash$8
    };
    mutex$6 = new Mutex();
    wasmCache$6 = null;
    name$7 = "xxhash64";
    data$7 = "AGFzbQEAAAABDANgAAF/YAAAYAF/AAMHBgABAgEAAQUEAQECAgYOAn8BQdCJBQt/AEGACAsHcAgGbWVtb3J5AgAOSGFzaF9HZXRCdWZmZXIAAAlIYXNoX0luaXQAAQtIYXNoX1VwZGF0ZQACCkhhc2hfRmluYWwAAw1IYXNoX0dldFN0YXRlAAQOSGFzaF9DYWxjdWxhdGUABQpTVEFURV9TSVpFAwEKmxEGBQBBgAkLYwEBfkEAQgA3A8iJAUEAQQApA4AJIgA3A5CJAUEAIABC+erQ0OfJoeThAHw3A5iJAUEAIABCz9bTvtLHq9lCfDcDiIkBQQAgAELW64Lu6v2J9eAAfDcDgIkBQQBBADYCwIkBC70IAwV/BH4CfwJAIABFDQBBAEEAKQPIiQEgAK18NwPIiQECQEEAKALAiQEiASAAakEfSw0AAkACQCAAQQNxIgINAEGACSEDIAAhAQwBCyAAQXxxIQFBgAkhAwNAQQBBACgCwIkBIgRBAWo2AsCJASAEQaCJAWogAy0AADoAACADQQFqIQMgAkF/aiICDQALCyAAQQRJDQEDQEEAQQAoAsCJASICQQFqNgLAiQEgAkGgiQFqIAMtAAA6AAAgA0EBai0AACECQQBBACgCwIkBIgRBAWo2AsCJASAEQaCJAWogAjoAACADQQJqLQAAIQJBAEEAKALAiQEiBEEBajYCwIkBIARBoIkBaiACOgAAIANBA2otAAAhAkEAQQAoAsCJASIEQQFqNgLAiQEgBEGgiQFqIAI6AAAgA0EEaiEDIAFBfGoiAQ0ADAILCyAAQeAIaiEFAkACQCABDQBBACkDmIkBIQZBACkDkIkBIQdBACkDiIkBIQhBACkDgIkBIQlBgAkhAwwBC0GACSEDAkAgAUEfSw0AQYAJIQMCQAJAQQAgAWtBA3EiBA0AIAEhAgwBCyABIQIDQCACQaCJAWogAy0AADoAACACQQFqIQIgA0EBaiEDIARBf2oiBA0ACwsgAUFjakEDSQ0AQSAgAmshCkEAIQQDQCACIARqIgFBoIkBaiADIARqIgstAAA6AAAgAUGhiQFqIAtBAWotAAA6AAAgAUGiiQFqIAtBAmotAAA6AAAgAUGjiQFqIAtBA2otAAA6AAAgCiAEQQRqIgRHDQALIAMgBGohAwtBAEEAKQOgiQFCz9bTvtLHq9lCfkEAKQOAiQF8Qh+JQoeVr6+Ytt6bnn9+Igk3A4CJAUEAQQApA6iJAULP1tO+0ser2UJ+QQApA4iJAXxCH4lCh5Wvr5i23puef34iCDcDiIkBQQBBACkDsIkBQs/W077Sx6vZQn5BACkDkIkBfEIfiUKHla+vmLbem55/fiIHNwOQiQFBAEEAKQO4iQFCz9bTvtLHq9lCfkEAKQOYiQF8Qh+JQoeVr6+Ytt6bnn9+IgY3A5iJAQsgAEGACWohAgJAIAMgBUsNAANAIAMpAwBCz9bTvtLHq9lCfiAJfEIfiUKHla+vmLbem55/fiEJIANBGGopAwBCz9bTvtLHq9lCfiAGfEIfiUKHla+vmLbem55/fiEGIANBEGopAwBCz9bTvtLHq9lCfiAHfEIfiUKHla+vmLbem55/fiEHIANBCGopAwBCz9bTvtLHq9lCfiAIfEIfiUKHla+vmLbem55/fiEIIANBIGoiAyAFTQ0ACwtBACAGNwOYiQFBACAHNwOQiQFBACAINwOIiQFBACAJNwOAiQFBACACIANrNgLAiQEgAiADRg0AQQAhAgNAIAJBoIkBaiADIAJqLQAAOgAAIAJBAWoiAkEAKALAiQFJDQALCwvlBwIFfgV/AkACQEEAKQPIiQEiAEIgVA0AQQApA4iJASIBQgeJQQApA4CJASICQgGJfEEAKQOQiQEiA0IMiXxBACkDmIkBIgRCEol8IAJCz9bTvtLHq9lCfkIfiUKHla+vmLbem55/foVCh5Wvr5i23puef35C49zKlfzO8vWFf3wgAULP1tO+0ser2UJ+Qh+JQoeVr6+Ytt6bnn9+hUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCADQs/W077Sx6vZQn5CH4lCh5Wvr5i23puef36FQoeVr6+Ytt6bnn9+QuPcypX8zvL1hX98IARCz9bTvtLHq9lCfkIfiUKHla+vmLbem55/foVCh5Wvr5i23puef35C49zKlfzO8vWFf3whAQwBC0EAKQOQiQFCxc/ZsvHluuonfCEBCyABIAB8IQBBoIkBIQVBqIkBIQYCQEEAKALAiQEiB0GgiQFqIghBqIkBSQ0AQaCJASEFAkAgB0F4aiIJQQhxDQBBACkDoIkBQs/W077Sx6vZQn5CH4lCh5Wvr5i23puef34gAIVCG4lCh5Wvr5i23puef35C49zKlfzO8vWFf3whAEGwiQEhBkGoiQEhBSAJQQhJDQELA0AgBikDAELP1tO+0ser2UJ+Qh+JQoeVr6+Ytt6bnn9+IAUpAwBCz9bTvtLHq9lCfkIfiUKHla+vmLbem55/fiAAhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fIVCG4lCh5Wvr5i23puef35C49zKlfzO8vWFf3whACAGQQhqIQUgBkEQaiIGIAhNDQALIAZBeGohBQsCQAJAIAVBBGoiCSAITQ0AIAUhCQwBCyAFNQIAQoeVr6+Ytt6bnn9+IACFQheJQs/W077Sx6vZQn5C+fPd8Zn2masWfCEACwJAIAkgCEYNACAHQZ+JAWohBQJAAkAgByAJa0EBcQ0AIAkhBgwBCyAJQQFqIQYgCTEAAELFz9my8eW66id+IACFQguJQoeVr6+Ytt6bnn9+IQALIAUgCUYNAANAIAZBAWoxAABCxc/ZsvHluuonfiAGMQAAQsXP2bLx5brqJ34gAIVCC4lCh5Wvr5i23puef36FQguJQoeVr6+Ytt6bnn9+IQAgBkECaiIGIAhHDQALC0EAIABCIYggAIVCz9bTvtLHq9lCfiIAQh2IIACFQvnz3fGZ9pmrFn4iAEIgiCAAhSIBQjiGIAFCgP4Dg0IohoQgAUKAgPwHg0IYhiABQoCAgPgPg0IIhoSEIABCCIhCgICA+A+DIABCGIhCgID8B4OEIABCKIhCgP4DgyAAQjiIhISENwOACQsGAEGAiQELAgALCwsBAEGACAsEUAAAAA==";
    hash$7 = "177fbfa3";
    wasmJson$7 = {
      name: name$7,
      data: data$7,
      hash: hash$7
    };
    mutex$5 = new Mutex();
    wasmCache$5 = null;
    seedBuffer$2 = new Uint8Array(8);
    name$6 = "xxhash3";
    data$6 = "AGFzbQEAAAABNAhgAAF/YAR/f39/AGAHf39/f39/fwBgBH9+fn4BfmAEf39/fgF+YAN/f34BfmAAAGABfwADDg0AAQIDBAUFBQYHBgAGBQQBAQICBg4CfwFBwI4FC38AQcAJCwdwCAZtZW1vcnkCAA5IYXNoX0dldEJ1ZmZlcgAACUhhc2hfSW5pdAAIC0hhc2hfVXBkYXRlAAkKSGFzaF9GaW5hbAAKDUhhc2hfR2V0U3RhdGUACw5IYXNoX0NhbGN1bGF0ZQAMClNUQVRFX1NJWkUDAQr6QQ0FAEGACgvkAwMPfgF/AX4CQCADRQ0AIAApAzAhBCAAKQM4IQUgACkDICEGIAApAyghByAAKQMQIQggACkDGCEJIAApAwAhCiAAKQMIIQsDQCAFIAFBMGopAwAiDHwgAkE4aikDACABQThqKQMAIg2FIgVCIIggBUL/////D4N+fCEFIAcgAUEgaikDACIOfCACQShqKQMAIAFBKGopAwAiD4UiB0IgiCAHQv////8Pg358IQcgCSABQRBqKQMAIhB8IAJBGGopAwAgAUEYaikDACIRhSIJQiCIIAlC/////w+DfnwhCSALIAEpAwAiEnwgAkEIaiITKQMAIAFBCGopAwAiFIUiC0IgiCALQv////8Pg358IQsgAkEwaikDACAMhSIMQiCIIAxC/////w+DfiAEfCANfCEEIAJBIGopAwAgDoUiDEIgiCAMQv////8Pg34gBnwgD3whBiACQRBqKQMAIBCFIgxCIIggDEL/////D4N+IAh8IBF8IQggAikDACAShSIMQiCIIAxC/////w+DfiAKfCAUfCEKIAFBwABqIQEgEyECIANBf2oiAw0ACyAAIAk3AxggACAKNwMAIAAgCzcDCCAAIAc3AyggACAINwMQIAAgBTcDOCAAIAY3AyAgACAENwMwCwveAgIBfwF+AkAgBCACIAEoAgAiB2siAkkNACAAIAMgBSAHQQN0aiACEAEgACAFIAZqIgcpAwAgACkDACIIQi+IhSAIhUKx893xCX43AwAgACAHKQMIIAApAwgiCEIviIUgCIVCsfPd8Ql+NwMIIAAgBykDECAAKQMQIghCL4iFIAiFQrHz3fEJfjcDECAAIAcpAxggACkDGCIIQi+IhSAIhUKx893xCX43AxggACAHKQMgIAApAyAiCEIviIUgCIVCsfPd8Ql+NwMgIAAgBykDKCAAKQMoIghCL4iFIAiFQrHz3fEJfjcDKCAAIAcpAzAgACkDMCIIQi+IhSAIhUKx893xCX43AzAgACAHKQM4IAApAzgiCEIviIUgCIVCsfPd8Ql+NwM4IAAgAyACQQZ0aiAFIAQgAmsiBxABIAEgBzYCAA8LIAAgAyAFIAdBA3RqIAQQASABIAcgBGo2AgALhQEBAX8gAiABhSADpyIEQRh0IARBgP4DcUEIdHIgBEEIdkGA/gNxIARBGHZycq1CIIYgA4V9QQA1AoCMAUIghiAAQfyLAWo1AgCEhSIDQjGJIANCGImFIAOFQqW+4/TRjIfZn39+IgNCI4ggAK18IAOFQqW+4/TRjIfZn39+IgNCHIggA4ULZwAgAiABc60gA3wiA0IhiEEALQCAjAFBEHQgAEEIdHIgAEEBdkGAjAFqLQAAQRh0ciAAQf+LAWotAAByrYUgA4VCz9bTvtLHq9lCfiIDQh2IIAOFQvnz3fGZ9pmrFn4iA0IgiCADhQuJAwEEfgJAIABBCUkNAEEAKQOAjAEgASkDICABKQMYhSACfIUiA0I4hiADQoD+A4NCKIaEIANCgID8B4NCGIYgA0KAgID4D4NCCIaEhCADQgiIQoCAgPgPgyADQhiIQoCA/AeDhCADQiiIQoD+A4MgA0I4iISEhCAArXwgAEH4iwFqKQMAIAEpAzAgASkDKIUgAn2FIgJ8IAJC/////w+DIgQgA0IgiCIFfiIGQv////8PgyACQiCIIgIgA0L/////D4MiA358IAQgA34iA0IgiHwiBEIghiADQv////8Pg4QgBkIgiCACIAV+fCAEQiCIfIV8IgNCJYggA4VC+fPd8ZnymasWfiIDQiCIIAOFDwsCQCAAQQRJDQAgACABQQhqKQMAIAFBEGopAwAgAhADDwsCQCAARQ0AIAAgASgCACABQQRqKAIAIAIQBA8LIAEpAzggASkDQIUgAoUiA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC94IAQZ+IACtQoeVr6+Ytt6bnn9+IQMCQCAAQSFJDQACQCAAQcEASQ0AAkAgAEHhAEkNACABKQNoIAJ9QQApA7iMAYUiBEL/////D4MiBSABKQNgIAJ8QQApA7CMAYUiBkIgiCIHfiIIQv////8PgyAEQiCIIgQgBkL/////D4MiBn58IAUgBn4iBUIgiHwiBkIghiAFQv////8Pg4QgCEIgiCAEIAd+fCAGQiCIfIUgA3wgASkDeCACfSAAQciLAWopAwCFIgNC/////w+DIgQgASkDcCACfCAAQcCLAWopAwCFIgVCIIgiBn4iB0L/////D4MgA0IgiCIDIAVC/////w+DIgV+fCAEIAV+IgRCIIh8IgVCIIYgBEL/////D4OEIAdCIIggAyAGfnwgBUIgiHyFfCEDCyABKQNIIAJ9QQApA6iMAYUiBEL/////D4MiBSABKQNAIAJ8QQApA6CMAYUiBkIgiCIHfiIIQv////8PgyAEQiCIIgQgBkL/////D4MiBn58IAUgBn4iBUIgiHwiBkIghiAFQv////8Pg4QgCEIgiCAEIAd+fCAGQiCIfIUgA3wgASkDWCACfSAAQdiLAWopAwCFIgNC/////w+DIgQgASkDUCACfCAAQdCLAWopAwCFIgVCIIgiBn4iB0L/////D4MgA0IgiCIDIAVC/////w+DIgV+fCAEIAV+IgRCIIh8IgVCIIYgBEL/////D4OEIAdCIIggAyAGfnwgBUIgiHyFfCEDCyABKQMoIAJ9QQApA5iMAYUiBEL/////D4MiBSABKQMgIAJ8QQApA5CMAYUiBkIgiCIHfiIIQv////8PgyAEQiCIIgQgBkL/////D4MiBn58IAUgBn4iBUIgiHwiBkIghiAFQv////8Pg4QgCEIgiCAEIAd+fCAGQiCIfIUgA3wgASkDOCACfSAAQeiLAWopAwCFIgNC/////w+DIgQgASkDMCACfCAAQeCLAWopAwCFIgVCIIgiBn4iB0L/////D4MgA0IgiCIDIAVC/////w+DIgV+fCAEIAV+IgRCIIh8IgVCIIYgBEL/////D4OEIAdCIIggAyAGfnwgBUIgiHyFfCEDCyABKQMIIAJ9QQApA4iMAYUiBEL/////D4MiBSABKQMAIAJ8QQApA4CMAYUiBkIgiCIHfiIIQv////8PgyAEQiCIIgQgBkL/////D4MiBn58IAUgBn4iBUIgiHwiBkIghiAFQv////8Pg4QgCEIgiCAEIAd+fCAGQiCIfIUgA3wgASkDGCACfSAAQfiLAWopAwCFIgNC/////w+DIgQgASkDECACfCAAQfCLAWopAwCFIgJCIIgiBX4iBkL/////D4MgA0IgiCIDIAJC/////w+DIgJ+fCAEIAJ+IgJCIIh8IgRCIIYgAkL/////D4OEIAZCIIggAyAFfnwgBEIgiHyFfCICQiWIIAKFQvnz3fGZ8pmrFn4iAkIgiCAChQv8CgQBfwV+An8BfkEAIQMgASkDeCACfUEAKQP4jAGFIgRC/////w+DIgUgASkDcCACfEEAKQPwjAGFIgZCIIgiB34iCEL/////D4MgBEIgiCIEIAZC/////w+DIgZ+fCAFIAZ+IgVCIIh8IgZCIIYgBUL/////D4OEIAhCIIggBCAHfnwgBkIgiHyFIAEpA2ggAn1BACkD6IwBhSIEQv////8PgyIFIAEpA2AgAnxBACkD4IwBhSIGQiCIIgd+IghC/////w+DIARCIIgiBCAGQv////8PgyIGfnwgBSAGfiIFQiCIfCIGQiCGIAVC/////w+DhCAIQiCIIAQgB358IAZCIIh8hSABKQNYIAJ9QQApA9iMAYUiBEL/////D4MiBSABKQNQIAJ8QQApA9CMAYUiBkIgiCIHfiIIQv////8PgyAEQiCIIgQgBkL/////D4MiBn58IAUgBn4iBUIgiHwiBkIghiAFQv////8Pg4QgCEIgiCAEIAd+fCAGQiCIfIUgASkDSCACfUEAKQPIjAGFIgRC/////w+DIgUgASkDQCACfEEAKQPAjAGFIgZCIIgiB34iCEL/////D4MgBEIgiCIEIAZC/////w+DIgZ+fCAFIAZ+IgVCIIh8IgZCIIYgBUL/////D4OEIAhCIIggBCAHfnwgBkIgiHyFIAEpAzggAn1BACkDuIwBhSIEQv////8PgyIFIAEpAzAgAnxBACkDsIwBhSIGQiCIIgd+IghC/////w+DIARCIIgiBCAGQv////8PgyIGfnwgBSAGfiIFQiCIfCIGQiCGIAVC/////w+DhCAIQiCIIAQgB358IAZCIIh8hSABKQMoIAJ9QQApA6iMAYUiBEL/////D4MiBSABKQMgIAJ8QQApA6CMAYUiBkIgiCIHfiIIQv////8PgyAEQiCIIgQgBkL/////D4MiBn58IAUgBn4iBUIgiHwiBkIghiAFQv////8Pg4QgCEIgiCAEIAd+fCAGQiCIfIUgASkDGCACfUEAKQOYjAGFIgRC/////w+DIgUgASkDECACfEEAKQOQjAGFIgZCIIgiB34iCEL/////D4MgBEIgiCIEIAZC/////w+DIgZ+fCAFIAZ+IgVCIIh8IgZCIIYgBUL/////D4OEIAhCIIggBCAHfnwgBkIgiHyFIAEpAwggAn1BACkDiIwBhSIEQv////8PgyIFIAEpAwAgAnxBACkDgIwBhSIGQiCIIgd+IghC/////w+DIARCIIgiBCAGQv////8PgyIGfnwgBSAGfiIFQiCIfCIGQiCGIAVC/////w+DhCAIQiCIIAQgB358IAZCIIh8hSAArUKHla+vmLbem55/fnx8fHx8fHx8IgRCJYggBIVC+fPd8ZnymasWfiIEQiCIIASFIQQCQCAAQZABSA0AIABBBHZBeGohCQNAIAEgA2oiCkELaikDACACfSADQYiNAWopAwCFIgVC/////w+DIgYgCkEDaikDACACfCADQYCNAWopAwCFIgdCIIgiCH4iC0L/////D4MgBUIgiCIFIAdC/////w+DIgd+fCAGIAd+IgZCIIh8IgdCIIYgBkL/////D4OEIAtCIIggBSAIfnwgB0IgiHyFIAR8IQQgA0EQaiEDIAlBf2oiCQ0ACwsgASkDfyACfSAAQfiLAWopAwCFIgVC/////w+DIgYgASkDdyACfCAAQfCLAWopAwCFIgJCIIgiB34iCEL/////D4MgBUIgiCIFIAJC/////w+DIgJ+fCAGIAJ+IgJCIIh8IgZCIIYgAkL/////D4OEIAhCIIggBSAHfnwgBkIgiHyFIAR8IgJCJYggAoVC+fPd8ZnymasWfiICQiCIIAKFC98FAgF+AX8CQAJAQQApA4AKIgBQRQ0AQYAIIQFCACEADAELAkBBACkDoI4BIABSDQBBACEBDAELQQAhAUEAQq+v79e895Kg/gAgAH03A/iLAUEAIABCxZbr+djShYIofDcD8IsBQQBCj/Hjja2P9JhOIAB9NwPoiwFBACAAQqus+MXV79HQfHw3A+CLAUEAQtOt1LKShbW0nn8gAH03A9iLAUEAIABCl5r0jvWWvO3JAHw3A9CLAUEAQsWDgv2v/8SxayAAfTcDyIsBQQAgAELqi7OdyOb09UN8NwPAiwFBAELIv/rLnJveueQAIAB9NwO4iwFBACAAQoqjgd/Ume2sMXw3A7CLAUEAQvm57738+MKnHSAAfTcDqIsBQQAgAEKo9dv7s5ynmj98NwOgiwFBAEK4sry3lNW31lggAH03A5iLAUEAIABC8cihuqm0w/zOAHw3A5CLAUEAQoihl9u445SXo38gAH03A4iLAUEAIABCvNDI2pvysIBLfDcDgIsBQQBC4OvAtJ7QjpPMACAAfTcD+IoBQQAgAEK4kZii9/6Qko5/fDcD8IoBQQBCgrXB7sf5v7khIAB9NwPoigFBACAAQsvzmffEmfDy+AB8NwPgigFBAELygJGl+vbssx8gAH03A9iKAUEAIABC3qm3y76Q5MtbfDcD0IoBQQBC/IKE5PK+yNYcIAB9NwPIigFBACAAQrj9s8uzhOmlvn98NwPAigELQQBCADcDkI4BQQBCADcDiI4BQQBCADcDgI4BQQBCvdzKlQw3A4CKAUEAQoeVr6+Ytt6bnn83A4iKAUEAQs/W077Sx6vZQjcDkIoBQQBC+fPd8Zn2masWNwOYigFBAELj3MqV/M7y9YV/NwOgigFBAEL3lK+vCDcDqIoBQQBCxc/ZsvHluuonNwOwigFBAEKx893xCTcDuIoBQQAgADcDoI4BQQAgATYCsI4BQQBCkICAgIAQNwOYjgEL9AkBCH9BAEEAKQOQjgEgAK18NwOQjgECQAJAAkBBACgCgI4BIgEgAGoiAkGAAksNACABQYCMAWohA0GACiEEAkAgAEEITw0AIAAhAQwCCwJAAkAgAEF4aiIFQQN2QQFqQQdxIgYNAEGACiEEIAAhAQwBCyAGQQN0IQFBgAohBANAIAMgBCkDADcDACADQQhqIQMgBEEIaiEEIAZBf2oiBg0ACyAAIAFrIQELIAVBOEkNAQNAIAMgBCkDADcDACADQQhqIARBCGopAwA3AwAgA0EQaiAEQRBqKQMANwMAIANBGGogBEEYaikDADcDACADQSBqIARBIGopAwA3AwAgA0EoaiAEQShqKQMANwMAIANBMGogBEEwaikDADcDACADQThqIARBOGopAwA3AwAgA0HAAGohAyAEQcAAaiEEIAFBQGoiAUEHSw0ADAILC0GACiEEIABBgApqIQVBACgCsI4BIgNBwIoBIAMbIQYCQCABRQ0AIAFBgIwBaiEDQYAKIQQCQAJAQYACIAFrIgdBCE8NACAHIQAMAQsCQAJAQfgBIAFrIghBA3ZBAWpBB3EiAg0AQYAKIQQgByEADAELQYAKIQQgAkEDdCIAIQIDQCADIAQpAwA3AwAgA0EIaiEDIARBCGohBCACQXhqIgINAAtBgAIgASAAamshAAsgCEE4SQ0AA0AgAyAEKQMANwMAIANBCGogBEEIaikDADcDACADQRBqIARBEGopAwA3AwAgA0EYaiAEQRhqKQMANwMAIANBIGogBEEgaikDADcDACADQShqIARBKGopAwA3AwAgA0EwaiAEQTBqKQMANwMAIANBOGogBEE4aikDADcDACADQcAAaiEDIARBwABqIQQgAEFAaiIAQQdLDQALCwJAIABFDQACQAJAIABBB3EiAg0AIAAhAQwBCyAAQXhxIQEDQCADIAQtAAA6AAAgA0EBaiEDIARBAWohBCACQX9qIgINAAsLIABBCEkNAANAIAMgBCkAADcAACADQQhqIQMgBEEIaiEEIAFBeGoiAQ0ACwtBgIoBQYiOAUEAKAKYjgFBgIwBQQQgBkEAKAKcjgEQAkEAQQA2AoCOASAHQYAKaiEECwJAIARBgAJqIAVPDQAgBUGAfmohAgNAQYCKAUGIjgFBACgCmI4BIAQiA0EEIAZBACgCnI4BEAIgA0GAAmoiBCACSQ0AC0EAIAMpA8ABNwPAjQFBACADKQPIATcDyI0BQQAgAykD0AE3A9CNAUEAIAMpA9gBNwPYjQFBACADKQPgATcD4I0BQQAgAykD6AE3A+iNAUEAIAMpA/ABNwPwjQFBACADKQP4ATcD+I0BC0GAjAEhAwJAAkAgBSAEayICQQhPDQAgAiEGDAELQYCMASEDIAIhBgNAIAMgBCkDADcDACADQQhqIQMgBEEIaiEEIAZBeGoiBkEHSw0ACwsgBkUNAQNAIAMgBC0AADoAACADQQFqIQMgBEEBaiEEIAZBf2oiBg0ADAILCyABRQ0AAkACQCABQQdxIgYNACABIQIMAQsgAUF4cSECA0AgAyAELQAAOgAAIANBAWohAyAEQQFqIQQgBkF/aiIGDQALCwJAIAFBCEkNAANAIAMgBCkAADcAACADQQhqIQMgBEEIaiEEIAJBeGoiAg0ACwtBACgCgI4BIABqIQILQQAgAjYCgI4BC/ISBQR/A34BfxV+BX8jACIAIQEgAEGAAWtBQHEiAiQAQQAoArCOASIAQcCKASAAGyEDAkACQEEAKQOQjgEiBELxAVQNACACQQApA4CKATcDACACQQApA4iKATcDCCACQQApA5CKATcDECACQQApA5iKATcDGCACQQApA6CKATcDICACQQApA6iKATcDKCACQQApA7CKASIFNwMwIAJBACkDuIoBIgY3AzgCQAJAQQAoAoCOASIHQcAASQ0AIAJBACgCiI4BNgJAIAIgAkHAAGpBACgCmI4BQYCMASAHQX9qQQZ2IANBACgCnI4BIgAQAiADIABqIgBBeWopAwAhCCAAKQMJIQkgACkDGSEKIAApAykhCyAHQcCLAWopAwAhBSAAKQMBIQwgB0HIiwFqKQMAIQYgB0HQiwFqKQMAIQ0gACkDESEOIAdB2IsBaikDACEPIAdB4IsBaikDACEQIAApAyEhESAHQeiLAWopAwAhEiACKQMAIRMgAikDECEUIAIpAyAhFSACKQMwIRYgAikDCCEXIAIpAxghGCACKQMoIRkgAiACKQM4IAdB8IsBaikDACIafCAAKQMxIAdB+IsBaikDACIbhSIcQiCIIBxC/////w+Dfnw3AzggGSAQfCARIBKFIhFCIIggEUL/////D4N+fCERIBggDXwgDiAPhSIOQiCIIA5C/////w+DfnwhDiAXIAV8IAwgBoUiDEIgiCAMQv////8Pg358IQwgGyAWIAsgGoUiC0IgiCALQv////8Pg358fCELIBIgFSAKIBCFIhBCIIggEEL/////D4N+fHwhECAPIBQgCSANhSINQiCIIA1C/////w+Dfnx8IRIgBiATIAggBYUiBUIgiCAFQv////8Pg358fCEIDAELIAdBwI0BaiEdQcAAIAdrIR4gAkHAAGohAAJAAkACQCAHQThNDQAgHiEfDAELAkACQEE4IAdrQQN2QQFqQQdxIh8NACACQcAAaiEAIB4hHwwBCyACQcAAaiEAIB9BA3QiICEfA0AgACAdKQMANwMAIABBCGohACAdQQhqIR0gH0F4aiIfDQALQcAAIAcgIGprIR8LAkAgBw0AA0AgACAdKQMANwMAIABBCGogHUEIaikDADcDACAAQRBqIB1BEGopAwA3AwAgAEEYaiAdQRhqKQMANwMAIABBIGogHUEgaikDADcDACAAQShqIB1BKGopAwA3AwAgAEEwaiAdQTBqKQMANwMAIABBOGogHUE4aikDADcDACAAQcAAaiEAIB1BwABqIR0gH0FAaiIfQQdLDQALCyAfRQ0BCyAfQX9qISECQCAfQQdxIiBFDQAgH0F4cSEfA0AgACAdLQAAOgAAIABBAWohACAdQQFqIR0gIEF/aiIgDQALCyAhQQdJDQADQCAAIB0pAAA3AAAgAEEIaiEAIB1BCGohHSAfQXhqIh8NAAsLIAJBwABqIB5qIR1BgIwBIQACQAJAAkAgB0EISQ0AAkAgB0E4akEDdkEBakEHcSIfDQAMAgsgH0EDdCEgQYCMASEAA0AgHSAAKQMANwMAIB1BCGohHSAAQQhqIQAgH0F/aiIfDQALIAcgIGshBwsgB0UNAQJAAkAgB0EHcSIgDQAgByEfDAELIAdBeHEhHwNAIB0gAC0AADoAACAdQQFqIR0gAEEBaiEAICBBf2oiIA0ACwsgB0EISQ0BCwNAIB0gACkAADcAACAdQQhqIR0gAEEIaiEAIB9BeGoiHw0ACwsgA0EAKAKcjgFqIgBBeWopAwAhCiAAKQMJIRMgACkDGSEUIAApAykhCyAAKQMBIQwgACkDESEOIAApAyEhESACKQMAIRUgAikDECEWIAIpAyAhFyACKQMIIRggAikDQCENIAIpA0ghDyACKQMYIRkgAikDUCESIAIpA1ghCCACKQMoIRogAikDYCEQIAIpA2ghCSACIAYgAikDcCIbfCAAKQMxIAIpA3giBoUiHEIgiCAcQv////8Pg358NwM4IBogEHwgESAJhSIRQiCIIBFC/////w+DfnwhESAZIBJ8IA4gCIUiDkIgiCAOQv////8Pg358IQ4gGCANfCAMIA+FIgxCIIggDEL/////D4N+fCEMIAYgCyAbhSILQiCIIAtC/////w+DfiAFfHwhCyAJIBcgFCAQhSIFQiCIIAVC/////w+Dfnx8IRAgCCAWIBMgEoUiBUIgiCAFQv////8Pg358fCESIA8gFSAKIA2FIgVCIIggBUL/////D4N+fHwhCAsgAykDQyACKQM4hSIFQv////8PgyIGIAMpAzsgC4UiC0IgiCINfiIPQv////8PgyAFQiCIIgUgC0L/////D4MiC358IAYgC34iBkIgiHwiC0IghiAGQv////8Pg4QgD0IgiCAFIA1+fCALQiCIfIUgAykDMyARhSIFQv////8PgyIGIAMpAysgEIUiC0IgiCINfiIPQv////8PgyAFQiCIIgUgC0L/////D4MiC358IAYgC34iBkIgiHwiC0IghiAGQv////8Pg4QgD0IgiCAFIA1+fCALQiCIfIUgAykDIyAOhSIFQv////8PgyIGIAMpAxsgEoUiC0IgiCINfiIPQv////8PgyAFQiCIIgUgC0L/////D4MiC358IAYgC34iBkIgiHwiC0IghiAGQv////8Pg4QgD0IgiCAFIA1+fCALQiCIfIUgAykDEyAMhSIFQv////8PgyIGIAMpAwsgCIUiC0IgiCINfiIPQv////8PgyAFQiCIIgUgC0L/////D4MiC358IAYgC34iBkIgiHwiC0IghiAGQv////8Pg4QgD0IgiCAFIA1+fCALQiCIfIUgBEKHla+vmLbem55/fnx8fHwiBEIliCAEhUL5893xmfKZqxZ+IgRCIIggBIUhBAwBCyAEpyEAAkBBACkDoI4BIgRQDQACQCAAQRBLDQAgAEGACCAEEAUhBAwCCwJAIABBgAFLDQAgAEGACCAEEAYhBAwCCyAAQYAIIAQQByEEDAELAkAgAEEQSw0AIAAgA0IAEAUhBAwBCwJAIABBgAFLDQAgACADQgAQBiEEDAELIAAgA0IAEAchBAtBACAEQjiGIARCgP4Dg0IohoQgBEKAgPwHg0IYhiAEQoCAgPgPg0IIhoSEIARCCIhCgICA+A+DIARCGIhCgID8B4OEIARCKIhCgP4DgyAEQjiIhISENwOACiABJAALBgBBgIoBCwIACwvMAQEAQYAIC8QBuP5sOSOkS758AYEs9yGtHN7UbemDkJfbckCkpLezZx/LeeZOzMDleIJa0H3M/3IhuAhGdPdDJI7gNZDmgTomTDwoUruRwwDLiNBlixtTLqNxZEiXog35TjgZ70ap3qzYqPp2P+OcND/53LvHxwtPHYpR4EvNtFkxyJ9+ydl4c2TqxayDNNPrw8WBoP/6E2PrFw3dUbfw2knTFlUmKdRonisWvlh9R6H8j/i40XrQMc5FyzqPlRYEKK/X+8q7S0B+QAIAAA==";
    hash$6 = "5a2fbdbb";
    wasmJson$6 = {
      name: name$6,
      data: data$6,
      hash: hash$6
    };
    mutex$4 = new Mutex();
    wasmCache$4 = null;
    seedBuffer$1 = new Uint8Array(8);
    name$5 = "xxhash128";
    data$5 = "AGFzbQEAAAABKwdgAAF/YAR/f39/AGAHf39/f39/fwBgA39/fgF+YAR/f39+AGAAAGABfwADDQwAAQIDBAQEBQYFAAUFBAEBAgIGDgJ/AUHAjgULfwBBwAkLB3AIBm1lbW9yeQIADkhhc2hfR2V0QnVmZmVyAAAJSGFzaF9Jbml0AAcLSGFzaF9VcGRhdGUACApIYXNoX0ZpbmFsAAkNSGFzaF9HZXRTdGF0ZQAKDkhhc2hfQ2FsY3VsYXRlAAsKU1RBVEVfU0laRQMBCqBNDAUAQYAKC+QDAw9+AX8BfgJAIANFDQAgACkDMCEEIAApAzghBSAAKQMgIQYgACkDKCEHIAApAxAhCCAAKQMYIQkgACkDACEKIAApAwghCwNAIAUgAUEwaikDACIMfCACQThqKQMAIAFBOGopAwAiDYUiBUIgiCAFQv////8Pg358IQUgByABQSBqKQMAIg58IAJBKGopAwAgAUEoaikDACIPhSIHQiCIIAdC/////w+DfnwhByAJIAFBEGopAwAiEHwgAkEYaikDACABQRhqKQMAIhGFIglCIIggCUL/////D4N+fCEJIAsgASkDACISfCACQQhqIhMpAwAgAUEIaikDACIUhSILQiCIIAtC/////w+DfnwhCyACQTBqKQMAIAyFIgxCIIggDEL/////D4N+IAR8IA18IQQgAkEgaikDACAOhSIMQiCIIAxC/////w+DfiAGfCAPfCEGIAJBEGopAwAgEIUiDEIgiCAMQv////8Pg34gCHwgEXwhCCACKQMAIBKFIgxCIIggDEL/////D4N+IAp8IBR8IQogAUHAAGohASATIQIgA0F/aiIDDQALIAAgCTcDGCAAIAo3AwAgACALNwMIIAAgBzcDKCAAIAg3AxAgACAFNwM4IAAgBjcDICAAIAQ3AzALC94CAgF/AX4CQCAEIAIgASgCACIHayICSQ0AIAAgAyAFIAdBA3RqIAIQASAAIAUgBmoiBykDACAAKQMAIghCL4iFIAiFQrHz3fEJfjcDACAAIAcpAwggACkDCCIIQi+IhSAIhUKx893xCX43AwggACAHKQMQIAApAxAiCEIviIUgCIVCsfPd8Ql+NwMQIAAgBykDGCAAKQMYIghCL4iFIAiFQrHz3fEJfjcDGCAAIAcpAyAgACkDICIIQi+IhSAIhUKx893xCX43AyAgACAHKQMoIAApAygiCEIviIUgCIVCsfPd8Ql+NwMoIAAgBykDMCAAKQMwIghCL4iFIAiFQrHz3fEJfjcDMCAAIAcpAzggACkDOCIIQi+IhSAIhUKx893xCX43AzggACADIAJBBnRqIAUgBCACayIHEAEgASAHNgIADwsgACADIAUgB0EDdGogBBABIAEgByAEajYCAAvtAwEFfiABKQM4IAApAziFIgNC/////w+DIgQgASkDMCAAKQMwhSIFQiCIIgZ+IgdC/////w+DIANCIIgiAyAFQv////8PgyIFfnwgBCAFfiIEQiCIfCIFQiCGIARC/////w+DhCAHQiCIIAMgBn58IAVCIIh8hSABKQMoIAApAyiFIgNC/////w+DIgQgASkDICAAKQMghSIFQiCIIgZ+IgdC/////w+DIANCIIgiAyAFQv////8PgyIFfnwgBCAFfiIEQiCIfCIFQiCGIARC/////w+DhCAHQiCIIAMgBn58IAVCIIh8hSABKQMYIAApAxiFIgNC/////w+DIgQgASkDECAAKQMQhSIFQiCIIgZ+IgdC/////w+DIANCIIgiAyAFQv////8PgyIFfnwgBCAFfiIEQiCIfCIFQiCGIARC/////w+DhCAHQiCIIAMgBn58IAVCIIh8hSABKQMIIAApAwiFIgNC/////w+DIgQgASkDACAAKQMAhSIFQiCIIgZ+IgdC/////w+DIANCIIgiAyAFQv////8PgyIFfnwgBCAFfiIEQiCIfCIFQiCGIARC/////w+DhCAHQiCIIAMgBn58IAVCIIh8hSACfHx8fCICQiWIIAKFQvnz3fGZ8pmrFn4iAkIgiCAChQu6CAIFfgN/AkAgAUEJSQ0AIAAgAUH4iwFqKQMAIgQgAikDOCACKQMwhSADfIUiBUL/////D4NC95Svrwh+IAVCgICAgHCDfEEAKQOAjAEgAikDKCACKQMghSADfYUgBIUiA0IgiCIEQrHz3fEJfnwgBEKHla+vCH4iBEIgiHwgBEL/////D4MgA0L/////D4MiA0Kx893xCX58IANCh5Wvrwh+IgRCIIh8IgVCIIh8IgNCOIYgA0KA/gODQiiGhCADQoCA/AeDQhiGIANCgICA+A+DQgiGhIQgA0IIiEKAgID4D4MgA0IYiEKAgPwHg4QgA0IoiEKA/gODIANCOIiEhIQgBEL/////D4MgAUF/aq1CNoaEIAVCIIZ8hSIEQiCIIgVCz9bTvgJ+IgZC/////w+DIARC/////w+DIgRCvdzKlQx+fCAEQs/W074CfiIEQiCIfCIHQiCGIghCJYggCCAEQv////8Pg4SFQvnz3fGZ8pmrFn4iBEIgiCAEhTcDACAAIAVCvdzKlQx+IANCz9bTvtLHq9lCfnwgBkIgiHwgB0IgiHwiA0IliCADhUL5893xmfKZqxZ+IgNCIIggA4U3AwgPCwJAIAFBBEkNACAAIAIpAxggAikDEIUgA6ciAkEYdCACQYD+A3FBCHRyIAJBCHZBgP4DcSACQRh2cnKtQiCGIAOFfCABQfyLAWo1AgBCIIZBADUCgIwBhIUiA0IgiCIEIAFBAnRBh5Wvr3hqrSIFfiIGQiCIIARCsfPd8Ql+fCAGQv////8PgyADQv////8PgyIDQrHz3fEJfnwgAyAFfiIDQiCIfCIEQiCIfCAEQiCGIANC/////w+DhCIEQgGGfCIDQiWIIAOFQvnz3fGZ8pmrFn4iBUIgiCAFhTcDCCAAIANCA4ggBIUiA0IjiCADhUKlvuP00YyH2Z9/fiIDQhyIIAOFNwMADwsCQCABRQ0AIAAgAigCBCACKAIAc60gA3wiBEIhiEEALQCAjAFBEHQgAUEIdHIiCSABQQF2QYCMAWotAABBGHRyIgogAUH/iwFqLQAAIgFyIguthSAEhULP1tO+0ser2UJ+IgRCHYggBIVC+fPd8Zn2masWfiIEQiCIIASFNwMAIAAgAigCDCACKAIIc60gA30iA0IhiCABQRh0IAtBgP4DcUEIdHIgCUEIdkGA/gNxIApBGHZyckENd62FIAOFQs/W077Sx6vZQn4iA0IdiCADhUL5893xmfaZqxZ+IgNCIIggA4U3AwgPCyAAIAIpA1AgAikDWIUgA4UiBEIhiCAEhULP1tO+0ser2UJ+IgRCHYggBIVC+fPd8Zn2masWfiIEQiCIIASFNwMIIAAgAikDQCACKQNIhSADhSIDQiGIIAOFQs/W077Sx6vZQn4iA0IdiCADhUL5893xmfaZqxZ+IgNCIIggA4U3AwALwwoBCn4gAa0iBEKHla+vmLbem55/fiEFAkACQCABQSFPDQBCACEGDAELQgAhBwJAIAFBwQBJDQBCACEHAkAgAUHhAEkNACACQfgAaikDACADfSABQciLAWopAwAiCIUiB0L/////D4MiCSACKQNwIAN8IAFBwIsBaikDACIKhSILQiCIIgx+Ig1CIIggB0IgiCIHIAx+fCANQv////8PgyAHIAtC/////w+DIgt+fCAJIAt+IgdCIIh8IglCIIh8QQApA7iMASILQQApA7CMASIMfIUgCUIghiAHQv////8Pg4SFIQcgAkHoAGopAwAgA30gC4UiCUL/////D4MiCyACKQNgIAN8IAyFIgxCIIgiDX4iBkL/////D4MgCUIgiCIJIAxC/////w+DIgx+fCALIAx+IgtCIIh8IgxCIIYgC0L/////D4OEIAZCIIggCSANfnwgDEIgiHyFIAV8IAggCnyFIQULIAJB2ABqKQMAIAN9IAFB2IsBaikDACIIhSIJQv////8PgyIKIAIpA1AgA3wgAUHQiwFqKQMAIguFIgxCIIgiDX4iBkL/////D4MgCUIgiCIJIAxC/////w+DIgx+fCAKIAx+IgpCIIh8IgxCIIYgCkL/////D4OEIAZCIIggCSANfnwgDEIgiHyFIAd8QQApA6iMASIJQQApA6CMASIKfIUhByACQcgAaikDACADfSAJhSIJQv////8PgyIMIAIpA0AgA3wgCoUiCkIgiCINfiIGQv////8PgyAJQiCIIgkgCkL/////D4MiCn58IAwgCn4iCkIgiHwiDEIghiAKQv////8Pg4QgBkIgiCAJIA1+fCAMQiCIfIUgBXwgCCALfIUhBQsgAkE4aikDACADfSABQeiLAWopAwAiCIUiCUL/////D4MiCiACKQMwIAN8IAFB4IsBaikDACILhSIMQiCIIg1+IgZC/////w+DIAlCIIgiCSAMQv////8PgyIMfnwgCiAMfiIKQiCIfCIMQiCGIApC/////w+DhCAGQiCIIAkgDX58IAxCIIh8hSAHfEEAKQOYjAEiB0EAKQOQjAEiCXyFIQYgAkEoaikDACADfSAHhSIHQv////8PgyIKIAIpAyAgA3wgCYUiCUIgiCIMfiINQv////8PgyAHQiCIIgcgCUL/////D4MiCX58IAogCX4iCUIgiHwiCkIghiAJQv////8Pg4QgDUIgiCAHIAx+fCAKQiCIfIUgBXwgCCALfIUhBQsgACACQRhqKQMAIAN9IAFB+IsBaikDACIHhSIIQv////8PgyIJIAIpAxAgA3wgAUHwiwFqKQMAIgqFIgtCIIgiDH4iDUL/////D4MgCEIgiCIIIAtC/////w+DIgt+fCAJIAt+IglCIIh8IgtCIIYgCUL/////D4OEIA1CIIggCCAMfnwgC0IgiHyFIAZ8QQApA4iMASIIQQApA4CMASIJfIUiCyACQQhqKQMAIAN9IAiFIghC/////w+DIgwgAikDACADfCAJhSIJQiCIIg1+IgZC/////w+DIAhCIIgiCCAJQv////8PgyIJfnwgDCAJfiIJQiCIfCIMQiCGIAlC/////w+DhCAGQiCIIAggDX58IAxCIIh8hSAFfCAHIAp8hSIFfCIHQiWIIAeFQvnz3fGZ8pmrFn4iB0IgiCAHhTcDACAAQgAgBUKHla+vmLbem55/fiAEIAN9Qs/W077Sx6vZQn58IAtC49zKlfzO8vWFf358IgNCJYggA4VC+fPd8ZnymasWfiIDQiCIIAOFfTcDCAuhDwMBfxR+An9BACEEIAJB+ABqKQMAIAN9QQApA/iMASIFhSIGQv////8PgyIHIAIpA3AgA3xBACkD8IwBIgiFIglCIIgiCn4iC0L/////D4MgBkIgiCIGIAlC/////w+DIgl+fCAHIAl+IgdCIIh8IglCIIYgB0L/////D4OEIAtCIIggBiAKfnwgCUIgiHyFIAJB2ABqKQMAIAN9QQApA9iMASIHhSIGQv////8PgyIJIAIpA1AgA3xBACkD0IwBIgqFIgtCIIgiDH4iDUL/////D4MgBkIgiCIGIAtC/////w+DIgt+fCAJIAt+IglCIIh8IgtCIIYgCUL/////D4OEIA1CIIggBiAMfnwgC0IgiHyFIAJBOGopAwAgA31BACkDuIwBIgmFIgZC/////w+DIgsgAikDMCADfEEAKQOwjAEiDIUiDUIgiCIOfiIPQv////8PgyAGQiCIIgYgDUL/////D4MiDX58IAsgDX4iC0IgiHwiDUIghiALQv////8Pg4QgD0IgiCAGIA5+fCANQiCIfIUgAkEYaikDACADfUEAKQOYjAEiC4UiBkL/////D4MiDSACKQMQIAN8QQApA5CMASIOhSIPQiCIIhB+IhFC/////w+DIAZCIIgiBiAPQv////8PgyIPfnwgDSAPfiINQiCIfCIPQiCGIA1C/////w+DhCARQiCIIAYgEH58IA9CIIh8hUEAKQOIjAEiDUEAKQOAjAEiD3yFfEEAKQOojAEiEEEAKQOgjAEiEXyFfEEAKQPIjAEiEkEAKQPAjAEiE3yFfEEAKQPojAEiFEEAKQPgjAEiFXyFIgZCJYggBoVC+fPd8ZnymasWfiIGQiCIIAaFIQYgAkHoAGopAwAgA30gFIUiFEL/////D4MiFiACKQNgIAN8IBWFIhVCIIgiF34iGEL/////D4MgFEIgiCIUIBVC/////w+DIhV+fCAWIBV+IhVCIIh8IhZCIIYgFUL/////D4OEIBhCIIggFCAXfnwgFkIgiHyFIAJByABqKQMAIAN9IBKFIhJC/////w+DIhQgAikDQCADfCAThSITQiCIIhV+IhZC/////w+DIBJCIIgiEiATQv////8PgyITfnwgFCATfiITQiCIfCIUQiCGIBNC/////w+DhCAWQiCIIBIgFX58IBRCIIh8hSACQShqKQMAIAN9IBCFIhBC/////w+DIhIgAikDICADfCARhSIRQiCIIhN+IhRC/////w+DIBBCIIgiECARQv////8PgyIRfnwgEiARfiIRQiCIfCISQiCGIBFC/////w+DhCAUQiCIIBAgE358IBJCIIh8hSACQQhqKQMAIAN9IA2FIg1C/////w+DIhAgAikDACADfCAPhSIPQiCIIhF+IhJC/////w+DIA1CIIgiDSAPQv////8PgyIPfnwgECAPfiIPQiCIfCIQQiCGIA9C/////w+DhCASQiCIIA0gEX58IBBCIIh8hSABrSIPQoeVr6+Ytt6bnn9+fCALIA58hXwgCSAMfIV8IAcgCnyFfCAFIAh8hSIFQiWIIAWFQvnz3fGZ8pmrFn4iBUIgiCAFhSEFAkAgAUGgAUgNACABQQV2QXxqIRkDQCACIARqIhpBG2opAwAgA30gBEGYjQFqKQMAIgeFIghC/////w+DIgkgGkETaikDACADfCAEQZCNAWopAwAiCoUiC0IgiCIMfiINQv////8PgyAIQiCIIgggC0L/////D4MiC358IAkgC34iCUIgiHwiC0IghiAJQv////8Pg4QgDUIgiCAIIAx+fCALQiCIfIUgBnwgBEGIjQFqKQMAIgggBEGAjQFqKQMAIgl8hSEGIBpBC2opAwAgA30gCIUiCEL/////D4MiCyAaQQNqKQMAIAN8IAmFIglCIIgiDH4iDUL/////D4MgCEIgiCIIIAlC/////w+DIgl+fCALIAl+IglCIIh8IgtCIIYgCUL/////D4OEIA1CIIggCCAMfnwgC0IgiHyFIAV8IAcgCnyFIQUgBEEgaiEEIBlBf2oiGQ0ACwsgACACQf8AaikDACADfCABQeiLAWopAwAiB4UiCEL/////D4MiCSACKQN3IAN9IAFB4IsBaikDACIKhSILQiCIIgx+Ig1C/////w+DIAhCIIgiCCALQv////8PgyILfnwgCSALfiIJQiCIfCILQiCGIAlC/////w+DhCANQiCIIAggDH58IAtCIIh8hSAGfCABQfiLAWopAwAiBiABQfCLAWopAwAiCHyFIgkgAkHvAGopAwAgA3wgBoUiBkL/////D4MiCyACKQNnIAN9IAiFIghCIIgiDH4iDUL/////D4MgBkIgiCIGIAhC/////w+DIgh+fCALIAh+IghCIIh8IgtCIIYgCEL/////D4OEIA1CIIggBiAMfnwgC0IgiHyFIAV8IAcgCnyFIgZ8IgVCJYggBYVC+fPd8ZnymasWfiIFQiCIIAWFNwMAIABCACAGQoeVr6+Ytt6bnn9+IA8gA31Cz9bTvtLHq9lCfnwgCULj3MqV/M7y9YV/fnwiA0IliCADhUL5893xmfKZqxZ+IgNCIIggA4V9NwMIC98FAgF+AX8CQAJAQQApA4AKIgBQRQ0AQYAIIQFCACEADAELAkBBACkDoI4BIABSDQBBACEBDAELQQAhAUEAQq+v79e895Kg/gAgAH03A/iLAUEAIABCxZbr+djShYIofDcD8IsBQQBCj/Hjja2P9JhOIAB9NwPoiwFBACAAQqus+MXV79HQfHw3A+CLAUEAQtOt1LKShbW0nn8gAH03A9iLAUEAIABCl5r0jvWWvO3JAHw3A9CLAUEAQsWDgv2v/8SxayAAfTcDyIsBQQAgAELqi7OdyOb09UN8NwPAiwFBAELIv/rLnJveueQAIAB9NwO4iwFBACAAQoqjgd/Ume2sMXw3A7CLAUEAQvm57738+MKnHSAAfTcDqIsBQQAgAEKo9dv7s5ynmj98NwOgiwFBAEK4sry3lNW31lggAH03A5iLAUEAIABC8cihuqm0w/zOAHw3A5CLAUEAQoihl9u445SXo38gAH03A4iLAUEAIABCvNDI2pvysIBLfDcDgIsBQQBC4OvAtJ7QjpPMACAAfTcD+IoBQQAgAEK4kZii9/6Qko5/fDcD8IoBQQBCgrXB7sf5v7khIAB9NwPoigFBACAAQsvzmffEmfDy+AB8NwPgigFBAELygJGl+vbssx8gAH03A9iKAUEAIABC3qm3y76Q5MtbfDcD0IoBQQBC/IKE5PK+yNYcIAB9NwPIigFBACAAQrj9s8uzhOmlvn98NwPAigELQQBCADcDkI4BQQBCADcDiI4BQQBCADcDgI4BQQBCvdzKlQw3A4CKAUEAQoeVr6+Ytt6bnn83A4iKAUEAQs/W077Sx6vZQjcDkIoBQQBC+fPd8Zn2masWNwOYigFBAELj3MqV/M7y9YV/NwOgigFBAEL3lK+vCDcDqIoBQQBCxc/ZsvHluuonNwOwigFBAEKx893xCTcDuIoBQQAgADcDoI4BQQAgATYCsI4BQQBCkICAgIAQNwOYjgEL9AkBCH9BAEEAKQOQjgEgAK18NwOQjgECQAJAAkBBACgCgI4BIgEgAGoiAkGAAksNACABQYCMAWohA0GACiEEAkAgAEEITw0AIAAhAQwCCwJAAkAgAEF4aiIFQQN2QQFqQQdxIgYNAEGACiEEIAAhAQwBCyAGQQN0IQFBgAohBANAIAMgBCkDADcDACADQQhqIQMgBEEIaiEEIAZBf2oiBg0ACyAAIAFrIQELIAVBOEkNAQNAIAMgBCkDADcDACADQQhqIARBCGopAwA3AwAgA0EQaiAEQRBqKQMANwMAIANBGGogBEEYaikDADcDACADQSBqIARBIGopAwA3AwAgA0EoaiAEQShqKQMANwMAIANBMGogBEEwaikDADcDACADQThqIARBOGopAwA3AwAgA0HAAGohAyAEQcAAaiEEIAFBQGoiAUEHSw0ADAILC0GACiEEIABBgApqIQVBACgCsI4BIgNBwIoBIAMbIQYCQCABRQ0AIAFBgIwBaiEDQYAKIQQCQAJAQYACIAFrIgdBCE8NACAHIQAMAQsCQAJAQfgBIAFrIghBA3ZBAWpBB3EiAg0AQYAKIQQgByEADAELQYAKIQQgAkEDdCIAIQIDQCADIAQpAwA3AwAgA0EIaiEDIARBCGohBCACQXhqIgINAAtBgAIgASAAamshAAsgCEE4SQ0AA0AgAyAEKQMANwMAIANBCGogBEEIaikDADcDACADQRBqIARBEGopAwA3AwAgA0EYaiAEQRhqKQMANwMAIANBIGogBEEgaikDADcDACADQShqIARBKGopAwA3AwAgA0EwaiAEQTBqKQMANwMAIANBOGogBEE4aikDADcDACADQcAAaiEDIARBwABqIQQgAEFAaiIAQQdLDQALCwJAIABFDQACQAJAIABBB3EiAg0AIAAhAQwBCyAAQXhxIQEDQCADIAQtAAA6AAAgA0EBaiEDIARBAWohBCACQX9qIgINAAsLIABBCEkNAANAIAMgBCkAADcAACADQQhqIQMgBEEIaiEEIAFBeGoiAQ0ACwtBgIoBQYiOAUEAKAKYjgFBgIwBQQQgBkEAKAKcjgEQAkEAQQA2AoCOASAHQYAKaiEECwJAIARBgAJqIAVPDQAgBUGAfmohAgNAQYCKAUGIjgFBACgCmI4BIAQiA0EEIAZBACgCnI4BEAIgA0GAAmoiBCACSQ0AC0EAIAMpA8ABNwPAjQFBACADKQPIATcDyI0BQQAgAykD0AE3A9CNAUEAIAMpA9gBNwPYjQFBACADKQPgATcD4I0BQQAgAykD6AE3A+iNAUEAIAMpA/ABNwPwjQFBACADKQP4ATcD+I0BC0GAjAEhAwJAAkAgBSAEayICQQhPDQAgAiEGDAELQYCMASEDIAIhBgNAIAMgBCkDADcDACADQQhqIQMgBEEIaiEEIAZBeGoiBkEHSw0ACwsgBkUNAQNAIAMgBC0AADoAACADQQFqIQMgBEEBaiEEIAZBf2oiBg0ADAILCyABRQ0AAkACQCABQQdxIgYNACABIQIMAQsgAUF4cSECA0AgAyAELQAAOgAAIANBAWohAyAEQQFqIQQgBkF/aiIGDQALCwJAIAFBCEkNAANAIAMgBCkAADcAACADQQhqIQMgBEEIaiEEIAJBeGoiAg0ACwtBACgCgI4BIABqIQILQQAgAjYCgI4BC90QBgR/A34BfwN+BX8CfiMAIgAhASAAQYABa0FAcSICJABBACgCsI4BIgBBwIoBIAAbIQMCQAJAQQApA5COASIEQvEBVA0AIAJBACkDgIoBNwMAIAJBACkDiIoBNwMIIAJBACkDkIoBNwMQIAJBACkDmIoBNwMYIAJBACkDoIoBNwMgIAJBACkDqIoBNwMoIAJBACkDsIoBIgU3AzAgAkEAKQO4igEiBjcDOAJAAkBBACgCgI4BIgdBwABJDQAgAkEAKAKIjgE2AkAgAiACQcAAakEAKAKYjgFBgIwBIAdBf2pBBnYgA0EAKAKcjgEiABACIAIgAikDCCAHQcCLAWopAwAiBXwgAyAAaiIAKQMBIAdByIsBaikDACIGhSIIQiCIIAhC/////w+Dfnw3AwggAiACKQMYIAdB0IsBaikDACIIfCAAKQMRIAdB2IsBaikDACIJhSIKQiCIIApC/////w+Dfnw3AxggAiAGIAUgAEF5aikDAIUiBUIgiCAFQv////8Pg34gAikDAHx8NwMAIAIgCSAIIAApAwmFIgVCIIggBUL/////D4N+IAIpAxB8fDcDECAAKQMZIQUgAikDICEGIAIgAikDKCAHQeCLAWopAwAiCHwgACkDISAHQeiLAWopAwAiCYUiCkIgiCAKQv////8Pg358NwMoIAIgCSAGIAUgCIUiBUIgiCAFQv////8Pg358fDcDICACIAIpAzggB0HwiwFqKQMAIgV8IAApAzEgB0H4iwFqKQMAIgaFIghCIIggCEL/////D4N+fDcDOCACIAYgBSAAKQMphSIFQiCIIAVC/////w+DfiACKQMwfHw3AzAMAQsgB0HAjQFqIQtBwAAgB2shDCACQcAAaiEAAkACQAJAIAdBOE0NACAMIQ0MAQsCQAJAQTggB2tBA3ZBAWpBB3EiDQ0AIAJBwABqIQAgDCENDAELIAJBwABqIQAgDUEDdCIOIQ0DQCAAIAspAwA3AwAgAEEIaiEAIAtBCGohCyANQXhqIg0NAAtBwAAgByAOamshDQsCQCAHDQADQCAAIAspAwA3AwAgAEEIaiALQQhqKQMANwMAIABBEGogC0EQaikDADcDACAAQRhqIAtBGGopAwA3AwAgAEEgaiALQSBqKQMANwMAIABBKGogC0EoaikDADcDACAAQTBqIAtBMGopAwA3AwAgAEE4aiALQThqKQMANwMAIABBwABqIQAgC0HAAGohCyANQUBqIg1BB0sNAAsLIA1FDQELIA1Bf2ohDwJAIA1BB3EiDkUNACANQXhxIQ0DQCAAIAstAAA6AAAgAEEBaiEAIAtBAWohCyAOQX9qIg4NAAsLIA9BB0kNAANAIAAgCykAADcAACAAQQhqIQAgC0EIaiELIA1BeGoiDQ0ACwsgAkHAAGogDGohC0GAjAEhAAJAAkACQCAHQQhJDQACQCAHQThqQQN2QQFqQQdxIg0NAAwCCyANQQN0IQ5BgIwBIQADQCALIAApAwA3AwAgC0EIaiELIABBCGohACANQX9qIg0NAAsgByAOayEHCyAHRQ0BAkACQCAHQQdxIg4NACAHIQ0MAQsgB0F4cSENA0AgCyAALQAAOgAAIAtBAWohCyAAQQFqIQAgDkF/aiIODQALCyAHQQhJDQELA0AgCyAAKQAANwAAIAtBCGohCyAAQQhqIQAgDUF4aiINDQALCyACIAIpAwggAikDQCIIfCADQQAoApyOAWoiACkDASACKQNIIgmFIgpCIIggCkL/////D4N+fDcDCCACIAIpAxggAikDUCIKfCAAKQMRIAIpA1giEIUiEUIgiCARQv////8Pg358NwMYIAIgECAKIAApAwmFIgpCIIggCkL/////D4N+IAIpAxB8fDcDECACIAkgCCAAQXlqKQMAhSIIQiCIIAhC/////w+DfiACKQMAfHw3AwAgACkDGSEIIAIpAyAhCSACIAIpAyggAikDYCIKfCAAKQMhIAIpA2giEIUiEUIgiCARQv////8Pg358NwMoIAIgECAJIAggCoUiCEIgiCAIQv////8Pg358fDcDICACIAYgAikDcCIIfCAAKQMxIAIpA3giBoUiCUIgiCAJQv////8Pg358NwM4IAIgBiAIIAApAymFIghCIIggCEL/////D4N+IAV8fDcDMAsgAiACIANBC2ogBEKHla+vmLbem55/fhADNwNAIAIgAiADQQAoApyOAWpBdWogBELP1tO+0ser2UJ+Qn+FEAM3A0gMAQsgBKchAAJAQQApA6COASIEUA0AAkAgAEEQSw0AIAJBwABqIABBgAggBBAEDAILAkAgAEGAAUsNACACQcAAaiAAQYAIIAQQBQwCCyACQcAAaiAAQYAIIAQQBgwBCwJAIABBEEsNACACQcAAaiAAIANCABAEDAELAkAgAEGAAUsNACACQcAAaiAAIANCABAFDAELIAJBwABqIAAgA0IAEAYLQQAgAikDcDcDuApBACACKQNgNwOoCkEAIAIpA1A3A5gKQQAgAkH4AGopAwA3A8AKQQAgAkHoAGopAwA3A7AKQQAgAkHYAGopAwA3A6AKQQAgAikDSCIEQjiGIARCgP4Dg0IohoQgBEKAgPwHg0IYhiAEQoCAgPgPg0IIhoSEIARCCIhCgICA+A+DIARCGIhCgID8B4OEIARCKIhCgP4DgyAEQjiIhISEIgQ3A4AKQQAgBDcDkApBACACKQNAIgRCOIYgBEKA/gODQiiGhCAEQoCA/AeDQhiGIARCgICA+A+DQgiGhIQgBEIIiEKAgID4D4MgBEIYiEKAgPwHg4QgBEIoiEKA/gODIARCOIiEhIQ3A4gKIAEkAAsGAEGAigELAgALC8wBAQBBgAgLxAG4/mw5I6RLvnwBgSz3Ia0c3tRt6YOQl9tyQKSkt7NnH8t55k7MwOV4glrQfcz/ciG4CEZ090MkjuA1kOaBOiZMPChSu5HDAMuI0GWLG1Muo3FkSJeiDflOOBnvRqnerNio+nY/45w0P/ncu8fHC08dilHgS820WTHIn37J2XhzZOrFrIM00+vDxYGg//oTY+sXDd1Rt/DaSdMWVSYp1GieKxa+WH1HofyP+LjRetAxzkXLOo+VFgQor9f7yrtLQH5AAgAA";
    hash$5 = "b9ab74e2";
    wasmJson$5 = {
      name: name$5,
      data: data$5,
      hash: hash$5
    };
    mutex$3 = new Mutex();
    wasmCache$3 = null;
    seedBuffer = new Uint8Array(8);
    name$4 = "ripemd160";
    data$4 = "AGFzbQEAAAABEQRgAAF/YAAAYAF/AGACf38AAwkIAAECAwIBAAIFBAEBAgIGDgJ/AUHgiQULfwBBgAgLB4MBCQZtZW1vcnkCAA5IYXNoX0dldEJ1ZmZlcgAACUhhc2hfSW5pdAABEHJpcGVtZDE2MF91cGRhdGUAAwtIYXNoX1VwZGF0ZQAECkhhc2hfRmluYWwABQ1IYXNoX0dldFN0YXRlAAYOSGFzaF9DYWxjdWxhdGUABwpTVEFURV9TSVpFAwEKzzIIBQBBgAkLOgBBAEHww8uefDYCmIkBQQBC/rnrxemOlZkQNwKQiQFBAEKBxpS6lvHq5m83AoiJAUEAQgA3AoCJAQuPLAEhf0EAIAAoAiQiASAAKAIAIgIgACgCECIDIAIgACgCLCIEIAAoAgwiBSAAKAIEIgYgACgCPCIHIAIgACgCMCIIIAcgACgCCCIJQQAoAoiJASIKQQAoApCJASILQQAoApSJASIMQX9zckEAKAKMiQEiDXNqIAAoAhQiDmpB5peKhQVqQQh3QQAoApiJASIPaiIQQQp3IhFqIAEgDUEKdyISaiACIAtBCnciE2ogDCAAKAIcIhRqIA8gACgCOCIVaiAQIA0gE0F/c3JzakHml4qFBWpBCXcgDGoiFiAQIBJBf3Nyc2pB5peKhQVqQQl3IBNqIhAgFiARQX9zcnNqQeaXioUFakELdyASaiIXIBAgFkEKdyIWQX9zcnNqQeaXioUFakENdyARaiIYIBcgEEEKdyIZQX9zcnNqQeaXioUFakEPdyAWaiIaQQp3IhtqIAAoAhgiECAYQQp3IhxqIAAoAjQiESAXQQp3IhdqIAMgGWogBCAWaiAaIBggF0F/c3JzakHml4qFBWpBD3cgGWoiFiAaIBxBf3Nyc2pB5peKhQVqQQV3IBdqIhcgFiAbQX9zcnNqQeaXioUFakEHdyAcaiIYIBcgFkEKdyIZQX9zcnNqQeaXioUFakEHdyAbaiIaIBggF0EKdyIXQX9zcnNqQeaXioUFakEIdyAZaiIbQQp3IhxqIAUgGkEKdyIdaiAAKAIoIhYgGEEKdyIYaiAGIBdqIAAoAiAiACAZaiAbIBogGEF/c3JzakHml4qFBWpBC3cgF2oiFyAbIB1Bf3Nyc2pB5peKhQVqQQ53IBhqIhggFyAcQX9zcnNqQeaXioUFakEOdyAdaiIZIBggF0EKdyIaQX9zcnNqQeaXioUFakEMdyAcaiIbIBkgGEEKdyIcQX9zcnNqQeaXioUFakEGdyAaaiIdQQp3IhdqIAUgGUEKdyIYaiAQIBpqIBsgGEF/c3FqIB0gGHFqQaSit+IFakEJdyAcaiIaIBdBf3NxaiAEIBxqIB0gG0EKdyIZQX9zcWogGiAZcWpBpKK34gVqQQ13IBhqIhsgF3FqQaSit+IFakEPdyAZaiIcIBtBCnciGEF/c3FqIBQgGWogGyAaQQp3IhlBf3NxaiAcIBlxakGkorfiBWpBB3cgF2oiGyAYcWpBpKK34gVqQQx3IBlqIh1BCnciF2ogFiAcQQp3IhpqIBEgGWogGyAaQX9zcWogHSAacWpBpKK34gVqQQh3IBhqIhwgF0F/c3FqIA4gGGogHSAbQQp3IhhBf3NxaiAcIBhxakGkorfiBWpBCXcgGmoiGiAXcWpBpKK34gVqQQt3IBhqIhsgGkEKdyIZQX9zcWogFSAYaiAaIBxBCnciGEF/c3FqIBsgGHFqQaSit+IFakEHdyAXaiIcIBlxakGkorfiBWpBB3cgGGoiHUEKdyIXaiADIBtBCnciGmogACAYaiAcIBpBf3NxaiAdIBpxakGkorfiBWpBDHcgGWoiGyAXQX9zcWogCCAZaiAdIBxBCnciGEF/c3FqIBsgGHFqQaSit+IFakEHdyAaaiIaIBdxakGkorfiBWpBBncgGGoiHCAaQQp3IhlBf3NxaiABIBhqIBogG0EKdyIYQX9zcWogHCAYcWpBpKK34gVqQQ93IBdqIhogGXFqQaSit+IFakENdyAYaiIbQQp3Ih1qIAYgGkEKdyIeaiAOIBxBCnciF2ogByAZaiAJIBhqIBogF0F/c3FqIBsgF3FqQaSit+IFakELdyAZaiIYIBtBf3NyIB5zakHz/cDrBmpBCXcgF2oiFyAYQX9zciAdc2pB8/3A6wZqQQd3IB5qIhkgF0F/c3IgGEEKdyIYc2pB8/3A6wZqQQ93IB1qIhogGUF/c3IgF0EKdyIXc2pB8/3A6wZqQQt3IBhqIhtBCnciHGogASAaQQp3Ih1qIBAgGUEKdyIZaiAVIBdqIBQgGGogGyAaQX9zciAZc2pB8/3A6wZqQQh3IBdqIhcgG0F/c3IgHXNqQfP9wOsGakEGdyAZaiIYIBdBf3NyIBxzakHz/cDrBmpBBncgHWoiGSAYQX9zciAXQQp3IhdzakHz/cDrBmpBDncgHGoiGiAZQX9zciAYQQp3IhhzakHz/cDrBmpBDHcgF2oiG0EKdyIcaiAWIBpBCnciHWogCSAZQQp3IhlqIAggGGogACAXaiAbIBpBf3NyIBlzakHz/cDrBmpBDXcgGGoiFyAbQX9zciAdc2pB8/3A6wZqQQV3IBlqIhggF0F/c3IgHHNqQfP9wOsGakEOdyAdaiIZIBhBf3NyIBdBCnciF3NqQfP9wOsGakENdyAcaiIaIBlBf3NyIBhBCnciGHNqQfP9wOsGakENdyAXaiIbQQp3IhxqIBEgGGogAyAXaiAbIBpBf3NyIBlBCnciGXNqQfP9wOsGakEHdyAYaiIYIBtBf3NyIBpBCnciGnNqQfP9wOsGakEFdyAZaiIXQQp3IhsgECAaaiAYQQp3Ih0gACAZaiAcIBdBf3NxaiAXIBhxakHp7bXTB2pBD3cgGmoiGEF/c3FqIBggF3FqQenttdMHakEFdyAcaiIXQX9zcWogFyAYcWpB6e210wdqQQh3IB1qIhlBCnciGmogBSAbaiAXQQp3IhwgBiAdaiAYQQp3Ih0gGUF/c3FqIBkgF3FqQenttdMHakELdyAbaiIXQX9zcWogFyAZcWpB6e210wdqQQ53IB1qIhhBCnciGyAHIBxqIBdBCnciHiAEIB1qIBogGEF/c3FqIBggF3FqQenttdMHakEOdyAcaiIXQX9zcWogFyAYcWpB6e210wdqQQZ3IBpqIhhBf3NxaiAYIBdxakHp7bXTB2pBDncgHmoiGUEKdyIaaiAIIBtqIBhBCnciHCAOIB5qIBdBCnciHSAZQX9zcWogGSAYcWpB6e210wdqQQZ3IBtqIhdBf3NxaiAXIBlxakHp7bXTB2pBCXcgHWoiGEEKdyIbIBEgHGogF0EKdyIeIAkgHWogGiAYQX9zcWogGCAXcWpB6e210wdqQQx3IBxqIhdBf3NxaiAXIBhxakHp7bXTB2pBCXcgGmoiGEF/c3FqIBggF3FqQenttdMHakEMdyAeaiIZQQp3IhogB2ogFSAXQQp3IhxqIBogFiAbaiAYQQp3Ih0gFCAeaiAcIBlBf3NxaiAZIBhxakHp7bXTB2pBBXcgG2oiF0F/c3FqIBcgGXFqQenttdMHakEPdyAcaiIYQX9zcWogGCAXcWpB6e210wdqQQh3IB1qIhkgGEEKdyIbcyAdIAhqIBggF0EKdyIXcyAZc2pBCHcgGmoiGHNqQQV3IBdqIhpBCnciHCAAaiAZQQp3IhkgBmogFyAWaiAYIBlzIBpzakEMdyAbaiIXIBxzIBsgA2ogGiAYQQp3IhhzIBdzakEJdyAZaiIZc2pBDHcgGGoiGiAZQQp3IhtzIBggDmogGSAXQQp3IhdzIBpzakEFdyAcaiIYc2pBDncgF2oiGUEKdyIcIBVqIBpBCnciGiAJaiAXIBRqIBggGnMgGXNqQQZ3IBtqIhcgHHMgGyAQaiAZIBhBCnciGHMgF3NqQQh3IBpqIhlzakENdyAYaiIaIBlBCnciG3MgGCARaiAZIBdBCnciGHMgGnNqQQZ3IBxqIhlzakEFdyAYaiIcQQp3Ih0gDGogBCAWIA4gDiARIBYgDiAUIAEgACABIBAgFCAEIBAgBiAPaiATIA1zIAsgDXMgDHMgCmogAmpBC3cgD2oiF3NqQQ53IAxqIh5BCnciH2ogAyASaiAJIAxqIBcgEnMgHnNqQQ93IBNqIgwgH3MgBSATaiAeIBdBCnciE3MgDHNqQQx3IBJqIhJzakEFdyATaiIXIBJBCnciHnMgEyAOaiASIAxBCnciDHMgF3NqQQh3IB9qIhJzakEHdyAMaiITQQp3Ih9qIAEgF0EKdyIXaiAMIBRqIBIgF3MgE3NqQQl3IB5qIgwgH3MgHiAAaiATIBJBCnciEnMgDHNqQQt3IBdqIhNzakENdyASaiIXIBNBCnciHnMgEiAWaiATIAxBCnciDHMgF3NqQQ53IB9qIhJzakEPdyAMaiITQQp3Ih9qIB4gEWogEyASQQp3IiBzIAwgCGogEiAXQQp3IgxzIBNzakEGdyAeaiISc2pBB3cgDGoiE0EKdyIXICAgB2ogEyASQQp3Ih5zIAwgFWogEiAfcyATc2pBCXcgIGoiE3NqQQh3IB9qIgxBf3NxaiAMIBNxakGZ84nUBWpBB3cgHmoiEkEKdyIfaiARIBdqIAxBCnciICADIB5qIBNBCnciEyASQX9zcWogEiAMcWpBmfOJ1AVqQQZ3IBdqIgxBf3NxaiAMIBJxakGZ84nUBWpBCHcgE2oiEkEKdyIXIBYgIGogDEEKdyIeIAYgE2ogHyASQX9zcWogEiAMcWpBmfOJ1AVqQQ13ICBqIgxBf3NxaiAMIBJxakGZ84nUBWpBC3cgH2oiEkF/c3FqIBIgDHFqQZnzidQFakEJdyAeaiITQQp3Ih9qIAUgF2ogEkEKdyIgIAcgHmogDEEKdyIeIBNBf3NxaiATIBJxakGZ84nUBWpBB3cgF2oiDEF/c3FqIAwgE3FqQZnzidQFakEPdyAeaiISQQp3IhcgAiAgaiAMQQp3IiEgCCAeaiAfIBJBf3NxaiASIAxxakGZ84nUBWpBB3cgIGoiDEF/c3FqIAwgEnFqQZnzidQFakEMdyAfaiISQX9zcWogEiAMcWpBmfOJ1AVqQQ93ICFqIhNBCnciHmogCSAXaiASQQp3Ih8gDiAhaiAMQQp3IiAgE0F/c3FqIBMgEnFqQZnzidQFakEJdyAXaiIMQX9zcWogDCATcWpBmfOJ1AVqQQt3ICBqIhJBCnciEyAEIB9qIAxBCnciFyAVICBqIB4gEkF/c3FqIBIgDHFqQZnzidQFakEHdyAfaiIMQX9zcWogDCAScWpBmfOJ1AVqQQ13IB5qIhJBf3MiIHFqIBIgDHFqQZnzidQFakEMdyAXaiIeQQp3Ih9qIAMgEkEKdyISaiAVIAxBCnciDGogFiATaiAFIBdqIB4gIHIgDHNqQaHX5/YGakELdyATaiITIB5Bf3NyIBJzakGh1+f2BmpBDXcgDGoiDCATQX9zciAfc2pBodfn9gZqQQZ3IBJqIhIgDEF/c3IgE0EKdyITc2pBodfn9gZqQQd3IB9qIhcgEkF/c3IgDEEKdyIMc2pBodfn9gZqQQ53IBNqIh5BCnciH2ogCSAXQQp3IiBqIAYgEkEKdyISaiAAIAxqIAcgE2ogHiAXQX9zciASc2pBodfn9gZqQQl3IAxqIgwgHkF/c3IgIHNqQaHX5/YGakENdyASaiISIAxBf3NyIB9zakGh1+f2BmpBD3cgIGoiEyASQX9zciAMQQp3IgxzakGh1+f2BmpBDncgH2oiFyATQX9zciASQQp3IhJzakGh1+f2BmpBCHcgDGoiHkEKdyIfaiAEIBdBCnciIGogESATQQp3IhNqIBAgEmogAiAMaiAeIBdBf3NyIBNzakGh1+f2BmpBDXcgEmoiDCAeQX9zciAgc2pBodfn9gZqQQZ3IBNqIhIgDEF/c3IgH3NqQaHX5/YGakEFdyAgaiITIBJBf3NyIAxBCnciF3NqQaHX5/YGakEMdyAfaiIeIBNBf3NyIBJBCnciEnNqQaHX5/YGakEHdyAXaiIfQQp3IgxqIAEgE0EKdyITaiAIIBdqIB8gHkF/c3IgE3NqQaHX5/YGakEFdyASaiIXIAxBf3NxaiAGIBJqIB8gHkEKdyISQX9zcWogFyAScWpB3Pnu+HhqQQt3IBNqIh4gDHFqQdz57vh4akEMdyASaiIfIB5BCnciE0F/c3FqIAQgEmogHiAXQQp3IhJBf3NxaiAfIBJxakHc+e74eGpBDncgDGoiHiATcWpB3Pnu+HhqQQ93IBJqIiBBCnciDGogCCAfQQp3IhdqIAIgEmogHiAXQX9zcWogICAXcWpB3Pnu+HhqQQ53IBNqIh8gDEF/c3FqIAAgE2ogICAeQQp3IhJBf3NxaiAfIBJxakHc+e74eGpBD3cgF2oiFyAMcWpB3Pnu+HhqQQl3IBJqIh4gF0EKdyITQX9zcWogAyASaiAXIB9BCnciEkF/c3FqIB4gEnFqQdz57vh4akEIdyAMaiIfIBNxakHc+e74eGpBCXcgEmoiIEEKdyIMaiAHIB5BCnciF2ogBSASaiAfIBdBf3NxaiAgIBdxakHc+e74eGpBDncgE2oiHiAMQX9zcWogFCATaiAgIB9BCnciEkF/c3FqIB4gEnFqQdz57vh4akEFdyAXaiIXIAxxakHc+e74eGpBBncgEmoiHyAXQQp3IhNBf3NxaiAVIBJqIBcgHkEKdyISQX9zcWogHyAScWpB3Pnu+HhqQQh3IAxqIhcgE3FqQdz57vh4akEGdyASaiIeQQp3IiBqIAIgF0EKdyIOaiADIB9BCnciDGogCSATaiAeIA5Bf3NxaiAQIBJqIBcgDEF/c3FqIB4gDHFqQdz57vh4akEFdyATaiIDIA5xakHc+e74eGpBDHcgDGoiDCADICBBf3Nyc2pBzvrPynpqQQl3IA5qIg4gDCADQQp3IgNBf3Nyc2pBzvrPynpqQQ93ICBqIhIgDiAMQQp3IgxBf3Nyc2pBzvrPynpqQQV3IANqIhNBCnciF2ogCSASQQp3IhZqIAggDkEKdyIJaiAUIAxqIAEgA2ogEyASIAlBf3Nyc2pBzvrPynpqQQt3IAxqIgMgEyAWQX9zcnNqQc76z8p6akEGdyAJaiIIIAMgF0F/c3JzakHO+s/KempBCHcgFmoiCSAIIANBCnciA0F/c3JzakHO+s/KempBDXcgF2oiDiAJIAhBCnciCEF/c3JzakHO+s/KempBDHcgA2oiFEEKdyIWaiAAIA5BCnciDGogBSAJQQp3IgBqIAYgCGogFSADaiAUIA4gAEF/c3JzakHO+s/KempBBXcgCGoiAyAUIAxBf3Nyc2pBzvrPynpqQQx3IABqIgAgAyAWQX9zcnNqQc76z8p6akENdyAMaiIGIAAgA0EKdyIDQX9zcnNqQc76z8p6akEOdyAWaiIIIAYgAEEKdyIAQX9zcnNqQc76z8p6akELdyADaiIJQQp3IhVqNgKQiQFBACALIBggAmogGSAaQQp3IgJzIBxzakEPdyAbaiIOQQp3IhZqIBAgA2ogCSAIIAZBCnciA0F/c3JzakHO+s/KempBCHcgAGoiBkEKd2o2AoyJAUEAIA0gGyAFaiAcIBlBCnciBXMgDnNqQQ13IAJqIhRBCndqIAcgAGogBiAJIAhBCnciAEF/c3JzakHO+s/KempBBXcgA2oiB2o2AoiJAUEAIAAgCmogAiABaiAOIB1zIBRzakELdyAFaiIBaiARIANqIAcgBiAVQX9zcnNqQc76z8p6akEGd2o2ApiJAUEAIAAgD2ogHWogBSAEaiAUIBZzIAFzakELd2o2ApSJAQuiAwEIfwJAIAFFDQBBACECQQBBACgCgIkBIgMgAWoiBDYCgIkBIANBP3EhBQJAIAQgA08NAEEAQQAoAoSJAUEBajYChIkBCwJAIAVFDQACQCABQcAAIAVrIgZPDQAgBSECDAELIAZBA3EhB0EAIQMCQCAFQT9zQQNJDQAgBUGAiQFqIQggBkH8AHEhCUEAIQMDQCAIIANqIgJBHGogACADaiIELQAAOgAAIAJBHWogBEEBai0AADoAACACQR5qIARBAmotAAA6AAAgAkEfaiAEQQNqLQAAOgAAIAkgA0EEaiIDRw0ACwsCQCAHRQ0AIAAgA2ohAiADIAVqQZyJAWohAwNAIAMgAi0AADoAACACQQFqIQIgA0EBaiEDIAdBf2oiBw0ACwtBnIkBEAIgASAGayEBIAAgBmohAEEAIQILAkAgAUHAAEkNAANAIAAQAiAAQcAAaiEAIAFBQGoiAUE/Sw0ACwsgAUUNACACQZyJAWohA0EAIQIDQCADIAAtAAA6AAAgAEEBaiEAIANBAWohAyABIAJBAWoiAkH/AXFLDQALCwsJAEGACSAAEAMLggEBAn8jAEEQayIAJAAgAEEAKAKAiQEiAUEDdDYCCCAAQQAoAoSJAUEDdCABQR12cjYCDEGQCEE4QfgAIAFBP3EiAUE4SRsgAWsQAyAAQQhqQQgQA0EAQQAoAoiJATYCgAlBAEEAKQKMiQE3AoQJQQBBACkClIkBNwKMCSAAQRBqJAALBgBBgIkBC8EBAQF/IwBBEGsiASQAQQBB8MPLnnw2ApiJAUEAQv6568XpjpWZEDcCkIkBQQBCgcaUupbx6uZvNwKIiQFBAEIANwKAiQFBgAkgABADIAFBACgCgIkBIgBBA3Q2AgggAUEAKAKEiQFBA3QgAEEddnI2AgxBkAhBOEH4ACAAQT9xIgBBOEkbIABrEAMgAUEIakEIEANBAEEAKAKIiQE2AoAJQQBBACkCjIkBNwKECUEAQQApApSJATcCjAkgAUEQaiQACwtXAQBBgAgLUFwAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";
    hash$4 = "6abbce74";
    wasmJson$4 = {
      name: name$4,
      data: data$4,
      hash: hash$4
    };
    mutex$2 = new Mutex();
    wasmCache$2 = null;
    validateOptions$2 = (options) => {
      if (!options || typeof options !== "object") {
        throw new Error("Invalid options parameter. It requires an object.");
      }
      if (!options.hashFunction || !options.hashFunction.then) {
        throw new Error('Invalid hash function is provided! Usage: pbkdf2("password", "salt", 1000, 32, createSHA1()).');
      }
      if (!Number.isInteger(options.iterations) || options.iterations < 1) {
        throw new Error("Iterations should be a positive number");
      }
      if (!Number.isInteger(options.hashLength) || options.hashLength < 1) {
        throw new Error("Hash length should be a positive number");
      }
      if (options.outputType === void 0) {
        options.outputType = "hex";
      }
      if (!["hex", "binary"].includes(options.outputType)) {
        throw new Error(`Insupported output type ${options.outputType}. Valid values: ['hex', 'binary']`);
      }
    };
    name$3 = "scrypt";
    data$3 = "AGFzbQEAAAABGwVgAX8Bf2AAAX9gBH9/f38AYAF/AGADf39/AAMGBQABAgMEBQYBAQKAgAIGCAF/AUGQiAQLBzkEBm1lbW9yeQIAEkhhc2hfU2V0TWVtb3J5U2l6ZQAADkhhc2hfR2V0QnVmZmVyAAEGc2NyeXB0AAQK7iYFWAECf0EAIQECQCAAQQAoAogIIgJGDQACQCAAIAJrIgBBEHYgAEGAgHxxIABJaiIAQABBf0cNAEH/AcAPC0EAIQFBAEEAKQOICCAAQRB0rXw3A4gICyABwAtwAQJ/AkBBACgCgAgiAA0AQQA/AEEQdCIANgKACEEAKAKICCIBQYCAIEYNAAJAQYCAICABayIAQRB2IABBgIB8cSAASWoiAEAAQX9HDQBBAA8LQQBBACkDiAggAEEQdK18NwOICEEAKAKACCEACyAAC6QFAQN/IAIgA0EHdCAAakFAaiIEKQMANwMAIAIgBCkDCDcDCCACIAQpAxA3AxAgAiAEKQMYNwMYIAIgBCkDIDcDICACIAQpAyg3AyggAiAEKQMwNwMwIAIgBCkDODcDOAJAIANFDQAgA0EBdCEFIANBBnQhBkEAIQMDQCACIAIpAwAgACkDAIU3AwAgAiACKQMIIABBCGopAwCFNwMIIAIgAikDECAAQRBqKQMAhTcDECACIAIpAxggAEEYaikDAIU3AxggAiACKQMgIABBIGopAwCFNwMgIAIgAikDKCAAQShqKQMAhTcDKCACIAIpAzAgAEEwaikDAIU3AzAgAiACKQM4IABBOGopAwCFNwM4IAIQAyABIAIpAwA3AwAgAUEIaiACKQMINwMAIAFBEGogAikDEDcDACABQRhqIAIpAxg3AwAgAUEgaiACKQMgNwMAIAFBKGogAikDKDcDACABQTBqIAIpAzA3AwAgAUE4aiACKQM4NwMAIAIgAikDACAAQcAAaikDAIU3AwAgAiACKQMIIABByABqKQMAhTcDCCACIAIpAxAgAEHQAGopAwCFNwMQIAIgAikDGCAAQdgAaikDAIU3AxggAiACKQMgIABB4ABqKQMAhTcDICACIAIpAyggAEHoAGopAwCFNwMoIAIgAikDMCAAQfAAaikDAIU3AzAgAiACKQM4IABB+ABqKQMAhTcDOCACEAMgASAGaiIEIAIpAwA3AwAgBEEIaiACKQMINwMAIARBEGogAikDEDcDACAEQRhqIAIpAxg3AwAgBEEgaiACKQMgNwMAIARBKGogAikDKDcDACAEQTBqIAIpAzA3AwAgBEE4aiACKQM4NwMAIABBgAFqIQAgAUHAAGohASADQQJqIgMgBUkNAAsLC7oNCAF+AX8BfgF/AX4BfwF+En8gACAAKAIEIAApAygiAUIgiKciAiAAKQM4IgNCIIinIgRqQQd3IAApAwgiBUIgiKdzIgYgBGpBCXcgACkDGCIHQiCIp3MiCCAGakENdyACcyIJIAenIgogAaciC2pBB3cgA6dzIgIgC2pBCXcgBadzIgwgAmpBDXcgCnMiDSAMakESdyALcyIOIAApAwAiAUIgiKciDyAAKQMQIgNCIIinIhBqQQd3IAApAyAiBUIgiKdzIgtqQQd3cyIKIAkgCGpBEncgBHMiESACakEHdyAAKQMwIgenIgkgAaciEmpBB3cgA6dzIgQgEmpBCXcgBadzIhMgBGpBDXcgCXMiFHMiCSARakEJdyALIBBqQQl3IAdCIIincyIVcyIWIAlqQQ13IAJzIhcgFmpBEncgEXMiEWpBB3cgBiAUIBNqQRJ3IBJzIhJqQQd3IBUgC2pBDXcgD3MiFHMiAiASakEJdyAMcyIPIAJqQQ13IAZzIhhzIgYgEWpBCXcgCCANIBQgFWpBEncgEHMiECAEakEHd3MiDCAQakEJd3MiCHMiFSAGakENdyAKcyIUIAwgCiAOakEJdyATcyITIApqQQ13IAtzIhkgE2pBEncgDnMiCmpBB3cgF3MiCyAKakEJdyAPcyIOIAtqQQ13IAxzIhcgDmpBEncgCnMiDSACIAggDGpBDXcgBHMiDCAIakESdyAQcyIIakEHdyAZcyIKakEHd3MiBCAUIBVqQRJ3IBFzIhAgC2pBB3cgCSAYIA9qQRJ3IBJzIhFqQQd3IAxzIgwgEWpBCXcgE3MiEiAMakENdyAJcyIPcyIJIBBqQQl3IAogCGpBCXcgFnMiE3MiFiAJakENdyALcyIUIBZqQRJ3IBBzIhBqQQd3IAYgDyASakESdyARcyIRakEHdyATIApqQQ13IAJzIgtzIgIgEWpBCXcgDnMiDiACakENdyAGcyIYcyIGIBBqQQl3IBUgFyALIBNqQRJ3IAhzIgggDGpBB3dzIgsgCGpBCXdzIhNzIhUgBmpBDXcgBHMiFyALIAQgDWpBCXcgEnMiEiAEakENdyAKcyIZIBJqQRJ3IA1zIgRqQQd3IBRzIgogBGpBCXcgDnMiDyAKakENdyALcyIUIA9qQRJ3IARzIg0gAiATIAtqQQ13IAxzIgwgE2pBEncgCHMiCGpBB3cgGXMiC2pBB3dzIgQgFyAVakESdyAQcyIQIApqQQd3IAkgGCAOakESdyARcyIOakEHdyAMcyIMIA5qQQl3IBJzIhEgDGpBDXcgCXMiF3MiCSAQakEJdyALIAhqQQl3IBZzIhJzIhMgCWpBDXcgCnMiGCATakESdyAQcyIQakEHdyAGIBcgEWpBEncgDnMiCmpBB3cgEiALakENdyACcyIXcyICIApqQQl3IA9zIg4gAmpBDXcgBnMiFnMiBiAJIBYgDmpBEncgCnMiFmpBB3cgFSAUIBcgEmpBEncgCHMiCCAMakEHd3MiCiAIakEJd3MiEiAKakENdyAMcyIPcyIMIBZqQQl3IAQgDWpBCXcgEXMiEXMiFSAMakENdyAJcyIUIBVqQRJ3IBZzIglqQQd3IAIgDyASakESdyAIcyIIakEHdyARIARqQQ13IAtzIg9zIgsgCGpBCXcgE3MiEyALakENdyACcyIXcyIWajYCBCAAIAAoAgggFiAJakEJdyAKIA8gEWpBEncgDXMiEWpBB3cgGHMiAiARakEJdyAOcyIOcyIPajYCCCAAIAAoAgwgDyAWakENdyAGcyINajYCDCAAIAAoAhAgBiAQakEJdyAScyISIA4gAmpBDXcgCnMiGCAXIBNqQRJ3IAhzIgogDGpBB3dzIgggCmpBCXdzIhYgCGpBDXcgDHMiDGo2AhAgACAAKAIAIA0gD2pBEncgCXNqNgIAIAAgACgCFCAMIBZqQRJ3IApzajYCFCAAIAAoAhggCGo2AhggACAAKAIcIBZqNgIcIAAgACgCICASIAZqQQ13IARzIgkgGCAOakESdyARcyIGIAtqQQd3cyIKIAZqQQl3IBVzIgRqNgIgIAAgACgCJCAEIApqQQ13IAtzIgtqNgIkIAAgACgCKCALIARqQRJ3IAZzajYCKCAAIAAoAiwgCmo2AiwgACAAKAIwIAkgEmpBEncgEHMiBiACakEHdyAUcyILajYCMCAAIAAoAjQgCyAGakEJdyATcyIKajYCNCAAIAAoAjggCiALakENdyACcyICajYCOCAAIAAoAjwgAiAKakESdyAGc2o2AjwLvxIDFX8Bfg5/AkAgAkUNACAAQQd0IgNBQGoiBEEAKAKACCIFIAMgAmwiBmogAyABbGoiByADaiIIaiEJIAAgAkEHdCIKIAFBB3RqIgtsIQwgACALQYABamwhDSAAQQV0IgtBASALQQFLGyILQWBxIQ4gC0EBcSEPIAdBeGohECAHQXBqIREgB0FoaiESIAdBYGohEyAHQVhqIRQgB0FQaiEVIAdBSGohFiAHQUBqIRcgAa1Cf3whGCAEIAdqIRkgByAAQQh0IhpqIRsgACAKQYABamwhHCALQQRJIR1BACEeQQAhHwNAQQAoAoAIIiAgAyAfbGohIQJAIABFDQBBACEiAkAgHQ0AICAgHmohI0EAIQtBACEiA0AgByALaiIEICMgC2oiJCgCADYCACAEQQRqICRBBGooAgA2AgAgBEEIaiAkQQhqKAIANgIAIARBDGogJEEMaigCADYCACALQRBqIQsgDiAiQQRqIiJHDQALCyAPRQ0AIAcgIkECdCILaiAhIAtqKAIANgIACwJAIAFFDQBBACElIBwhIyAGISYDQCAFISQgACEiAkACQCAADQAgGyAXKQMANwMAIBsgFikDADcDCCAbIBUpAwA3AxAgGyAUKQMANwMYIBsgEykDADcDICAbIBIpAwA3AyggGyARKQMANwMwIBsgECkDADcDOAwBCwNAICQgJmoiCyAkIAxqIgQpAwA3AwAgC0EIaiAEQQhqKQMANwMAIAtBEGogBEEQaikDADcDACALQRhqIARBGGopAwA3AwAgC0EgaiAEQSBqKQMANwMAIAtBKGogBEEoaikDADcDACALQTBqIARBMGopAwA3AwAgC0E4aiAEQThqKQMANwMAIAtBwABqIARBwABqKQMANwMAIAtByABqIARByABqKQMANwMAIAtB0ABqIARB0ABqKQMANwMAIAtB2ABqIARB2ABqKQMANwMAIAtB4ABqIARB4ABqKQMANwMAIAtB6ABqIARB6ABqKQMANwMAIAtB8ABqIARB8ABqKQMANwMAIAtB+ABqIARB+ABqKQMANwMAICRBgAFqISQgIkF/aiIiDQALIAcgCCAbIAAQAiAFISQgACEiA0AgJCAjaiILICQgDWoiBCkDADcDACALQQhqIARBCGopAwA3AwAgC0EQaiAEQRBqKQMANwMAIAtBGGogBEEYaikDADcDACALQSBqIARBIGopAwA3AwAgC0EoaiAEQShqKQMANwMAIAtBMGogBEEwaikDADcDACALQThqIARBOGopAwA3AwAgC0HAAGogBEHAAGopAwA3AwAgC0HIAGogBEHIAGopAwA3AwAgC0HQAGogBEHQAGopAwA3AwAgC0HYAGogBEHYAGopAwA3AwAgC0HgAGogBEHgAGopAwA3AwAgC0HoAGogBEHoAGopAwA3AwAgC0HwAGogBEHwAGopAwA3AwAgC0H4AGogBEH4AGopAwA3AwAgJEGAAWohJCAiQX9qIiINAAsLIAggByAbIAAQAiAjIBpqISMgJiAaaiEmICVBAmoiJSABSQ0AC0EAISUDQAJAAkAgAA0AIBsgFykDADcDACAbIBYpAwA3AwggGyAVKQMANwMQIBsgFCkDADcDGCAbIBMpAwA3AyAgGyASKQMANwMoIBsgESkDADcDMCAbIBApAwA3AzgMAQsgACAKIBkpAgAgGIOnQQd0amwhJiAFISQgACEiA0AgJCAMaiILIAspAwAgJCAmaiIEKQMAhTcDACALQQhqIiMgIykDACAEQQhqKQMAhTcDACALQRBqIiMgIykDACAEQRBqKQMAhTcDACALQRhqIiMgIykDACAEQRhqKQMAhTcDACALQSBqIiMgIykDACAEQSBqKQMAhTcDACALQShqIiMgIykDACAEQShqKQMAhTcDACALQTBqIiMgIykDACAEQTBqKQMAhTcDACALQThqIiMgIykDACAEQThqKQMAhTcDACALQcAAaiIjICMpAwAgBEHAAGopAwCFNwMAIAtByABqIiMgIykDACAEQcgAaikDAIU3AwAgC0HQAGoiIyAjKQMAIARB0ABqKQMAhTcDACALQdgAaiIjICMpAwAgBEHYAGopAwCFNwMAIAtB4ABqIiMgIykDACAEQeAAaikDAIU3AwAgC0HoAGoiIyAjKQMAIARB6ABqKQMAhTcDACALQfAAaiIjICMpAwAgBEHwAGopAwCFNwMAIAtB+ABqIgsgCykDACAEQfgAaikDAIU3AwAgJEGAAWohJCAiQX9qIiINAAsgByAIIBsgABACIAAgCiAJKQIAIBiDp0EHdGpsISYgBSEkIAAhIgNAICQgDWoiCyALKQMAICQgJmoiBCkDAIU3AwAgC0EIaiIjICMpAwAgBEEIaikDAIU3AwAgC0EQaiIjICMpAwAgBEEQaikDAIU3AwAgC0EYaiIjICMpAwAgBEEYaikDAIU3AwAgC0EgaiIjICMpAwAgBEEgaikDAIU3AwAgC0EoaiIjICMpAwAgBEEoaikDAIU3AwAgC0EwaiIjICMpAwAgBEEwaikDAIU3AwAgC0E4aiIjICMpAwAgBEE4aikDAIU3AwAgC0HAAGoiIyAjKQMAIARBwABqKQMAhTcDACALQcgAaiIjICMpAwAgBEHIAGopAwCFNwMAIAtB0ABqIiMgIykDACAEQdAAaikDAIU3AwAgC0HYAGoiIyAjKQMAIARB2ABqKQMAhTcDACALQeAAaiIjICMpAwAgBEHgAGopAwCFNwMAIAtB6ABqIiMgIykDACAEQegAaikDAIU3AwAgC0HwAGoiIyAjKQMAIARB8ABqKQMAhTcDACALQfgAaiILIAspAwAgBEH4AGopAwCFNwMAICRBgAFqISQgIkF/aiIiDQALCyAIIAcgGyAAEAIgJUECaiIlIAFJDQALCwJAIABFDQBBACEiAkAgHQ0AICAgHmohI0EAIQtBACEiA0AgIyALaiIEIAcgC2oiJCgCADYCACAEQQRqICRBBGooAgA2AgAgBEEIaiAkQQhqKAIANgIAIARBDGogJEEMaigCADYCACALQRBqIQsgDiAiQQRqIiJHDQALCyAPRQ0AICEgIkECdCILaiAHIAtqKAIANgIACyAeIANqIR4gH0EBaiIfIAJHDQALCws=";
    hash$3 = "b32721f8";
    wasmJson$3 = {
      name: name$3,
      data: data$3,
      hash: hash$3
    };
    isPowerOfTwo = (v9) => v9 && !(v9 & v9 - 1);
    validateOptions$1 = (options) => {
      if (!options || typeof options !== "object") {
        throw new Error("Invalid options parameter. It requires an object.");
      }
      if (!Number.isInteger(options.blockSize) || options.blockSize < 1) {
        throw new Error("Block size should be a positive number");
      }
      if (!Number.isInteger(options.costFactor) || options.costFactor < 2 || !isPowerOfTwo(options.costFactor)) {
        throw new Error("Cost factor should be a power of 2, greater than 1");
      }
      if (!Number.isInteger(options.parallelism) || options.parallelism < 1) {
        throw new Error("Parallelism should be a positive number");
      }
      if (!Number.isInteger(options.hashLength) || options.hashLength < 1) {
        throw new Error("Hash length should be a positive number.");
      }
      if (options.outputType === void 0) {
        options.outputType = "hex";
      }
      if (!["hex", "binary"].includes(options.outputType)) {
        throw new Error(`Insupported output type ${options.outputType}. Valid values: ['hex', 'binary']`);
      }
    };
    name$2 = "bcrypt";
    data$2 = "AGFzbQEAAAABFwRgAAF/YAR/f39/AGADf39/AGABfwF/AwUEAAECAwUEAQECAgYIAX8BQZCrBQsHNAQGbWVtb3J5AgAOSGFzaF9HZXRCdWZmZXIAAAZiY3J5cHQAAg1iY3J5cHRfdmVyaWZ5AAMK9WAEBQBBgCsL21kEFH8Bfgh/AX4jAEHwAGshBCACQQA6AAIgAkGq4AA7AAACQCABLQAAQSpHDQAgAS0AAUEwRw0AIAJBMToAAQsCQCABLAAFIAEsAARBCmxqQfB7aiIFQQRJDQAgAS0AB0FgaiIGQd8ASw0AIAZBkAlqLQAAIgZBP0sNACABLQAIQWBqIgdB3wBLDQAgB0GQCWotAAAiB0E/Sw0AIAQgB0EEdiAGQQJ0cjoACCABLQAJQWBqIgZB3wBLDQAgBkGQCWotAAAiBkE/Sw0AIAQgBkECdiAHQQR0cjoACSABLQAKQWBqIgdB3wBLDQAgB0GQCWotAAAiB0E/Sw0AIAQgByAGQQZ0cjoACiABLQALQWBqIgZB3wBLDQAgBkGQCWotAAAiBkE/Sw0AIAEtAAxBYGoiB0HfAEsNACAHQZAJai0AACIHQT9LDQAgBCAHQQR2IAZBAnRyOgALIAEtAA1BYGoiBkHfAEsNACAGQZAJai0AACIGQT9LDQAgBCAGQQJ2IAdBBHRyOgAMIAEtAA5BYGoiB0HfAEsNACAHQZAJai0AACIHQT9LDQAgBCAHIAZBBnRyOgANIAEtAA9BYGoiBkHfAEsNACAGQZAJai0AACIGQT9LDQAgAS0AEEFgaiIHQd8ASw0AIAdBkAlqLQAAIgdBP0sNACAEIAdBBHYgBkECdHI6AA4gAS0AEUFgaiIGQd8ASw0AIAZBkAlqLQAAIgZBP0sNACAEIAZBAnYgB0EEdHI6AA8gAS0AEkFgaiIHQd8ASw0AIAdBkAlqLQAAIgdBP0sNACAEIAcgBkEGdHI6ABAgAS0AE0FgaiIGQd8ASw0AIAZBkAlqLQAAIgZBP0sNACABLQAUQWBqIgdB3wBLDQAgB0GQCWotAAAiB0E/Sw0AIAQgB0EEdiAGQQJ0cjoAESABLQAVQWBqIgZB3wBLDQAgBkGQCWotAAAiBkE/Sw0AIAQgBkECdiAHQQR0cjoAEiABLQAWQWBqIgdB3wBLDQAgB0GQCWotAAAiB0E/Sw0AIAQgByAGQQZ0cjoAEyABLQAXQWBqIgZB3wBLDQAgBkGQCWotAAAiBkE/Sw0AIAEtABhBYGoiB0HfAEsNACAHQZAJai0AACIHQT9LDQAgBCAHQQR2IAZBAnRyOgAUIAEtABlBYGoiBkHfAEsNACAGQZAJai0AACIGQT9LDQAgBCAGQQJ2IAdBBHRyOgAVIAEtABpBYGoiB0HfAEsNACAHQZAJai0AACIHQT9LDQAgBCAHIAZBBnRyOgAWIAEtABtBYGoiBkHfAEsNACAGQZAJai0AACIGQT9LDQAgAS0AHEFgaiIHQd8ASw0AIAdBkAlqLQAAIgdBP0sNAEEBIAV0IQggBCAHQQR2IAZBAnRyOgAXIAQgBCgCCCIFQRh0IAVBgP4DcUEIdHIgBUEIdkGA/gNxIAVBGHZyciIJNgIIIAQgBCgCDCIFQRh0IAVBgP4DcUEIdHIgBUEIdkGA/gNxIAVBGHZyciIKNgIMIAQgBCgCECIFQRh0IAVBgP4DcUEIdHIgBUEIdkGA/gNxIAVBGHZyciILNgIQIAQgBCgCFCIFQRh0IAVBgP4DcUEIdHIgBUEIdkGA/gNxIAVBGHZyciIMNgIUIARB6ABqIAEtAAJBnwdqLQAAIg1BAXFBAnRqIQ5BACEGQQAhB0EAIQ8gACEFA0AgBEIANwJoIAQgBS0AACIQNgJoIAQgBSwAACIRNgJsIAUtAAAhEiAEIBBBCHQiEDYCaCAEIBAgBUEBaiAAIBIbIgUtAAByIhA2AmggBCARQQh0IhE2AmwgBCARIAUsAAAiEnIiETYCbCAFLQAAIRMgBCAQQQh0IhA2AmggBCAQIAVBAWogACATGyIFLQAAciIQNgJoIAQgEUEIdCIRNgJsIAQgESAFLAAAIhNyIhE2AmwgBS0AACEUIAQgEEEIdCIQNgJoIAQgECAFQQFqIAAgFBsiBS0AAHIiEDYCaCAEIBFBCHQiETYCbCAEIBEgBSwAACIUciIRNgJsIAUtAAAhFSAEQSBqIAZqIA4oAgAiFjYCACAGQfApaiIXIBYgFygCAHM2AgAgESAQcyAHciEHIAVBAWogACAVGyEFIBQgEyAScnJBgAFxIA9yIQ8gBkEEaiIGQcgARw0AC0EAQQAoAvApIA9BCXQgDUEPdHFBgIAEIAdB//8DcSAHQRB2cmtxczYC8ClCACEYQX4hBkHwKSEHA0BBACgCrCpBACgCqCpBACgCpCpBACgCoCpBACgCnCpBACgCmCpBACgClCpBACgCkCpBACgCjCpBACgCiCpBACgChCpBACgCgCpBACgC/ClBACgC+ClBACgC9CkgBEEIaiAGQQJqIgZBAnFBAnRqKQMAIBiFIhhCIIinc0EAKALwKSAYp3MiAEEWdkH8B3FB8AlqKAIAIABBDnZB/AdxQfARaigCAGogAEEGdkH8B3FB8BlqKAIAcyAAQf8BcUECdEHwIWooAgBqcyIFQRZ2QfwHcUHwCWooAgAgBUEOdkH8B3FB8BFqKAIAaiAFQQZ2QfwHcUHwGWooAgBzIAVB/wFxQQJ0QfAhaigCAGpzIABzIgBBFnZB/AdxQfAJaigCACAAQQ52QfwHcUHwEWooAgBqIABBBnZB/AdxQfAZaigCAHMgAEH/AXFBAnRB8CFqKAIAanMgBXMiBUEWdkH8B3FB8AlqKAIAIAVBDnZB/AdxQfARaigCAGogBUEGdkH8B3FB8BlqKAIAcyAFQf8BcUECdEHwIWooAgBqcyAAcyIAQRZ2QfwHcUHwCWooAgAgAEEOdkH8B3FB8BFqKAIAaiAAQQZ2QfwHcUHwGWooAgBzIABB/wFxQQJ0QfAhaigCAGpzIAVzIgVBFnZB/AdxQfAJaigCACAFQQ52QfwHcUHwEWooAgBqIAVBBnZB/AdxQfAZaigCAHMgBUH/AXFBAnRB8CFqKAIAanMgAHMiAEEWdkH8B3FB8AlqKAIAIABBDnZB/AdxQfARaigCAGogAEEGdkH8B3FB8BlqKAIAcyAAQf8BcUECdEHwIWooAgBqcyAFcyIFQRZ2QfwHcUHwCWooAgAgBUEOdkH8B3FB8BFqKAIAaiAFQQZ2QfwHcUHwGWooAgBzIAVB/wFxQQJ0QfAhaigCAGpzIABzIgBBFnZB/AdxQfAJaigCACAAQQ52QfwHcUHwEWooAgBqIABBBnZB/AdxQfAZaigCAHMgAEH/AXFBAnRB8CFqKAIAanMgBXMiBUEWdkH8B3FB8AlqKAIAIAVBDnZB/AdxQfARaigCAGogBUEGdkH8B3FB8BlqKAIAcyAFQf8BcUECdEHwIWooAgBqcyAAcyIAQRZ2QfwHcUHwCWooAgAgAEEOdkH8B3FB8BFqKAIAaiAAQQZ2QfwHcUHwGWooAgBzIABB/wFxQQJ0QfAhaigCAGpzIAVzIgVBFnZB/AdxQfAJaigCACAFQQ52QfwHcUHwEWooAgBqIAVBBnZB/AdxQfAZaigCAHMgBUH/AXFBAnRB8CFqKAIAanMgAHMiAEEWdkH8B3FB8AlqKAIAIABBDnZB/AdxQfARaigCAGogAEEGdkH8B3FB8BlqKAIAcyAAQf8BcUECdEHwIWooAgBqcyAFcyIFQRZ2QfwHcUHwCWooAgAgBUEOdkH8B3FB8BFqKAIAaiAFQQZ2QfwHcUHwGWooAgBzIAVB/wFxQQJ0QfAhaigCAGpzIABzIgBBFnZB/AdxQfAJaigCACAAQQ52QfwHcUHwEWooAgBqIABBBnZB/AdxQfAZaigCAHMgAEH/AXFBAnRB8CFqKAIAanMgBXMiBUH/AXFBAnRB8CFqKAIAIQ8gBUEGdkH8B3FB8BlqKAIAIRAgBUEWdkH8B3FB8AlqKAIAIREgBUEOdkH8B3FB8BFqKAIAIRJBACgCsCohE0EAQQAoArQqIAVzNgKAqwFBACATIA8gECARIBJqc2pzIABzNgKEqwEgB0EAKQOAqwEiGDcCACAHQQhqIQcgBkEQSQ0ACyAYQiCIpyEFIBinIQZB8AkhAANAQQAoAqwqQQAoAqgqQQAoAqQqQQAoAqAqQQAoApwqQQAoApgqQQAoApQqQQAoApAqQQAoAowqQQAoAogqQQAoAoQqQQAoAoAqQQAoAvwpQQAoAvgpIAVBACgC9ClzIAZBACgC8ClzIAtzIgVBFnZB/AdxQfAJaigCACAFQQ52QfwHcUHwEWooAgBqIAVBBnZB/AdxQfAZaigCAHMgBUH/AXFBAnRB8CFqKAIAanMgDHMiBkEWdkH8B3FB8AlqKAIAIAZBDnZB/AdxQfARaigCAGogBkEGdkH8B3FB8BlqKAIAcyAGQf8BcUECdEHwIWooAgBqcyAFcyIFQRZ2QfwHcUHwCWooAgAgBUEOdkH8B3FB8BFqKAIAaiAFQQZ2QfwHcUHwGWooAgBzIAVB/wFxQQJ0QfAhaigCAGpzIAZzIgZBFnZB/AdxQfAJaigCACAGQQ52QfwHcUHwEWooAgBqIAZBBnZB/AdxQfAZaigCAHMgBkH/AXFBAnRB8CFqKAIAanMgBXMiBUEWdkH8B3FB8AlqKAIAIAVBDnZB/AdxQfARaigCAGogBUEGdkH8B3FB8BlqKAIAcyAFQf8BcUECdEHwIWooAgBqcyAGcyIGQRZ2QfwHcUHwCWooAgAgBkEOdkH8B3FB8BFqKAIAaiAGQQZ2QfwHcUHwGWooAgBzIAZB/wFxQQJ0QfAhaigCAGpzIAVzIgVBFnZB/AdxQfAJaigCACAFQQ52QfwHcUHwEWooAgBqIAVBBnZB/AdxQfAZaigCAHMgBUH/AXFBAnRB8CFqKAIAanMgBnMiBkEWdkH8B3FB8AlqKAIAIAZBDnZB/AdxQfARaigCAGogBkEGdkH8B3FB8BlqKAIAcyAGQf8BcUECdEHwIWooAgBqcyAFcyIFQRZ2QfwHcUHwCWooAgAgBUEOdkH8B3FB8BFqKAIAaiAFQQZ2QfwHcUHwGWooAgBzIAVB/wFxQQJ0QfAhaigCAGpzIAZzIgZBFnZB/AdxQfAJaigCACAGQQ52QfwHcUHwEWooAgBqIAZBBnZB/AdxQfAZaigCAHMgBkH/AXFBAnRB8CFqKAIAanMgBXMiBUEWdkH8B3FB8AlqKAIAIAVBDnZB/AdxQfARaigCAGogBUEGdkH8B3FB8BlqKAIAcyAFQf8BcUECdEHwIWooAgBqcyAGcyIGQRZ2QfwHcUHwCWooAgAgBkEOdkH8B3FB8BFqKAIAaiAGQQZ2QfwHcUHwGWooAgBzIAZB/wFxQQJ0QfAhaigCAGpzIAVzIgVBFnZB/AdxQfAJaigCACAFQQ52QfwHcUHwEWooAgBqIAVBBnZB/AdxQfAZaigCAHMgBUH/AXFBAnRB8CFqKAIAanMgBnMiBkEWdkH8B3FB8AlqKAIAIAZBDnZB/AdxQfARaigCAGogBkEGdkH8B3FB8BlqKAIAcyAGQf8BcUECdEHwIWooAgBqcyAFcyIFQRZ2QfwHcUHwCWooAgAgBUEOdkH8B3FB8BFqKAIAaiAFQQZ2QfwHcUHwGWooAgBzIAVB/wFxQQJ0QfAhaigCAGpzIAZzIgZB/wFxQQJ0QfAhaigCACEHIAZBBnZB/AdxQfAZaigCACEPIAZBFnZB/AdxQfAJaigCACEQIAZBDnZB/AdxQfARaigCACERQQAoArAqIRIgAEEAKAK0KiAGcyIGNgIAIABBBGogEiAHIA8gECARanNqcyAFcyIHNgIAQQAoAqwqQQAoAqgqQQAoAqQqQQAoAqAqQQAoApwqQQAoApgqQQAoApQqQQAoApAqQQAoAowqQQAoAogqQQAoAoQqQQAoAoAqQQAoAvwpQQAoAvgpQQAoAvQpIAlBACgC8ClzIAZzIgVBFnZB/AdxQfAJaigCACAFQQ52QfwHcUHwEWooAgBqIAVBBnZB/AdxQfAZaigCAHMgBUH/AXFBAnRB8CFqKAIAanMgCnMgB3MiBkEWdkH8B3FB8AlqKAIAIAZBDnZB/AdxQfARaigCAGogBkEGdkH8B3FB8BlqKAIAcyAGQf8BcUECdEHwIWooAgBqcyAFcyIFQRZ2QfwHcUHwCWooAgAgBUEOdkH8B3FB8BFqKAIAaiAFQQZ2QfwHcUHwGWooAgBzIAVB/wFxQQJ0QfAhaigCAGpzIAZzIgZBFnZB/AdxQfAJaigCACAGQQ52QfwHcUHwEWooAgBqIAZBBnZB/AdxQfAZaigCAHMgBkH/AXFBAnRB8CFqKAIAanMgBXMiBUEWdkH8B3FB8AlqKAIAIAVBDnZB/AdxQfARaigCAGogBUEGdkH8B3FB8BlqKAIAcyAFQf8BcUECdEHwIWooAgBqcyAGcyIGQRZ2QfwHcUHwCWooAgAgBkEOdkH8B3FB8BFqKAIAaiAGQQZ2QfwHcUHwGWooAgBzIAZB/wFxQQJ0QfAhaigCAGpzIAVzIgVBFnZB/AdxQfAJaigCACAFQQ52QfwHcUHwEWooAgBqIAVBBnZB/AdxQfAZaigCAHMgBUH/AXFBAnRB8CFqKAIAanMgBnMiBkEWdkH8B3FB8AlqKAIAIAZBDnZB/AdxQfARaigCAGogBkEGdkH8B3FB8BlqKAIAcyAGQf8BcUECdEHwIWooAgBqcyAFcyIFQRZ2QfwHcUHwCWooAgAgBUEOdkH8B3FB8BFqKAIAaiAFQQZ2QfwHcUHwGWooAgBzIAVB/wFxQQJ0QfAhaigCAGpzIAZzIgZBFnZB/AdxQfAJaigCACAGQQ52QfwHcUHwEWooAgBqIAZBBnZB/AdxQfAZaigCAHMgBkH/AXFBAnRB8CFqKAIAanMgBXMiBUEWdkH8B3FB8AlqKAIAIAVBDnZB/AdxQfARaigCAGogBUEGdkH8B3FB8BlqKAIAcyAFQf8BcUECdEHwIWooAgBqcyAGcyIGQRZ2QfwHcUHwCWooAgAgBkEOdkH8B3FB8BFqKAIAaiAGQQZ2QfwHcUHwGWooAgBzIAZB/wFxQQJ0QfAhaigCAGpzIAVzIgVBFnZB/AdxQfAJaigCACAFQQ52QfwHcUHwEWooAgBqIAVBBnZB/AdxQfAZaigCAHMgBUH/AXFBAnRB8CFqKAIAanMgBnMiBkEWdkH8B3FB8AlqKAIAIAZBDnZB/AdxQfARaigCAGogBkEGdkH8B3FB8BlqKAIAcyAGQf8BcUECdEHwIWooAgBqcyAFcyIFQRZ2QfwHcUHwCWooAgAgBUEOdkH8B3FB8BFqKAIAaiAFQQZ2QfwHcUHwGWooAgBzIAVB/wFxQQJ0QfAhaigCAGpzIAZzIgZB/wFxQQJ0QfAhaigCACEHIAZBBnZB/AdxQfAZaigCACEPIAZBFnZB/AdxQfAJaigCACEQIAZBDnZB/AdxQfARaigCACERQQAoArAqIRIgAEEIakEAKAK0KiAGcyIGNgIAIABBDGogEiAHIA8gECARanNqcyAFcyIFNgIAIABBEGoiAEHsKUkNAAtBACAFNgKEqwFBACAGNgKAqwEgBCgCZCEUIAQoAmAhFSAEKAJcIRYgBCgCWCEXIAQoAlQhCSAEKAJQIQogBCgCTCELIAQoAkghDCAEKAJEIQ4gBCgCQCENIAQoAjwhGSAEKAI4IRogBCgCNCEbIAQoAjAhHCAEKAIsIR0gBCgCKCEeIAQoAiQhHyAEKAIgISAgBCkDECEhIAQpAwghGANAQQBBACgC8CkgIHM2AvApQQBBACgC9CkgH3M2AvQpQQBBACgC+CkgHnM2AvgpQQBBACgC/CkgHXM2AvwpQQBBACgCgCogHHM2AoAqQQBBACgChCogG3M2AoQqQQBBACgCiCogGnM2AogqQQBBACgCjCogGXM2AowqQQBBACgCkCogDXM2ApAqQQBBACgClCogDnM2ApQqQQBBACgCmCogDHM2ApgqQQBBACgCnCogC3M2ApwqQQBBACgCoCogCnM2AqAqQQBBACgCpCogCXM2AqQqQQBBACgCqCogF3M2AqgqQQBBACgCrCogFnM2AqwqQQBBACgCsCogFXM2ArAqQQBBACgCtCogFHM2ArQqQQEhEwNAQQAhAEEAQgA3A4CrAUHwKSEGQQAhBQNAQQAoAqwqQQAoAqgqQQAoAqQqQQAoAqAqQQAoApwqQQAoApgqQQAoApQqQQAoApAqQQAoAowqQQAoAogqQQAoAoQqQQAoAoAqQQAoAvwpQQAoAvgpQQAoAvQpIABzQQAoAvApIAVzIgBBFnZB/AdxQfAJaigCACAAQQ52QfwHcUHwEWooAgBqIABBBnZB/AdxQfAZaigCAHMgAEH/AXFBAnRB8CFqKAIAanMiBUEWdkH8B3FB8AlqKAIAIAVBDnZB/AdxQfARaigCAGogBUEGdkH8B3FB8BlqKAIAcyAFQf8BcUECdEHwIWooAgBqcyAAcyIAQRZ2QfwHcUHwCWooAgAgAEEOdkH8B3FB8BFqKAIAaiAAQQZ2QfwHcUHwGWooAgBzIABB/wFxQQJ0QfAhaigCAGpzIAVzIgVBFnZB/AdxQfAJaigCACAFQQ52QfwHcUHwEWooAgBqIAVBBnZB/AdxQfAZaigCAHMgBUH/AXFBAnRB8CFqKAIAanMgAHMiAEEWdkH8B3FB8AlqKAIAIABBDnZB/AdxQfARaigCAGogAEEGdkH8B3FB8BlqKAIAcyAAQf8BcUECdEHwIWooAgBqcyAFcyIFQRZ2QfwHcUHwCWooAgAgBUEOdkH8B3FB8BFqKAIAaiAFQQZ2QfwHcUHwGWooAgBzIAVB/wFxQQJ0QfAhaigCAGpzIABzIgBBFnZB/AdxQfAJaigCACAAQQ52QfwHcUHwEWooAgBqIABBBnZB/AdxQfAZaigCAHMgAEH/AXFBAnRB8CFqKAIAanMgBXMiBUEWdkH8B3FB8AlqKAIAIAVBDnZB/AdxQfARaigCAGogBUEGdkH8B3FB8BlqKAIAcyAFQf8BcUECdEHwIWooAgBqcyAAcyIAQRZ2QfwHcUHwCWooAgAgAEEOdkH8B3FB8BFqKAIAaiAAQQZ2QfwHcUHwGWooAgBzIABB/wFxQQJ0QfAhaigCAGpzIAVzIgVBFnZB/AdxQfAJaigCACAFQQ52QfwHcUHwEWooAgBqIAVBBnZB/AdxQfAZaigCAHMgBUH/AXFBAnRB8CFqKAIAanMgAHMiAEEWdkH8B3FB8AlqKAIAIABBDnZB/AdxQfARaigCAGogAEEGdkH8B3FB8BlqKAIAcyAAQf8BcUECdEHwIWooAgBqcyAFcyIFQRZ2QfwHcUHwCWooAgAgBUEOdkH8B3FB8BFqKAIAaiAFQQZ2QfwHcUHwGWooAgBzIAVB/wFxQQJ0QfAhaigCAGpzIABzIgBBFnZB/AdxQfAJaigCACAAQQ52QfwHcUHwEWooAgBqIABBBnZB/AdxQfAZaigCAHMgAEH/AXFBAnRB8CFqKAIAanMgBXMiBUEWdkH8B3FB8AlqKAIAIAVBDnZB/AdxQfARaigCAGogBUEGdkH8B3FB8BlqKAIAcyAFQf8BcUECdEHwIWooAgBqcyAAcyIAQRZ2QfwHcUHwCWooAgAgAEEOdkH8B3FB8BFqKAIAaiAAQQZ2QfwHcUHwGWooAgBzIABB/wFxQQJ0QfAhaigCAGpzIAVzIgVB/wFxQQJ0QfAhaigCACEHIAVBBnZB/AdxQfAZaigCACEPIAVBFnZB/AdxQfAJaigCACEQIAVBDnZB/AdxQfARaigCACERQQAoArAqIRIgBkEAKAK0KiAFcyIFNgIAIAZBBGogEiAHIA8gECARanNqcyAAcyIANgIAIAZBCGoiBkG4KkkNAAtB8AkhBgNAQQAoAqwqQQAoAqgqQQAoAqQqQQAoAqAqQQAoApwqQQAoApgqQQAoApQqQQAoApAqQQAoAowqQQAoAogqQQAoAoQqQQAoAoAqQQAoAvwpQQAoAvgpQQAoAvQpIABzQQAoAvApIAVzIgBBFnZB/AdxQfAJaigCACAAQQ52QfwHcUHwEWooAgBqIABBBnZB/AdxQfAZaigCAHMgAEH/AXFBAnRB8CFqKAIAanMiBUEWdkH8B3FB8AlqKAIAIAVBDnZB/AdxQfARaigCAGogBUEGdkH8B3FB8BlqKAIAcyAFQf8BcUECdEHwIWooAgBqcyAAcyIAQRZ2QfwHcUHwCWooAgAgAEEOdkH8B3FB8BFqKAIAaiAAQQZ2QfwHcUHwGWooAgBzIABB/wFxQQJ0QfAhaigCAGpzIAVzIgVBFnZB/AdxQfAJaigCACAFQQ52QfwHcUHwEWooAgBqIAVBBnZB/AdxQfAZaigCAHMgBUH/AXFBAnRB8CFqKAIAanMgAHMiAEEWdkH8B3FB8AlqKAIAIABBDnZB/AdxQfARaigCAGogAEEGdkH8B3FB8BlqKAIAcyAAQf8BcUECdEHwIWooAgBqcyAFcyIFQRZ2QfwHcUHwCWooAgAgBUEOdkH8B3FB8BFqKAIAaiAFQQZ2QfwHcUHwGWooAgBzIAVB/wFxQQJ0QfAhaigCAGpzIABzIgBBFnZB/AdxQfAJaigCACAAQQ52QfwHcUHwEWooAgBqIABBBnZB/AdxQfAZaigCAHMgAEH/AXFBAnRB8CFqKAIAanMgBXMiBUEWdkH8B3FB8AlqKAIAIAVBDnZB/AdxQfARaigCAGogBUEGdkH8B3FB8BlqKAIAcyAFQf8BcUECdEHwIWooAgBqcyAAcyIAQRZ2QfwHcUHwCWooAgAgAEEOdkH8B3FB8BFqKAIAaiAAQQZ2QfwHcUHwGWooAgBzIABB/wFxQQJ0QfAhaigCAGpzIAVzIgVBFnZB/AdxQfAJaigCACAFQQ52QfwHcUHwEWooAgBqIAVBBnZB/AdxQfAZaigCAHMgBUH/AXFBAnRB8CFqKAIAanMgAHMiAEEWdkH8B3FB8AlqKAIAIABBDnZB/AdxQfARaigCAGogAEEGdkH8B3FB8BlqKAIAcyAAQf8BcUECdEHwIWooAgBqcyAFcyIFQRZ2QfwHcUHwCWooAgAgBUEOdkH8B3FB8BFqKAIAaiAFQQZ2QfwHcUHwGWooAgBzIAVB/wFxQQJ0QfAhaigCAGpzIABzIgBBFnZB/AdxQfAJaigCACAAQQ52QfwHcUHwEWooAgBqIABBBnZB/AdxQfAZaigCAHMgAEH/AXFBAnRB8CFqKAIAanMgBXMiBUEWdkH8B3FB8AlqKAIAIAVBDnZB/AdxQfARaigCAGogBUEGdkH8B3FB8BlqKAIAcyAFQf8BcUECdEHwIWooAgBqcyAAcyIAQRZ2QfwHcUHwCWooAgAgAEEOdkH8B3FB8BFqKAIAaiAAQQZ2QfwHcUHwGWooAgBzIABB/wFxQQJ0QfAhaigCAGpzIAVzIgVB/wFxQQJ0QfAhaigCACEHIAVBBnZB/AdxQfAZaigCACEPIAVBFnZB/AdxQfAJaigCACEQIAVBDnZB/AdxQfARaigCACERQQAoArAqIRIgBkEAKAK0KiAFcyIFNgIAIAZBBGogEiAHIA8gECARanNqcyAAcyIANgIAIAZBCGoiBkHsKUkNAAtBACAANgKEqwFBACAFNgKAqwECQCATQQFxRQ0AQQAhE0EAQQApAvApIBiFNwLwKUEAQQApAvgpICGFNwL4KUEAQQApAoAqIBiFNwKAKkEAQQApAogqICGFNwKIKkEAQQApApAqIBiFNwKQKkEAQQApApgqICGFNwKYKkEAQQApAqAqIBiFNwKgKkEAQQApAqgqICGFNwKoKkEAQQApArAqIBiFNwKwKgwBCwsgCEF/aiIIDQALQQAoArQqIQ9BACgCsCohEEEAKAKsKiERQQAoAqgqIRJBACgCpCohE0EAKAKgKiEIQQAoApwqIRRBACgCmCohFUEAKAKUKiEWQQAoApAqIRdBACgCjCohCUEAKAKIKiEKQQAoAoQqIQtBACgCgCohDEEAKAL8KSEOQQAoAvgpIQ1BACgC9CkhGUEAKALwKSEaQQAhGwNAIBtBAnQiHEGgCGopAwAiGKchACAYQiCIpyEGQUAhBwNAIBAgESASIBMgCCAUIBUgFiAXIAkgCiALIAwgDiANIAYgGXMgACAacyIAQRZ2QfwHcUHwCWooAgAgAEEOdkH8B3FB8BFqKAIAaiAAQQZ2QfwHcUHwGWooAgBzIABB/wFxQQJ0QfAhaigCAGpzIgVBFnZB/AdxQfAJaigCACAFQQ52QfwHcUHwEWooAgBqIAVBBnZB/AdxQfAZaigCAHMgBUH/AXFBAnRB8CFqKAIAanMgAHMiAEEWdkH8B3FB8AlqKAIAIABBDnZB/AdxQfARaigCAGogAEEGdkH8B3FB8BlqKAIAcyAAQf8BcUECdEHwIWooAgBqcyAFcyIFQRZ2QfwHcUHwCWooAgAgBUEOdkH8B3FB8BFqKAIAaiAFQQZ2QfwHcUHwGWooAgBzIAVB/wFxQQJ0QfAhaigCAGpzIABzIgBBFnZB/AdxQfAJaigCACAAQQ52QfwHcUHwEWooAgBqIABBBnZB/AdxQfAZaigCAHMgAEH/AXFBAnRB8CFqKAIAanMgBXMiBUEWdkH8B3FB8AlqKAIAIAVBDnZB/AdxQfARaigCAGogBUEGdkH8B3FB8BlqKAIAcyAFQf8BcUECdEHwIWooAgBqcyAAcyIAQRZ2QfwHcUHwCWooAgAgAEEOdkH8B3FB8BFqKAIAaiAAQQZ2QfwHcUHwGWooAgBzIABB/wFxQQJ0QfAhaigCAGpzIAVzIgVBFnZB/AdxQfAJaigCACAFQQ52QfwHcUHwEWooAgBqIAVBBnZB/AdxQfAZaigCAHMgBUH/AXFBAnRB8CFqKAIAanMgAHMiAEEWdkH8B3FB8AlqKAIAIABBDnZB/AdxQfARaigCAGogAEEGdkH8B3FB8BlqKAIAcyAAQf8BcUECdEHwIWooAgBqcyAFcyIFQRZ2QfwHcUHwCWooAgAgBUEOdkH8B3FB8BFqKAIAaiAFQQZ2QfwHcUHwGWooAgBzIAVB/wFxQQJ0QfAhaigCAGpzIABzIgBBFnZB/AdxQfAJaigCACAAQQ52QfwHcUHwEWooAgBqIABBBnZB/AdxQfAZaigCAHMgAEH/AXFBAnRB8CFqKAIAanMgBXMiBUEWdkH8B3FB8AlqKAIAIAVBDnZB/AdxQfARaigCAGogBUEGdkH8B3FB8BlqKAIAcyAFQf8BcUECdEHwIWooAgBqcyAAcyIAQRZ2QfwHcUHwCWooAgAgAEEOdkH8B3FB8BFqKAIAaiAAQQZ2QfwHcUHwGWooAgBzIABB/wFxQQJ0QfAhaigCAGpzIAVzIgVBFnZB/AdxQfAJaigCACAFQQ52QfwHcUHwEWooAgBqIAVBBnZB/AdxQfAZaigCAHMgBUH/AXFBAnRB8CFqKAIAanMgAHMiAEEWdkH8B3FB8AlqKAIAIABBDnZB/AdxQfARaigCAGogAEEGdkH8B3FB8BlqKAIAcyAAQf8BcUECdEHwIWooAgBqcyAFcyIFQRZ2QfwHcUHwCWooAgAgBUEOdkH8B3FB8BFqKAIAaiAFQQZ2QfwHcUHwGWooAgBzIAVB/wFxQQJ0QfAhaigCAGpzIABzIQYgBSAPcyEAIAdBAWoiBw0AC0EAIAY2AoSrAUEAIAA2AoCrASAEQQhqIBxqQQApA4CrATcDACAbQQRJIQAgG0ECaiEbIAANAAsgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASwAHEHwCGotAABBMHFBwAhqLQAAOgAcIAQgBCgCCCIBQRh0IAFBgP4DcUEIdHIgAUEIdkGA/gNxIAFBGHZyciIPNgIIIAQgBCgCDCIBQRh0IAFBgP4DcUEIdHIgAUEIdkGA/gNxIAFBGHZyciIBNgIMIAQgBCgCECIAQRh0IABBgP4DcUEIdHIgAEEIdkGA/gNxIABBGHZyciIANgIQIAQgBCgCFCIFQRh0IAVBgP4DcUEIdHIgBUEIdkGA/gNxIAVBGHZyciIGNgIUIAQgBCgCGCIFQRh0IAVBgP4DcUEIdHIgBUEIdkGA/gNxIAVBGHZyciIFNgIYIAQgBCgCHCIHQRh0IAdBgP4DcUEIdHIgB0EIdkGA/gNxIAdBGHZyciIHNgIcAkACQCADDQAgAiAEKQMINwMAIAIgBCkDEDcDCCACIAQpAxg3AxAMAQsgAiAHQT9xQcAIai0AADoAOCACIAZBGnZBwAhqLQAAOgAxIAIgAEE/cUHACGotAAA6ACggAiAPQRp2QcAIai0AADoAISACIAQtAAgiBEECdkHACGotAAA6AB0gAiAHQQ52QTxxQcAIai0AADoAOyACIAdBCnZBP3FBwAhqLQAAOgA5IAIgBUESdkE/cUHACGotAAA6ADUgAiAFQQh2QT9xQcAIai0AADoANCACIAZBEHYiA0E/cUHACGotAAA6ADAgAiAGQfwBcUECdkHACGotAAA6AC0gAiAAQRh2QT9xQcAIai0AADoALCACIABBCnZBP3FBwAhqLQAAOgApIAIgAUESdkE/cUHACGotAAA6ACUgAiABQQh2QT9xQcAIai0AADoAJCACIA9BEHYiEEE/cUHACGotAAA6ACAgAiAHQQZ2QQNxIAVBFnZBPHFyQcAIai0AADoANyACIAVBDHZBMHEgBUEcdnJBwAhqLQAAOgA2IAIgBUECdEE8cSAFQQ52QQNxckHACGotAAA6ADMgAiAFQfABcUEEdiAGQRR2QTBxckHACGotAAA6ADIgAiAGQQR0QTBxIAZBDHZBD3FyQcAIai0AADoALiACIABBDnZBPHEgAEEednJBwAhqLQAAOgArIAIgAEEGdkEDcSABQRZ2QTxxckHACGotAAA6ACcgAiABQQx2QTBxIAFBHHZyQcAIai0AADoAJiACIAFBAnRBPHEgAUEOdkEDcXJBwAhqLQAAOgAjIAIgAUHwAXFBBHYgD0EUdkEwcXJBwAhqLQAAOgAiIAIgBEEEdEEwcSAPQQx2QQ9xckHACGotAAA6AB4gAiAHQRB2QfABcSAHQYAGcXJBBHZBwAhqLQAAOgA6IAIgA0HAAXEgBkGAHnFyQQZ2QcAIai0AADoALyACIABBEHZB8AFxIABBgAZxckEEdkHACGotAAA6ACogAiAQQcABcSAPQYAecXJBBnZBwAhqLQAAOgAfCyACQQA6ADwLC4YGAQZ/IwBB4ABrIgMkAEEAIQQgAEGQK2pBADoAACADQSQ6AEYgAyABQQpuIgBBMGo6AEQgA0Gk5ISjAjYCQCADIABB9gFsIAFqQTByOgBFIANBAC0AgCsiAUECdkHACGotAAA6AEcgA0EALQCCKyIAQT9xQcAIai0AADoASiADQQAtAIMrIgVBAnZBwAhqLQAAOgBLIANBAC0AhSsiBkE/cUHACGotAAA6AE4gA0EALQCBKyIHQQR2IAFBBHRBMHFyQcAIai0AADoASCADIABBBnYgB0ECdEE8cXJBwAhqLQAAOgBJIANBAC0AhCsiAUEEdiAFQQR0QTBxckHACGotAAA6AEwgAyAGQQZ2IAFBAnRBPHFyQcAIai0AADoATSADQQAtAIYrIgFBAnZBwAhqLQAAOgBPIANBAC0AiCsiAEE/cUHACGotAAA6AFIgA0EALQCJKyIFQQJ2QcAIai0AADoAUyADQQAtAIsrIgZBP3FBwAhqLQAAOgBWIANBAC0AjCsiB0ECdkHACGotAAA6AFcgA0EALQCHKyIIQQR2IAFBBHRBMHFyQcAIai0AADoAUCADIABBBnYgCEECdEE8cXJBwAhqLQAAOgBRIANBAC0AiisiAUEEdiAFQQR0QTBxckHACGotAAA6AFQgAyAGQQZ2IAFBAnRBPHFyQcAIai0AADoAVSADQQAtAI0rIgFBBHYgB0EEdEEwcXJBwAhqLQAAOgBYIANBADoAXSADQQAtAI4rIgBBP3FBwAhqLQAAOgBaIANBAC0AjysiBUECdkHACGotAAA6AFsgAyAAQQZ2IAFBAnRBPHFyQcAIai0AADoAWSADIAVBBHRBMHFBwAhqLQAAOgBcQZArIANBwABqIAMgAhABA0AgBEGAK2ogAyAEaiIBLQAAOgAAIARBgStqIAFBAWotAAA6AAAgBEGCK2ogAUECai0AADoAACAEQYMraiABQQNqLQAAOgAAIARBhCtqIAFBBGotAAA6AAAgBEEFaiIEQTxHDQALIANB4ABqJAALhwECAX8IfiMAQcAAayIBJAAgAEG8K2pBADoAAEG8K0GAKyABQQEQAUEAKQOkKyECIAEpAyQhA0EAKQOcKyEEIAEpAxwhBUEAKQOsKyEGIAEpAywhB0EAKQO0KyEIIAEpAzQhCSABQcAAaiQAIAUgBFIgAyACUmogByAGUmpBf0EAIAkgCFIbRgsLxyICAEGACAvwAQIEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQQAAAAAAAAAaHByT0JuYWVsb2hlU3JlZER5cmN0YnVvAAAAAAAAAAAuL0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5AAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQEBAAAE2Nzg5Ojs8PT4/QEBAQEBAQAIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobQEBAQEBAHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDVAQEBAQABB8AkLyCCmCzHRrLXfmNty/S+33xrQ7a/huJZ+JmpFkHy6mX8s8UeZoST3bJGz4vIBCBb8joXYIGljaU5XcaP+WKR+PZP0j3SVDVi2jnJYzYtx7koVgh2kVHu1WVrCOdUwnBNg8iojsNHF8IVgKBh5QcrvONu4sNx5jg4YOmCLDp5sPooesMF3FdcnSzG92i+veGBcYFXzJVXmlKtVqmKYSFdAFOhjajnKVbYQqyo0XMy0zuhBEa+GVKGT6XJ8ERTusyq8b2Ndxakr9jEYdBY+XM4ek4ebM7rWr1zPJGyBUzJ6d4aVKJhIjzuvuUtrG+i/xJMhKGbMCdhhkakh+2CsfEgygOxdXV2E77F1hekCIybciBtl64E+iSPFrJbT829tDzlC9IOCRAsuBCCEpErwyGlemx+eQmjGIZps6fZhnAxn8IjTq9KgUWpoL1TYKKcPlqMzUatsC+9u5Dt6E1DwO7qYKvt+HWXxoXYBrzk+WcpmiA5DghmG7oy0n29Fw6WEfb5eizvYdW/gcyDBhZ9EGkCmasFWYqrTTgZ3PzZy3/4bPQKbQiTX0DdIEgrQ0+oP25vA8UnJclMHexuZgNh51CX33uj2GlD+4ztMeba94GyXugbABLZPqcHEYJ9Awp5cXmMkahmvb/totVNsPuuyORNv7FI7H1H8bSyVMJtERYHMCb1erwTQ4779SjPeBygPZrNLLhlXqMvAD3TIRTlfC9Lb+9O5vcB5VQoyYBrGAKHWeXIsQP4ln2fMox/7+OmljvgiMtvfFnU8FWth/cgeUC+rUgWt+rU9MmCHI/1IezFTgt8APrtXXJ6gjG/KLlaHGttpF9/2qELVw/9+KMYyZ6xzVU+MsCdbachYyrtdo//hoBHwuJg9+hC4gyH9bLX8SlvT0S155FOaZUX4trxJjtKQl/tL2vLd4TN+y6RBE/ti6MbkztrKIO8BTHc2/p5+0LQf8StN2tuVmJGQrnGOreqg1ZNr0NGO0OAlx68vWzyOt5R1jvvi9o9kKxLyEriIiBzwDZCgXq1PHMOPaJHxz9GtwaizGCIvL3cXDr7+LXXqoR8Ciw/MoOXodG+11vOsGJniic7gT6i0t+AT/YE7xHzZqK3SZqJfFgV3lYAUc8yTdxQaIWUgreaG+rV39UJUx881nfsMr83roIk+e9MbQdZJfh6uLQ4lAF6zcSC7AGgir+C4V5s2ZCQeuQnwHZFjVaqm31mJQ8F4f1Na2aJbfSDFueUCdgMmg6nPlWJoGcgRQUpzTsotR7NKqRR7UgBRGxUpU5o/Vw/W5MabvHakYCsAdOaBtW+6CB/pG1dr7JbyFdkNKiFlY7a2+bnnLgU0/2RWhcVdLbBToY+fqZlHughqB4Vu6XB6S0Qps7UuCXXbIyYZxLCmbq1936dJuGDunGay7Y9xjKrs/xeaaWxSZFbhnrHCpQI2GSlMCXVAE1mgPjoY5JqYVD9lnUJb1uSPa9Y/95kHnNKh9TDo7+Y4LU3BXSXwhiDdTCbrcITG6YJjXsweAj9raAnJ77o+FBiXPKFwamuENX9ohuKgUgVTnLc3B1CqHIQHPlyu3n/sRH2OuPIWVzfaOrANDFDwBB8c8P+zAAIa9QyusnS1PFh6gyW9IQnc+ROR0fYvqXxzRzKUAUf1IoHl5Trc2sI3NHa1yKfd85pGYUSpDgPQDz7HyOxBHnWkmc044i8O6juhu4AyMbM+GDiLVE4IuW1PAw1Cb78ECvaQErgseXyXJHKweVavia+8H3ea3hAIk9kSrouzLj/P3B9yElUkcWsu5t0aUIfNhJ8YR1h6F9oIdLyan7yMfUvpOux67PodhdtmQwlj0sNkxEcYHO8I2RUyNztD3Ra6wiRDTaESUcRlKgIAlFDd5DoTnvjfcVVOMRDWd6yBmxkRX/FWNQRrx6PXOxgRPAmlJFnt5o/y+vvxlyy/up5uPBUecEXjhrFv6eoKXg6Gsyo+WhznH3f6Bj1OudxlKQ8d55nWiT6AJchmUnjJTC5qsxCcug4Vxnjq4pRTPPyl9C0KHqdO9/I9Kx02DyY5GWB5whkIpyNSthIT927+retmH8PqlUW844PIe6bRN3+xKP+MAe/dMsOlWmy+hSFYZQKYq2gPpc7uO5Uv26197yqEL25bKLYhFXBhByl1R93sEBWfYTCozBOWvWHrHv40A89jA6qQXHO1OaJwTAuentUU3qrLvIbM7qcsYmCrXKucboTzsq8ei2TK8L0ZuWkjoFC7WmUyWmhAs7QqPNXpnjH3uCHAGQtUm5mgX4d+mfeVqH09YpqIN/h3LeOXX5PtEYESaBYpiDUO1h/mx6Hf3paZulh4pYT1V2NyIhv/w4OblkbCGusKs81UMC5T5EjZjygxvG3v8utY6v/GNGHtKP5zPHzu2RRKXeO3ZOgUXRBC4BM+ILbi7kXqq6qjFU9s29BPy/pC9ELHtbtq7x07T2UFIc1Bnnke2MdNhYZqR0vkUGKBPfKhYs9GJo1boIOI/KO2x8HDJBV/knTLaQuKhEeFspJWAL9bCZ1IGa10sWIUAA6CIyqNQljq9VUMPvStHWFwPyOS8HIzQX6TjfHsX9bbOyJsWTfefGB07sun8oVAbjJ3zoSAB6aeUPgZVdjv6DWX2WGqp2mpwgYMxfyrBFrcyguALnpEnoQ0RcMFZ9X9yZ4eDtPbc9vNiFUQedpfZ0BDZ+NlNMTF2Dg+cZ74KD0g/23x5yE+FUo9sI8rn+Pm962D22haPen3QIGUHCZM9jQpaZT3IBVB99QCdi5r9LxoAKLUcSQI1Gr0IDO31LdDr2EAUC72OR5GRSSXdE8hFECIi78d/JVNr5G1ltPd9HBFL6Bm7Am8v4WXvQPQbax/BIXLMbMn65ZBOf1V5kcl2poKyqsleFAo9CkEU9qGLAr7bbbpYhTcaABpSNekwA5o7o2hJ6L+P0+MrYfoBuCMtbbW9Hp8Hs6q7F8305mjeM5CKmtANZ7+ILmF89mr1znui04SO/f6yR1WGG1LMWajJrKX4+p0+m46MkNb3ffnQWj7IHjKTvUK+5ez/tisVkBFJ5VIujo6U1WHjYMgt6lr/kuVltC8Z6hVWJoVoWMpqcwz2+GZVkoqpvklMT8cfvRefDEpkALo+P1wLycEXBW7gOMsKAVIFcGVIm3G5D8TwUjchg/H7sn5Bw8fBEGkeUdAF26IXetRXzLRwJvVj8G88mQ1EUE0eHslYJwqYKPo+N8bbGMfwrQSDp4y4QLRT2avFYHRyuCVI2vhkj4zYgskOyK5vu4OorKFmQ265owMct4o96ItRXgS0P2Ut5ViCH1k8PXM52+jSVT6SH2HJ/2dwx6NPvNBY0cKdP8umatubzo3/fj0YNwSqPjd66FM4RuZDWtu2xBVe8Y3LGdtO9RlJwTo0NzHDSnxo/8AzJIPObUL7Q9p+597Zpx9284Lz5Ggo14V2YgvE7skrVtRv3mUe+vWO3azLjk3eVkRzJfiJoAtMS70p61CaDsrasbMTHUSHPEueDdCEmrnUZK35ruhBlBj+0sYEGsa+u3KEdi9JT3Jw+HiWRZCRIYTEgpu7AzZKuqr1U5nr2RfqIbaiOm/vv7D5GRXgLydhsD38Ph7eGBNYANgRoP90bAfOPYErkV3zPw21zNrQoNxqx7wh0GAsF9eADy+V6B3JK7ovZlCRlVhLli/j/RYTqL93fI473T0wr2Jh8P5ZlN0jrPIVfJ1tLnZ/EZhJut6hN8di3kOaoTilV+RjlluRnBXtCCRVdWMTN4CyeGsC7nQBYK7SGKoEZ6pdHW2GX+3Cdyp4KEJLWYzRjLEAh9a6Iy+8AkloJlKEP5uHR09uRrfpKULD/KGoWnxaCiD2rfc/gY5V5vO4qFSf81PAV4RUPqDBqfEtQKgJ9DmDSeM+JpBhj93Bkxgw7UGqGEoehfw4Ib1wKpYYABifdww157mEWPqOCOU3cJTNBbCwlbuy7vetryQoX3863YdWc4J5AVviAF8Sz0KcjkkfJJ8X3LjhrmdTXK0W8Ea/Lie03hVVO21pfwI03w92MQPrU1e71Ae+OZhsdkUhaI8E1Fs58fVb8RO4VbOvyo2N8jG3TQymtcSgmOSjvoOZ+AAYEA3zjk6z/X60zd3wqsbLcVanmewXEI3o09AJ4LTvpu8mZ2OEdUVcw+/fhwt1nvEAMdrG4y3RZChIb6xbrK0bjZqL6tIV3lulLzSdqPGyMJJZe74D1N93o1GHQpz1cZN0EzbuzkpUEa6qegmlawE416+8NX6oZpRLWrijO9jIu6GmrjCicD2LiRDqgMepaTQ8py6YcCDTWrpm1AV5Y/WW2S6+aImKOE6OqeGlalL6WJV79PvL8fa91L3aW8EP1kK+ncVqeSAAYawh63mCZuT5T47Wv2Q6ZfXNJ7Zt/AsUYsrAjqs1ZZ9pn0B1j7P0SgtfXzPJZ8fm7jyrXK01lpM9Yhacawp4OalGeD9rLBHm/qT7Y3E0+jMVzsoKWbV+CguE3mRAV94VWB17UQOlveMXtPj1G0FFbpt9IglYaEDvfBkBRWe68OiV5A87BonlyoHOqmbbT8b9SFjHvtmnPUZ89wmKNkzdfX9VbGCNFYDuzy6ihF3USj42QrCZ1HMq1+SrcxRF+hNjtwwOGJYnTeR+SCTwpB66s57PvtkziFRMr5Pd37jtqhGPSnDaVPeSIDmE2QQCK6iJLJt3f0thWlmIQcJCkaas93ARWTP3mxYrsggHN33vltAjVgbfwHSzLvjtGt+aqLdRf9ZOkQKNT7VzbS8qM7qcruEZPquEmaNR288v2Pkm9KeXS9UG3fCrnBjTvaNDQ50VxNb53EWcvhdfVOvCMtAQMzitE5qRtI0hK8VASgEsOEdOpiVtJ+4Bkigbs6COz9vgqsgNUsdGgH4J3InsWAVYdw/k+creTq7vSVFNOE5iKBLec5Rt8kyL8m6H6B+yBzg9tHHvMMRAc/HquihSYeQGpq9T9TL3trQONoK1SrDOQNnNpHGfDH5jU8rseC3WZ73Orv1Q/8Z1fKcRdknLCKXvyr85hVx/JEPJRWUm2GT5frrnLbOWWSowtGouhJeB8G2DGoF42VQ0hBCpAPLDm7s4DvbmBa+oJhMZOl4MjKVH5/fktPgKzSg0x7ycYlBdAobjDSjSyBxvsXYMnbDjZ813y4vmZtHbwvmHfHjD1TaTOWR2Noez3lizm9+Ps1msRgWBR0s/cXSj4SZIvv2V/Mj9SN2MqYxNaiTAs3MVmKB8Ky163ValzYWbsxz0oiSYpbe0Em5gRuQUEwUVsZxvcfG5goUejIG0OFFmnvyw/1TqskAD6hi4r8lu/bSvTUFaRJxIgIEsnzPy7YrnHbNwD4RU9PjQBZgvas48K1HJZwgOLp2zkb3xaGvd2BgdSBO/suF2I3oirD5qnp+qvlMXMJIGYyK+wLkasMB+eHr1mn41JCg3lymLSUJP5/mCMIyYU63W+J3zuPfj1fmcsM6iGo/JNMIo4UuihkTRHNwAyI4CaTQMZ8pmPouCIlsTuzmIShFdxPQOM9mVL5sDOk0tymswN1QfMm11YQ/FwlHtdnVFpIb+3mJ";
    hash$2 = "8bd8822d";
    wasmJson$2 = {
      name: name$2,
      data: data$2,
      hash: hash$2
    };
    validateOptions = (options) => {
      if (!options || typeof options !== "object") {
        throw new Error("Invalid options parameter. It requires an object.");
      }
      if (!Number.isInteger(options.costFactor) || options.costFactor < 4 || options.costFactor > 31) {
        throw new Error("Cost factor should be a number between 4 and 31");
      }
      options.password = getUInt8Buffer(options.password);
      if (options.password.length < 1) {
        throw new Error("Password should be at least 1 byte long");
      }
      if (options.password.length > 72) {
        throw new Error("Password should be at most 72 bytes long");
      }
      options.salt = getUInt8Buffer(options.salt);
      if (options.salt.length !== 16) {
        throw new Error("Salt should be 16 bytes long");
      }
      if (options.outputType === void 0) {
        options.outputType = "encoded";
      }
      if (!["hex", "binary", "encoded"].includes(options.outputType)) {
        throw new Error(`Insupported output type ${options.outputType}. Valid values: ['hex', 'binary', 'encoded']`);
      }
    };
    validateHashCharacters = (hash2) => {
      if (!/^\$2[axyb]\$[0-3][0-9]\$[./A-Za-z0-9]{53}$/.test(hash2)) {
        return false;
      }
      if (hash2[4] === "0" && Number(hash2[5]) < 4) {
        return false;
      }
      if (hash2[4] === "3" && Number(hash2[5]) > 1) {
        return false;
      }
      return true;
    };
    validateVerifyOptions = (options) => {
      if (!options || typeof options !== "object") {
        throw new Error("Invalid options parameter. It requires an object.");
      }
      if (options.hash === void 0 || typeof options.hash !== "string") {
        throw new Error("Hash should be specified");
      }
      if (options.hash.length !== 60) {
        throw new Error("Hash should be 60 bytes long");
      }
      if (!validateHashCharacters(options.hash)) {
        throw new Error("Invalid hash");
      }
      options.password = getUInt8Buffer(options.password);
      if (options.password.length < 1) {
        throw new Error("Password should be at least 1 byte long");
      }
      if (options.password.length > 72) {
        throw new Error("Password should be at most 72 bytes long");
      }
    };
    name$1 = "whirlpool";
    data$1 = "AGFzbQEAAAABEQRgAAF/YAF/AGACf38AYAAAAwkIAAECAwEDAAEFBAEBAgIGDgJ/AUHQmwULfwBBgAgLB3AIBm1lbW9yeQIADkhhc2hfR2V0QnVmZmVyAAAJSGFzaF9Jbml0AAMLSGFzaF9VcGRhdGUABApIYXNoX0ZpbmFsAAUNSGFzaF9HZXRTdGF0ZQAGDkhhc2hfQ2FsY3VsYXRlAAcKU1RBVEVfU0laRQMBCu0bCAUAQYAZC8wGAQl+IAApAwAhAUEAQQApA4CbASICNwPAmQEgACkDGCEDIAApAxAhBCAAKQMIIQVBAEEAKQOYmwEiBjcD2JkBQQBBACkDkJsBIgc3A9CZAUEAQQApA4ibASIINwPImQFBACABIAKFNwOAmgFBACAFIAiFNwOImgFBACAEIAeFNwOQmgFBACADIAaFNwOYmgEgACkDICEDQQBBACkDoJsBIgE3A+CZAUEAIAMgAYU3A6CaASAAKQMoIQRBAEEAKQOomwEiAzcD6JkBQQAgBCADhTcDqJoBIAApAzAhBUEAQQApA7CbASIENwPwmQFBACAFIASFNwOwmgEgACkDOCEJQQBBACkDuJsBIgU3A/iZAUEAIAkgBYU3A7iaAUEAQpjGmMb+kO6AzwA3A4CZAUHAmQFBgJkBEAJBgJoBQcCZARACQQBCtszKrp/v28jSADcDgJkBQcCZAUGAmQEQAkGAmgFBwJkBEAJBAELg+O70uJTDvTU3A4CZAUHAmQFBgJkBEAJBgJoBQcCZARACQQBCncDfluzlkv/XADcDgJkBQcCZAUGAmQEQAkGAmgFBwJkBEAJBAEKV7t2p/pO8pVo3A4CZAUHAmQFBgJkBEAJBgJoBQcCZARACQQBC2JKn0ZCW6LWFfzcDgJkBQcCZAUGAmQEQAkGAmgFBwJkBEAJBAEK9u8Ggv9nPgucANwOAmQFBwJkBQYCZARACQYCaAUHAmQEQAkEAQuTPhNr4tN/KWDcDgJkBQcCZAUGAmQEQAkGAmgFBwJkBEAJBAEL73fOz1vvFo55/NwOAmQFBwJkBQYCZARACQYCaAUHAmQEQAkEAQsrb/L3Q1dbBMzcDgJkBQcCZAUGAmQEQAkGAmgFBwJkBEAJBACACQQApA4CaASAAKQMAhYU3A4CbAUEAIAhBACkDiJoBIAApAwiFhTcDiJsBQQAgB0EAKQOQmgEgACkDEIWFNwOQmwFBACAGQQApA5iaASAAKQMYhYU3A5ibAUEAIAFBACkDoJoBIAApAyCFhTcDoJsBQQAgA0EAKQOomgEgACkDKIWFNwOomwFBACAEQQApA7CaASAAKQMwhYU3A7CbAUEAIAVBACkDuJoBIAApAziFhTcDuJsBC4YMCgF+AX8BfgF/AX4BfwF+AX8EfgN/IAAgACkDACICpyIDQf8BcUEDdEGQCGopAwBCOIkgACkDOCIEpyIFQQV2QfgPcUGQCGopAwCFQjiJIAApAzAiBqciB0ENdkH4D3FBkAhqKQMAhUI4iSAAKQMoIginIglBFXZB+A9xQZAIaikDAIVCOIkgACkDICIKQiCIp0H/AXFBA3RBkAhqKQMAhUI4iSAAKQMYIgtCKIinQf8BcUEDdEGQCGopAwCFQjiJIAApAxAiDEIwiKdB/wFxQQN0QZAIaikDAIVCOIkgACkDCCINQjiIp0EDdEGQCGopAwCFQjiJIAEpAwCFNwMAIAAgDaciDkH/AXFBA3RBkAhqKQMAQjiJIANBBXZB+A9xQZAIaikDAIVCOIkgBUENdkH4D3FBkAhqKQMAhUI4iSAHQRV2QfgPcUGQCGopAwCFQjiJIAhCIIinQf8BcUEDdEGQCGopAwCFQjiJIApCKIinQf8BcUEDdEGQCGopAwCFQjiJIAtCMIinQf8BcUEDdEGQCGopAwCFQjiJIAxCOIinQQN0QZAIaikDAIVCOIkgASkDCIU3AwggACAMpyIPQf8BcUEDdEGQCGopAwBCOIkgDkEFdkH4D3FBkAhqKQMAhUI4iSADQQ12QfgPcUGQCGopAwCFQjiJIAVBFXZB+A9xQZAIaikDAIVCOIkgBkIgiKdB/wFxQQN0QZAIaikDAIVCOIkgCEIoiKdB/wFxQQN0QZAIaikDAIVCOIkgCkIwiKdB/wFxQQN0QZAIaikDAIVCOIkgC0I4iKdBA3RBkAhqKQMAhUI4iSABKQMQhTcDECAAIAunIhBB/wFxQQN0QZAIaikDAEI4iSAPQQV2QfgPcUGQCGopAwCFQjiJIA5BDXZB+A9xQZAIaikDAIVCOIkgA0EVdkH4D3FBkAhqKQMAhUI4iSAEQiCIp0H/AXFBA3RBkAhqKQMAhUI4iSAGQiiIp0H/AXFBA3RBkAhqKQMAhUI4iSAIQjCIp0H/AXFBA3RBkAhqKQMAhUI4iSAKQjiIp0EDdEGQCGopAwCFQjiJIAEpAxiFNwMYIAAgCqciA0H/AXFBA3RBkAhqKQMAQjiJIBBBBXZB+A9xQZAIaikDAIVCOIkgD0ENdkH4D3FBkAhqKQMAhUI4iSAOQRV2QfgPcUGQCGopAwCFQjiJIAJCIIinQf8BcUEDdEGQCGopAwCFQjiJIARCKIinQf8BcUEDdEGQCGopAwCFQjiJIAZCMIinQf8BcUEDdEGQCGopAwCFQjiJIAhCOIinQQN0QZAIaikDAIVCOIkgASkDIIU3AyAgACAJQf8BcUEDdEGQCGopAwBCOIkgA0EFdkH4D3FBkAhqKQMAhUI4iSAQQQ12QfgPcUGQCGopAwCFQjiJIA9BFXZB+A9xQZAIaikDAIVCOIkgDUIgiKdB/wFxQQN0QZAIaikDAIVCOIkgAkIoiKdB/wFxQQN0QZAIaikDAIVCOIkgBEIwiKdB/wFxQQN0QZAIaikDAIVCOIkgBkI4iKdBA3RBkAhqKQMAhUI4iSABKQMohTcDKCAAIAdB/wFxQQN0QZAIaikDAEI4iSAJQQV2QfgPcUGQCGopAwCFQjiJIANBDXZB+A9xQZAIaikDAIVCOIkgEEEVdkH4D3FBkAhqKQMAhUI4iSAMQiCIp0H/AXFBA3RBkAhqKQMAhUI4iSANQiiIp0H/AXFBA3RBkAhqKQMAhUI4iSACQjCIp0H/AXFBA3RBkAhqKQMAhUI4iSAEQjiIp0EDdEGQCGopAwCFQjiJIAEpAzCFNwMwIAAgBUH/AXFBA3RBkAhqKQMAQjiJIAdBBXZB+A9xQZAIaikDAIVCOIkgCUENdkH4D3FBkAhqKQMAhUI4iSADQRV2QfgPcUGQCGopAwCFQjiJIAtCIIinQf8BcUEDdEGQCGopAwCFQjiJIAxCKIinQf8BcUEDdEGQCGopAwCFQjiJIA1CMIinQf8BcUEDdEGQCGopAwCFQjiJIAJCOIinQQN0QZAIaikDAIVCOIkgASkDOIU3AzgLXABBAEIANwPImwFBAEIANwO4mwFBAEIANwOwmwFBAEIANwOomwFBAEIANwOgmwFBAEIANwOYmwFBAEIANwOQmwFBAEIANwOImwFBAEIANwOAmwFBAEEANgLAmwELxgMBB39BACEBQQBBACkDyJsBIACtfDcDyJsBAkBBACgCwJsBIgJFDQBBACEBAkAgAiAAaiIDQcAAIANBwABJGyIEIAJB/wFxIgVNDQAgBCAFayIBQQNxIQYCQAJAIAQgBUF/c2pBA08NAEEAIQEMAQsgAUF8cSEHQQAhAQNAIAUgAWoiAkHAmgFqIAFBgBlqLQAAOgAAIAJBwZoBaiABQYEZai0AADoAACACQcKaAWogAUGCGWotAAA6AAAgAkHDmgFqIAFBgxlqLQAAOgAAIAcgAUEEaiIBRw0ACyAFIAFqIgUhAgsgBkUNACACQf8BcUEBaiECA0AgBUHAmgFqIAFBgBlqLQAAOgAAIAIiBUEBaiECIAFBAWohASAFIQUgBkF/aiIGDQALCwJAIANBP00NAEHAmgEQAUEAIQQLQQAgBDYCwJsBCwJAIAAgAWsiAkHAAEkNAANAIAFBgBlqEAEgAUHAAGohASACQUBqIgJBP0sNAAsLAkAgASAARg0AQQAgAjYCwJsBIAJFDQBBACECQQAhBQNAIAJBwJoBaiACIAFqQYAZai0AADoAAEEAKALAmwEgBUEBaiIFQf8BcSICSw0ACwsL/wMCBH8BfiMAQcAAayIAJAAgAEE4akIANwMAIABBMGpCADcDACAAQShqQgA3AwAgAEEgakIANwMAIABBGGpCADcDACAAQRBqQgA3AwAgAEIANwMIIABCADcDAEEAIQECQAJAQQAoAsCbASICRQ0AQQAhAwNAIAAgAWogAUHAmgFqLQAAOgAAIAFBAWohASACIANBAWoiA0H/AXFLDQALQQAgAkEBajYCwJsBIAAgAmpBgAE6AAAgAkFgcUEgRw0BIAAQASAAQgA3AxggAEIANwMQIABCADcDCCAAQgA3AwAMAQtBAEEBNgLAmwEgAEGAAToAAAtBACkDyJsBIQRBAEIANwPImwEgAEEAOgA2IABBADYBMiAAQgA3ASogAEEAOgApIABCADcAISAAQQA6ACAgACAEQgWIPAA+IAAgBEINiDwAPSAAIARCFYg8ADwgACAEQh2IPAA7IAAgBEIliDwAOiAAIARCLYg8ADkgACAEQjWIPAA4IAAgBEI9iDwANyAAIASnQQN0OgA/IAAQAUEAQQApA4CbATcDgBlBAEEAKQOImwE3A4gZQQBBACkDkJsBNwOQGUEAQQApA5ibATcDmBlBAEEAKQOgmwE3A6AZQQBBACkDqJsBNwOoGUEAQQApA7CbATcDsBlBAEEAKQO4mwE3A7gZIABBwABqJAALBgBBwJoBC2IAQQBCADcDyJsBQQBCADcDuJsBQQBCADcDsJsBQQBCADcDqJsBQQBCADcDoJsBQQBCADcDmJsBQQBCADcDkJsBQQBCADcDiJsBQQBCADcDgJsBQQBBADYCwJsBIAAQBBAFCwuYEAEAQYAIC5AQkAAAAAAAAAAAAAAAAAAAABgYYBjAeDDYIyOMIwWvRibGxj/GfvmRuOjoh+gTb837h4cmh0yhE8u4uNq4qWJtEQEBBAEIBQIJT08hT0Jung02Ntg2re5sm6amoqZZBFH/0tJv0t69uQz19fP1+wb3Dnl5+XnvgPKWb2+hb1/O3jCRkX6R/O8/bVJSVVKqB6T4YGCdYCf9wEe8vMq8iXZlNZubVpuszSs3jo4CjgSMAYqjo7ajcRVb0gwMMAxgPBhse3vxe/+K9oQ1NdQ1teFqgB0ddB3oaTr14OCn4FNH3bPX13vX9qyzIcLCL8Je7ZmcLi64Lm2WXENLSzFLYnqWKf7+3/6jIeFdV1dBV4IWrtUVFVQVqEEqvXd3wXeftu7oNzfcN6XrbpLl5bPle1bXnp+fRp+M2SMT8PDn8NMX/SNKSjVKan+UINraT9qelalEWFh9WPolsKLJyQPJBsqPzykppClVjVJ8CgooClAiFFqxsf6x4U9/UKCguqBpGl3Ja2uxa3/a1hSFhS6FXKsX2b29zr2Bc2c8XV1pXdI0uo8QEEAQgFAgkPT09/TzA/UHy8sLyxbAi90+Pvg+7cZ80wUFFAUoEQotZ2eBZx/mznjk5Lfkc1PVlycnnCclu04CQUEZQTJYgnOLixaLLJ0Lp6enpqdRAVP2fX3pfc+U+rKVlW6V3Ps3SdjYR9iOn61W+/vL+4sw63Du7p/uI3HBzXx87XzHkfi7ZmaFZhfjzHHd3VPdpo6nexcXXBe4Sy6vR0cBRwJGjkWenkKehNwhGsrKD8oexYnULS20LXWZWli/v8a/kXljLgcHHAc4Gw4/ra2OrQEjR6xaWnVa6i+0sIODNoNstRvvMzPMM4X/ZrZjY5FjP/LGXAICCAIQCgQSqqqSqjk4SZNxcdlxr6ji3sjIB8gOz43GGRlkGch9MtFJSTlJcnCSO9nZQ9mGmq9f8vLv8sMd+THj46vjS0jbqFtbcVviKra5iIgaiDSSDbyamlKapMgpPiYmmCYtvkwLMjLIMo36ZL+wsPqw6Up9Wenpg+kbas/yDw88D3gzHnfV1XPV5qa3M4CAOoB0uh30vr7Cvpl8YSfNzRPNJt6H6zQ00DS95GiJSEg9SHp1kDL//9v/qyTjVHp69Xr3j/SNkJB6kPTqPWRfX2Ffwj6+nSAggCAdoEA9aGi9aGfV0A8aGmga0HI0yq6ugq4ZLEG3tLTqtMledX1UVE1UmhmozpOTdpPs5Tt/IiKIIg2qRC9kZI1kB+nIY/Hx4/HbEv8qc3PRc7+i5swSEkgSkFokgkBAHUA6XYB6CAggCEAoEEjDwyvDVuiblezsl+wze8Xf29tL25aQq02hob6hYR9fwI2NDo0cgweRPT30PfXJesiXl2aXzPEzWwAAAAAAAAAAz88bzzbUg/krK6wrRYdWbnZ2xXaXs+zhgoIygmSwGebW1n/W/qmxKBsbbBvYdzbDtbXutcFbd3Svr4avESlDvmpqtWp339QdUFBdULoNoOpFRQlFEkyKV/Pz6/PLGPs4MDDAMJ3wYK3v75vvK3TDxD8//D/lw37aVVVJVZIcqseiorKieRBZ2+rqj+oDZcnpZWWJZQ/symq6utK6uWhpAy8vvC9lk15KwMAnwE7nnY7e3l/evoGhYBwccBzgbDj8/f3T/bsu50ZNTSlNUmSaH5KScpLk4Dl2dXXJdY+86voGBhgGMB4MNoqKEookmAmusrLysvlAeUvm5r/mY1nRhQ4OOA5wNhx+Hx98H/hjPudiYpViN/fEVdTUd9Tuo7U6qKiaqCkyTYGWlmKWxPQxUvn5w/mbOu9ixcUzxWb2l6MlJZQlNbFKEFlZeVnyILKrhIQqhFSuFdByctVyt6fkxTk55DnV3XLsTEwtTFphmBZeXmVeyju8lHh4/XjnhfCfODjgON3YcOWMjAqMFIYFmNHRY9HGsr8XpaWupUELV+Ti4q/iQ03ZoWFhmWEv+MJOs7P2s/FFe0IhIYQhFaVCNJycSpyU1iUIHh54HvBmPO5DQxFDIlKGYcfHO8d2/JOx/PzX/LMr5U8EBBAEIBQIJFFRWVGyCKLjmZlembzHLyVtbaltT8TaIg0NNA1oORpl+vrP+oM16Xnf31vftoSjaX5+5X7Xm/ypJCSQJD20SBk7O+w7xdd2/qurlqsxPUuazs4fzj7RgfAREUQRiFUimY+PBo8MiQODTk4lTkprnAS3t+a30VFzZuvri+sLYMvgPDzwPP3MeMGBgT6BfL8f/ZSUapTU/jVA9/f79+sM8xy5ud65oWdvGBMTTBOYXyaLLCywLH2cWFHT02vT1ri7Befnu+drXNOMbm6lblfL3DnExDfEbvOVqgMDDAMYDwYbVlZFVooTrNxERA1EGkmIXn9/4X/fnv6gqameqSE3T4gqKqgqTYJUZ7u71ruxbWsKwcEjwUbin4dTU1FTogKm8dzcV9yui6VyCwssC1gnFlOdnU6dnNMnAWxsrWxHwdgrMTHEMZX1YqR0dM10h7no8/b2//bjCfEVRkYFRgpDjEysrIqsCSZFpYmJHok8lw+1FBRQFKBEKLTh4aPhW0LfuhYWWBawTiymOjroOs3SdPdpablpb9DSBgkJJAlILRJBcHDdcKet4Ne2tuK22VRxb9DQZ9DOt70e7e2T7Tt+x9bMzBfMLtuF4kJCFUIqV4RomJhamLTCLSykpKqkSQ5V7SgooChdiFB1XFxtXNoxuIb4+Mf4kz/ta4aGIoZEpBHC";
    hash$1 = "8d8f6035";
    wasmJson$1 = {
      name: name$1,
      data: data$1,
      hash: hash$1
    };
    mutex$1 = new Mutex();
    wasmCache$1 = null;
    name = "sm3";
    data = "AGFzbQEAAAABDANgAAF/YAAAYAF/AAMIBwABAgIBAAIFBAEBAgIGDgJ/AUHwiQULfwBBgAgLB3AIBm1lbW9yeQIADkhhc2hfR2V0QnVmZmVyAAAJSGFzaF9Jbml0AAELSGFzaF9VcGRhdGUAAgpIYXNoX0ZpbmFsAAQNSGFzaF9HZXRTdGF0ZQAFDkhhc2hfQ2FsY3VsYXRlAAYKU1RBVEVfU0laRQMBCtodBwUAQYAJC1EAQQBCzdy3nO7Jw/2wfzcCoIkBQQBCvOG8y6qVzpgWNwKYiQFBAELXhZG5gcCBxVo3ApCJAUEAQu+sgJyX16yKyQA3AoiJAUEAQgA3AoCJAQvvAwEIfwJAIABFDQBBACEBQQBBACgCgIkBIgIgAGoiAzYCgIkBIAJBP3EhBAJAIAMgAk8NAEEAQQAoAoSJAUEBajYChIkBC0GACSECAkAgBEUNAAJAIABBwAAgBGsiBU8NACAEIQEMAQsgBEE/cyEGIARBqIkBaiECQYAJIQMCQAJAIAVBB3EiBw0AIAUhCAwBCyAHIQgDQCACIAMtAAA6AAAgAkEBaiECIANBAWohAyAIQX9qIggNAAtBwAAgByAEamshCAsCQCAGQQdJDQADQCACIAMpAAA3AAAgAkEIaiECIANBCGohAyAIQXhqIggNAAsLQaiJARADIAVBgAlqIQIgACAFayEACwJAIABBwABJDQADQCACEAMgAkHAAGohAiAAQUBqIgBBP0sNAAsLIABFDQAgAUGoiQFqIQMCQAJAIABBB3EiCA0AIAAhBAwBCyAAQThxIQQDQCADIAItAAA6AAAgA0EBaiEDIAJBAWohAiAIQX9qIggNAAsLIABBCEkNAANAIAMgAi0AADoAACADIAItAAE6AAEgAyACLQACOgACIAMgAi0AAzoAAyADIAItAAQ6AAQgAyACLQAFOgAFIAMgAi0ABjoABiADIAItAAc6AAcgA0EIaiEDIAJBCGohAiAEQXhqIgQNAAsLC+wLARl/IwBBkAJrIgEkACABIAAoAhgiAkEYdCACQYD+A3FBCHRyIAJBCHZBgP4DcSACQRh2cnIiAzYCGCABIAAoAhQiAkEYdCACQYD+A3FBCHRyIAJBCHZBgP4DcSACQRh2cnIiBDYCFCABIAAoAggiAkEYdCACQYD+A3FBCHRyIAJBCHZBgP4DcSACQRh2cnIiBTYCCCABIAAoAhAiAkEYdCACQYD+A3FBCHRyIAJBCHZBgP4DcSACQRh2cnIiBjYCECABIAAoAiAiAkEYdCACQYD+A3FBCHRyIAJBCHZBgP4DcSACQRh2cnIiBzYCICABIAAoAgQiAkEYdCACQYD+A3FBCHRyIAJBCHZBgP4DcSACQRh2cnIiCDYCBCABIAAoAgwiAkEYdCACQYD+A3FBCHRyIAJBCHZBgP4DcSACQRh2cnIiCTYCDCABIAAoAhwiAkEYdCACQYD+A3FBCHRyIAJBCHZBgP4DcSACQRh2cnIiCjYCHCABIAAoAgAiAkEYdCACQYD+A3FBCHRyIAJBCHZBgP4DcSACQRh2cnIiCzYCACAAKAIkIQIgASAAKAI0IgxBGHQgDEGA/gNxQQh0ciAMQQh2QYD+A3EgDEEYdnJyIg02AjQgASAAKAIoIgxBGHQgDEGA/gNxQQh0ciAMQQh2QYD+A3EgDEEYdnJyIg42AiggASALIA1BD3dzIApzIgxBF3cgDEEPd3MgCUEHd3MgDnMgDHMiCjYCQCABIAAoAjgiDEEYdCAMQYD+A3FBCHRyIAxBCHZBgP4DcSAMQRh2cnIiCzYCOCABIAAoAiwiDEEYdCAMQYD+A3FBCHRyIAxBCHZBgP4DcSAMQRh2cnIiDzYCLCABIAggC0EPd3MgB3MiDEEXdyAMQQ93cyAGQQd3cyAPcyAMczYCRCABIAAoAjwiDEEYdCAMQYD+A3FBCHRyIAxBCHZBgP4DcSAMQRh2cnIiDDYCPCABIAJBGHQgAkGA/gNxQQh0ciACQQh2QYD+A3EgAkEYdnJyIgI2AiQgASAAKAIwIgBBGHQgAEGA/gNxQQh0ciAAQQh2QYD+A3EgAEEYdnJyIgY2AjAgASAFIAxBD3dzIAJzIgBBF3cgAEEPd3MgBEEHd3MgBnMgAHM2AkggASAOIApBD3dzIAlzIgBBF3cgAEEPd3MgA0EHd3MgDXMgAHM2AkxBACEGQSAhByABIQxBACgCiIkBIhAhCUEAKAKkiQEiESEPQQAoAqCJASISIQ1BACgCnIkBIhMhCEEAKAKYiQEiFCEOQQAoApSJASIVIRZBACgCkIkBIhchA0EAKAKMiQEiGCELA0AgCCAOIgJzIA0iBHMgD2ogCSIAQQx3Ig0gAmpBmYqxzgcgB3ZBmYqxzgcgBnRyakEHdyIPaiAMKAIAIhlqIglBEXcgCUEJd3MgCXMhDiADIgUgC3MgAHMgFmogDyANc2ogDEEQaigCACAZc2ohCSAMQQRqIQwgB0F/aiEHIAhBE3chDSALQQl3IQMgBCEPIAIhCCAFIRYgACELIAZBAWoiBkEQRw0AC0EAIQZBECEHA0AgASAGaiIMQdAAaiAMQThqKAIAIAxBLGooAgAgDEEQaigCAHMgDEHEAGooAgAiFkEPd3MiCEEXd3MgCEEPd3MgDEEcaigCAEEHd3MgCHMiGTYCACANIg8gDiIMQX9zcSACIAxxciAEaiAJIghBDHciDSAMakGKu57UByAHd2pBB3ciBGogCmoiCUERdyAJQQl3cyAJcyEOIAggAyILIABycSALIABxciAFaiAEIA1zaiAZIApzaiEJIAZBBGohBiACQRN3IQ0gAEEJdyEDIBYhCiAPIQQgDCECIAshBSAIIQAgB0EBaiIHQcAARw0AC0EAIA8gEXM2AqSJAUEAIA0gEnM2AqCJAUEAIAwgE3M2ApyJAUEAIA4gFHM2ApiJAUEAIAsgFXM2ApSJAUEAIAMgF3M2ApCJAUEAIAggGHM2AoyJAUEAIAkgEHM2AoiJASABQZACaiQAC4ILAQp/IwBBEGsiACQAIABBACgCgIkBIgFBG3QgAUELdEGAgPwHcXIgAUEFdkGA/gNxIAFBA3RBGHZycjYCDCAAQQAoAoSJASICQQN0IgMgAUEddnIiBEEYdCAEQYD+A3FBCHRyIAJBBXZBgP4DcSADQRh2cnI2AggCQEE4QfgAIAFBP3EiBUE4SRsgBWsiA0UNAEEAIAMgAWoiATYCgIkBAkAgASADTw0AQQAgAkEBajYChIkBC0GQCCEBQQAhBgJAIAVFDQACQCADQcAAIAVrIgdPDQAgBSEGDAELIAVBP3MhCCAFQaiJAWohAUGQCCECAkACQCAHQQdxIgkNACAHIQQMAQsgCSEEA0AgASACLQAAOgAAIAFBAWohASACQQFqIQIgBEF/aiIEDQALQcAAIAkgBWprIQQLAkAgCEEHSQ0AA0AgASACKQAANwAAIAFBCGohASACQQhqIQIgBEF4aiIEDQALC0GoiQEQAyAHQZAIaiEBIAMgB2shAwsCQCADQcAASQ0AA0AgARADIAFBwABqIQEgA0FAaiIDQT9LDQALCyADRQ0AIAZBqIkBaiECAkACQCADQQdxIgQNACADIQUMAQsgA0E4cSEFA0AgAiABLQAAOgAAIAJBAWohAiABQQFqIQEgBEF/aiIEDQALCyADQQhJDQADQCACIAEtAAA6AAAgAiABLQABOgABIAIgAS0AAjoAAiACIAEtAAM6AAMgAiABLQAEOgAEIAIgAS0ABToABSACIAEtAAY6AAYgAiABLQAHOgAHIAJBCGohAiABQQhqIQEgBUF4aiIFDQALC0EAQQAoAoCJASICQQhqNgKAiQEgAkE/cSEBAkAgAkF4SQ0AQQBBACgChIkBQQFqNgKEiQELAkACQAJAAkAgAQ0AQQAhAQwBCyABQThJDQAgAUGoiQFqIAAtAAg6AAACQCABQT9GDQAgAUGpiQFqIAAtAAk6AAAgAUE+Rg0AIAFBqokBaiAALQAKOgAAIAFBPUYNACABQauJAWogAC0ACzoAACABQTxGDQAgAUGsiQFqIAAtAAw6AAAgAUE7Rg0AIAFBrYkBaiAALQANOgAAIAFBOkYNACABQa6JAWogAC0ADjoAACABQTlGDQAgAUGviQFqIAAtAA86AABBqIkBEAMMAwtBqIkBEAMgAkEHcSIERQ0CIAFBR2ohBSAAQQhqQcAAIAFraiECIAFBSGohBkGoiQEhASAEIQMDQCABIAItAAA6AAAgAUEBaiEBIAJBAWohAiADQX9qIgMNAAsgBUEHSQ0CIAYgBGshAwwBCyABQaiJAWohASAAQQhqIQJBCCEDCwNAIAEgAikAADcAACABQQhqIQEgAkEIaiECIANBeGoiAw0ACwtBAEEAKAKIiQEiAUEYdCABQYD+A3FBCHRyIAFBCHZBgP4DcSABQRh2cnI2AoAJQQBBACgCjIkBIgFBGHQgAUGA/gNxQQh0ciABQQh2QYD+A3EgAUEYdnJyNgKECUEAQQAoApCJASIBQRh0IAFBgP4DcUEIdHIgAUEIdkGA/gNxIAFBGHZycjYCiAlBAEEAKAKUiQEiAUEYdCABQYD+A3FBCHRyIAFBCHZBgP4DcSABQRh2cnI2AowJQQBBACgCmIkBIgFBGHQgAUGA/gNxQQh0ciABQQh2QYD+A3EgAUEYdnJyNgKQCUEAQQAoApyJASIBQRh0IAFBgP4DcUEIdHIgAUEIdkGA/gNxIAFBGHZycjYClAlBAEEAKAKgiQEiAUEYdCABQYD+A3FBCHRyIAFBCHZBgP4DcSABQRh2cnI2ApgJQQBBACgCpIkBIgFBGHQgAUGA/gNxQQh0ciABQQh2QYD+A3EgAUEYdnJyNgKcCSAAQRBqJAALBgBBgIkBC5UCAQR/QQBCzdy3nO7Jw/2wfzcCoIkBQQBCvOG8y6qVzpgWNwKYiQFBAELXhZG5gcCBxVo3ApCJAUEAQu+sgJyX16yKyQA3AoiJAUEAQgA3AoCJAQJAIABFDQBBACAANgKAiQFBgAkhAQJAIABBwABJDQBBgAkhAQNAIAEQAyABQcAAaiEBIABBQGoiAEE/Sw0ACyAARQ0BCyAAQX9qIQICQAJAIABBB3EiAw0AQaiJASEEDAELIABBeHEhAEGoiQEhBANAIAQgAS0AADoAACAEQQFqIQQgAUEBaiEBIANBf2oiAw0ACwsgAkEHSQ0AA0AgBCABKQAANwAAIARBCGohBCABQQhqIQEgAEF4aiIADQALCxAECwtRAgBBgAgLBGgAAAAAQZAIC0CAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";
    hash = "b6fb4b8e";
    wasmJson = {
      name,
      data,
      hash
    };
    mutex = new Mutex();
    wasmCache = null;
  }
});

// node_modules/.pnpm/@cosmjs+crypto@0.37.0/node_modules/@cosmjs/crypto/build/libsodium.js
var require_libsodium = __commonJS({
  "node_modules/.pnpm/@cosmjs+crypto@0.37.0/node_modules/@cosmjs/crypto/build/libsodium.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Xchacha20poly1305Ietf = exports.xchacha20NonceLength = exports.Ed25519 = exports.Ed25519Keypair = exports.Argon2id = void 0;
    exports.isArgon2idOptions = isArgon2idOptions;
    var utils_1 = require_build();
    var chacha_js_1 = require_chacha();
    var ed25519_js_1 = require_ed25519();
    var hash_wasm_1 = (init_index_esm(), __toCommonJS(index_esm_exports));
    function isArgon2idOptions(thing) {
      if (!(0, utils_1.isNonNullObject)(thing))
        return false;
      if (typeof thing.outputLength !== "number")
        return false;
      if (typeof thing.opsLimit !== "number")
        return false;
      if (typeof thing.memLimitKib !== "number")
        return false;
      return true;
    }
    var Argon2id = class {
      static async execute(password, salt, options) {
        const opts = {
          password,
          salt,
          outputType: "binary",
          iterations: options.opsLimit,
          memorySize: options.memLimitKib,
          parallelism: 1,
          // no parallelism allowed, just like libsodium
          hashLength: options.outputLength
        };
        if (salt.length !== 16) {
          throw new Error(`Got invalid salt length ${salt.length}. Must be 16.`);
        }
        const hash2 = await (0, hash_wasm_1.argon2id)(opts);
        (0, utils_1.assert)(typeof hash2 !== "string");
        return hash2;
      }
    };
    exports.Argon2id = Argon2id;
    var Ed25519Keypair = class _Ed25519Keypair {
      // a libsodium privkey has the format `<ed25519 privkey> + <ed25519 pubkey>`
      static fromLibsodiumPrivkey(libsodiumPrivkey) {
        if (libsodiumPrivkey.length !== 64) {
          throw new Error(`Unexpected key length ${libsodiumPrivkey.length}. Must be 64.`);
        }
        return new _Ed25519Keypair(libsodiumPrivkey.slice(0, 32), libsodiumPrivkey.slice(32, 64));
      }
      privkey;
      pubkey;
      constructor(privkey, pubkey) {
        this.privkey = privkey;
        this.pubkey = pubkey;
      }
      toLibsodiumPrivkey() {
        return new Uint8Array([...this.privkey, ...this.pubkey]);
      }
    };
    exports.Ed25519Keypair = Ed25519Keypair;
    var Ed25519 = class {
      /**
       * Generates a keypair deterministically from a given 32 bytes seed.
       *
       * This seed equals the Ed25519 private key.
       * For implementation details see crypto_sign_seed_keypair in
       * https://download.libsodium.org/doc/public-key_cryptography/public-key_signatures.html
       * and diagram on https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/
       */
      static async makeKeypair(privKey) {
        const pubKey = ed25519_js_1.ed25519.getPublicKey(privKey);
        return new Ed25519Keypair(privKey, pubKey);
      }
      static async createSignature(message, keyPair) {
        return ed25519_js_1.ed25519.sign(message, keyPair.privkey);
      }
      static async verifySignature(signature, message, pubkey) {
        return ed25519_js_1.ed25519.verify(signature, message, pubkey);
      }
    };
    exports.Ed25519 = Ed25519;
    exports.xchacha20NonceLength = 24;
    var Xchacha20poly1305Ietf = class {
      static async encrypt(message, key, nonce) {
        const additionalAuthenticatedData = void 0;
        const cipher = (0, chacha_js_1.xchacha20poly1305)(key, nonce, additionalAuthenticatedData);
        return cipher.encrypt(message);
      }
      static async decrypt(ciphertext, key, nonce) {
        const additionalAuthenticatedData = void 0;
        const cipher = (0, chacha_js_1.xchacha20poly1305)(key, nonce, additionalAuthenticatedData);
        return cipher.decrypt(ciphertext);
      }
    };
    exports.Xchacha20poly1305Ietf = Xchacha20poly1305Ietf;
  }
});

// node_modules/.pnpm/@cosmjs+crypto@0.37.0/node_modules/@cosmjs/crypto/build/random.js
var require_random = __commonJS({
  "node_modules/.pnpm/@cosmjs+crypto@0.37.0/node_modules/@cosmjs/crypto/build/random.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Random = void 0;
    var Random = class {
      /**
       * Returns `count` cryptographically secure random bytes
       */
      static getBytes(count) {
        const out = new Uint8Array(count);
        globalThis.crypto.getRandomValues(out);
        return out;
      }
    };
    exports.Random = Random;
  }
});

// node_modules/.pnpm/@cosmjs+crypto@0.37.0/node_modules/@cosmjs/crypto/build/ripemd.js
var require_ripemd = __commonJS({
  "node_modules/.pnpm/@cosmjs+crypto@0.37.0/node_modules/@cosmjs/crypto/build/ripemd.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Ripemd160 = void 0;
    exports.ripemd160 = ripemd1602;
    var legacy_js_1 = require_legacy();
    var utils_1 = require_utils2();
    var Ripemd160 = class {
      blockSize = 512 / 8;
      impl = legacy_js_1.ripemd160.create();
      constructor(firstData) {
        if (firstData) {
          this.update(firstData);
        }
      }
      update(data2) {
        this.impl.update((0, utils_1.toRealUint8Array)(data2));
        return this;
      }
      digest() {
        return this.impl.digest();
      }
    };
    exports.Ripemd160 = Ripemd160;
    function ripemd1602(data2) {
      return new Ripemd160(data2).digest();
    }
  }
});

// node_modules/.pnpm/@cosmjs+encoding@0.37.0/node_modules/@cosmjs/encoding/build/ascii.js
var require_ascii = __commonJS({
  "node_modules/.pnpm/@cosmjs+encoding@0.37.0/node_modules/@cosmjs/encoding/build/ascii.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toAscii = toAscii;
    exports.fromAscii = fromAscii;
    function toAscii(input) {
      const toNums = (str2) => str2.split("").map((x3) => {
        const charCode = x3.charCodeAt(0);
        if (charCode < 32 || charCode > 126) {
          throw new Error(`Cannot encode character that is out of printable ASCII range: ${charCode}`);
        }
        return charCode;
      });
      return Uint8Array.from(toNums(input));
    }
    function fromAscii(data2) {
      const fromNums = (listOfNumbers) => listOfNumbers.map((x3) => {
        if (x3 < 32 || x3 > 126) {
          throw new Error(`Cannot decode character that is out of printable ASCII range: ${x3}`);
        }
        return String.fromCharCode(x3);
      });
      return fromNums(Array.from(data2)).join("");
    }
  }
});

// node_modules/.pnpm/@cosmjs+encoding@0.37.0/node_modules/@cosmjs/encoding/build/base64.js
var require_base64 = __commonJS({
  "node_modules/.pnpm/@cosmjs+encoding@0.37.0/node_modules/@cosmjs/encoding/build/base64.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o3, m3, k5, k22) {
      if (k22 === void 0) k22 = k5;
      var desc = Object.getOwnPropertyDescriptor(m3, k5);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k5];
        } };
      }
      Object.defineProperty(o3, k22, desc);
    }) : (function(o3, m3, k5, k22) {
      if (k22 === void 0) k22 = k5;
      o3[k22] = m3[k5];
    }));
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o3, v9) {
      Object.defineProperty(o3, "default", { enumerable: true, value: v9 });
    }) : function(o3, v9) {
      o3["default"] = v9;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
      var ownKeys = function(o3) {
        ownKeys = Object.getOwnPropertyNames || function(o4) {
          var ar3 = [];
          for (var k5 in o4) if (Object.prototype.hasOwnProperty.call(o4, k5)) ar3[ar3.length] = k5;
          return ar3;
        };
        return ownKeys(o3);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k5 = ownKeys(mod), i3 = 0; i3 < k5.length; i3++) if (k5[i3] !== "default") __createBinding(result, mod, k5[i3]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toBase64 = toBase64;
    exports.fromBase64 = fromBase64;
    var base64js = __importStar(require_base64_js());
    function toBase64(data2) {
      return base64js.fromByteArray(data2);
    }
    function fromBase64(base64String) {
      if (!base64String.match(/^[a-zA-Z0-9+/]*={0,2}$/)) {
        throw new Error("Invalid base64 string format");
      }
      return base64js.toByteArray(base64String);
    }
  }
});

// node_modules/.pnpm/@scure+base@2.0.0/node_modules/@scure/base/index.js
var base_exports = {};
__export(base_exports, {
  base16: () => base16,
  base32: () => base32,
  base32crockford: () => base32crockford,
  base32hex: () => base32hex,
  base32hexnopad: () => base32hexnopad,
  base32nopad: () => base32nopad,
  base58: () => base58,
  base58check: () => base58check,
  base58flickr: () => base58flickr,
  base58xmr: () => base58xmr,
  base58xrp: () => base58xrp,
  base64: () => base64,
  base64nopad: () => base64nopad,
  base64url: () => base64url,
  base64urlnopad: () => base64urlnopad,
  bech32: () => bech32,
  bech32m: () => bech32m,
  bytes: () => bytes,
  bytesToString: () => bytesToString,
  createBase58check: () => createBase58check,
  hex: () => hex,
  str: () => str,
  stringToBytes: () => stringToBytes2,
  utf8: () => utf8,
  utils: () => utils
});
function isBytes(a2) {
  return a2 instanceof Uint8Array || ArrayBuffer.isView(a2) && a2.constructor.name === "Uint8Array";
}
function abytes(b5) {
  if (!isBytes(b5))
    throw new Error("Uint8Array expected");
}
function isArrayOf(isString, arr) {
  if (!Array.isArray(arr))
    return false;
  if (arr.length === 0)
    return true;
  if (isString) {
    return arr.every((item) => typeof item === "string");
  } else {
    return arr.every((item) => Number.isSafeInteger(item));
  }
}
function afn(input) {
  if (typeof input !== "function")
    throw new Error("function expected");
  return true;
}
function astr(label, input) {
  if (typeof input !== "string")
    throw new Error(`${label}: string expected`);
  return true;
}
function anumber(n2) {
  if (!Number.isSafeInteger(n2))
    throw new Error(`invalid integer: ${n2}`);
}
function aArr(input) {
  if (!Array.isArray(input))
    throw new Error("array expected");
}
function astrArr(label, input) {
  if (!isArrayOf(true, input))
    throw new Error(`${label}: array of strings expected`);
}
function anumArr(label, input) {
  if (!isArrayOf(false, input))
    throw new Error(`${label}: array of numbers expected`);
}
function chain(...args) {
  const id = (a2) => a2;
  const wrap = (a2, b5) => (c3) => a2(b5(c3));
  const encode = args.map((x3) => x3.encode).reduceRight(wrap, id);
  const decode = args.map((x3) => x3.decode).reduce(wrap, id);
  return { encode, decode };
}
function alphabet(letters) {
  const lettersA = typeof letters === "string" ? letters.split("") : letters;
  const len = lettersA.length;
  astrArr("alphabet", lettersA);
  const indexes = new Map(lettersA.map((l3, i3) => [l3, i3]));
  return {
    encode: (digits) => {
      aArr(digits);
      return digits.map((i3) => {
        if (!Number.isSafeInteger(i3) || i3 < 0 || i3 >= len)
          throw new Error(`alphabet.encode: digit index outside alphabet "${i3}". Allowed: ${letters}`);
        return lettersA[i3];
      });
    },
    decode: (input) => {
      aArr(input);
      return input.map((letter) => {
        astr("alphabet.decode", letter);
        const i3 = indexes.get(letter);
        if (i3 === void 0)
          throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);
        return i3;
      });
    }
  };
}
function join(separator = "") {
  astr("join", separator);
  return {
    encode: (from) => {
      astrArr("join.decode", from);
      return from.join(separator);
    },
    decode: (to3) => {
      astr("join.decode", to3);
      return to3.split(separator);
    }
  };
}
function padding(bits, chr = "=") {
  anumber(bits);
  astr("padding", chr);
  return {
    encode(data2) {
      astrArr("padding.encode", data2);
      while (data2.length * bits % 8)
        data2.push(chr);
      return data2;
    },
    decode(input) {
      astrArr("padding.decode", input);
      let end = input.length;
      if (end * bits % 8)
        throw new Error("padding: invalid, string should have whole number of bytes");
      for (; end > 0 && input[end - 1] === chr; end--) {
        const last = end - 1;
        const byte = last * bits;
        if (byte % 8 === 0)
          throw new Error("padding: invalid, string has too much padding");
      }
      return input.slice(0, end);
    }
  };
}
function normalize(fn3) {
  afn(fn3);
  return { encode: (from) => from, decode: (to3) => fn3(to3) };
}
function convertRadix(data2, from, to3) {
  if (from < 2)
    throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);
  if (to3 < 2)
    throw new Error(`convertRadix: invalid to=${to3}, base cannot be less than 2`);
  aArr(data2);
  if (!data2.length)
    return [];
  let pos = 0;
  const res = [];
  const digits = Array.from(data2, (d3) => {
    anumber(d3);
    if (d3 < 0 || d3 >= from)
      throw new Error(`invalid integer: ${d3}`);
    return d3;
  });
  const dlen = digits.length;
  while (true) {
    let carry = 0;
    let done = true;
    for (let i3 = pos; i3 < dlen; i3++) {
      const digit2 = digits[i3];
      const fromCarry = from * carry;
      const digitBase = fromCarry + digit2;
      if (!Number.isSafeInteger(digitBase) || fromCarry / from !== carry || digitBase - digit2 !== fromCarry) {
        throw new Error("convertRadix: carry overflow");
      }
      const div = digitBase / to3;
      carry = digitBase % to3;
      const rounded = Math.floor(div);
      digits[i3] = rounded;
      if (!Number.isSafeInteger(rounded) || rounded * to3 + carry !== digitBase)
        throw new Error("convertRadix: carry overflow");
      if (!done)
        continue;
      else if (!rounded)
        pos = i3;
      else
        done = false;
    }
    res.push(carry);
    if (done)
      break;
  }
  for (let i3 = 0; i3 < data2.length - 1 && data2[i3] === 0; i3++)
    res.push(0);
  return res.reverse();
}
function convertRadix2(data2, from, to3, padding2) {
  aArr(data2);
  if (from <= 0 || from > 32)
    throw new Error(`convertRadix2: wrong from=${from}`);
  if (to3 <= 0 || to3 > 32)
    throw new Error(`convertRadix2: wrong to=${to3}`);
  if (radix2carry(from, to3) > 32) {
    throw new Error(`convertRadix2: carry overflow from=${from} to=${to3} carryBits=${radix2carry(from, to3)}`);
  }
  let carry = 0;
  let pos = 0;
  const max = powers[from];
  const mask = powers[to3] - 1;
  const res = [];
  for (const n2 of data2) {
    anumber(n2);
    if (n2 >= max)
      throw new Error(`convertRadix2: invalid data word=${n2} from=${from}`);
    carry = carry << from | n2;
    if (pos + from > 32)
      throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
    pos += from;
    for (; pos >= to3; pos -= to3)
      res.push((carry >> pos - to3 & mask) >>> 0);
    const pow = powers[pos];
    if (pow === void 0)
      throw new Error("invalid carry");
    carry &= pow - 1;
  }
  carry = carry << to3 - pos & mask;
  if (!padding2 && pos >= from)
    throw new Error("Excess padding");
  if (!padding2 && carry > 0)
    throw new Error(`Non-zero padding: ${carry}`);
  if (padding2 && pos > 0)
    res.push(carry >>> 0);
  return res;
}
function radix(num) {
  anumber(num);
  const _256 = 2 ** 8;
  return {
    encode: (bytes2) => {
      if (!isBytes(bytes2))
        throw new Error("radix.encode input should be Uint8Array");
      return convertRadix(Array.from(bytes2), _256, num);
    },
    decode: (digits) => {
      anumArr("radix.decode", digits);
      return Uint8Array.from(convertRadix(digits, num, _256));
    }
  };
}
function radix2(bits, revPadding = false) {
  anumber(bits);
  if (bits <= 0 || bits > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (bytes2) => {
      if (!isBytes(bytes2))
        throw new Error("radix2.encode input should be Uint8Array");
      return convertRadix2(Array.from(bytes2), 8, bits, !revPadding);
    },
    decode: (digits) => {
      anumArr("radix2.decode", digits);
      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
    }
  };
}
function unsafeWrapper(fn3) {
  afn(fn3);
  return function(...args) {
    try {
      return fn3.apply(null, args);
    } catch (e) {
    }
  };
}
function checksum(len, fn3) {
  anumber(len);
  afn(fn3);
  return {
    encode(data2) {
      if (!isBytes(data2))
        throw new Error("checksum.encode: input should be Uint8Array");
      const sum = fn3(data2).slice(0, len);
      const res = new Uint8Array(data2.length + len);
      res.set(data2);
      res.set(sum, data2.length);
      return res;
    },
    decode(data2) {
      if (!isBytes(data2))
        throw new Error("checksum.decode: input should be Uint8Array");
      const payload = data2.slice(0, -len);
      const oldChecksum = data2.slice(-len);
      const newChecksum = fn3(payload).slice(0, len);
      for (let i3 = 0; i3 < len; i3++)
        if (newChecksum[i3] !== oldChecksum[i3])
          throw new Error("Invalid checksum");
      return payload;
    }
  };
}
function bech32Polymod(pre) {
  const b5 = pre >> 25;
  let chk = (pre & 33554431) << 5;
  for (let i3 = 0; i3 < POLYMOD_GENERATORS.length; i3++) {
    if ((b5 >> i3 & 1) === 1)
      chk ^= POLYMOD_GENERATORS[i3];
  }
  return chk;
}
function bechChecksum(prefix, words, encodingConst = 1) {
  const len = prefix.length;
  let chk = 1;
  for (let i3 = 0; i3 < len; i3++) {
    const c3 = prefix.charCodeAt(i3);
    if (c3 < 33 || c3 > 126)
      throw new Error(`Invalid prefix (${prefix})`);
    chk = bech32Polymod(chk) ^ c3 >> 5;
  }
  chk = bech32Polymod(chk);
  for (let i3 = 0; i3 < len; i3++)
    chk = bech32Polymod(chk) ^ prefix.charCodeAt(i3) & 31;
  for (let v9 of words)
    chk = bech32Polymod(chk) ^ v9;
  for (let i3 = 0; i3 < 6; i3++)
    chk = bech32Polymod(chk);
  chk ^= encodingConst;
  return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]], 30, 5, false));
}
function genBech32(encoding) {
  const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
  const _words = radix2(5);
  const fromWords = _words.decode;
  const toWords = _words.encode;
  const fromWordsUnsafe = unsafeWrapper(fromWords);
  function encode(prefix, words, limit = 90) {
    astr("bech32.encode prefix", prefix);
    if (isBytes(words))
      words = Array.from(words);
    anumArr("bech32.encode", words);
    const plen = prefix.length;
    if (plen === 0)
      throw new TypeError(`Invalid prefix length ${plen}`);
    const actualLength = plen + 7 + words.length;
    if (limit !== false && actualLength > limit)
      throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
    const lowered = prefix.toLowerCase();
    const sum = bechChecksum(lowered, words, ENCODING_CONST);
    return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
  }
  function decode(str2, limit = 90) {
    astr("bech32.decode input", str2);
    const slen = str2.length;
    if (slen < 8 || limit !== false && slen > limit)
      throw new TypeError(`invalid string length: ${slen} (${str2}). Expected (8..${limit})`);
    const lowered = str2.toLowerCase();
    if (str2 !== lowered && str2 !== str2.toUpperCase())
      throw new Error(`String must be lowercase or uppercase`);
    const sepIndex = lowered.lastIndexOf("1");
    if (sepIndex === 0 || sepIndex === -1)
      throw new Error(`Letter "1" must be present between prefix and data only`);
    const prefix = lowered.slice(0, sepIndex);
    const data2 = lowered.slice(sepIndex + 1);
    if (data2.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const words = BECH_ALPHABET.decode(data2).slice(0, -6);
    const sum = bechChecksum(prefix, words, ENCODING_CONST);
    if (!data2.endsWith(sum))
      throw new Error(`Invalid checksum in ${str2}: expected "${sum}"`);
    return { prefix, words };
  }
  const decodeUnsafe = unsafeWrapper(decode);
  function decodeToBytes(str2) {
    const { prefix, words } = decode(str2, false);
    return { prefix, words, bytes: fromWords(words) };
  }
  function encodeFromBytes(prefix, bytes2) {
    return encode(prefix, toWords(bytes2));
  }
  return {
    encode,
    decode,
    encodeFromBytes,
    decodeToBytes,
    decodeUnsafe,
    fromWords,
    fromWordsUnsafe,
    toWords
  };
}
var gcd, radix2carry, powers, utils, base16, base32, base32nopad, base32hex, base32hexnopad, base32crockford, hasBase64Builtin, decodeBase64Builtin, base64, base64nopad, base64url, base64urlnopad, genBase58, base58, base58flickr, base58xrp, XMR_BLOCK_LEN, base58xmr, createBase58check, base58check, BECH_ALPHABET, POLYMOD_GENERATORS, bech32, bech32m, utf8, hasHexBuiltin, hexBuiltin, hex, CODERS, coderTypeError, bytesToString, str, stringToBytes2, bytes;
var init_base = __esm({
  "node_modules/.pnpm/@scure+base@2.0.0/node_modules/@scure/base/index.js"() {
    gcd = (a2, b5) => b5 === 0 ? a2 : gcd(b5, a2 % b5);
    radix2carry = (from, to3) => from + (to3 - gcd(from, to3));
    powers = (() => {
      let res = [];
      for (let i3 = 0; i3 < 40; i3++)
        res.push(2 ** i3);
      return res;
    })();
    utils = {
      alphabet,
      chain,
      checksum,
      convertRadix,
      convertRadix2,
      radix,
      radix2,
      join,
      padding
    };
    base16 = chain(radix2(4), alphabet("0123456789ABCDEF"), join(""));
    base32 = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding(5), join(""));
    base32nopad = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), join(""));
    base32hex = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding(5), join(""));
    base32hexnopad = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), join(""));
    base32crockford = chain(radix2(5), alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join(""), normalize((s2) => s2.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
    hasBase64Builtin = (() => typeof Uint8Array.from([]).toBase64 === "function" && typeof Uint8Array.fromBase64 === "function")();
    decodeBase64Builtin = (s2, isUrl) => {
      astr("base64", s2);
      const re4 = isUrl ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/;
      const alphabet2 = isUrl ? "base64url" : "base64";
      if (s2.length > 0 && !re4.test(s2))
        throw new Error("invalid base64");
      return Uint8Array.fromBase64(s2, { alphabet: alphabet2, lastChunkHandling: "strict" });
    };
    base64 = hasBase64Builtin ? {
      encode(b5) {
        abytes(b5);
        return b5.toBase64();
      },
      decode(s2) {
        return decodeBase64Builtin(s2, false);
      }
    } : chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding(6), join(""));
    base64nopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), join(""));
    base64url = hasBase64Builtin ? {
      encode(b5) {
        abytes(b5);
        return b5.toBase64({ alphabet: "base64url" });
      },
      decode(s2) {
        return decodeBase64Builtin(s2, true);
      }
    } : chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding(6), join(""));
    base64urlnopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), join(""));
    genBase58 = (abc) => chain(radix(58), alphabet(abc), join(""));
    base58 = genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
    base58flickr = genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
    base58xrp = genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
    XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];
    base58xmr = {
      encode(data2) {
        let res = "";
        for (let i3 = 0; i3 < data2.length; i3 += 8) {
          const block = data2.subarray(i3, i3 + 8);
          res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], "1");
        }
        return res;
      },
      decode(str2) {
        let res = [];
        for (let i3 = 0; i3 < str2.length; i3 += 11) {
          const slice = str2.slice(i3, i3 + 11);
          const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);
          const block = base58.decode(slice);
          for (let j3 = 0; j3 < block.length - blockLen; j3++) {
            if (block[j3] !== 0)
              throw new Error("base58xmr: wrong padding");
          }
          res = res.concat(Array.from(block.slice(block.length - blockLen)));
        }
        return Uint8Array.from(res);
      }
    };
    createBase58check = (sha2563) => chain(checksum(4, (data2) => sha2563(sha2563(data2))), base58);
    base58check = createBase58check;
    BECH_ALPHABET = chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join(""));
    POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
    bech32 = genBech32("bech32");
    bech32m = genBech32("bech32m");
    utf8 = {
      encode: (data2) => new TextDecoder().decode(data2),
      decode: (str2) => new TextEncoder().encode(str2)
    };
    hasHexBuiltin = (() => typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function")();
    hexBuiltin = {
      encode(data2) {
        abytes(data2);
        return data2.toHex();
      },
      decode(s2) {
        astr("hex", s2);
        return Uint8Array.fromHex(s2);
      }
    };
    hex = hasHexBuiltin ? hexBuiltin : chain(radix2(4), alphabet("0123456789abcdef"), join(""), normalize((s2) => {
      if (typeof s2 !== "string" || s2.length % 2 !== 0)
        throw new TypeError(`hex.decode: expected string, got ${typeof s2} with length ${s2.length}`);
      return s2.toLowerCase();
    }));
    CODERS = {
      utf8,
      hex,
      base16,
      base32,
      base64,
      base64url,
      base58,
      base58xmr
    };
    coderTypeError = "Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr";
    bytesToString = (type, bytes2) => {
      if (typeof type !== "string" || !CODERS.hasOwnProperty(type))
        throw new TypeError(coderTypeError);
      if (!isBytes(bytes2))
        throw new TypeError("bytesToString() expects Uint8Array");
      return CODERS[type].encode(bytes2);
    };
    str = bytesToString;
    stringToBytes2 = (type, str2) => {
      if (!CODERS.hasOwnProperty(type))
        throw new TypeError(coderTypeError);
      if (typeof str2 !== "string")
        throw new TypeError("stringToBytes() expects string");
      return CODERS[type].decode(str2);
    };
    bytes = stringToBytes2;
  }
});

// node_modules/.pnpm/@cosmjs+encoding@0.37.0/node_modules/@cosmjs/encoding/build/bech32.js
var require_bech32 = __commonJS({
  "node_modules/.pnpm/@cosmjs+encoding@0.37.0/node_modules/@cosmjs/encoding/build/bech32.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toBech32 = toBech32;
    exports.fromBech32 = fromBech322;
    exports.normalizeBech32 = normalizeBech32;
    var base_1 = (init_base(), __toCommonJS(base_exports));
    function toBech32(prefix, data2, limit) {
      const address = base_1.bech32.encode(prefix, base_1.bech32.toWords(data2), limit);
      return address;
    }
    function hasBech32Separator(input) {
      return input.indexOf("1") !== -1;
    }
    function fromBech322(address, limit = Infinity) {
      if (!hasBech32Separator(address))
        throw new Error(`No bech32 separator found`);
      const decodedAddress = base_1.bech32.decode(address, limit);
      return {
        prefix: decodedAddress.prefix,
        data: new Uint8Array(base_1.bech32.fromWords(decodedAddress.words))
      };
    }
    function normalizeBech32(address) {
      const { prefix, data: data2 } = fromBech322(address);
      return toBech32(prefix, data2);
    }
  }
});

// node_modules/.pnpm/@cosmjs+encoding@0.37.0/node_modules/@cosmjs/encoding/build/hex.js
var require_hex = __commonJS({
  "node_modules/.pnpm/@cosmjs+encoding@0.37.0/node_modules/@cosmjs/encoding/build/hex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toHex = toHex;
    exports.fromHex = fromHex;
    function toHex(data2) {
      let out = "";
      for (const byte of data2) {
        out += ("0" + byte.toString(16)).slice(-2);
      }
      return out;
    }
    function fromHex(hexstring) {
      if (hexstring.length % 2 !== 0) {
        throw new Error("hex string length must be a multiple of 2");
      }
      const out = new Uint8Array(hexstring.length / 2);
      for (let i3 = 0; i3 < out.length; i3++) {
        const j3 = 2 * i3;
        const hexByteAsString = hexstring.slice(j3, j3 + 2);
        if (!hexByteAsString.match(/[0-9a-f]{2}/i)) {
          throw new Error("hex string contains invalid characters");
        }
        out[i3] = parseInt(hexByteAsString, 16);
      }
      return out;
    }
  }
});

// node_modules/.pnpm/@cosmjs+encoding@0.37.0/node_modules/@cosmjs/encoding/build/rfc3339.js
var require_rfc3339 = __commonJS({
  "node_modules/.pnpm/@cosmjs+encoding@0.37.0/node_modules/@cosmjs/encoding/build/rfc3339.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromRfc3339 = fromRfc3339;
    exports.toRfc3339 = toRfc3339;
    var rfc3339Matcher = /^(\d{4})-(\d{2})-(\d{2})[T ](\d{2}):(\d{2}):(\d{2})(\.\d{1,9})?((?:[+-]\d{2}:\d{2})|Z)$/;
    function padded(integer, length = 2) {
      return integer.toString().padStart(length, "0");
    }
    function fromRfc3339(str2) {
      const matches = rfc3339Matcher.exec(str2);
      if (!matches) {
        throw new Error("Date string is not in RFC3339 format");
      }
      const year = +matches[1];
      const month = +matches[2];
      const day = +matches[3];
      const hour = +matches[4];
      const minute = +matches[5];
      const second = +matches[6];
      const milliSeconds = matches[7] ? Math.floor(+matches[7] * 1e3) : 0;
      let tzOffsetSign;
      let tzOffsetHours;
      let tzOffsetMinutes;
      if (matches[8] === "Z") {
        tzOffsetSign = 1;
        tzOffsetHours = 0;
        tzOffsetMinutes = 0;
      } else {
        tzOffsetSign = matches[8].substring(0, 1) === "-" ? -1 : 1;
        tzOffsetHours = +matches[8].substring(1, 3);
        tzOffsetMinutes = +matches[8].substring(4, 6);
      }
      const tzOffset = tzOffsetSign * (tzOffsetHours * 60 + tzOffsetMinutes) * 60;
      const date = /* @__PURE__ */ new Date();
      date.setUTCFullYear(year, month - 1, day);
      date.setUTCHours(hour, minute, second, milliSeconds);
      return new Date(date.getTime() - tzOffset * 1e3);
    }
    function toRfc3339(date) {
      const year = date.getUTCFullYear();
      const month = padded(date.getUTCMonth() + 1);
      const day = padded(date.getUTCDate());
      const hour = padded(date.getUTCHours());
      const minute = padded(date.getUTCMinutes());
      const second = padded(date.getUTCSeconds());
      const ms2 = padded(date.getUTCMilliseconds(), 3);
      return `${year}-${month}-${day}T${hour}:${minute}:${second}.${ms2}Z`;
    }
  }
});

// node_modules/.pnpm/@cosmjs+encoding@0.37.0/node_modules/@cosmjs/encoding/build/utf8.js
var require_utf8 = __commonJS({
  "node_modules/.pnpm/@cosmjs+encoding@0.37.0/node_modules/@cosmjs/encoding/build/utf8.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toUtf8 = toUtf8;
    exports.fromUtf8 = fromUtf8;
    function toUtf8(str2) {
      return new TextEncoder().encode(str2);
    }
    function fromUtf8(data2, lossy = false) {
      const fatal = !lossy;
      return new TextDecoder("utf-8", { fatal }).decode(data2);
    }
  }
});

// node_modules/.pnpm/@cosmjs+encoding@0.37.0/node_modules/@cosmjs/encoding/build/index.js
var require_build2 = __commonJS({
  "node_modules/.pnpm/@cosmjs+encoding@0.37.0/node_modules/@cosmjs/encoding/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toUtf8 = exports.fromUtf8 = exports.toRfc3339 = exports.fromRfc3339 = exports.toHex = exports.fromHex = exports.toBech32 = exports.normalizeBech32 = exports.fromBech32 = exports.toBase64 = exports.fromBase64 = exports.toAscii = exports.fromAscii = void 0;
    var ascii_1 = require_ascii();
    Object.defineProperty(exports, "fromAscii", { enumerable: true, get: function() {
      return ascii_1.fromAscii;
    } });
    Object.defineProperty(exports, "toAscii", { enumerable: true, get: function() {
      return ascii_1.toAscii;
    } });
    var base64_1 = require_base64();
    Object.defineProperty(exports, "fromBase64", { enumerable: true, get: function() {
      return base64_1.fromBase64;
    } });
    Object.defineProperty(exports, "toBase64", { enumerable: true, get: function() {
      return base64_1.toBase64;
    } });
    var bech32_1 = require_bech32();
    Object.defineProperty(exports, "fromBech32", { enumerable: true, get: function() {
      return bech32_1.fromBech32;
    } });
    Object.defineProperty(exports, "normalizeBech32", { enumerable: true, get: function() {
      return bech32_1.normalizeBech32;
    } });
    Object.defineProperty(exports, "toBech32", { enumerable: true, get: function() {
      return bech32_1.toBech32;
    } });
    var hex_1 = require_hex();
    Object.defineProperty(exports, "fromHex", { enumerable: true, get: function() {
      return hex_1.fromHex;
    } });
    Object.defineProperty(exports, "toHex", { enumerable: true, get: function() {
      return hex_1.toHex;
    } });
    var rfc3339_1 = require_rfc3339();
    Object.defineProperty(exports, "fromRfc3339", { enumerable: true, get: function() {
      return rfc3339_1.fromRfc3339;
    } });
    Object.defineProperty(exports, "toRfc3339", { enumerable: true, get: function() {
      return rfc3339_1.toRfc3339;
    } });
    var utf8_1 = require_utf8();
    Object.defineProperty(exports, "fromUtf8", { enumerable: true, get: function() {
      return utf8_1.fromUtf8;
    } });
    Object.defineProperty(exports, "toUtf8", { enumerable: true, get: function() {
      return utf8_1.toUtf8;
    } });
  }
});

// node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/abstract/weierstrass.js
var require_weierstrass = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/abstract/weierstrass.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DER = exports.DERErr = void 0;
    exports._splitEndoScalar = _splitEndoScalar;
    exports._normFnElement = _normFnElement;
    exports.weierstrassN = weierstrassN;
    exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
    exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
    exports.ecdh = ecdh;
    exports.ecdsa = ecdsa;
    exports.weierstrassPoints = weierstrassPoints;
    exports._legacyHelperEquat = _legacyHelperEquat;
    exports.weierstrass = weierstrass;
    var hmac_js_1 = require_hmac();
    var utils_1 = require_utils();
    var utils_ts_1 = require_utils4();
    var curve_ts_1 = require_curve();
    var modular_ts_1 = require_modular();
    var divNearest = (num, den) => (num + (num >= 0 ? den : -den) / _2n) / den;
    function _splitEndoScalar(k5, basis, n2) {
      const [[a1, b1], [a2, b22]] = basis;
      const c1 = divNearest(b22 * k5, n2);
      const c22 = divNearest(-b1 * k5, n2);
      let k1 = k5 - c1 * a1 - c22 * a2;
      let k22 = -c1 * b1 - c22 * b22;
      const k1neg = k1 < _0n;
      const k2neg = k22 < _0n;
      if (k1neg)
        k1 = -k1;
      if (k2neg)
        k22 = -k22;
      const MAX_NUM = (0, utils_ts_1.bitMask)(Math.ceil((0, utils_ts_1.bitLen)(n2) / 2)) + _1n;
      if (k1 < _0n || k1 >= MAX_NUM || k22 < _0n || k22 >= MAX_NUM) {
        throw new Error("splitScalar (endomorphism): failed, k=" + k5);
      }
      return { k1neg, k1, k2neg, k2: k22 };
    }
    function validateSigFormat(format) {
      if (!["compact", "recovered", "der"].includes(format))
        throw new Error('Signature format must be "compact", "recovered", or "der"');
      return format;
    }
    function validateSigOpts(opts, def) {
      const optsn = {};
      for (let optName of Object.keys(def)) {
        optsn[optName] = opts[optName] === void 0 ? def[optName] : opts[optName];
      }
      (0, utils_ts_1._abool2)(optsn.lowS, "lowS");
      (0, utils_ts_1._abool2)(optsn.prehash, "prehash");
      if (optsn.format !== void 0)
        validateSigFormat(optsn.format);
      return optsn;
    }
    var DERErr = class extends Error {
      constructor(m3 = "") {
        super(m3);
      }
    };
    exports.DERErr = DERErr;
    exports.DER = {
      // asn.1 DER encoding utils
      Err: DERErr,
      // Basic building block is TLV (Tag-Length-Value)
      _tlv: {
        encode: (tag, data2) => {
          const { Err: E5 } = exports.DER;
          if (tag < 0 || tag > 256)
            throw new E5("tlv.encode: wrong tag");
          if (data2.length & 1)
            throw new E5("tlv.encode: unpadded data");
          const dataLen = data2.length / 2;
          const len = (0, utils_ts_1.numberToHexUnpadded)(dataLen);
          if (len.length / 2 & 128)
            throw new E5("tlv.encode: long form length too big");
          const lenLen = dataLen > 127 ? (0, utils_ts_1.numberToHexUnpadded)(len.length / 2 | 128) : "";
          const t = (0, utils_ts_1.numberToHexUnpadded)(tag);
          return t + lenLen + len + data2;
        },
        // v - value, l - left bytes (unparsed)
        decode(tag, data2) {
          const { Err: E5 } = exports.DER;
          let pos = 0;
          if (tag < 0 || tag > 256)
            throw new E5("tlv.encode: wrong tag");
          if (data2.length < 2 || data2[pos++] !== tag)
            throw new E5("tlv.decode: wrong tlv");
          const first = data2[pos++];
          const isLong2 = !!(first & 128);
          let length = 0;
          if (!isLong2)
            length = first;
          else {
            const lenLen = first & 127;
            if (!lenLen)
              throw new E5("tlv.decode(long): indefinite length not supported");
            if (lenLen > 4)
              throw new E5("tlv.decode(long): byte length is too big");
            const lengthBytes = data2.subarray(pos, pos + lenLen);
            if (lengthBytes.length !== lenLen)
              throw new E5("tlv.decode: length bytes not complete");
            if (lengthBytes[0] === 0)
              throw new E5("tlv.decode(long): zero leftmost byte");
            for (const b5 of lengthBytes)
              length = length << 8 | b5;
            pos += lenLen;
            if (length < 128)
              throw new E5("tlv.decode(long): not minimal encoding");
          }
          const v9 = data2.subarray(pos, pos + length);
          if (v9.length !== length)
            throw new E5("tlv.decode: wrong value length");
          return { v: v9, l: data2.subarray(pos + length) };
        }
      },
      // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
      // since we always use positive integers here. It must always be empty:
      // - add zero byte if exists
      // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
      _int: {
        encode(num) {
          const { Err: E5 } = exports.DER;
          if (num < _0n)
            throw new E5("integer: negative integers are not allowed");
          let hex2 = (0, utils_ts_1.numberToHexUnpadded)(num);
          if (Number.parseInt(hex2[0], 16) & 8)
            hex2 = "00" + hex2;
          if (hex2.length & 1)
            throw new E5("unexpected DER parsing assertion: unpadded hex");
          return hex2;
        },
        decode(data2) {
          const { Err: E5 } = exports.DER;
          if (data2[0] & 128)
            throw new E5("invalid signature integer: negative");
          if (data2[0] === 0 && !(data2[1] & 128))
            throw new E5("invalid signature integer: unnecessary leading zero");
          return (0, utils_ts_1.bytesToNumberBE)(data2);
        }
      },
      toSig(hex2) {
        const { Err: E5, _int: int, _tlv: tlv } = exports.DER;
        const data2 = (0, utils_ts_1.ensureBytes)("signature", hex2);
        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data2);
        if (seqLeftBytes.length)
          throw new E5("invalid signature: left bytes after parsing");
        const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);
        const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);
        if (sLeftBytes.length)
          throw new E5("invalid signature: left bytes after parsing");
        return { r: int.decode(rBytes), s: int.decode(sBytes) };
      },
      hexFromSig(sig) {
        const { _tlv: tlv, _int: int } = exports.DER;
        const rs2 = tlv.encode(2, int.encode(sig.r));
        const ss = tlv.encode(2, int.encode(sig.s));
        const seq = rs2 + ss;
        return tlv.encode(48, seq);
      }
    };
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _4n = BigInt(4);
    function _normFnElement(Fn3, key) {
      const { BYTES: expected } = Fn3;
      let num;
      if (typeof key === "bigint") {
        num = key;
      } else {
        let bytes2 = (0, utils_ts_1.ensureBytes)("private key", key);
        try {
          num = Fn3.fromBytes(bytes2);
        } catch (error) {
          throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);
        }
      }
      if (!Fn3.isValidNot0(num))
        throw new Error("invalid private key: out of range [1..N-1]");
      return num;
    }
    function weierstrassN(params, extraOpts = {}) {
      const validated = (0, curve_ts_1._createCurveFields)("weierstrass", params, extraOpts);
      const { Fp, Fn: Fn3 } = validated;
      let CURVE = validated.CURVE;
      const { h: cofactor, n: CURVE_ORDER } = CURVE;
      (0, utils_ts_1._validateObject)(extraOpts, {}, {
        allowInfinityPoint: "boolean",
        clearCofactor: "function",
        isTorsionFree: "function",
        fromBytes: "function",
        toBytes: "function",
        endo: "object",
        wrapPrivateKey: "boolean"
      });
      const { endo } = extraOpts;
      if (endo) {
        if (!Fp.is0(CURVE.a) || typeof endo.beta !== "bigint" || !Array.isArray(endo.basises)) {
          throw new Error('invalid endo: expected "beta": bigint and "basises": array');
        }
      }
      const lengths = getWLengths(Fp, Fn3);
      function assertCompressionIsSupported() {
        if (!Fp.isOdd)
          throw new Error("compression is not supported: Field does not have .isOdd()");
      }
      function pointToBytes(_c2, point, isCompressed) {
        const { x: x3, y: y4 } = point.toAffine();
        const bx = Fp.toBytes(x3);
        (0, utils_ts_1._abool2)(isCompressed, "isCompressed");
        if (isCompressed) {
          assertCompressionIsSupported();
          const hasEvenY = !Fp.isOdd(y4);
          return (0, utils_ts_1.concatBytes)(pprefix(hasEvenY), bx);
        } else {
          return (0, utils_ts_1.concatBytes)(Uint8Array.of(4), bx, Fp.toBytes(y4));
        }
      }
      function pointFromBytes(bytes2) {
        (0, utils_ts_1._abytes2)(bytes2, void 0, "Point");
        const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths;
        const length = bytes2.length;
        const head = bytes2[0];
        const tail = bytes2.subarray(1);
        if (length === comp && (head === 2 || head === 3)) {
          const x3 = Fp.fromBytes(tail);
          if (!Fp.isValid(x3))
            throw new Error("bad point: is not on curve, wrong x");
          const y22 = weierstrassEquation(x3);
          let y4;
          try {
            y4 = Fp.sqrt(y22);
          } catch (sqrtError) {
            const err = sqrtError instanceof Error ? ": " + sqrtError.message : "";
            throw new Error("bad point: is not on curve, sqrt error" + err);
          }
          assertCompressionIsSupported();
          const isYOdd = Fp.isOdd(y4);
          const isHeadOdd = (head & 1) === 1;
          if (isHeadOdd !== isYOdd)
            y4 = Fp.neg(y4);
          return { x: x3, y: y4 };
        } else if (length === uncomp && head === 4) {
          const L3 = Fp.BYTES;
          const x3 = Fp.fromBytes(tail.subarray(0, L3));
          const y4 = Fp.fromBytes(tail.subarray(L3, L3 * 2));
          if (!isValidXY(x3, y4))
            throw new Error("bad point: is not on curve");
          return { x: x3, y: y4 };
        } else {
          throw new Error(`bad point: got length ${length}, expected compressed=${comp} or uncompressed=${uncomp}`);
        }
      }
      const encodePoint = extraOpts.toBytes || pointToBytes;
      const decodePoint = extraOpts.fromBytes || pointFromBytes;
      function weierstrassEquation(x3) {
        const x22 = Fp.sqr(x3);
        const x32 = Fp.mul(x22, x3);
        return Fp.add(Fp.add(x32, Fp.mul(x3, CURVE.a)), CURVE.b);
      }
      function isValidXY(x3, y4) {
        const left = Fp.sqr(y4);
        const right = weierstrassEquation(x3);
        return Fp.eql(left, right);
      }
      if (!isValidXY(CURVE.Gx, CURVE.Gy))
        throw new Error("bad curve params: generator point");
      const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);
      const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));
      if (Fp.is0(Fp.add(_4a3, _27b2)))
        throw new Error("bad curve params: a or b");
      function acoord(title, n2, banZero = false) {
        if (!Fp.isValid(n2) || banZero && Fp.is0(n2))
          throw new Error(`bad point coordinate ${title}`);
        return n2;
      }
      function aprjpoint(other) {
        if (!(other instanceof Point))
          throw new Error("ProjectivePoint expected");
      }
      function splitEndoScalarN(k5) {
        if (!endo || !endo.basises)
          throw new Error("no endo");
        return _splitEndoScalar(k5, endo.basises, Fn3.ORDER);
      }
      const toAffineMemo = (0, utils_ts_1.memoized)((p4, iz) => {
        const { X: X3, Y: Y6, Z: Z3 } = p4;
        if (Fp.eql(Z3, Fp.ONE))
          return { x: X3, y: Y6 };
        const is0 = p4.is0();
        if (iz == null)
          iz = is0 ? Fp.ONE : Fp.inv(Z3);
        const x3 = Fp.mul(X3, iz);
        const y4 = Fp.mul(Y6, iz);
        const zz = Fp.mul(Z3, iz);
        if (is0)
          return { x: Fp.ZERO, y: Fp.ZERO };
        if (!Fp.eql(zz, Fp.ONE))
          throw new Error("invZ was invalid");
        return { x: x3, y: y4 };
      });
      const assertValidMemo = (0, utils_ts_1.memoized)((p4) => {
        if (p4.is0()) {
          if (extraOpts.allowInfinityPoint && !Fp.is0(p4.Y))
            return;
          throw new Error("bad point: ZERO");
        }
        const { x: x3, y: y4 } = p4.toAffine();
        if (!Fp.isValid(x3) || !Fp.isValid(y4))
          throw new Error("bad point: x or y not field elements");
        if (!isValidXY(x3, y4))
          throw new Error("bad point: equation left != right");
        if (!p4.isTorsionFree())
          throw new Error("bad point: not in prime-order subgroup");
        return true;
      });
      function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
        k2p = new Point(Fp.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);
        k1p = (0, curve_ts_1.negateCt)(k1neg, k1p);
        k2p = (0, curve_ts_1.negateCt)(k2neg, k2p);
        return k1p.add(k2p);
      }
      class Point {
        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
        constructor(X3, Y6, Z3) {
          this.X = acoord("x", X3);
          this.Y = acoord("y", Y6, true);
          this.Z = acoord("z", Z3);
          Object.freeze(this);
        }
        static CURVE() {
          return CURVE;
        }
        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
        static fromAffine(p4) {
          const { x: x3, y: y4 } = p4 || {};
          if (!p4 || !Fp.isValid(x3) || !Fp.isValid(y4))
            throw new Error("invalid affine point");
          if (p4 instanceof Point)
            throw new Error("projective point not allowed");
          if (Fp.is0(x3) && Fp.is0(y4))
            return Point.ZERO;
          return new Point(x3, y4, Fp.ONE);
        }
        static fromBytes(bytes2) {
          const P5 = Point.fromAffine(decodePoint((0, utils_ts_1._abytes2)(bytes2, void 0, "point")));
          P5.assertValidity();
          return P5;
        }
        static fromHex(hex2) {
          return Point.fromBytes((0, utils_ts_1.ensureBytes)("pointHex", hex2));
        }
        get x() {
          return this.toAffine().x;
        }
        get y() {
          return this.toAffine().y;
        }
        /**
         *
         * @param windowSize
         * @param isLazy true will defer table computation until the first multiplication
         * @returns
         */
        precompute(windowSize = 8, isLazy = true) {
          wnaf.createCache(this, windowSize);
          if (!isLazy)
            this.multiply(_3n);
          return this;
        }
        // TODO: return `this`
        /** A point on curve is valid if it conforms to equation. */
        assertValidity() {
          assertValidMemo(this);
        }
        hasEvenY() {
          const { y: y4 } = this.toAffine();
          if (!Fp.isOdd)
            throw new Error("Field doesn't support isOdd");
          return !Fp.isOdd(y4);
        }
        /** Compare one point to another. */
        equals(other) {
          aprjpoint(other);
          const { X: X1, Y: Y1, Z: Z1 } = this;
          const { X: X22, Y: Y22, Z: Z22 } = other;
          const U1 = Fp.eql(Fp.mul(X1, Z22), Fp.mul(X22, Z1));
          const U22 = Fp.eql(Fp.mul(Y1, Z22), Fp.mul(Y22, Z1));
          return U1 && U22;
        }
        /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
        negate() {
          return new Point(this.X, Fp.neg(this.Y), this.Z);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
          const { a: a2, b: b5 } = CURVE;
          const b32 = Fp.mul(b5, _3n);
          const { X: X1, Y: Y1, Z: Z1 } = this;
          let X3 = Fp.ZERO, Y32 = Fp.ZERO, Z3 = Fp.ZERO;
          let t0 = Fp.mul(X1, X1);
          let t1 = Fp.mul(Y1, Y1);
          let t2 = Fp.mul(Z1, Z1);
          let t3 = Fp.mul(X1, Y1);
          t3 = Fp.add(t3, t3);
          Z3 = Fp.mul(X1, Z1);
          Z3 = Fp.add(Z3, Z3);
          X3 = Fp.mul(a2, Z3);
          Y32 = Fp.mul(b32, t2);
          Y32 = Fp.add(X3, Y32);
          X3 = Fp.sub(t1, Y32);
          Y32 = Fp.add(t1, Y32);
          Y32 = Fp.mul(X3, Y32);
          X3 = Fp.mul(t3, X3);
          Z3 = Fp.mul(b32, Z3);
          t2 = Fp.mul(a2, t2);
          t3 = Fp.sub(t0, t2);
          t3 = Fp.mul(a2, t3);
          t3 = Fp.add(t3, Z3);
          Z3 = Fp.add(t0, t0);
          t0 = Fp.add(Z3, t0);
          t0 = Fp.add(t0, t2);
          t0 = Fp.mul(t0, t3);
          Y32 = Fp.add(Y32, t0);
          t2 = Fp.mul(Y1, Z1);
          t2 = Fp.add(t2, t2);
          t0 = Fp.mul(t2, t3);
          X3 = Fp.sub(X3, t0);
          Z3 = Fp.mul(t2, t1);
          Z3 = Fp.add(Z3, Z3);
          Z3 = Fp.add(Z3, Z3);
          return new Point(X3, Y32, Z3);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(other) {
          aprjpoint(other);
          const { X: X1, Y: Y1, Z: Z1 } = this;
          const { X: X22, Y: Y22, Z: Z22 } = other;
          let X3 = Fp.ZERO, Y32 = Fp.ZERO, Z3 = Fp.ZERO;
          const a2 = CURVE.a;
          const b32 = Fp.mul(CURVE.b, _3n);
          let t0 = Fp.mul(X1, X22);
          let t1 = Fp.mul(Y1, Y22);
          let t2 = Fp.mul(Z1, Z22);
          let t3 = Fp.add(X1, Y1);
          let t4 = Fp.add(X22, Y22);
          t3 = Fp.mul(t3, t4);
          t4 = Fp.add(t0, t1);
          t3 = Fp.sub(t3, t4);
          t4 = Fp.add(X1, Z1);
          let t5 = Fp.add(X22, Z22);
          t4 = Fp.mul(t4, t5);
          t5 = Fp.add(t0, t2);
          t4 = Fp.sub(t4, t5);
          t5 = Fp.add(Y1, Z1);
          X3 = Fp.add(Y22, Z22);
          t5 = Fp.mul(t5, X3);
          X3 = Fp.add(t1, t2);
          t5 = Fp.sub(t5, X3);
          Z3 = Fp.mul(a2, t4);
          X3 = Fp.mul(b32, t2);
          Z3 = Fp.add(X3, Z3);
          X3 = Fp.sub(t1, Z3);
          Z3 = Fp.add(t1, Z3);
          Y32 = Fp.mul(X3, Z3);
          t1 = Fp.add(t0, t0);
          t1 = Fp.add(t1, t0);
          t2 = Fp.mul(a2, t2);
          t4 = Fp.mul(b32, t4);
          t1 = Fp.add(t1, t2);
          t2 = Fp.sub(t0, t2);
          t2 = Fp.mul(a2, t2);
          t4 = Fp.add(t4, t2);
          t0 = Fp.mul(t1, t4);
          Y32 = Fp.add(Y32, t0);
          t0 = Fp.mul(t5, t4);
          X3 = Fp.mul(t3, X3);
          X3 = Fp.sub(X3, t0);
          t0 = Fp.mul(t3, t1);
          Z3 = Fp.mul(t5, Z3);
          Z3 = Fp.add(Z3, t0);
          return new Point(X3, Y32, Z3);
        }
        subtract(other) {
          return this.add(other.negate());
        }
        is0() {
          return this.equals(Point.ZERO);
        }
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */
        multiply(scalar) {
          const { endo: endo2 } = extraOpts;
          if (!Fn3.isValidNot0(scalar))
            throw new Error("invalid scalar: out of range");
          let point, fake;
          const mul = (n2) => wnaf.cached(this, n2, (p4) => (0, curve_ts_1.normalizeZ)(Point, p4));
          if (endo2) {
            const { k1neg, k1, k2neg, k2: k22 } = splitEndoScalarN(scalar);
            const { p: k1p, f: k1f } = mul(k1);
            const { p: k2p, f: k2f } = mul(k22);
            fake = k1f.add(k2f);
            point = finishEndo(endo2.beta, k1p, k2p, k1neg, k2neg);
          } else {
            const { p: p4, f: f6 } = mul(scalar);
            point = p4;
            fake = f6;
          }
          return (0, curve_ts_1.normalizeZ)(Point, [point, fake])[0];
        }
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed secret key e.g. sig verification, which works over *public* keys.
         */
        multiplyUnsafe(sc2) {
          const { endo: endo2 } = extraOpts;
          const p4 = this;
          if (!Fn3.isValid(sc2))
            throw new Error("invalid scalar: out of range");
          if (sc2 === _0n || p4.is0())
            return Point.ZERO;
          if (sc2 === _1n)
            return p4;
          if (wnaf.hasCache(this))
            return this.multiply(sc2);
          if (endo2) {
            const { k1neg, k1, k2neg, k2: k22 } = splitEndoScalarN(sc2);
            const { p1, p2: p22 } = (0, curve_ts_1.mulEndoUnsafe)(Point, p4, k1, k22);
            return finishEndo(endo2.beta, p1, p22, k1neg, k2neg);
          } else {
            return wnaf.unsafe(p4, sc2);
          }
        }
        multiplyAndAddUnsafe(Q3, a2, b5) {
          const sum = this.multiplyUnsafe(a2).add(Q3.multiplyUnsafe(b5));
          return sum.is0() ? void 0 : sum;
        }
        /**
         * Converts Projective point to affine (x, y) coordinates.
         * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
         */
        toAffine(invertedZ) {
          return toAffineMemo(this, invertedZ);
        }
        /**
         * Checks whether Point is free of torsion elements (is in prime subgroup).
         * Always torsion-free for cofactor=1 curves.
         */
        isTorsionFree() {
          const { isTorsionFree } = extraOpts;
          if (cofactor === _1n)
            return true;
          if (isTorsionFree)
            return isTorsionFree(Point, this);
          return wnaf.unsafe(this, CURVE_ORDER).is0();
        }
        clearCofactor() {
          const { clearCofactor } = extraOpts;
          if (cofactor === _1n)
            return this;
          if (clearCofactor)
            return clearCofactor(Point, this);
          return this.multiplyUnsafe(cofactor);
        }
        isSmallOrder() {
          return this.multiplyUnsafe(cofactor).is0();
        }
        toBytes(isCompressed = true) {
          (0, utils_ts_1._abool2)(isCompressed, "isCompressed");
          this.assertValidity();
          return encodePoint(Point, this, isCompressed);
        }
        toHex(isCompressed = true) {
          return (0, utils_ts_1.bytesToHex)(this.toBytes(isCompressed));
        }
        toString() {
          return `<Point ${this.is0() ? "ZERO" : this.toHex()}>`;
        }
        // TODO: remove
        get px() {
          return this.X;
        }
        get py() {
          return this.X;
        }
        get pz() {
          return this.Z;
        }
        toRawBytes(isCompressed = true) {
          return this.toBytes(isCompressed);
        }
        _setWindowSize(windowSize) {
          this.precompute(windowSize);
        }
        static normalizeZ(points) {
          return (0, curve_ts_1.normalizeZ)(Point, points);
        }
        static msm(points, scalars) {
          return (0, curve_ts_1.pippenger)(Point, Fn3, points, scalars);
        }
        static fromPrivateKey(privateKey) {
          return Point.BASE.multiply(_normFnElement(Fn3, privateKey));
        }
      }
      Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
      Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
      Point.Fp = Fp;
      Point.Fn = Fn3;
      const bits = Fn3.BITS;
      const wnaf = new curve_ts_1.wNAF(Point, extraOpts.endo ? Math.ceil(bits / 2) : bits);
      Point.BASE.precompute(8);
      return Point;
    }
    function pprefix(hasEvenY) {
      return Uint8Array.of(hasEvenY ? 2 : 3);
    }
    function SWUFpSqrtRatio(Fp, Z3) {
      const q2 = Fp.ORDER;
      let l3 = _0n;
      for (let o3 = q2 - _1n; o3 % _2n === _0n; o3 /= _2n)
        l3 += _1n;
      const c1 = l3;
      const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;
      const _2n_pow_c1 = _2n_pow_c1_1 * _2n;
      const c22 = (q2 - _1n) / _2n_pow_c1;
      const c3 = (c22 - _1n) / _2n;
      const c4 = _2n_pow_c1 - _1n;
      const c5 = _2n_pow_c1_1;
      const c6 = Fp.pow(Z3, c22);
      const c7 = Fp.pow(Z3, (c22 + _1n) / _2n);
      let sqrtRatio = (u4, v9) => {
        let tv1 = c6;
        let tv2 = Fp.pow(v9, c4);
        let tv3 = Fp.sqr(tv2);
        tv3 = Fp.mul(tv3, v9);
        let tv5 = Fp.mul(u4, tv3);
        tv5 = Fp.pow(tv5, c3);
        tv5 = Fp.mul(tv5, tv2);
        tv2 = Fp.mul(tv5, v9);
        tv3 = Fp.mul(tv5, u4);
        let tv4 = Fp.mul(tv3, tv2);
        tv5 = Fp.pow(tv4, c5);
        let isQR = Fp.eql(tv5, Fp.ONE);
        tv2 = Fp.mul(tv3, c7);
        tv5 = Fp.mul(tv4, tv1);
        tv3 = Fp.cmov(tv2, tv3, isQR);
        tv4 = Fp.cmov(tv5, tv4, isQR);
        for (let i3 = c1; i3 > _1n; i3--) {
          let tv52 = i3 - _2n;
          tv52 = _2n << tv52 - _1n;
          let tvv5 = Fp.pow(tv4, tv52);
          const e1 = Fp.eql(tvv5, Fp.ONE);
          tv2 = Fp.mul(tv3, tv1);
          tv1 = Fp.mul(tv1, tv1);
          tvv5 = Fp.mul(tv4, tv1);
          tv3 = Fp.cmov(tv2, tv3, e1);
          tv4 = Fp.cmov(tvv5, tv4, e1);
        }
        return { isValid: isQR, value: tv3 };
      };
      if (Fp.ORDER % _4n === _3n) {
        const c12 = (Fp.ORDER - _3n) / _4n;
        const c23 = Fp.sqrt(Fp.neg(Z3));
        sqrtRatio = (u4, v9) => {
          let tv1 = Fp.sqr(v9);
          const tv2 = Fp.mul(u4, v9);
          tv1 = Fp.mul(tv1, tv2);
          let y1 = Fp.pow(tv1, c12);
          y1 = Fp.mul(y1, tv2);
          const y22 = Fp.mul(y1, c23);
          const tv3 = Fp.mul(Fp.sqr(y1), v9);
          const isQR = Fp.eql(tv3, u4);
          let y4 = Fp.cmov(y22, y1, isQR);
          return { isValid: isQR, value: y4 };
        };
      }
      return sqrtRatio;
    }
    function mapToCurveSimpleSWU(Fp, opts) {
      (0, modular_ts_1.validateField)(Fp);
      const { A: A5, B: B4, Z: Z3 } = opts;
      if (!Fp.isValid(A5) || !Fp.isValid(B4) || !Fp.isValid(Z3))
        throw new Error("mapToCurveSimpleSWU: invalid opts");
      const sqrtRatio = SWUFpSqrtRatio(Fp, Z3);
      if (!Fp.isOdd)
        throw new Error("Field does not have .isOdd()");
      return (u4) => {
        let tv1, tv2, tv3, tv4, tv5, tv6, x3, y4;
        tv1 = Fp.sqr(u4);
        tv1 = Fp.mul(tv1, Z3);
        tv2 = Fp.sqr(tv1);
        tv2 = Fp.add(tv2, tv1);
        tv3 = Fp.add(tv2, Fp.ONE);
        tv3 = Fp.mul(tv3, B4);
        tv4 = Fp.cmov(Z3, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO));
        tv4 = Fp.mul(tv4, A5);
        tv2 = Fp.sqr(tv3);
        tv6 = Fp.sqr(tv4);
        tv5 = Fp.mul(tv6, A5);
        tv2 = Fp.add(tv2, tv5);
        tv2 = Fp.mul(tv2, tv3);
        tv6 = Fp.mul(tv6, tv4);
        tv5 = Fp.mul(tv6, B4);
        tv2 = Fp.add(tv2, tv5);
        x3 = Fp.mul(tv1, tv3);
        const { isValid, value } = sqrtRatio(tv2, tv6);
        y4 = Fp.mul(tv1, u4);
        y4 = Fp.mul(y4, value);
        x3 = Fp.cmov(x3, tv3, isValid);
        y4 = Fp.cmov(y4, value, isValid);
        const e1 = Fp.isOdd(u4) === Fp.isOdd(y4);
        y4 = Fp.cmov(Fp.neg(y4), y4, e1);
        const tv4_inv = (0, modular_ts_1.FpInvertBatch)(Fp, [tv4], true)[0];
        x3 = Fp.mul(x3, tv4_inv);
        return { x: x3, y: y4 };
      };
    }
    function getWLengths(Fp, Fn3) {
      return {
        secretKey: Fn3.BYTES,
        publicKey: 1 + Fp.BYTES,
        publicKeyUncompressed: 1 + 2 * Fp.BYTES,
        publicKeyHasPrefix: true,
        signature: 2 * Fn3.BYTES
      };
    }
    function ecdh(Point, ecdhOpts = {}) {
      const { Fn: Fn3 } = Point;
      const randomBytes_ = ecdhOpts.randomBytes || utils_ts_1.randomBytes;
      const lengths = Object.assign(getWLengths(Point.Fp, Fn3), { seed: (0, modular_ts_1.getMinHashLength)(Fn3.ORDER) });
      function isValidSecretKey(secretKey) {
        try {
          return !!_normFnElement(Fn3, secretKey);
        } catch (error) {
          return false;
        }
      }
      function isValidPublicKey(publicKey, isCompressed) {
        const { publicKey: comp, publicKeyUncompressed } = lengths;
        try {
          const l3 = publicKey.length;
          if (isCompressed === true && l3 !== comp)
            return false;
          if (isCompressed === false && l3 !== publicKeyUncompressed)
            return false;
          return !!Point.fromBytes(publicKey);
        } catch (error) {
          return false;
        }
      }
      function randomSecretKey(seed = randomBytes_(lengths.seed)) {
        return (0, modular_ts_1.mapHashToField)((0, utils_ts_1._abytes2)(seed, lengths.seed, "seed"), Fn3.ORDER);
      }
      function getPublicKey(secretKey, isCompressed = true) {
        return Point.BASE.multiply(_normFnElement(Fn3, secretKey)).toBytes(isCompressed);
      }
      function keygen(seed) {
        const secretKey = randomSecretKey(seed);
        return { secretKey, publicKey: getPublicKey(secretKey) };
      }
      function isProbPub(item) {
        if (typeof item === "bigint")
          return false;
        if (item instanceof Point)
          return true;
        const { secretKey, publicKey, publicKeyUncompressed } = lengths;
        if (Fn3.allowedLengths || secretKey === publicKey)
          return void 0;
        const l3 = (0, utils_ts_1.ensureBytes)("key", item).length;
        return l3 === publicKey || l3 === publicKeyUncompressed;
      }
      function getSharedSecret(secretKeyA, publicKeyB, isCompressed = true) {
        if (isProbPub(secretKeyA) === true)
          throw new Error("first arg must be private key");
        if (isProbPub(publicKeyB) === false)
          throw new Error("second arg must be public key");
        const s2 = _normFnElement(Fn3, secretKeyA);
        const b5 = Point.fromHex(publicKeyB);
        return b5.multiply(s2).toBytes(isCompressed);
      }
      const utils2 = {
        isValidSecretKey,
        isValidPublicKey,
        randomSecretKey,
        // TODO: remove
        isValidPrivateKey: isValidSecretKey,
        randomPrivateKey: randomSecretKey,
        normPrivateKeyToScalar: (key) => _normFnElement(Fn3, key),
        precompute(windowSize = 8, point = Point.BASE) {
          return point.precompute(windowSize, false);
        }
      };
      return Object.freeze({ getPublicKey, getSharedSecret, keygen, Point, utils: utils2, lengths });
    }
    function ecdsa(Point, hash2, ecdsaOpts = {}) {
      (0, utils_1.ahash)(hash2);
      (0, utils_ts_1._validateObject)(ecdsaOpts, {}, {
        hmac: "function",
        lowS: "boolean",
        randomBytes: "function",
        bits2int: "function",
        bits2int_modN: "function"
      });
      const randomBytes = ecdsaOpts.randomBytes || utils_ts_1.randomBytes;
      const hmac = ecdsaOpts.hmac || ((key, ...msgs) => (0, hmac_js_1.hmac)(hash2, key, (0, utils_ts_1.concatBytes)(...msgs)));
      const { Fp, Fn: Fn3 } = Point;
      const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn3;
      const { keygen, getPublicKey, getSharedSecret, utils: utils2, lengths } = ecdh(Point, ecdsaOpts);
      const defaultSigOpts = {
        prehash: false,
        lowS: typeof ecdsaOpts.lowS === "boolean" ? ecdsaOpts.lowS : false,
        format: void 0,
        //'compact' as ECDSASigFormat,
        extraEntropy: false
      };
      const defaultSigOpts_format = "compact";
      function isBiggerThanHalfOrder(number) {
        const HALF = CURVE_ORDER >> _1n;
        return number > HALF;
      }
      function validateRS(title, num) {
        if (!Fn3.isValidNot0(num))
          throw new Error(`invalid signature ${title}: out of range 1..Point.Fn.ORDER`);
        return num;
      }
      function validateSigLength(bytes2, format) {
        validateSigFormat(format);
        const size = lengths.signature;
        const sizer = format === "compact" ? size : format === "recovered" ? size + 1 : void 0;
        return (0, utils_ts_1._abytes2)(bytes2, sizer, `${format} signature`);
      }
      class Signature {
        constructor(r2, s2, recovery) {
          this.r = validateRS("r", r2);
          this.s = validateRS("s", s2);
          if (recovery != null)
            this.recovery = recovery;
          Object.freeze(this);
        }
        static fromBytes(bytes2, format = defaultSigOpts_format) {
          validateSigLength(bytes2, format);
          let recid;
          if (format === "der") {
            const { r: r3, s: s3 } = exports.DER.toSig((0, utils_ts_1._abytes2)(bytes2));
            return new Signature(r3, s3);
          }
          if (format === "recovered") {
            recid = bytes2[0];
            format = "compact";
            bytes2 = bytes2.subarray(1);
          }
          const L3 = Fn3.BYTES;
          const r2 = bytes2.subarray(0, L3);
          const s2 = bytes2.subarray(L3, L3 * 2);
          return new Signature(Fn3.fromBytes(r2), Fn3.fromBytes(s2), recid);
        }
        static fromHex(hex2, format) {
          return this.fromBytes((0, utils_ts_1.hexToBytes)(hex2), format);
        }
        addRecoveryBit(recovery) {
          return new Signature(this.r, this.s, recovery);
        }
        recoverPublicKey(messageHash) {
          const FIELD_ORDER = Fp.ORDER;
          const { r: r2, s: s2, recovery: rec } = this;
          if (rec == null || ![0, 1, 2, 3].includes(rec))
            throw new Error("recovery id invalid");
          const hasCofactor = CURVE_ORDER * _2n < FIELD_ORDER;
          if (hasCofactor && rec > 1)
            throw new Error("recovery id is ambiguous for h>1 curve");
          const radj = rec === 2 || rec === 3 ? r2 + CURVE_ORDER : r2;
          if (!Fp.isValid(radj))
            throw new Error("recovery id 2 or 3 invalid");
          const x3 = Fp.toBytes(radj);
          const R6 = Point.fromBytes((0, utils_ts_1.concatBytes)(pprefix((rec & 1) === 0), x3));
          const ir3 = Fn3.inv(radj);
          const h4 = bits2int_modN((0, utils_ts_1.ensureBytes)("msgHash", messageHash));
          const u1 = Fn3.create(-h4 * ir3);
          const u22 = Fn3.create(s2 * ir3);
          const Q3 = Point.BASE.multiplyUnsafe(u1).add(R6.multiplyUnsafe(u22));
          if (Q3.is0())
            throw new Error("point at infinify");
          Q3.assertValidity();
          return Q3;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
          return isBiggerThanHalfOrder(this.s);
        }
        toBytes(format = defaultSigOpts_format) {
          validateSigFormat(format);
          if (format === "der")
            return (0, utils_ts_1.hexToBytes)(exports.DER.hexFromSig(this));
          const r2 = Fn3.toBytes(this.r);
          const s2 = Fn3.toBytes(this.s);
          if (format === "recovered") {
            if (this.recovery == null)
              throw new Error("recovery bit must be present");
            return (0, utils_ts_1.concatBytes)(Uint8Array.of(this.recovery), r2, s2);
          }
          return (0, utils_ts_1.concatBytes)(r2, s2);
        }
        toHex(format) {
          return (0, utils_ts_1.bytesToHex)(this.toBytes(format));
        }
        // TODO: remove
        assertValidity() {
        }
        static fromCompact(hex2) {
          return Signature.fromBytes((0, utils_ts_1.ensureBytes)("sig", hex2), "compact");
        }
        static fromDER(hex2) {
          return Signature.fromBytes((0, utils_ts_1.ensureBytes)("sig", hex2), "der");
        }
        normalizeS() {
          return this.hasHighS() ? new Signature(this.r, Fn3.neg(this.s), this.recovery) : this;
        }
        toDERRawBytes() {
          return this.toBytes("der");
        }
        toDERHex() {
          return (0, utils_ts_1.bytesToHex)(this.toBytes("der"));
        }
        toCompactRawBytes() {
          return this.toBytes("compact");
        }
        toCompactHex() {
          return (0, utils_ts_1.bytesToHex)(this.toBytes("compact"));
        }
      }
      const bits2int = ecdsaOpts.bits2int || function bits2int_def(bytes2) {
        if (bytes2.length > 8192)
          throw new Error("input is too large");
        const num = (0, utils_ts_1.bytesToNumberBE)(bytes2);
        const delta = bytes2.length * 8 - fnBits;
        return delta > 0 ? num >> BigInt(delta) : num;
      };
      const bits2int_modN = ecdsaOpts.bits2int_modN || function bits2int_modN_def(bytes2) {
        return Fn3.create(bits2int(bytes2));
      };
      const ORDER_MASK = (0, utils_ts_1.bitMask)(fnBits);
      function int2octets(num) {
        (0, utils_ts_1.aInRange)("num < 2^" + fnBits, num, _0n, ORDER_MASK);
        return Fn3.toBytes(num);
      }
      function validateMsgAndHash(message, prehash) {
        (0, utils_ts_1._abytes2)(message, void 0, "message");
        return prehash ? (0, utils_ts_1._abytes2)(hash2(message), void 0, "prehashed message") : message;
      }
      function prepSig(message, privateKey, opts) {
        if (["recovered", "canonical"].some((k5) => k5 in opts))
          throw new Error("sign() legacy options not supported");
        const { lowS, prehash, extraEntropy } = validateSigOpts(opts, defaultSigOpts);
        message = validateMsgAndHash(message, prehash);
        const h1int = bits2int_modN(message);
        const d3 = _normFnElement(Fn3, privateKey);
        const seedArgs = [int2octets(d3), int2octets(h1int)];
        if (extraEntropy != null && extraEntropy !== false) {
          const e = extraEntropy === true ? randomBytes(lengths.secretKey) : extraEntropy;
          seedArgs.push((0, utils_ts_1.ensureBytes)("extraEntropy", e));
        }
        const seed = (0, utils_ts_1.concatBytes)(...seedArgs);
        const m3 = h1int;
        function k2sig(kBytes) {
          const k5 = bits2int(kBytes);
          if (!Fn3.isValidNot0(k5))
            return;
          const ik = Fn3.inv(k5);
          const q2 = Point.BASE.multiply(k5).toAffine();
          const r2 = Fn3.create(q2.x);
          if (r2 === _0n)
            return;
          const s2 = Fn3.create(ik * Fn3.create(m3 + r2 * d3));
          if (s2 === _0n)
            return;
          let recovery = (q2.x === r2 ? 0 : 2) | Number(q2.y & _1n);
          let normS = s2;
          if (lowS && isBiggerThanHalfOrder(s2)) {
            normS = Fn3.neg(s2);
            recovery ^= 1;
          }
          return new Signature(r2, normS, recovery);
        }
        return { seed, k2sig };
      }
      function sign2(message, secretKey, opts = {}) {
        message = (0, utils_ts_1.ensureBytes)("message", message);
        const { seed, k2sig } = prepSig(message, secretKey, opts);
        const drbg = (0, utils_ts_1.createHmacDrbg)(hash2.outputLen, Fn3.BYTES, hmac);
        const sig = drbg(seed, k2sig);
        return sig;
      }
      function tryParsingSig(sg) {
        let sig = void 0;
        const isHex = typeof sg === "string" || (0, utils_ts_1.isBytes)(sg);
        const isObj = !isHex && sg !== null && typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint";
        if (!isHex && !isObj)
          throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
        if (isObj) {
          sig = new Signature(sg.r, sg.s);
        } else if (isHex) {
          try {
            sig = Signature.fromBytes((0, utils_ts_1.ensureBytes)("sig", sg), "der");
          } catch (derError) {
            if (!(derError instanceof exports.DER.Err))
              throw derError;
          }
          if (!sig) {
            try {
              sig = Signature.fromBytes((0, utils_ts_1.ensureBytes)("sig", sg), "compact");
            } catch (error) {
              return false;
            }
          }
        }
        if (!sig)
          return false;
        return sig;
      }
      function verify(signature, message, publicKey, opts = {}) {
        const { lowS, prehash, format } = validateSigOpts(opts, defaultSigOpts);
        publicKey = (0, utils_ts_1.ensureBytes)("publicKey", publicKey);
        message = validateMsgAndHash((0, utils_ts_1.ensureBytes)("message", message), prehash);
        if ("strict" in opts)
          throw new Error("options.strict was renamed to lowS");
        const sig = format === void 0 ? tryParsingSig(signature) : Signature.fromBytes((0, utils_ts_1.ensureBytes)("sig", signature), format);
        if (sig === false)
          return false;
        try {
          const P5 = Point.fromBytes(publicKey);
          if (lowS && sig.hasHighS())
            return false;
          const { r: r2, s: s2 } = sig;
          const h4 = bits2int_modN(message);
          const is2 = Fn3.inv(s2);
          const u1 = Fn3.create(h4 * is2);
          const u22 = Fn3.create(r2 * is2);
          const R6 = Point.BASE.multiplyUnsafe(u1).add(P5.multiplyUnsafe(u22));
          if (R6.is0())
            return false;
          const v9 = Fn3.create(R6.x);
          return v9 === r2;
        } catch (e) {
          return false;
        }
      }
      function recoverPublicKey(signature, message, opts = {}) {
        const { prehash } = validateSigOpts(opts, defaultSigOpts);
        message = validateMsgAndHash(message, prehash);
        return Signature.fromBytes(signature, "recovered").recoverPublicKey(message).toBytes();
      }
      return Object.freeze({
        keygen,
        getPublicKey,
        getSharedSecret,
        utils: utils2,
        lengths,
        Point,
        sign: sign2,
        verify,
        recoverPublicKey,
        Signature,
        hash: hash2
      });
    }
    function weierstrassPoints(c3) {
      const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c3);
      const Point = weierstrassN(CURVE, curveOpts);
      return _weierstrass_new_output_to_legacy(c3, Point);
    }
    function _weierstrass_legacy_opts_to_new(c3) {
      const CURVE = {
        a: c3.a,
        b: c3.b,
        p: c3.Fp.ORDER,
        n: c3.n,
        h: c3.h,
        Gx: c3.Gx,
        Gy: c3.Gy
      };
      const Fp = c3.Fp;
      let allowedLengths = c3.allowedPrivateKeyLengths ? Array.from(new Set(c3.allowedPrivateKeyLengths.map((l3) => Math.ceil(l3 / 2)))) : void 0;
      const Fn3 = (0, modular_ts_1.Field)(CURVE.n, {
        BITS: c3.nBitLength,
        allowedLengths,
        modFromBytes: c3.wrapPrivateKey
      });
      const curveOpts = {
        Fp,
        Fn: Fn3,
        allowInfinityPoint: c3.allowInfinityPoint,
        endo: c3.endo,
        isTorsionFree: c3.isTorsionFree,
        clearCofactor: c3.clearCofactor,
        fromBytes: c3.fromBytes,
        toBytes: c3.toBytes
      };
      return { CURVE, curveOpts };
    }
    function _ecdsa_legacy_opts_to_new(c3) {
      const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c3);
      const ecdsaOpts = {
        hmac: c3.hmac,
        randomBytes: c3.randomBytes,
        lowS: c3.lowS,
        bits2int: c3.bits2int,
        bits2int_modN: c3.bits2int_modN
      };
      return { CURVE, curveOpts, hash: c3.hash, ecdsaOpts };
    }
    function _legacyHelperEquat(Fp, a2, b5) {
      function weierstrassEquation(x3) {
        const x22 = Fp.sqr(x3);
        const x32 = Fp.mul(x22, x3);
        return Fp.add(Fp.add(x32, Fp.mul(x3, a2)), b5);
      }
      return weierstrassEquation;
    }
    function _weierstrass_new_output_to_legacy(c3, Point) {
      const { Fp, Fn: Fn3 } = Point;
      function isWithinCurveOrder(num) {
        return (0, utils_ts_1.inRange)(num, _1n, Fn3.ORDER);
      }
      const weierstrassEquation = _legacyHelperEquat(Fp, c3.a, c3.b);
      return Object.assign({}, {
        CURVE: c3,
        Point,
        ProjectivePoint: Point,
        normPrivateKeyToScalar: (key) => _normFnElement(Fn3, key),
        weierstrassEquation,
        isWithinCurveOrder
      });
    }
    function _ecdsa_new_output_to_legacy(c3, _ecdsa) {
      const Point = _ecdsa.Point;
      return Object.assign({}, _ecdsa, {
        ProjectivePoint: Point,
        CURVE: Object.assign({}, c3, (0, modular_ts_1.nLength)(Point.Fn.ORDER, Point.Fn.BITS))
      });
    }
    function weierstrass(c3) {
      const { CURVE, curveOpts, hash: hash2, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c3);
      const Point = weierstrassN(CURVE, curveOpts);
      const signs = ecdsa(Point, hash2, ecdsaOpts);
      return _ecdsa_new_output_to_legacy(c3, signs);
    }
  }
});

// node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/_shortw_utils.js
var require_shortw_utils = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/_shortw_utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getHash = getHash;
    exports.createCurve = createCurve;
    var weierstrass_ts_1 = require_weierstrass();
    function getHash(hash2) {
      return { hash: hash2 };
    }
    function createCurve(curveDef, defHash) {
      const create3 = (hash2) => (0, weierstrass_ts_1.weierstrass)({ ...curveDef, hash: hash2 });
      return { ...create3(defHash), create: create3 };
    }
  }
});

// node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/secp256k1.js
var require_secp256k1 = __commonJS({
  "node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/secp256k1.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeToCurve = exports.hashToCurve = exports.secp256k1_hasher = exports.schnorr = exports.secp256k1 = void 0;
    var sha2_js_1 = require_sha2();
    var utils_js_1 = require_utils();
    var _shortw_utils_ts_1 = require_shortw_utils();
    var hash_to_curve_ts_1 = require_hash_to_curve();
    var modular_ts_1 = require_modular();
    var weierstrass_ts_1 = require_weierstrass();
    var utils_ts_1 = require_utils4();
    var secp256k1_CURVE = {
      p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
      n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
      h: BigInt(1),
      a: BigInt(0),
      b: BigInt(7),
      Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
      Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
    };
    var secp256k1_ENDO = {
      beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
      basises: [
        [BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],
        [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]
      ]
    };
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    function sqrtMod(y4) {
      const P5 = secp256k1_CURVE.p;
      const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
      const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
      const b22 = y4 * y4 * y4 % P5;
      const b32 = b22 * b22 * y4 % P5;
      const b6 = (0, modular_ts_1.pow2)(b32, _3n, P5) * b32 % P5;
      const b9 = (0, modular_ts_1.pow2)(b6, _3n, P5) * b32 % P5;
      const b11 = (0, modular_ts_1.pow2)(b9, _2n, P5) * b22 % P5;
      const b222 = (0, modular_ts_1.pow2)(b11, _11n, P5) * b11 % P5;
      const b44 = (0, modular_ts_1.pow2)(b222, _22n, P5) * b222 % P5;
      const b88 = (0, modular_ts_1.pow2)(b44, _44n, P5) * b44 % P5;
      const b176 = (0, modular_ts_1.pow2)(b88, _88n, P5) * b88 % P5;
      const b220 = (0, modular_ts_1.pow2)(b176, _44n, P5) * b44 % P5;
      const b223 = (0, modular_ts_1.pow2)(b220, _3n, P5) * b32 % P5;
      const t1 = (0, modular_ts_1.pow2)(b223, _23n, P5) * b222 % P5;
      const t2 = (0, modular_ts_1.pow2)(t1, _6n, P5) * b22 % P5;
      const root = (0, modular_ts_1.pow2)(t2, _2n, P5);
      if (!Fpk1.eql(Fpk1.sqr(root), y4))
        throw new Error("Cannot find square root");
      return root;
    }
    var Fpk1 = (0, modular_ts_1.Field)(secp256k1_CURVE.p, { sqrt: sqrtMod });
    exports.secp256k1 = (0, _shortw_utils_ts_1.createCurve)({ ...secp256k1_CURVE, Fp: Fpk1, lowS: true, endo: secp256k1_ENDO }, sha2_js_1.sha256);
    var TAGGED_HASH_PREFIXES = {};
    function taggedHash(tag, ...messages) {
      let tagP = TAGGED_HASH_PREFIXES[tag];
      if (tagP === void 0) {
        const tagH = (0, sha2_js_1.sha256)((0, utils_ts_1.utf8ToBytes)(tag));
        tagP = (0, utils_ts_1.concatBytes)(tagH, tagH);
        TAGGED_HASH_PREFIXES[tag] = tagP;
      }
      return (0, sha2_js_1.sha256)((0, utils_ts_1.concatBytes)(tagP, ...messages));
    }
    var pointToBytes = (point) => point.toBytes(true).slice(1);
    var Pointk1 = (() => exports.secp256k1.Point)();
    var hasEven = (y4) => y4 % _2n === _0n;
    function schnorrGetExtPubKey(priv) {
      const { Fn: Fn3, BASE } = Pointk1;
      const d_ = (0, weierstrass_ts_1._normFnElement)(Fn3, priv);
      const p4 = BASE.multiply(d_);
      const scalar = hasEven(p4.y) ? d_ : Fn3.neg(d_);
      return { scalar, bytes: pointToBytes(p4) };
    }
    function lift_x(x3) {
      const Fp = Fpk1;
      if (!Fp.isValidNot0(x3))
        throw new Error("invalid x: Fail if x ≥ p");
      const xx = Fp.create(x3 * x3);
      const c3 = Fp.create(xx * x3 + BigInt(7));
      let y4 = Fp.sqrt(c3);
      if (!hasEven(y4))
        y4 = Fp.neg(y4);
      const p4 = Pointk1.fromAffine({ x: x3, y: y4 });
      p4.assertValidity();
      return p4;
    }
    var num = utils_ts_1.bytesToNumberBE;
    function challenge(...args) {
      return Pointk1.Fn.create(num(taggedHash("BIP0340/challenge", ...args)));
    }
    function schnorrGetPublicKey(secretKey) {
      return schnorrGetExtPubKey(secretKey).bytes;
    }
    function schnorrSign(message, secretKey, auxRand = (0, utils_js_1.randomBytes)(32)) {
      const { Fn: Fn3 } = Pointk1;
      const m3 = (0, utils_ts_1.ensureBytes)("message", message);
      const { bytes: px, scalar: d3 } = schnorrGetExtPubKey(secretKey);
      const a2 = (0, utils_ts_1.ensureBytes)("auxRand", auxRand, 32);
      const t = Fn3.toBytes(d3 ^ num(taggedHash("BIP0340/aux", a2)));
      const rand = taggedHash("BIP0340/nonce", t, px, m3);
      const { bytes: rx, scalar: k5 } = schnorrGetExtPubKey(rand);
      const e = challenge(rx, px, m3);
      const sig = new Uint8Array(64);
      sig.set(rx, 0);
      sig.set(Fn3.toBytes(Fn3.create(k5 + e * d3)), 32);
      if (!schnorrVerify(sig, m3, px))
        throw new Error("sign: Invalid signature produced");
      return sig;
    }
    function schnorrVerify(signature, message, publicKey) {
      const { Fn: Fn3, BASE } = Pointk1;
      const sig = (0, utils_ts_1.ensureBytes)("signature", signature, 64);
      const m3 = (0, utils_ts_1.ensureBytes)("message", message);
      const pub = (0, utils_ts_1.ensureBytes)("publicKey", publicKey, 32);
      try {
        const P5 = lift_x(num(pub));
        const r2 = num(sig.subarray(0, 32));
        if (!(0, utils_ts_1.inRange)(r2, _1n, secp256k1_CURVE.p))
          return false;
        const s2 = num(sig.subarray(32, 64));
        if (!(0, utils_ts_1.inRange)(s2, _1n, secp256k1_CURVE.n))
          return false;
        const e = challenge(Fn3.toBytes(r2), pointToBytes(P5), m3);
        const R6 = BASE.multiplyUnsafe(s2).add(P5.multiplyUnsafe(Fn3.neg(e)));
        const { x: x3, y: y4 } = R6.toAffine();
        if (R6.is0() || !hasEven(y4) || x3 !== r2)
          return false;
        return true;
      } catch (error) {
        return false;
      }
    }
    exports.schnorr = (() => {
      const size = 32;
      const seedLength = 48;
      const randomSecretKey = (seed = (0, utils_js_1.randomBytes)(seedLength)) => {
        return (0, modular_ts_1.mapHashToField)(seed, secp256k1_CURVE.n);
      };
      exports.secp256k1.utils.randomSecretKey;
      function keygen(seed) {
        const secretKey = randomSecretKey(seed);
        return { secretKey, publicKey: schnorrGetPublicKey(secretKey) };
      }
      return {
        keygen,
        getPublicKey: schnorrGetPublicKey,
        sign: schnorrSign,
        verify: schnorrVerify,
        Point: Pointk1,
        utils: {
          randomSecretKey,
          randomPrivateKey: randomSecretKey,
          taggedHash,
          // TODO: remove
          lift_x,
          pointToBytes,
          numberToBytesBE: utils_ts_1.numberToBytesBE,
          bytesToNumberBE: utils_ts_1.bytesToNumberBE,
          mod: modular_ts_1.mod
        },
        lengths: {
          secretKey: size,
          publicKey: size,
          publicKeyHasPrefix: false,
          signature: size * 2,
          seed: seedLength
        }
      };
    })();
    var isoMap = (() => (0, hash_to_curve_ts_1.isogenyMap)(Fpk1, [
      // xNum
      [
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
        "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
        "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
      ],
      // xDen
      [
        "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
        "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ],
      // yNum
      [
        "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
        "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
        "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
        "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
      ],
      // yDen
      [
        "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
        "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
        "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ]
    ].map((i3) => i3.map((j3) => BigInt(j3)))))();
    var mapSWU = (() => (0, weierstrass_ts_1.mapToCurveSimpleSWU)(Fpk1, {
      A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
      B: BigInt("1771"),
      Z: Fpk1.create(BigInt("-11"))
    }))();
    exports.secp256k1_hasher = (() => (0, hash_to_curve_ts_1.createHasher)(exports.secp256k1.Point, (scalars) => {
      const { x: x3, y: y4 } = mapSWU(Fpk1.create(scalars[0]));
      return isoMap(x3, y4);
    }, {
      DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
      encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
      p: Fpk1.ORDER,
      m: 1,
      k: 128,
      expand: "xmd",
      hash: sha2_js_1.sha256
    }))();
    exports.hashToCurve = (() => exports.secp256k1_hasher.hashToCurve)();
    exports.encodeToCurve = (() => exports.secp256k1_hasher.encodeToCurve)();
  }
});

// node_modules/.pnpm/@cosmjs+crypto@0.37.0/node_modules/@cosmjs/crypto/build/secp256k1signature.js
var require_secp256k1signature = __commonJS({
  "node_modules/.pnpm/@cosmjs+crypto@0.37.0/node_modules/@cosmjs/crypto/build/secp256k1signature.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExtendedSecp256k1Signature = exports.Secp256k1Signature = void 0;
    function trimLeadingNullBytes(inData) {
      let numberOfLeadingNullBytes = 0;
      for (const byte of inData) {
        if (byte === 0) {
          numberOfLeadingNullBytes++;
        } else {
          break;
        }
      }
      return inData.slice(numberOfLeadingNullBytes);
    }
    var derTagInteger = 2;
    var Secp256k1Signature = class _Secp256k1Signature {
      /**
       * Takes the pair of integers (r, s) as 2x32 byte of binary data.
       *
       * Note: This is the format Cosmos SDK uses natively.
       *
       * @param data a 64 byte value containing integers r and s.
       */
      static fromFixedLength(data2) {
        if (data2.length !== 64) {
          throw new Error(`Got invalid data length: ${data2.length}. Expected 2x 32 bytes for the pair (r, s)`);
        }
        return new _Secp256k1Signature(trimLeadingNullBytes(data2.slice(0, 32)), trimLeadingNullBytes(data2.slice(32, 64)));
      }
      static fromDer(data2) {
        let pos = 0;
        if (data2[pos++] !== 48) {
          throw new Error("Prefix 0x30 expected");
        }
        const bodyLength = data2[pos++];
        if (data2.length - pos !== bodyLength) {
          throw new Error("Data length mismatch detected");
        }
        const rTag = data2[pos++];
        if (rTag !== derTagInteger) {
          throw new Error("INTEGER tag expected");
        }
        const rLength = data2[pos++];
        if (rLength >= 128) {
          throw new Error("Decoding length values above 127 not supported");
        }
        const rData = data2.slice(pos, pos + rLength);
        pos += rLength;
        const sTag = data2[pos++];
        if (sTag !== derTagInteger) {
          throw new Error("INTEGER tag expected");
        }
        const sLength = data2[pos++];
        if (sLength >= 128) {
          throw new Error("Decoding length values above 127 not supported");
        }
        const sData = data2.slice(pos, pos + sLength);
        pos += sLength;
        return new _Secp256k1Signature(
          // r/s data can contain leading 0 bytes to express integers being non-negative in DER
          trimLeadingNullBytes(rData),
          trimLeadingNullBytes(sData)
        );
      }
      data;
      constructor(r2, s2) {
        if (r2.length > 32 || r2.length === 0 || r2[0] === 0) {
          throw new Error("Unsigned integer r must be encoded as unpadded big endian.");
        }
        if (s2.length > 32 || s2.length === 0 || s2[0] === 0) {
          throw new Error("Unsigned integer s must be encoded as unpadded big endian.");
        }
        this.data = {
          r: r2,
          s: s2
        };
      }
      r(length) {
        if (length === void 0) {
          return this.data.r;
        } else {
          const paddingLength = length - this.data.r.length;
          if (paddingLength < 0) {
            throw new Error("Length too small to hold parameter r");
          }
          const padding2 = new Uint8Array(paddingLength);
          return new Uint8Array([...padding2, ...this.data.r]);
        }
      }
      s(length) {
        if (length === void 0) {
          return this.data.s;
        } else {
          const paddingLength = length - this.data.s.length;
          if (paddingLength < 0) {
            throw new Error("Length too small to hold parameter s");
          }
          const padding2 = new Uint8Array(paddingLength);
          return new Uint8Array([...padding2, ...this.data.s]);
        }
      }
      toFixedLength() {
        return new Uint8Array([...this.r(32), ...this.s(32)]);
      }
      toDer() {
        const rEncoded = this.data.r[0] >= 128 ? new Uint8Array([0, ...this.data.r]) : this.data.r;
        const sEncoded = this.data.s[0] >= 128 ? new Uint8Array([0, ...this.data.s]) : this.data.s;
        const rLength = rEncoded.length;
        const sLength = sEncoded.length;
        const data2 = new Uint8Array([derTagInteger, rLength, ...rEncoded, derTagInteger, sLength, ...sEncoded]);
        return new Uint8Array([48, data2.length, ...data2]);
      }
    };
    exports.Secp256k1Signature = Secp256k1Signature;
    var ExtendedSecp256k1Signature2 = class _ExtendedSecp256k1Signature extends Secp256k1Signature {
      /**
       * Decode extended signature from the simple fixed length encoding
       * described in toFixedLength().
       */
      static fromFixedLength(data2) {
        if (data2.length !== 65) {
          throw new Error(`Got invalid data length ${data2.length}. Expected 32 + 32 + 1`);
        }
        return new _ExtendedSecp256k1Signature(trimLeadingNullBytes(data2.slice(0, 32)), trimLeadingNullBytes(data2.slice(32, 64)), data2[64]);
      }
      recovery;
      constructor(r2, s2, recovery) {
        super(r2, s2);
        if (!Number.isInteger(recovery)) {
          throw new Error("The recovery parameter must be an integer.");
        }
        if (recovery < 0 || recovery > 4) {
          throw new Error("The recovery parameter must be one of 0, 1, 2, 3.");
        }
        this.recovery = recovery;
      }
      /**
       * A simple custom encoding that encodes the extended signature as
       * r (32 bytes) | s (32 bytes) | recovery param (1 byte)
       * where | denotes concatenation of bonary data.
       */
      toFixedLength() {
        return new Uint8Array([...this.r(32), ...this.s(32), this.recovery]);
      }
    };
    exports.ExtendedSecp256k1Signature = ExtendedSecp256k1Signature2;
  }
});

// node_modules/.pnpm/@cosmjs+crypto@0.37.0/node_modules/@cosmjs/crypto/build/secp256k1.js
var require_secp256k12 = __commonJS({
  "node_modules/.pnpm/@cosmjs+crypto@0.37.0/node_modules/@cosmjs/crypto/build/secp256k1.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Secp256k1 = void 0;
    var encoding_1 = require_build2();
    var utils_1 = require_build();
    var secp256k1_1 = require_secp256k1();
    var secp256k1signature_1 = require_secp256k1signature();
    function unsignedBigIntToBytes(a2) {
      (0, utils_1.assert)(a2 >= 0n);
      let hex2 = a2.toString(16);
      if (hex2.length % 2)
        hex2 = "0" + hex2;
      return (0, encoding_1.fromHex)(hex2);
    }
    function bytesToUnsignedBigInt(a2) {
      return BigInt("0x" + (0, encoding_1.toHex)(a2));
    }
    var Secp256k12 = class {
      /**
       * Takes a 32 byte private key and returns a privkey/pubkey pair.
       *
       * The resulting pubkey is uncompressed. For the use in Cosmos it should
       * be compressed first using `Secp256k1.compressPubkey`.
       */
      static async makeKeypair(privkey) {
        if (privkey.length !== 32) {
          throw new Error("input data is not a valid secp256k1 private key");
        }
        if (!secp256k1_1.secp256k1.utils.isValidPrivateKey(privkey)) {
          throw new Error("input data is not a valid secp256k1 private key");
        }
        const out = {
          privkey,
          // encodes uncompressed as
          // - 1-byte prefix "04"
          // - 32-byte x coordinate
          // - 32-byte y coordinate
          pubkey: secp256k1_1.secp256k1.getPublicKey(privkey, false)
        };
        return out;
      }
      /**
       * Creates a signature that is
       * - deterministic (RFC 6979)
       * - lowS signature
       * - DER encoded
       */
      static async createSignature(messageHash, privkey) {
        if (messageHash.length === 0) {
          throw new Error("Message hash must not be empty");
        }
        if (messageHash.length > 32) {
          throw new Error("Message hash length must not exceed 32 bytes");
        }
        const { recovery, r: r2, s: s2 } = secp256k1_1.secp256k1.sign(messageHash, privkey, {
          lowS: true
        });
        if (typeof recovery !== "number")
          throw new Error("Recovery param missing");
        return new secp256k1signature_1.ExtendedSecp256k1Signature(unsignedBigIntToBytes(r2), unsignedBigIntToBytes(s2), recovery);
      }
      static async verifySignature(signature, messageHash, pubkey) {
        if (messageHash.length === 0) {
          throw new Error("Message hash must not be empty");
        }
        if (messageHash.length > 32) {
          throw new Error("Message hash length must not exceed 32 bytes");
        }
        const encodedSig = secp256k1_1.secp256k1.Signature.fromDER(signature.toDer());
        return secp256k1_1.secp256k1.verify(encodedSig, messageHash, pubkey, { lowS: false });
      }
      static recoverPubkey(signature, messageHash) {
        const pk = new secp256k1_1.secp256k1.Signature(bytesToUnsignedBigInt(signature.r()), bytesToUnsignedBigInt(signature.s()), signature.recovery).recoverPublicKey(messageHash);
        return pk.toBytes(false);
      }
      /**
       * Takes a compressed or uncompressed pubkey and return a compressed one.
       *
       * This function is idempotent.
       */
      static compressPubkey(pubkey) {
        switch (pubkey.length) {
          case 33:
            return pubkey;
          case 65:
            return secp256k1_1.secp256k1.Point.fromBytes(pubkey).toBytes(true);
          default:
            throw new Error("Invalid pubkey length");
        }
      }
      /**
       * Takes a compressed or uncompressed pubkey and returns an uncompressed one.
       *
       * This function is idempotent.
       */
      static uncompressPubkey(pubkey) {
        switch (pubkey.length) {
          case 33:
            return secp256k1_1.secp256k1.Point.fromBytes(pubkey).toBytes(false);
          case 65:
            return pubkey;
          default:
            throw new Error("Invalid pubkey length");
        }
      }
      static trimRecoveryByte(signature) {
        switch (signature.length) {
          case 64:
            return signature;
          case 65:
            return signature.slice(0, 64);
          default:
            throw new Error("Invalid signature length");
        }
      }
    };
    exports.Secp256k1 = Secp256k12;
  }
});

// node_modules/.pnpm/@cosmjs+crypto@0.37.0/node_modules/@cosmjs/crypto/build/sha.js
var require_sha = __commonJS({
  "node_modules/.pnpm/@cosmjs+crypto@0.37.0/node_modules/@cosmjs/crypto/build/sha.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Sha512 = exports.Sha256 = void 0;
    exports.sha256 = sha2563;
    exports.sha512 = sha5122;
    var sha2_js_1 = require_sha2();
    var utils_1 = require_utils2();
    var Sha2562 = class {
      blockSize = 512 / 8;
      impl = sha2_js_1.sha256.create();
      constructor(firstData) {
        if (firstData) {
          this.update(firstData);
        }
      }
      update(data2) {
        this.impl.update((0, utils_1.toRealUint8Array)(data2));
        return this;
      }
      digest() {
        return this.impl.digest();
      }
    };
    exports.Sha256 = Sha2562;
    function sha2563(data2) {
      return new Sha2562(data2).digest();
    }
    var Sha512 = class {
      blockSize = 1024 / 8;
      impl = sha2_js_1.sha512.create();
      constructor(firstData) {
        if (firstData) {
          this.update(firstData);
        }
      }
      update(data2) {
        this.impl.update((0, utils_1.toRealUint8Array)(data2));
        return this;
      }
      digest() {
        return this.impl.digest();
      }
    };
    exports.Sha512 = Sha512;
    function sha5122(data2) {
      return new Sha512(data2).digest();
    }
  }
});

// node_modules/.pnpm/@cosmjs+math@0.37.0/node_modules/@cosmjs/math/build/decimal.js
var require_decimal = __commonJS({
  "node_modules/.pnpm/@cosmjs+math@0.37.0/node_modules/@cosmjs/math/build/decimal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Decimal = void 0;
    var maxFractionalDigits = 100;
    var Decimal = class _Decimal {
      static fromUserInput(input, fractionalDigits) {
        _Decimal.verifyFractionalDigits(fractionalDigits);
        const badCharacter = input.match(/[^0-9.]/);
        if (badCharacter) {
          throw new Error(`Invalid character at position ${badCharacter.index + 1}`);
        }
        let whole;
        let fractional;
        if (input === "") {
          whole = "0";
          fractional = "";
        } else if (input.search(/\./) === -1) {
          whole = input;
          fractional = "";
        } else {
          const parts = input.split(".");
          switch (parts.length) {
            case 0:
            case 1:
              throw new Error("Fewer than two elements in split result. This must not happen here.");
            case 2:
              if (!parts[1])
                throw new Error("Fractional part missing");
              whole = parts[0];
              fractional = parts[1].replace(/0+$/, "");
              break;
            default:
              throw new Error("More than one separator found");
          }
        }
        if (fractional.length > fractionalDigits) {
          throw new Error("Got more fractional digits than supported");
        }
        const quantity = `${whole}${fractional.padEnd(fractionalDigits, "0")}`;
        return new _Decimal(quantity, fractionalDigits);
      }
      static fromAtomics(atomics, fractionalDigits) {
        _Decimal.verifyFractionalDigits(fractionalDigits);
        return new _Decimal(atomics, fractionalDigits);
      }
      /**
       * Creates a Decimal with value 0.0 and the given number of fractional digits.
       *
       * Fractional digits are not relevant for the value but needed to be able
       * to perform arithmetic operations with other decimals.
       */
      static zero(fractionalDigits) {
        _Decimal.verifyFractionalDigits(fractionalDigits);
        return new _Decimal("0", fractionalDigits);
      }
      /**
       * Creates a Decimal with value 1.0 and the given number of fractional digits.
       *
       * Fractional digits are not relevant for the value but needed to be able
       * to perform arithmetic operations with other decimals.
       */
      static one(fractionalDigits) {
        _Decimal.verifyFractionalDigits(fractionalDigits);
        return new _Decimal("1" + "0".repeat(fractionalDigits), fractionalDigits);
      }
      static verifyFractionalDigits(fractionalDigits) {
        if (!Number.isInteger(fractionalDigits))
          throw new Error("Fractional digits is not an integer");
        if (fractionalDigits < 0)
          throw new Error("Fractional digits must not be negative");
        if (fractionalDigits > maxFractionalDigits) {
          throw new Error(`Fractional digits must not exceed ${maxFractionalDigits}`);
        }
      }
      static compare(a2, b5) {
        if (a2.fractionalDigits !== b5.fractionalDigits)
          throw new Error("Fractional digits do not match");
        const difference = a2.data.atomics - b5.data.atomics;
        if (difference < 0n)
          return -1;
        if (difference > 0n)
          return 1;
        return 0;
      }
      get atomics() {
        return this.data.atomics.toString();
      }
      get fractionalDigits() {
        return this.data.fractionalDigits;
      }
      data;
      constructor(atomics, fractionalDigits) {
        if (!atomics.match(/^[0-9]+$/)) {
          throw new Error("Invalid string format. Only non-negative integers in decimal representation supported.");
        }
        this.data = {
          atomics: BigInt(atomics),
          fractionalDigits
        };
      }
      /** Creates a new instance with the same value */
      clone() {
        return new _Decimal(this.atomics, this.fractionalDigits);
      }
      /** Returns the greatest decimal <= this which has no fractional part (rounding down) */
      floor() {
        const factor = 10n ** BigInt(this.data.fractionalDigits);
        const whole = this.data.atomics / factor;
        const fractional = this.data.atomics % factor;
        if (fractional === 0n) {
          return this.clone();
        } else {
          return _Decimal.fromAtomics((whole * factor).toString(), this.fractionalDigits);
        }
      }
      /** Returns the smallest decimal >= this which has no fractional part (rounding up) */
      ceil() {
        const factor = 10n ** BigInt(this.data.fractionalDigits);
        const whole = this.data.atomics / factor;
        const fractional = this.data.atomics % factor;
        if (fractional === 0n) {
          return this.clone();
        } else {
          return _Decimal.fromAtomics(((whole + 1n) * factor).toString(), this.fractionalDigits);
        }
      }
      toString() {
        const factor = 10n ** BigInt(this.data.fractionalDigits);
        const whole = this.data.atomics / factor;
        const fractional = this.data.atomics % factor;
        if (fractional === 0n) {
          return whole.toString();
        } else {
          const fullFractionalPart = fractional.toString().padStart(this.data.fractionalDigits, "0");
          const trimmedFractionalPart = fullFractionalPart.replace(/0+$/, "");
          return `${whole.toString()}.${trimmedFractionalPart}`;
        }
      }
      /**
       * Returns an approximation as a float type. Only use this if no
       * exact calculation is required.
       */
      toFloatApproximation() {
        const out = Number(this.toString());
        if (Number.isNaN(out))
          throw new Error("Conversion to number failed");
        return out;
      }
      /**
       * a.plus(b) returns a+b.
       *
       * Both values need to have the same fractional digits.
       */
      plus(b5) {
        if (this.fractionalDigits !== b5.fractionalDigits)
          throw new Error("Fractional digits do not match");
        const sum = this.data.atomics + b5.data.atomics;
        return new _Decimal(sum.toString(), this.fractionalDigits);
      }
      /**
       * a.minus(b) returns a-b.
       *
       * Both values need to have the same fractional digits.
       * The resulting difference needs to be non-negative.
       */
      minus(b5) {
        if (this.fractionalDigits !== b5.fractionalDigits)
          throw new Error("Fractional digits do not match");
        const difference = this.data.atomics - b5.data.atomics;
        if (difference < 0n)
          throw new Error("Difference must not be negative");
        return new _Decimal(difference.toString(), this.fractionalDigits);
      }
      /**
       * a.multiply(b) returns a*b.
       *
       * We only allow multiplication by unsigned integers to avoid rounding errors.
       */
      multiply(b5) {
        const product = this.data.atomics * b5.toBigInt();
        return new _Decimal(product.toString(), this.fractionalDigits);
      }
      equals(b5) {
        return _Decimal.compare(this, b5) === 0;
      }
      isLessThan(b5) {
        return _Decimal.compare(this, b5) < 0;
      }
      isLessThanOrEqual(b5) {
        return _Decimal.compare(this, b5) <= 0;
      }
      isGreaterThan(b5) {
        return _Decimal.compare(this, b5) > 0;
      }
      isGreaterThanOrEqual(b5) {
        return _Decimal.compare(this, b5) >= 0;
      }
    };
    exports.Decimal = Decimal;
  }
});

// node_modules/.pnpm/@cosmjs+math@0.37.0/node_modules/@cosmjs/math/build/integers.js
var require_integers = __commonJS({
  "node_modules/.pnpm/@cosmjs+math@0.37.0/node_modules/@cosmjs/math/build/integers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Uint64 = exports.Uint53 = exports.Int53 = exports.Uint32 = void 0;
    var uint64MaxValue = 18446744073709551615n;
    var Uint32 = class _Uint32 {
      /** @deprecated use Uint32.fromBytes */
      static fromBigEndianBytes(bytes2) {
        return _Uint32.fromBytes(bytes2);
      }
      /**
       * Creates a Uint32 from a fixed length byte array.
       *
       * @param bytes a list of exactly 4 bytes
       * @param endianness defaults to big endian
       */
      static fromBytes(bytes2, endianness = "be") {
        if (bytes2.length !== 4) {
          throw new Error("Invalid input length. Expected 4 bytes.");
        }
        for (let i3 = 0; i3 < bytes2.length; ++i3) {
          if (!Number.isInteger(bytes2[i3]) || bytes2[i3] > 255 || bytes2[i3] < 0) {
            throw new Error(`Invalid value in byte. Found: ${bytes2[i3]}`);
          }
        }
        const beBytes = endianness === "be" ? bytes2 : Array.from(bytes2).reverse();
        return new _Uint32(beBytes[0] * 2 ** 24 + beBytes[1] * 2 ** 16 + beBytes[2] * 2 ** 8 + beBytes[3]);
      }
      static fromString(str2) {
        if (!str2.match(/^[0-9]+$/)) {
          throw new Error("Invalid string format");
        }
        return new _Uint32(Number.parseInt(str2, 10));
      }
      data;
      constructor(input) {
        if (Number.isNaN(input)) {
          throw new Error("Input is not a number");
        }
        if (!Number.isInteger(input)) {
          throw new Error("Input is not an integer");
        }
        if (input < 0 || input > 4294967295) {
          throw new Error("Input not in uint32 range: " + input.toString());
        }
        this.data = input;
      }
      toBytesBigEndian() {
        return new Uint8Array([
          Math.floor(this.data / 2 ** 24) & 255,
          Math.floor(this.data / 2 ** 16) & 255,
          Math.floor(this.data / 2 ** 8) & 255,
          Math.floor(this.data / 2 ** 0) & 255
        ]);
      }
      toBytesLittleEndian() {
        return new Uint8Array([
          Math.floor(this.data / 2 ** 0) & 255,
          Math.floor(this.data / 2 ** 8) & 255,
          Math.floor(this.data / 2 ** 16) & 255,
          Math.floor(this.data / 2 ** 24) & 255
        ]);
      }
      toNumber() {
        return this.data;
      }
      toBigInt() {
        return BigInt(this.toNumber());
      }
      toString() {
        return this.data.toString();
      }
    };
    exports.Uint32 = Uint32;
    var Int53 = class _Int53 {
      static fromString(str2) {
        if (!str2.match(/^-?[0-9]+$/)) {
          throw new Error("Invalid string format");
        }
        return new _Int53(Number.parseInt(str2, 10));
      }
      data;
      constructor(input) {
        if (Number.isNaN(input)) {
          throw new Error("Input is not a number");
        }
        if (!Number.isInteger(input)) {
          throw new Error("Input is not an integer");
        }
        if (input < Number.MIN_SAFE_INTEGER || input > Number.MAX_SAFE_INTEGER) {
          throw new Error("Input not in int53 range: " + input.toString());
        }
        this.data = input;
      }
      toNumber() {
        return this.data;
      }
      toBigInt() {
        return BigInt(this.toNumber());
      }
      toString() {
        return this.data.toString();
      }
    };
    exports.Int53 = Int53;
    var Uint53 = class _Uint53 {
      static fromString(str2) {
        const signed = Int53.fromString(str2);
        return new _Uint53(signed.toNumber());
      }
      data;
      constructor(input) {
        const signed = new Int53(input);
        if (signed.toNumber() < 0) {
          throw new Error("Input is negative");
        }
        this.data = signed;
      }
      toNumber() {
        return this.data.toNumber();
      }
      toBigInt() {
        return BigInt(this.toNumber());
      }
      toString() {
        return this.data.toString();
      }
    };
    exports.Uint53 = Uint53;
    var Uint64 = class _Uint64 {
      /** @deprecated use Uint64.fromBytes */
      static fromBytesBigEndian(bytes2) {
        return _Uint64.fromBytes(bytes2);
      }
      /**
       * Creates a Uint64 from a fixed length byte array.
       *
       * @param bytes a list of exactly 8 bytes
       * @param endianness defaults to big endian
       */
      static fromBytes(bytes2, endianness = "be") {
        if (bytes2.length !== 8) {
          throw new Error("Invalid input length. Expected 8 bytes.");
        }
        const beBytes = endianness === "be" ? Array.from(bytes2) : Array.from(bytes2).reverse();
        let value = 0n;
        for (const byte of beBytes) {
          value *= 256n;
          if (!Number.isInteger(byte) || byte > 255 || byte < 0) {
            throw new Error(`Invalid value in byte. Found: ${byte}`);
          }
          value += BigInt(byte);
        }
        return new _Uint64(value);
      }
      static fromString(str2) {
        if (!str2.match(/^[0-9]+$/)) {
          throw new Error("Invalid string format");
        }
        return new _Uint64(BigInt(str2));
      }
      static fromNumber(input) {
        if (Number.isNaN(input)) {
          throw new Error("Input is not a number");
        }
        if (!Number.isInteger(input)) {
          throw new Error("Input is not an integer");
        }
        if (!Number.isSafeInteger(input)) {
          throw new Error("Input is not a safe integer");
        }
        const bigint = BigInt(input);
        return new _Uint64(bigint);
      }
      data;
      constructor(data2) {
        if (data2 < 0n) {
          throw new Error("Input is negative");
        }
        if (data2 > uint64MaxValue) {
          throw new Error("Input exceeds uint64 range");
        }
        this.data = data2;
      }
      toBytesBigEndian() {
        return this.toBytesLittleEndian().reverse();
      }
      toBytesLittleEndian() {
        const bytes2 = new Uint8Array(8);
        let value = this.data;
        for (let i3 = 0; i3 < bytes2.length; i3++) {
          bytes2[i3] = Number(value % 256n);
          value /= 256n;
        }
        return bytes2;
      }
      toString() {
        return this.data.toString(10);
      }
      toBigInt() {
        return this.data;
      }
      toNumber() {
        if (this.data > BigInt(Number.MAX_SAFE_INTEGER)) {
          throw new Error("number can only safely store up to 53 bits");
        }
        const num = Number(this.data);
        return num;
      }
    };
    exports.Uint64 = Uint64;
  }
});

// node_modules/.pnpm/@cosmjs+math@0.37.0/node_modules/@cosmjs/math/build/index.js
var require_build3 = __commonJS({
  "node_modules/.pnpm/@cosmjs+math@0.37.0/node_modules/@cosmjs/math/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Uint64 = exports.Uint53 = exports.Uint32 = exports.Int53 = exports.Decimal = void 0;
    var decimal_1 = require_decimal();
    Object.defineProperty(exports, "Decimal", { enumerable: true, get: function() {
      return decimal_1.Decimal;
    } });
    var integers_1 = require_integers();
    Object.defineProperty(exports, "Int53", { enumerable: true, get: function() {
      return integers_1.Int53;
    } });
    Object.defineProperty(exports, "Uint32", { enumerable: true, get: function() {
      return integers_1.Uint32;
    } });
    Object.defineProperty(exports, "Uint53", { enumerable: true, get: function() {
      return integers_1.Uint53;
    } });
    Object.defineProperty(exports, "Uint64", { enumerable: true, get: function() {
      return integers_1.Uint64;
    } });
  }
});

// node_modules/.pnpm/@cosmjs+crypto@0.37.0/node_modules/@cosmjs/crypto/build/slip10.js
var require_slip10 = __commonJS({
  "node_modules/.pnpm/@cosmjs+crypto@0.37.0/node_modules/@cosmjs/crypto/build/slip10.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Slip10 = exports.Slip10RawIndex = exports.Slip10Curve = void 0;
    exports.slip10CurveFromString = slip10CurveFromString;
    exports.pathToString = pathToString;
    exports.stringToPath = stringToPath;
    var encoding_1 = require_build2();
    var math_1 = require_build3();
    var utils_1 = require_build();
    var secp256k1_1 = require_secp256k1();
    var hmac_1 = require_hmac2();
    var sha_1 = require_sha();
    var Slip10Curve;
    (function(Slip10Curve2) {
      Slip10Curve2["Secp256k1"] = "Bitcoin seed";
      Slip10Curve2["Ed25519"] = "ed25519 seed";
    })(Slip10Curve || (exports.Slip10Curve = Slip10Curve = {}));
    function bytesToUnsignedBigInt(a2) {
      return BigInt("0x" + (0, encoding_1.toHex)(a2));
    }
    function intTo32be(n2) {
      (0, utils_1.assert)(n2 >= 0n);
      (0, utils_1.assert)(n2 < 2n ** (32n * 8n));
      const hex2 = n2.toString(16).padStart(64, "0");
      return (0, encoding_1.fromHex)(hex2);
    }
    function slip10CurveFromString(curveString) {
      switch (curveString) {
        case Slip10Curve.Ed25519:
          return Slip10Curve.Ed25519;
        case Slip10Curve.Secp256k1:
          return Slip10Curve.Secp256k1;
        default:
          throw new Error(`Unknown curve string: '${curveString}'`);
      }
    }
    var Slip10RawIndex = class _Slip10RawIndex extends math_1.Uint32 {
      static hardened(hardenedIndex) {
        return new _Slip10RawIndex(hardenedIndex + 2 ** 31);
      }
      static normal(normalIndex) {
        return new _Slip10RawIndex(normalIndex);
      }
      isHardened() {
        return this.data >= 2 ** 31;
      }
    };
    exports.Slip10RawIndex = Slip10RawIndex;
    var Slip10 = class _Slip10 {
      static derivePath(curve, seed, path) {
        let result = this.master(curve, seed);
        for (const rawIndex of path) {
          result = this.child(curve, result.privkey, result.chainCode, rawIndex);
        }
        return result;
      }
      static master(curve, seed) {
        const i3 = new hmac_1.Hmac(sha_1.Sha512, (0, encoding_1.toAscii)(curve)).update(seed).digest();
        const il = i3.slice(0, 32);
        const ir3 = i3.slice(32, 64);
        if (curve !== Slip10Curve.Ed25519 && (this.isZero(il) || this.isGteN(curve, il))) {
          return this.master(curve, i3);
        }
        return {
          chainCode: ir3,
          privkey: il
        };
      }
      static child(curve, parentPrivkey, parentChainCode, rawIndex) {
        let i3;
        if (rawIndex.isHardened()) {
          const payload = new Uint8Array([0, ...parentPrivkey, ...rawIndex.toBytesBigEndian()]);
          i3 = new hmac_1.Hmac(sha_1.Sha512, parentChainCode).update(payload).digest();
        } else {
          if (curve === Slip10Curve.Ed25519) {
            throw new Error("Normal keys are not allowed with ed25519");
          } else {
            const data2 = new Uint8Array([
              ..._Slip10.serializedPoint(curve, bytesToUnsignedBigInt(parentPrivkey)),
              ...rawIndex.toBytesBigEndian()
            ]);
            i3 = new hmac_1.Hmac(sha_1.Sha512, parentChainCode).update(data2).digest();
          }
        }
        return this.childImpl(curve, parentPrivkey, parentChainCode, rawIndex, i3);
      }
      /**
       * Implementation of ser_P(point(k_par)) from BIP-0032
       *
       * @see https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki
       */
      static serializedPoint(curve, p4) {
        switch (curve) {
          case Slip10Curve.Secp256k1:
            return secp256k1_1.secp256k1.Point.BASE.multiply(p4).toBytes(true);
          default:
            throw new Error("curve not supported");
        }
      }
      static childImpl(curve, parentPrivkey, parentChainCode, rawIndex, i3) {
        const il = i3.slice(0, 32);
        const ir3 = i3.slice(32, 64);
        const returnChainCode = ir3;
        if (curve === Slip10Curve.Ed25519) {
          return {
            chainCode: returnChainCode,
            privkey: il
          };
        }
        const n2 = this.n(curve);
        const returnChildKeyAsNumber = (bytesToUnsignedBigInt(il) + bytesToUnsignedBigInt(parentPrivkey)) % n2;
        const returnChildKey = intTo32be(returnChildKeyAsNumber);
        if (this.isGteN(curve, il) || this.isZero(returnChildKey)) {
          const newI = new hmac_1.Hmac(sha_1.Sha512, parentChainCode).update(new Uint8Array([1, ...ir3, ...rawIndex.toBytesBigEndian()])).digest();
          return this.childImpl(curve, parentPrivkey, parentChainCode, rawIndex, newI);
        }
        return {
          chainCode: returnChainCode,
          privkey: returnChildKey
        };
      }
      static isZero(privkey) {
        return privkey.every((byte) => byte === 0);
      }
      static isGteN(curve, privkey) {
        const keyAsNumber = bytesToUnsignedBigInt(privkey);
        return keyAsNumber >= this.n(curve);
      }
      static n(curve) {
        switch (curve) {
          case Slip10Curve.Secp256k1:
            return 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n;
          default:
            throw new Error("curve not supported");
        }
      }
    };
    exports.Slip10 = Slip10;
    function pathToString(path) {
      return path.reduce((current, component) => {
        const componentString = component.isHardened() ? `${component.toNumber() - 2 ** 31}'` : component.toString();
        return current + "/" + componentString;
      }, "m");
    }
    function stringToPath(input) {
      if (!input.startsWith("m"))
        throw new Error("Path string must start with 'm'");
      let rest = input.slice(1);
      const out = new Array();
      while (rest) {
        const match = rest.match(/^\/([0-9]+)('?)/);
        if (!match)
          throw new Error("Syntax error while reading path component");
        const [fullMatch, numberString, apostrophe] = match;
        const value = math_1.Uint53.fromString(numberString).toNumber();
        if (value >= 2 ** 31)
          throw new Error("Component value too high. Must not exceed 2**31-1.");
        if (apostrophe)
          out.push(Slip10RawIndex.hardened(value));
        else
          out.push(Slip10RawIndex.normal(value));
        rest = rest.slice(fullMatch.length);
      }
      return out;
    }
  }
});

// node_modules/.pnpm/@cosmjs+crypto@0.37.0/node_modules/@cosmjs/crypto/build/index.js
var require_build4 = __commonJS({
  "node_modules/.pnpm/@cosmjs+crypto@0.37.0/node_modules/@cosmjs/crypto/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringToPath = exports.Slip10RawIndex = exports.slip10CurveFromString = exports.Slip10Curve = exports.Slip10 = exports.pathToString = exports.sha512 = exports.Sha512 = exports.sha256 = exports.Sha256 = exports.Secp256k1Signature = exports.ExtendedSecp256k1Signature = exports.Secp256k1 = exports.ripemd160 = exports.Ripemd160 = exports.Random = exports.Xchacha20poly1305Ietf = exports.xchacha20NonceLength = exports.isArgon2idOptions = exports.Ed25519Keypair = exports.Ed25519 = exports.Argon2id = exports.keccak256 = exports.Keccak256 = exports.Hmac = exports.EnglishMnemonic = exports.Bip39 = void 0;
    var bip39_1 = require_bip392();
    Object.defineProperty(exports, "Bip39", { enumerable: true, get: function() {
      return bip39_1.Bip39;
    } });
    Object.defineProperty(exports, "EnglishMnemonic", { enumerable: true, get: function() {
      return bip39_1.EnglishMnemonic;
    } });
    var hmac_1 = require_hmac2();
    Object.defineProperty(exports, "Hmac", { enumerable: true, get: function() {
      return hmac_1.Hmac;
    } });
    var keccak_1 = require_keccak();
    Object.defineProperty(exports, "Keccak256", { enumerable: true, get: function() {
      return keccak_1.Keccak256;
    } });
    Object.defineProperty(exports, "keccak256", { enumerable: true, get: function() {
      return keccak_1.keccak256;
    } });
    var libsodium_1 = require_libsodium();
    Object.defineProperty(exports, "Argon2id", { enumerable: true, get: function() {
      return libsodium_1.Argon2id;
    } });
    Object.defineProperty(exports, "Ed25519", { enumerable: true, get: function() {
      return libsodium_1.Ed25519;
    } });
    Object.defineProperty(exports, "Ed25519Keypair", { enumerable: true, get: function() {
      return libsodium_1.Ed25519Keypair;
    } });
    Object.defineProperty(exports, "isArgon2idOptions", { enumerable: true, get: function() {
      return libsodium_1.isArgon2idOptions;
    } });
    Object.defineProperty(exports, "xchacha20NonceLength", { enumerable: true, get: function() {
      return libsodium_1.xchacha20NonceLength;
    } });
    Object.defineProperty(exports, "Xchacha20poly1305Ietf", { enumerable: true, get: function() {
      return libsodium_1.Xchacha20poly1305Ietf;
    } });
    var random_1 = require_random();
    Object.defineProperty(exports, "Random", { enumerable: true, get: function() {
      return random_1.Random;
    } });
    var ripemd_1 = require_ripemd();
    Object.defineProperty(exports, "Ripemd160", { enumerable: true, get: function() {
      return ripemd_1.Ripemd160;
    } });
    Object.defineProperty(exports, "ripemd160", { enumerable: true, get: function() {
      return ripemd_1.ripemd160;
    } });
    var secp256k1_1 = require_secp256k12();
    Object.defineProperty(exports, "Secp256k1", { enumerable: true, get: function() {
      return secp256k1_1.Secp256k1;
    } });
    var secp256k1signature_1 = require_secp256k1signature();
    Object.defineProperty(exports, "ExtendedSecp256k1Signature", { enumerable: true, get: function() {
      return secp256k1signature_1.ExtendedSecp256k1Signature;
    } });
    Object.defineProperty(exports, "Secp256k1Signature", { enumerable: true, get: function() {
      return secp256k1signature_1.Secp256k1Signature;
    } });
    var sha_1 = require_sha();
    Object.defineProperty(exports, "Sha256", { enumerable: true, get: function() {
      return sha_1.Sha256;
    } });
    Object.defineProperty(exports, "sha256", { enumerable: true, get: function() {
      return sha_1.sha256;
    } });
    Object.defineProperty(exports, "Sha512", { enumerable: true, get: function() {
      return sha_1.Sha512;
    } });
    Object.defineProperty(exports, "sha512", { enumerable: true, get: function() {
      return sha_1.sha512;
    } });
    var slip10_1 = require_slip10();
    Object.defineProperty(exports, "pathToString", { enumerable: true, get: function() {
      return slip10_1.pathToString;
    } });
    Object.defineProperty(exports, "Slip10", { enumerable: true, get: function() {
      return slip10_1.Slip10;
    } });
    Object.defineProperty(exports, "Slip10Curve", { enumerable: true, get: function() {
      return slip10_1.Slip10Curve;
    } });
    Object.defineProperty(exports, "slip10CurveFromString", { enumerable: true, get: function() {
      return slip10_1.slip10CurveFromString;
    } });
    Object.defineProperty(exports, "Slip10RawIndex", { enumerable: true, get: function() {
      return slip10_1.Slip10RawIndex;
    } });
    Object.defineProperty(exports, "stringToPath", { enumerable: true, get: function() {
      return slip10_1.stringToPath;
    } });
  }
});

// node_modules/.pnpm/@cosmjs+amino@0.37.0/node_modules/@cosmjs/amino/build/pubkeys.js
var require_pubkeys = __commonJS({
  "node_modules/.pnpm/@cosmjs+amino@0.37.0/node_modules/@cosmjs/amino/build/pubkeys.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pubkeyType = void 0;
    exports.isEd25519Pubkey = isEd25519Pubkey;
    exports.isSecp256k1Pubkey = isSecp256k1Pubkey;
    exports.isSinglePubkey = isSinglePubkey;
    exports.isMultisigThresholdPubkey = isMultisigThresholdPubkey;
    function isEd25519Pubkey(pubkey) {
      return pubkey.type === "tendermint/PubKeyEd25519";
    }
    function isSecp256k1Pubkey(pubkey) {
      return pubkey.type === "tendermint/PubKeySecp256k1";
    }
    exports.pubkeyType = {
      /** @see https://github.com/tendermint/tendermint/blob/v0.33.0/crypto/ed25519/ed25519.go#L22 */
      secp256k1: "tendermint/PubKeySecp256k1",
      /** @see https://github.com/tendermint/tendermint/blob/v0.33.0/crypto/secp256k1/secp256k1.go#L23 */
      ed25519: "tendermint/PubKeyEd25519",
      /** @see https://github.com/tendermint/tendermint/blob/v0.33.0/crypto/sr25519/codec.go#L12 */
      sr25519: "tendermint/PubKeySr25519",
      multisigThreshold: "tendermint/PubKeyMultisigThreshold"
    };
    function isSinglePubkey(pubkey) {
      const singPubkeyTypes = [exports.pubkeyType.ed25519, exports.pubkeyType.secp256k1, exports.pubkeyType.sr25519];
      return singPubkeyTypes.includes(pubkey.type);
    }
    function isMultisigThresholdPubkey(pubkey) {
      return pubkey.type === "tendermint/PubKeyMultisigThreshold";
    }
  }
});

// node_modules/.pnpm/@cosmjs+amino@0.37.0/node_modules/@cosmjs/amino/build/encoding.js
var require_encoding = __commonJS({
  "node_modules/.pnpm/@cosmjs+amino@0.37.0/node_modules/@cosmjs/amino/build/encoding.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeSecp256k1Pubkey = encodeSecp256k1Pubkey;
    exports.encodeEd25519Pubkey = encodeEd25519Pubkey;
    exports.decodeAminoPubkey = decodeAminoPubkey;
    exports.decodeBech32Pubkey = decodeBech32Pubkey;
    exports.encodeAminoPubkey = encodeAminoPubkey;
    exports.encodeBech32Pubkey = encodeBech32Pubkey;
    var encoding_1 = require_build2();
    var math_1 = require_build3();
    var utils_1 = require_build();
    var pubkeys_1 = require_pubkeys();
    function encodeSecp256k1Pubkey(pubkey) {
      if (pubkey.length !== 33 || pubkey[0] !== 2 && pubkey[0] !== 3) {
        throw new Error("Public key must be compressed secp256k1, i.e. 33 bytes starting with 0x02 or 0x03");
      }
      return {
        type: pubkeys_1.pubkeyType.secp256k1,
        value: (0, encoding_1.toBase64)(pubkey)
      };
    }
    function encodeEd25519Pubkey(pubkey) {
      if (pubkey.length !== 32) {
        throw new Error("Ed25519 public key must be 32 bytes long");
      }
      return {
        type: pubkeys_1.pubkeyType.ed25519,
        value: (0, encoding_1.toBase64)(pubkey)
      };
    }
    var pubkeyAminoPrefixSecp256k1 = (0, encoding_1.fromHex)(
      "eb5ae98721"
      /* fixed length */
    );
    var pubkeyAminoPrefixEd25519 = (0, encoding_1.fromHex)(
      "1624de6420"
      /* fixed length */
    );
    var pubkeyAminoPrefixSr25519 = (0, encoding_1.fromHex)(
      "0dfb100520"
      /* fixed length */
    );
    var pubkeyAminoPrefixMultisigThreshold = (0, encoding_1.fromHex)(
      "22c1f7e2"
      /* variable length not included */
    );
    function decodeAminoPubkey(data2) {
      if ((0, utils_1.arrayContentStartsWith)(data2, pubkeyAminoPrefixSecp256k1)) {
        const rest = data2.slice(pubkeyAminoPrefixSecp256k1.length);
        if (rest.length !== 33) {
          throw new Error("Invalid rest data length. Expected 33 bytes (compressed secp256k1 pubkey).");
        }
        return {
          type: pubkeys_1.pubkeyType.secp256k1,
          value: (0, encoding_1.toBase64)(rest)
        };
      } else if ((0, utils_1.arrayContentStartsWith)(data2, pubkeyAminoPrefixEd25519)) {
        const rest = data2.slice(pubkeyAminoPrefixEd25519.length);
        if (rest.length !== 32) {
          throw new Error("Invalid rest data length. Expected 32 bytes (Ed25519 pubkey).");
        }
        return {
          type: pubkeys_1.pubkeyType.ed25519,
          value: (0, encoding_1.toBase64)(rest)
        };
      } else if ((0, utils_1.arrayContentStartsWith)(data2, pubkeyAminoPrefixSr25519)) {
        const rest = data2.slice(pubkeyAminoPrefixSr25519.length);
        if (rest.length !== 32) {
          throw new Error("Invalid rest data length. Expected 32 bytes (Sr25519 pubkey).");
        }
        return {
          type: pubkeys_1.pubkeyType.sr25519,
          value: (0, encoding_1.toBase64)(rest)
        };
      } else if ((0, utils_1.arrayContentStartsWith)(data2, pubkeyAminoPrefixMultisigThreshold)) {
        return decodeMultisigPubkey(data2);
      } else {
        throw new Error("Unsupported public key type. Amino data starts with: " + (0, encoding_1.toHex)(data2.slice(0, 5)));
      }
    }
    function decodeBech32Pubkey(bechEncoded) {
      const { data: data2 } = (0, encoding_1.fromBech32)(bechEncoded);
      return decodeAminoPubkey(data2);
    }
    function decodeUvarint(reader) {
      if (reader.length < 1) {
        throw new Error("Can't decode varint. EOF");
      }
      if (reader[0] > 127) {
        throw new Error("Decoding numbers > 127 is not supported here. Please tell those lazy CosmJS maintainers to port the binary.Varint implementation from the Go standard library and write some tests.");
      }
      return [reader[0], 1];
    }
    function decodeMultisigPubkey(data2) {
      const reader = Array.from(data2);
      const prefixFromReader = reader.splice(0, pubkeyAminoPrefixMultisigThreshold.length);
      if (!(0, utils_1.arrayContentStartsWith)(prefixFromReader, pubkeyAminoPrefixMultisigThreshold)) {
        throw new Error("Invalid multisig prefix.");
      }
      if (reader.shift() != 8) {
        throw new Error("Invalid multisig data. Expecting 0x08 prefix before threshold.");
      }
      const [threshold, thresholdBytesLength] = decodeUvarint(reader);
      reader.splice(0, thresholdBytesLength);
      const pubkeys = [];
      while (reader.length > 0) {
        if (reader.shift() != 18) {
          throw new Error("Invalid multisig data. Expecting 0x12 prefix before participant pubkey length.");
        }
        const [pubkeyLength, pubkeyLengthBytesSize] = decodeUvarint(reader);
        reader.splice(0, pubkeyLengthBytesSize);
        if (reader.length < pubkeyLength) {
          throw new Error("Invalid multisig data length.");
        }
        const encodedPubkey = reader.splice(0, pubkeyLength);
        const pubkey = decodeAminoPubkey(Uint8Array.from(encodedPubkey));
        pubkeys.push(pubkey);
      }
      return {
        type: pubkeys_1.pubkeyType.multisigThreshold,
        value: {
          threshold: threshold.toString(),
          pubkeys
        }
      };
    }
    function encodeUvarint(value) {
      const checked = math_1.Uint53.fromString(value.toString()).toNumber();
      if (checked > 127) {
        throw new Error("Encoding numbers > 127 is not supported here. Please tell those lazy CosmJS maintainers to port the binary.PutUvarint implementation from the Go standard library and write some tests.");
      }
      return [checked];
    }
    function encodeAminoPubkey(pubkey) {
      if ((0, pubkeys_1.isMultisigThresholdPubkey)(pubkey)) {
        const out = Array.from(pubkeyAminoPrefixMultisigThreshold);
        out.push(8);
        out.push(...encodeUvarint(pubkey.value.threshold));
        for (const pubkeyData of pubkey.value.pubkeys.map((p4) => encodeAminoPubkey(p4))) {
          out.push(18);
          out.push(...encodeUvarint(pubkeyData.length));
          out.push(...pubkeyData);
        }
        return new Uint8Array(out);
      } else if ((0, pubkeys_1.isEd25519Pubkey)(pubkey)) {
        return new Uint8Array([...pubkeyAminoPrefixEd25519, ...(0, encoding_1.fromBase64)(pubkey.value)]);
      } else if ((0, pubkeys_1.isSecp256k1Pubkey)(pubkey)) {
        return new Uint8Array([...pubkeyAminoPrefixSecp256k1, ...(0, encoding_1.fromBase64)(pubkey.value)]);
      } else {
        throw new Error("Unsupported pubkey type");
      }
    }
    function encodeBech32Pubkey(pubkey, prefix) {
      return (0, encoding_1.toBech32)(prefix, encodeAminoPubkey(pubkey));
    }
  }
});

// node_modules/.pnpm/@cosmjs+amino@0.37.0/node_modules/@cosmjs/amino/build/addresses.js
var require_addresses = __commonJS({
  "node_modules/.pnpm/@cosmjs+amino@0.37.0/node_modules/@cosmjs/amino/build/addresses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rawEd25519PubkeyToRawAddress = rawEd25519PubkeyToRawAddress;
    exports.rawSecp256k1PubkeyToRawAddress = rawSecp256k1PubkeyToRawAddress2;
    exports.pubkeyToRawAddress = pubkeyToRawAddress;
    exports.pubkeyToAddress = pubkeyToAddress;
    var crypto_1 = require_build4();
    var encoding_1 = require_build2();
    var encoding_2 = require_encoding();
    var pubkeys_1 = require_pubkeys();
    function rawEd25519PubkeyToRawAddress(pubkeyData) {
      if (pubkeyData.length !== 32) {
        throw new Error(`Invalid Ed25519 pubkey length: ${pubkeyData.length}`);
      }
      return (0, crypto_1.sha256)(pubkeyData).slice(0, 20);
    }
    function rawSecp256k1PubkeyToRawAddress2(pubkeyData) {
      if (pubkeyData.length !== 33) {
        throw new Error(`Invalid Secp256k1 pubkey length (compressed): ${pubkeyData.length}`);
      }
      return (0, crypto_1.ripemd160)((0, crypto_1.sha256)(pubkeyData));
    }
    function pubkeyToRawAddress(pubkey) {
      if ((0, pubkeys_1.isSecp256k1Pubkey)(pubkey)) {
        const pubkeyData = (0, encoding_1.fromBase64)(pubkey.value);
        return rawSecp256k1PubkeyToRawAddress2(pubkeyData);
      } else if ((0, pubkeys_1.isEd25519Pubkey)(pubkey)) {
        const pubkeyData = (0, encoding_1.fromBase64)(pubkey.value);
        return rawEd25519PubkeyToRawAddress(pubkeyData);
      } else if ((0, pubkeys_1.isMultisigThresholdPubkey)(pubkey)) {
        const pubkeyData = (0, encoding_2.encodeAminoPubkey)(pubkey);
        return (0, crypto_1.sha256)(pubkeyData).slice(0, 20);
      } else {
        throw new Error("Unsupported public key type");
      }
    }
    function pubkeyToAddress(pubkey, prefix) {
      return (0, encoding_1.toBech32)(prefix, pubkeyToRawAddress(pubkey));
    }
  }
});

// node_modules/.pnpm/@cosmjs+amino@0.37.0/node_modules/@cosmjs/amino/build/coins.js
var require_coins = __commonJS({
  "node_modules/.pnpm/@cosmjs+amino@0.37.0/node_modules/@cosmjs/amino/build/coins.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.coin = coin2;
    exports.coins = coins;
    exports.parseCoins = parseCoins;
    exports.addCoins = addCoins;
    var math_1 = require_build3();
    function coin2(amount, denom) {
      let outAmount;
      if (typeof amount === "number") {
        try {
          outAmount = new math_1.Uint53(amount).toString();
        } catch (_err) {
          throw new Error("Given amount is not a safe integer. Consider using a string instead to overcome the limitations of JS numbers.");
        }
      } else {
        if (!amount.match(/^[0-9]+$/)) {
          throw new Error("Invalid unsigned integer string format");
        }
        outAmount = amount.replace(/^0*/, "") || "0";
      }
      return {
        amount: outAmount,
        denom
      };
    }
    function coins(amount, denom) {
      return [coin2(amount, denom)];
    }
    function parseCoins(input) {
      return input.replace(/\s/g, "").split(",").filter(Boolean).map((part) => {
        const match = part.match(/^([0-9]+)([a-zA-Z][a-zA-Z0-9/:._-]{2,127})$/);
        if (!match)
          throw new Error("Got an invalid coin string");
        return {
          amount: match[1].replace(/^0+/, "") || "0",
          denom: match[2]
        };
      });
    }
    function addCoins(lhs, rhs) {
      if (lhs.denom !== rhs.denom)
        throw new Error("Trying to add two coins with different denoms");
      return {
        amount: math_1.Decimal.fromAtomics(lhs.amount, 0).plus(math_1.Decimal.fromAtomics(rhs.amount, 0)).atomics,
        denom: lhs.denom
      };
    }
  }
});

// node_modules/.pnpm/@cosmjs+amino@0.37.0/node_modules/@cosmjs/amino/build/multisig.js
var require_multisig = __commonJS({
  "node_modules/.pnpm/@cosmjs+amino@0.37.0/node_modules/@cosmjs/amino/build/multisig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.compareArrays = compareArrays;
    exports.createMultisigThresholdPubkey = createMultisigThresholdPubkey;
    var encoding_1 = require_build2();
    var math_1 = require_build3();
    var addresses_1 = require_addresses();
    function compareArrays(a2, b5) {
      const aHex = (0, encoding_1.toHex)(a2);
      const bHex = (0, encoding_1.toHex)(b5);
      return aHex === bHex ? 0 : aHex < bHex ? -1 : 1;
    }
    function createMultisigThresholdPubkey(pubkeys, threshold, nosort = false) {
      const uintThreshold = new math_1.Uint53(threshold);
      if (uintThreshold.toNumber() > pubkeys.length) {
        throw new Error(`Threshold k = ${uintThreshold.toNumber()} exceeds number of keys n = ${pubkeys.length}`);
      }
      const outPubkeys = nosort ? pubkeys : Array.from(pubkeys).sort((lhs, rhs) => {
        const addressLhs = (0, addresses_1.pubkeyToRawAddress)(lhs);
        const addressRhs = (0, addresses_1.pubkeyToRawAddress)(rhs);
        return compareArrays(addressLhs, addressRhs);
      });
      return {
        type: "tendermint/PubKeyMultisigThreshold",
        value: {
          threshold: uintThreshold.toString(),
          pubkeys: outPubkeys
        }
      };
    }
  }
});

// node_modules/.pnpm/@cosmjs+amino@0.37.0/node_modules/@cosmjs/amino/build/omitdefault.js
var require_omitdefault = __commonJS({
  "node_modules/.pnpm/@cosmjs+amino@0.37.0/node_modules/@cosmjs/amino/build/omitdefault.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.omitDefault = omitDefault;
    function omitDefault(input) {
      switch (typeof input) {
        case "string":
          return input === "" ? void 0 : input;
        case "number":
          return input === 0 ? void 0 : input;
        case "bigint":
          return input === BigInt(0) ? void 0 : input;
        case "boolean":
          return !input ? void 0 : input;
        default:
          throw new Error(`Got unsupported type '${typeof input}'`);
      }
    }
  }
});

// node_modules/.pnpm/@cosmjs+amino@0.37.0/node_modules/@cosmjs/amino/build/paths.js
var require_paths = __commonJS({
  "node_modules/.pnpm/@cosmjs+amino@0.37.0/node_modules/@cosmjs/amino/build/paths.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.makeCosmoshubPath = makeCosmoshubPath;
    var crypto_1 = require_build4();
    function makeCosmoshubPath(a2) {
      return [
        crypto_1.Slip10RawIndex.hardened(44),
        crypto_1.Slip10RawIndex.hardened(118),
        crypto_1.Slip10RawIndex.hardened(0),
        crypto_1.Slip10RawIndex.normal(0),
        crypto_1.Slip10RawIndex.normal(a2)
      ];
    }
  }
});

// node_modules/.pnpm/@cosmjs+amino@0.37.0/node_modules/@cosmjs/amino/build/signature.js
var require_signature = __commonJS({
  "node_modules/.pnpm/@cosmjs+amino@0.37.0/node_modules/@cosmjs/amino/build/signature.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeSecp256k1Signature = encodeSecp256k1Signature2;
    exports.decodeSignature = decodeSignature;
    var encoding_1 = require_build2();
    var encoding_2 = require_encoding();
    var pubkeys_1 = require_pubkeys();
    function encodeSecp256k1Signature2(pubkey, signature) {
      if (signature.length !== 64) {
        throw new Error("Signature must be 64 bytes long. Cosmos SDK uses a 2x32 byte fixed length encoding for the secp256k1 signature integers r and s.");
      }
      return {
        pub_key: (0, encoding_2.encodeSecp256k1Pubkey)(pubkey),
        signature: (0, encoding_1.toBase64)(signature)
      };
    }
    function decodeSignature(signature) {
      switch (signature.pub_key.type) {
        // Note: please don't add cases here without writing additional unit tests
        case pubkeys_1.pubkeyType.secp256k1:
          return {
            pubkey: (0, encoding_1.fromBase64)(signature.pub_key.value),
            signature: (0, encoding_1.fromBase64)(signature.signature)
          };
        default:
          throw new Error("Unsupported pubkey type");
      }
    }
  }
});

// node_modules/.pnpm/@cosmjs+amino@0.37.0/node_modules/@cosmjs/amino/build/signdoc.js
var require_signdoc = __commonJS({
  "node_modules/.pnpm/@cosmjs+amino@0.37.0/node_modules/@cosmjs/amino/build/signdoc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sortedJsonStringify = sortedJsonStringify;
    exports.makeSignDoc = makeSignDoc;
    exports.escapeCharacters = escapeCharacters;
    exports.serializeSignDoc = serializeSignDoc2;
    var encoding_1 = require_build2();
    var math_1 = require_build3();
    function sortedObject(obj) {
      if (typeof obj !== "object" || obj === null) {
        return obj;
      }
      if (Array.isArray(obj)) {
        return obj.map(sortedObject);
      }
      const sortedKeys = Object.keys(obj).sort();
      const result = {};
      sortedKeys.forEach((key) => {
        result[key] = sortedObject(obj[key]);
      });
      return result;
    }
    function sortedJsonStringify(obj) {
      return JSON.stringify(sortedObject(obj));
    }
    function makeSignDoc(msgs, fee, chainId, memo, accountNumber, sequence, timeout_height) {
      return {
        chain_id: chainId,
        account_number: math_1.Uint53.fromString(accountNumber.toString()).toString(),
        sequence: math_1.Uint53.fromString(sequence.toString()).toString(),
        fee,
        msgs,
        memo: memo || "",
        ...timeout_height && { timeout_height: timeout_height.toString() }
      };
    }
    function escapeCharacters(input) {
      const amp = /&/g;
      const lt2 = /</g;
      const gt3 = />/g;
      return input.replace(amp, "\\u0026").replace(lt2, "\\u003c").replace(gt3, "\\u003e");
    }
    function serializeSignDoc2(signDoc) {
      const serialized = escapeCharacters(sortedJsonStringify(signDoc));
      return (0, encoding_1.toUtf8)(serialized);
    }
  }
});

// node_modules/.pnpm/@cosmjs+amino@0.37.0/node_modules/@cosmjs/amino/build/wallet.js
var require_wallet = __commonJS({
  "node_modules/.pnpm/@cosmjs+amino@0.37.0/node_modules/@cosmjs/amino/build/wallet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.supportedAlgorithms = exports.cosmjsSalt = void 0;
    exports.executeKdf = executeKdf;
    exports.encrypt = encrypt;
    exports.decrypt = decrypt;
    var crypto_1 = require_build4();
    var encoding_1 = require_build2();
    var utils_1 = require_build();
    exports.cosmjsSalt = (0, encoding_1.toAscii)("The CosmJS salt.");
    async function executeKdf(password, configuration) {
      switch (configuration.algorithm) {
        case "argon2id": {
          const options = configuration.params;
          if (!(0, crypto_1.isArgon2idOptions)(options))
            throw new Error("Invalid format of argon2id params");
          const screamTest = (0, utils_1.sleep)(options.opsLimit * 250);
          const result = await crypto_1.Argon2id.execute(password, exports.cosmjsSalt, options);
          await screamTest;
          return result;
        }
        default:
          throw new Error("Unsupported KDF algorithm");
      }
    }
    exports.supportedAlgorithms = {
      xchacha20poly1305Ietf: "xchacha20poly1305-ietf"
    };
    async function encrypt(plaintext, encryptionKey, config) {
      switch (config.algorithm) {
        case exports.supportedAlgorithms.xchacha20poly1305Ietf: {
          const nonce = crypto_1.Random.getBytes(crypto_1.xchacha20NonceLength);
          return new Uint8Array([
            ...nonce,
            ...await crypto_1.Xchacha20poly1305Ietf.encrypt(plaintext, encryptionKey, nonce)
          ]);
        }
        default:
          throw new Error(`Unsupported encryption algorithm: '${config.algorithm}'`);
      }
    }
    async function decrypt(ciphertext, encryptionKey, config) {
      switch (config.algorithm) {
        case exports.supportedAlgorithms.xchacha20poly1305Ietf: {
          const nonce = ciphertext.slice(0, crypto_1.xchacha20NonceLength);
          return crypto_1.Xchacha20poly1305Ietf.decrypt(ciphertext.slice(crypto_1.xchacha20NonceLength), encryptionKey, nonce);
        }
        default:
          throw new Error(`Unsupported encryption algorithm: '${config.algorithm}'`);
      }
    }
  }
});

// node_modules/.pnpm/@cosmjs+amino@0.37.0/node_modules/@cosmjs/amino/build/secp256k1hdwallet.js
var require_secp256k1hdwallet = __commonJS({
  "node_modules/.pnpm/@cosmjs+amino@0.37.0/node_modules/@cosmjs/amino/build/secp256k1hdwallet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Secp256k1HdWallet = void 0;
    exports.extractKdfConfiguration = extractKdfConfiguration;
    var crypto_1 = require_build4();
    var encoding_1 = require_build2();
    var utils_1 = require_build();
    var addresses_1 = require_addresses();
    var paths_1 = require_paths();
    var signature_1 = require_signature();
    var signdoc_1 = require_signdoc();
    var wallet_1 = require_wallet();
    var serializationTypeV1 = "secp256k1wallet-v1";
    var basicPasswordHashingOptions = {
      algorithm: "argon2id",
      params: {
        outputLength: 32,
        opsLimit: 24,
        memLimitKib: 12 * 1024
      }
    };
    function isDerivationJson(thing) {
      if (!(0, utils_1.isNonNullObject)(thing))
        return false;
      if (typeof thing.hdPath !== "string")
        return false;
      if (typeof thing.prefix !== "string")
        return false;
      return true;
    }
    function extractKdfConfigurationV1(doc) {
      return doc.kdf;
    }
    function extractKdfConfiguration(serialization) {
      const root = JSON.parse(serialization);
      if (!(0, utils_1.isNonNullObject)(root))
        throw new Error("Root document is not an object.");
      switch (root.type) {
        case serializationTypeV1:
          return extractKdfConfigurationV1(root);
        default:
          throw new Error("Unsupported serialization type");
      }
    }
    var defaultOptions = {
      bip39Password: "",
      hdPaths: [(0, paths_1.makeCosmoshubPath)(0)],
      prefix: "cosmos"
    };
    var Secp256k1HdWallet = class _Secp256k1HdWallet {
      /**
       * Restores a wallet from the given BIP39 mnemonic.
       *
       * @param mnemonic Any valid English mnemonic.
       * @param options An optional `Secp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
       */
      static async fromMnemonic(mnemonic, options = {}) {
        const mnemonicChecked = new crypto_1.EnglishMnemonic(mnemonic);
        const seed = await crypto_1.Bip39.mnemonicToSeed(mnemonicChecked, options.bip39Password);
        return new _Secp256k1HdWallet(mnemonicChecked, {
          ...options,
          seed
        });
      }
      /**
       * Generates a new wallet with a BIP39 mnemonic of the given length.
       *
       * @param length The number of words in the mnemonic (12, 15, 18, 21 or 24).
       * @param options An optional `Secp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
       */
      static async generate(length = 12, options = {}) {
        const entropyLength = 4 * Math.floor(11 * length / 33);
        const entropy = crypto_1.Random.getBytes(entropyLength);
        const mnemonic = crypto_1.Bip39.encode(entropy);
        return _Secp256k1HdWallet.fromMnemonic(mnemonic.toString(), options);
      }
      /**
       * Restores a wallet from an encrypted serialization.
       *
       * @param password The user provided password used to generate an encryption key via a KDF.
       *                 This is not normalized internally (see "Unicode normalization" to learn more).
       *
       * @deprecated Wallet encryption support will be removed from CosmJS in a future version.
       *             If you actually use this, please comment at https://github.com/cosmos/cosmjs/issues/1796.
       */
      static async deserialize(serialization, password) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root))
          throw new Error("Root document is not an object.");
        switch (root.type) {
          case serializationTypeV1:
            return _Secp256k1HdWallet.deserializeTypeV1(serialization, password);
          default:
            throw new Error("Unsupported serialization type");
        }
      }
      /**
       * Restores a wallet from an encrypted serialization.
       *
       * This is an advanced alternative to calling `deserialize(serialization, password)` directly, which allows
       * you to offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
       *
       * The caller is responsible for ensuring the key was derived with the given KDF configuration. This can be
       * done using `extractKdfConfiguration(serialization)` and `executeKdf(password, kdfConfiguration)` from this package.
       *
       * @deprecated Wallet encryption support will be removed from CosmJS in a future version.
       *             If you actually use this, please comment at https://github.com/cosmos/cosmjs/issues/1796.
       */
      static async deserializeWithEncryptionKey(serialization, encryptionKey) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root))
          throw new Error("Root document is not an object.");
        const untypedRoot = root;
        switch (untypedRoot.type) {
          case serializationTypeV1: {
            const decryptedBytes = await (0, wallet_1.decrypt)((0, encoding_1.fromBase64)(untypedRoot.data), encryptionKey, untypedRoot.encryption);
            const decryptedDocument = JSON.parse((0, encoding_1.fromUtf8)(decryptedBytes));
            const { mnemonic, accounts } = decryptedDocument;
            (0, utils_1.assert)(typeof mnemonic === "string");
            if (!Array.isArray(accounts))
              throw new Error("Property 'accounts' is not an array");
            if (!accounts.every((account) => isDerivationJson(account))) {
              throw new Error("Account is not in the correct format.");
            }
            const firstPrefix = accounts[0].prefix;
            if (!accounts.every(({ prefix }) => prefix === firstPrefix)) {
              throw new Error("Accounts do not all have the same prefix");
            }
            const hdPaths = accounts.map(({ hdPath }) => (0, crypto_1.stringToPath)(hdPath));
            return _Secp256k1HdWallet.fromMnemonic(mnemonic, {
              hdPaths,
              prefix: firstPrefix
            });
          }
          default:
            throw new Error("Unsupported serialization type");
        }
      }
      static async deserializeTypeV1(serialization, password) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root))
          throw new Error("Root document is not an object.");
        const encryptionKey = await (0, wallet_1.executeKdf)(password, root.kdf);
        return _Secp256k1HdWallet.deserializeWithEncryptionKey(serialization, encryptionKey);
      }
      /** Base secret */
      secret;
      /** BIP39 seed */
      seed;
      /** Derivation instruction */
      accounts;
      constructor(mnemonic, options) {
        const hdPaths = options.hdPaths ?? defaultOptions.hdPaths;
        const prefix = options.prefix ?? defaultOptions.prefix;
        this.secret = mnemonic;
        this.seed = options.seed;
        this.accounts = hdPaths.map((hdPath) => ({
          hdPath,
          prefix
        }));
      }
      get mnemonic() {
        return this.secret.toString();
      }
      async getAccounts() {
        const accountsWithPrivkeys = await this.getAccountsWithPrivkeys();
        return accountsWithPrivkeys.map(({ algo, pubkey, address }) => ({
          algo,
          pubkey,
          address
        }));
      }
      async signAmino(signerAddress, signDoc) {
        const accounts = await this.getAccountsWithPrivkeys();
        const account = accounts.find(({ address }) => address === signerAddress);
        if (account === void 0) {
          throw new Error(`Address ${signerAddress} not found in wallet`);
        }
        const { privkey, pubkey } = account;
        const message = (0, crypto_1.sha256)((0, signdoc_1.serializeSignDoc)(signDoc));
        const signature = await crypto_1.Secp256k1.createSignature(message, privkey);
        const signatureBytes = new Uint8Array([...signature.r(32), ...signature.s(32)]);
        return {
          signed: signDoc,
          signature: (0, signature_1.encodeSecp256k1Signature)(pubkey, signatureBytes)
        };
      }
      /**
       * Generates an encrypted serialization of this wallet.
       *
       * @param password The user provided password used to generate an encryption key via a KDF.
       *                 This is not normalized internally (see "Unicode normalization" to learn more).
       *
       * @deprecated Wallet encryption support will be removed from CosmJS in a future version.
       *             If you actually use this, please comment at https://github.com/cosmos/cosmjs/issues/1796.
       */
      async serialize(password) {
        const kdfConfiguration = basicPasswordHashingOptions;
        const encryptionKey = await (0, wallet_1.executeKdf)(password, kdfConfiguration);
        return this.serializeWithEncryptionKey(encryptionKey, kdfConfiguration);
      }
      /**
       * Generates an encrypted serialization of this wallet.
       *
       * This is an advanced alternative to calling `serialize(password)` directly, which allows you to
       * offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
       *
       * The caller is responsible for ensuring the key was derived with the given KDF options. If this
       * is not the case, the wallet cannot be restored with the original password.
       *
       * @deprecated Wallet encryption support will be removed from CosmJS in a future version.
       *             If you actually use this, please comment at https://github.com/cosmos/cosmjs/issues/1796.
       */
      async serializeWithEncryptionKey(encryptionKey, kdfConfiguration) {
        const dataToEncrypt = {
          mnemonic: this.mnemonic,
          accounts: this.accounts.map(({ hdPath, prefix }) => ({
            hdPath: (0, crypto_1.pathToString)(hdPath),
            prefix
          }))
        };
        const dataToEncryptRaw = (0, encoding_1.toUtf8)(JSON.stringify(dataToEncrypt));
        const encryptionConfiguration = {
          algorithm: wallet_1.supportedAlgorithms.xchacha20poly1305Ietf
        };
        const encryptedData = await (0, wallet_1.encrypt)(dataToEncryptRaw, encryptionKey, encryptionConfiguration);
        const out = {
          type: serializationTypeV1,
          kdf: kdfConfiguration,
          encryption: encryptionConfiguration,
          data: (0, encoding_1.toBase64)(encryptedData)
        };
        return JSON.stringify(out);
      }
      async getKeyPair(hdPath) {
        const { privkey } = crypto_1.Slip10.derivePath(crypto_1.Slip10Curve.Secp256k1, this.seed, hdPath);
        const { pubkey } = await crypto_1.Secp256k1.makeKeypair(privkey);
        return {
          privkey,
          pubkey: crypto_1.Secp256k1.compressPubkey(pubkey)
        };
      }
      async getAccountsWithPrivkeys() {
        return Promise.all(this.accounts.map(async ({ hdPath, prefix }) => {
          const { privkey, pubkey } = await this.getKeyPair(hdPath);
          const address = (0, encoding_1.toBech32)(prefix, (0, addresses_1.rawSecp256k1PubkeyToRawAddress)(pubkey));
          return {
            algo: "secp256k1",
            privkey,
            pubkey,
            address
          };
        }));
      }
    };
    exports.Secp256k1HdWallet = Secp256k1HdWallet;
  }
});

// node_modules/.pnpm/@cosmjs+amino@0.37.0/node_modules/@cosmjs/amino/build/secp256k1wallet.js
var require_secp256k1wallet = __commonJS({
  "node_modules/.pnpm/@cosmjs+amino@0.37.0/node_modules/@cosmjs/amino/build/secp256k1wallet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Secp256k1Wallet = void 0;
    var crypto_1 = require_build4();
    var encoding_1 = require_build2();
    var addresses_1 = require_addresses();
    var signature_1 = require_signature();
    var signdoc_1 = require_signdoc();
    var Secp256k1Wallet = class _Secp256k1Wallet {
      /**
       * Creates a Secp256k1Wallet from the given private key
       *
       * @param privkey The private key.
       * @param prefix The bech32 address prefix (human readable part). Defaults to "cosmos".
       */
      static async fromKey(privkey, prefix = "cosmos") {
        const uncompressed = (await crypto_1.Secp256k1.makeKeypair(privkey)).pubkey;
        return new _Secp256k1Wallet(privkey, crypto_1.Secp256k1.compressPubkey(uncompressed), prefix);
      }
      pubkey;
      privkey;
      prefix;
      constructor(privkey, pubkey, prefix) {
        this.privkey = privkey;
        this.pubkey = pubkey;
        this.prefix = prefix;
      }
      get address() {
        return (0, encoding_1.toBech32)(this.prefix, (0, addresses_1.rawSecp256k1PubkeyToRawAddress)(this.pubkey));
      }
      async getAccounts() {
        return [
          {
            algo: "secp256k1",
            address: this.address,
            pubkey: this.pubkey
          }
        ];
      }
      async signAmino(signerAddress, signDoc) {
        if (signerAddress !== this.address) {
          throw new Error(`Address ${signerAddress} not found in wallet`);
        }
        const message = new crypto_1.Sha256((0, signdoc_1.serializeSignDoc)(signDoc)).digest();
        const signature = await crypto_1.Secp256k1.createSignature(message, this.privkey);
        const signatureBytes = new Uint8Array([...signature.r(32), ...signature.s(32)]);
        return {
          signed: signDoc,
          signature: (0, signature_1.encodeSecp256k1Signature)(this.pubkey, signatureBytes)
        };
      }
    };
    exports.Secp256k1Wallet = Secp256k1Wallet;
  }
});

// node_modules/.pnpm/@cosmjs+amino@0.37.0/node_modules/@cosmjs/amino/build/stdtx.js
var require_stdtx = __commonJS({
  "node_modules/.pnpm/@cosmjs+amino@0.37.0/node_modules/@cosmjs/amino/build/stdtx.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isStdTx = isStdTx;
    exports.makeStdTx = makeStdTx;
    function isStdTx(txValue) {
      const { memo, msg, fee, signatures } = txValue;
      return typeof memo === "string" && Array.isArray(msg) && typeof fee === "object" && Array.isArray(signatures);
    }
    function makeStdTx(content, signatures) {
      return {
        msg: content.msgs,
        fee: content.fee,
        memo: content.memo,
        signatures: Array.isArray(signatures) ? signatures : [signatures]
      };
    }
  }
});

// node_modules/.pnpm/@cosmjs+amino@0.37.0/node_modules/@cosmjs/amino/build/index.js
var require_build5 = __commonJS({
  "node_modules/.pnpm/@cosmjs+amino@0.37.0/node_modules/@cosmjs/amino/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.executeKdf = exports.makeStdTx = exports.isStdTx = exports.serializeSignDoc = exports.makeSignDoc = exports.encodeSecp256k1Signature = exports.decodeSignature = exports.Secp256k1Wallet = exports.Secp256k1HdWallet = exports.extractKdfConfiguration = exports.pubkeyType = exports.isSinglePubkey = exports.isSecp256k1Pubkey = exports.isMultisigThresholdPubkey = exports.isEd25519Pubkey = exports.makeCosmoshubPath = exports.omitDefault = exports.createMultisigThresholdPubkey = exports.encodeSecp256k1Pubkey = exports.encodeEd25519Pubkey = exports.encodeBech32Pubkey = exports.encodeAminoPubkey = exports.decodeBech32Pubkey = exports.decodeAminoPubkey = exports.parseCoins = exports.coins = exports.coin = exports.addCoins = exports.rawSecp256k1PubkeyToRawAddress = exports.rawEd25519PubkeyToRawAddress = exports.pubkeyToRawAddress = exports.pubkeyToAddress = void 0;
    var addresses_1 = require_addresses();
    Object.defineProperty(exports, "pubkeyToAddress", { enumerable: true, get: function() {
      return addresses_1.pubkeyToAddress;
    } });
    Object.defineProperty(exports, "pubkeyToRawAddress", { enumerable: true, get: function() {
      return addresses_1.pubkeyToRawAddress;
    } });
    Object.defineProperty(exports, "rawEd25519PubkeyToRawAddress", { enumerable: true, get: function() {
      return addresses_1.rawEd25519PubkeyToRawAddress;
    } });
    Object.defineProperty(exports, "rawSecp256k1PubkeyToRawAddress", { enumerable: true, get: function() {
      return addresses_1.rawSecp256k1PubkeyToRawAddress;
    } });
    var coins_1 = require_coins();
    Object.defineProperty(exports, "addCoins", { enumerable: true, get: function() {
      return coins_1.addCoins;
    } });
    Object.defineProperty(exports, "coin", { enumerable: true, get: function() {
      return coins_1.coin;
    } });
    Object.defineProperty(exports, "coins", { enumerable: true, get: function() {
      return coins_1.coins;
    } });
    Object.defineProperty(exports, "parseCoins", { enumerable: true, get: function() {
      return coins_1.parseCoins;
    } });
    var encoding_1 = require_encoding();
    Object.defineProperty(exports, "decodeAminoPubkey", { enumerable: true, get: function() {
      return encoding_1.decodeAminoPubkey;
    } });
    Object.defineProperty(exports, "decodeBech32Pubkey", { enumerable: true, get: function() {
      return encoding_1.decodeBech32Pubkey;
    } });
    Object.defineProperty(exports, "encodeAminoPubkey", { enumerable: true, get: function() {
      return encoding_1.encodeAminoPubkey;
    } });
    Object.defineProperty(exports, "encodeBech32Pubkey", { enumerable: true, get: function() {
      return encoding_1.encodeBech32Pubkey;
    } });
    Object.defineProperty(exports, "encodeEd25519Pubkey", { enumerable: true, get: function() {
      return encoding_1.encodeEd25519Pubkey;
    } });
    Object.defineProperty(exports, "encodeSecp256k1Pubkey", { enumerable: true, get: function() {
      return encoding_1.encodeSecp256k1Pubkey;
    } });
    var multisig_1 = require_multisig();
    Object.defineProperty(exports, "createMultisigThresholdPubkey", { enumerable: true, get: function() {
      return multisig_1.createMultisigThresholdPubkey;
    } });
    var omitdefault_1 = require_omitdefault();
    Object.defineProperty(exports, "omitDefault", { enumerable: true, get: function() {
      return omitdefault_1.omitDefault;
    } });
    var paths_1 = require_paths();
    Object.defineProperty(exports, "makeCosmoshubPath", { enumerable: true, get: function() {
      return paths_1.makeCosmoshubPath;
    } });
    var pubkeys_1 = require_pubkeys();
    Object.defineProperty(exports, "isEd25519Pubkey", { enumerable: true, get: function() {
      return pubkeys_1.isEd25519Pubkey;
    } });
    Object.defineProperty(exports, "isMultisigThresholdPubkey", { enumerable: true, get: function() {
      return pubkeys_1.isMultisigThresholdPubkey;
    } });
    Object.defineProperty(exports, "isSecp256k1Pubkey", { enumerable: true, get: function() {
      return pubkeys_1.isSecp256k1Pubkey;
    } });
    Object.defineProperty(exports, "isSinglePubkey", { enumerable: true, get: function() {
      return pubkeys_1.isSinglePubkey;
    } });
    Object.defineProperty(exports, "pubkeyType", { enumerable: true, get: function() {
      return pubkeys_1.pubkeyType;
    } });
    var secp256k1hdwallet_1 = require_secp256k1hdwallet();
    Object.defineProperty(exports, "extractKdfConfiguration", { enumerable: true, get: function() {
      return secp256k1hdwallet_1.extractKdfConfiguration;
    } });
    Object.defineProperty(exports, "Secp256k1HdWallet", { enumerable: true, get: function() {
      return secp256k1hdwallet_1.Secp256k1HdWallet;
    } });
    var secp256k1wallet_1 = require_secp256k1wallet();
    Object.defineProperty(exports, "Secp256k1Wallet", { enumerable: true, get: function() {
      return secp256k1wallet_1.Secp256k1Wallet;
    } });
    var signature_1 = require_signature();
    Object.defineProperty(exports, "decodeSignature", { enumerable: true, get: function() {
      return signature_1.decodeSignature;
    } });
    Object.defineProperty(exports, "encodeSecp256k1Signature", { enumerable: true, get: function() {
      return signature_1.encodeSecp256k1Signature;
    } });
    var signdoc_1 = require_signdoc();
    Object.defineProperty(exports, "makeSignDoc", { enumerable: true, get: function() {
      return signdoc_1.makeSignDoc;
    } });
    Object.defineProperty(exports, "serializeSignDoc", { enumerable: true, get: function() {
      return signdoc_1.serializeSignDoc;
    } });
    var stdtx_1 = require_stdtx();
    Object.defineProperty(exports, "isStdTx", { enumerable: true, get: function() {
      return stdtx_1.isStdTx;
    } });
    Object.defineProperty(exports, "makeStdTx", { enumerable: true, get: function() {
      return stdtx_1.makeStdTx;
    } });
    var wallet_1 = require_wallet();
    Object.defineProperty(exports, "executeKdf", { enumerable: true, get: function() {
      return wallet_1.executeKdf;
    } });
  }
});

// node_modules/.pnpm/long@4.0.0/node_modules/long/src/long.js
var require_long = __commonJS({
  "node_modules/.pnpm/long@4.0.0/node_modules/long/src/long.js"(exports, module) {
    module.exports = Long2;
    var wasm2 = null;
    try {
      wasm2 = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
        0,
        97,
        115,
        109,
        1,
        0,
        0,
        0,
        1,
        13,
        2,
        96,
        0,
        1,
        127,
        96,
        4,
        127,
        127,
        127,
        127,
        1,
        127,
        3,
        7,
        6,
        0,
        1,
        1,
        1,
        1,
        1,
        6,
        6,
        1,
        127,
        1,
        65,
        0,
        11,
        7,
        50,
        6,
        3,
        109,
        117,
        108,
        0,
        1,
        5,
        100,
        105,
        118,
        95,
        115,
        0,
        2,
        5,
        100,
        105,
        118,
        95,
        117,
        0,
        3,
        5,
        114,
        101,
        109,
        95,
        115,
        0,
        4,
        5,
        114,
        101,
        109,
        95,
        117,
        0,
        5,
        8,
        103,
        101,
        116,
        95,
        104,
        105,
        103,
        104,
        0,
        0,
        10,
        191,
        1,
        6,
        4,
        0,
        35,
        0,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        126,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        127,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        128,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        129,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        130,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11
      ])), {}).exports;
    } catch (e) {
    }
    function Long2(low, high, unsigned) {
      this.low = low | 0;
      this.high = high | 0;
      this.unsigned = !!unsigned;
    }
    Long2.prototype.__isLong__;
    Object.defineProperty(Long2.prototype, "__isLong__", { value: true });
    function isLong2(obj) {
      return (obj && obj["__isLong__"]) === true;
    }
    Long2.isLong = isLong2;
    var INT_CACHE2 = {};
    var UINT_CACHE2 = {};
    function fromInt2(value, unsigned) {
      var obj, cachedObj, cache;
      if (unsigned) {
        value >>>= 0;
        if (cache = 0 <= value && value < 256) {
          cachedObj = UINT_CACHE2[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = fromBits2(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
          UINT_CACHE2[value] = obj;
        return obj;
      } else {
        value |= 0;
        if (cache = -128 <= value && value < 128) {
          cachedObj = INT_CACHE2[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = fromBits2(value, value < 0 ? -1 : 0, false);
        if (cache)
          INT_CACHE2[value] = obj;
        return obj;
      }
    }
    Long2.fromInt = fromInt2;
    function fromNumber2(value, unsigned) {
      if (isNaN(value))
        return unsigned ? UZERO2 : ZERO2;
      if (unsigned) {
        if (value < 0)
          return UZERO2;
        if (value >= TWO_PWR_64_DBL2)
          return MAX_UNSIGNED_VALUE2;
      } else {
        if (value <= -TWO_PWR_63_DBL2)
          return MIN_VALUE2;
        if (value + 1 >= TWO_PWR_63_DBL2)
          return MAX_VALUE2;
      }
      if (value < 0)
        return fromNumber2(-value, unsigned).neg();
      return fromBits2(value % TWO_PWR_32_DBL2 | 0, value / TWO_PWR_32_DBL2 | 0, unsigned);
    }
    Long2.fromNumber = fromNumber2;
    function fromBits2(lowBits, highBits, unsigned) {
      return new Long2(lowBits, highBits, unsigned);
    }
    Long2.fromBits = fromBits2;
    var pow_dbl2 = Math.pow;
    function fromString3(str2, unsigned, radix3) {
      if (str2.length === 0)
        throw Error("empty string");
      if (str2 === "NaN" || str2 === "Infinity" || str2 === "+Infinity" || str2 === "-Infinity")
        return ZERO2;
      if (typeof unsigned === "number") {
        radix3 = unsigned, unsigned = false;
      } else {
        unsigned = !!unsigned;
      }
      radix3 = radix3 || 10;
      if (radix3 < 2 || 36 < radix3)
        throw RangeError("radix");
      var p4;
      if ((p4 = str2.indexOf("-")) > 0)
        throw Error("interior hyphen");
      else if (p4 === 0) {
        return fromString3(str2.substring(1), unsigned, radix3).neg();
      }
      var radixToPower = fromNumber2(pow_dbl2(radix3, 8));
      var result = ZERO2;
      for (var i3 = 0; i3 < str2.length; i3 += 8) {
        var size = Math.min(8, str2.length - i3), value = parseInt(str2.substring(i3, i3 + size), radix3);
        if (size < 8) {
          var power = fromNumber2(pow_dbl2(radix3, size));
          result = result.mul(power).add(fromNumber2(value));
        } else {
          result = result.mul(radixToPower);
          result = result.add(fromNumber2(value));
        }
      }
      result.unsigned = unsigned;
      return result;
    }
    Long2.fromString = fromString3;
    function fromValue2(val, unsigned) {
      if (typeof val === "number")
        return fromNumber2(val, unsigned);
      if (typeof val === "string")
        return fromString3(val, unsigned);
      return fromBits2(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
    }
    Long2.fromValue = fromValue2;
    var TWO_PWR_16_DBL2 = 1 << 16;
    var TWO_PWR_24_DBL2 = 1 << 24;
    var TWO_PWR_32_DBL2 = TWO_PWR_16_DBL2 * TWO_PWR_16_DBL2;
    var TWO_PWR_64_DBL2 = TWO_PWR_32_DBL2 * TWO_PWR_32_DBL2;
    var TWO_PWR_63_DBL2 = TWO_PWR_64_DBL2 / 2;
    var TWO_PWR_242 = fromInt2(TWO_PWR_24_DBL2);
    var ZERO2 = fromInt2(0);
    Long2.ZERO = ZERO2;
    var UZERO2 = fromInt2(0, true);
    Long2.UZERO = UZERO2;
    var ONE2 = fromInt2(1);
    Long2.ONE = ONE2;
    var UONE2 = fromInt2(1, true);
    Long2.UONE = UONE2;
    var NEG_ONE2 = fromInt2(-1);
    Long2.NEG_ONE = NEG_ONE2;
    var MAX_VALUE2 = fromBits2(4294967295 | 0, 2147483647 | 0, false);
    Long2.MAX_VALUE = MAX_VALUE2;
    var MAX_UNSIGNED_VALUE2 = fromBits2(4294967295 | 0, 4294967295 | 0, true);
    Long2.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE2;
    var MIN_VALUE2 = fromBits2(0, 2147483648 | 0, false);
    Long2.MIN_VALUE = MIN_VALUE2;
    var LongPrototype2 = Long2.prototype;
    LongPrototype2.toInt = function toInt2() {
      return this.unsigned ? this.low >>> 0 : this.low;
    };
    LongPrototype2.toNumber = function toNumber2() {
      if (this.unsigned)
        return (this.high >>> 0) * TWO_PWR_32_DBL2 + (this.low >>> 0);
      return this.high * TWO_PWR_32_DBL2 + (this.low >>> 0);
    };
    LongPrototype2.toString = function toString3(radix3) {
      radix3 = radix3 || 10;
      if (radix3 < 2 || 36 < radix3)
        throw RangeError("radix");
      if (this.isZero())
        return "0";
      if (this.isNegative()) {
        if (this.eq(MIN_VALUE2)) {
          var radixLong = fromNumber2(radix3), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
          return div.toString(radix3) + rem1.toInt().toString(radix3);
        } else
          return "-" + this.neg().toString(radix3);
      }
      var radixToPower = fromNumber2(pow_dbl2(radix3, 6), this.unsigned), rem = this;
      var result = "";
      while (true) {
        var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix3);
        rem = remDiv;
        if (rem.isZero())
          return digits + result;
        else {
          while (digits.length < 6)
            digits = "0" + digits;
          result = "" + digits + result;
        }
      }
    };
    LongPrototype2.getHighBits = function getHighBits2() {
      return this.high;
    };
    LongPrototype2.getHighBitsUnsigned = function getHighBitsUnsigned2() {
      return this.high >>> 0;
    };
    LongPrototype2.getLowBits = function getLowBits2() {
      return this.low;
    };
    LongPrototype2.getLowBitsUnsigned = function getLowBitsUnsigned2() {
      return this.low >>> 0;
    };
    LongPrototype2.getNumBitsAbs = function getNumBitsAbs2() {
      if (this.isNegative())
        return this.eq(MIN_VALUE2) ? 64 : this.neg().getNumBitsAbs();
      var val = this.high != 0 ? this.high : this.low;
      for (var bit = 31; bit > 0; bit--)
        if ((val & 1 << bit) != 0)
          break;
      return this.high != 0 ? bit + 33 : bit + 1;
    };
    LongPrototype2.isZero = function isZero2() {
      return this.high === 0 && this.low === 0;
    };
    LongPrototype2.eqz = LongPrototype2.isZero;
    LongPrototype2.isNegative = function isNegative2() {
      return !this.unsigned && this.high < 0;
    };
    LongPrototype2.isPositive = function isPositive2() {
      return this.unsigned || this.high >= 0;
    };
    LongPrototype2.isOdd = function isOdd2() {
      return (this.low & 1) === 1;
    };
    LongPrototype2.isEven = function isEven2() {
      return (this.low & 1) === 0;
    };
    LongPrototype2.equals = function equals2(other) {
      if (!isLong2(other))
        other = fromValue2(other);
      if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
        return false;
      return this.high === other.high && this.low === other.low;
    };
    LongPrototype2.eq = LongPrototype2.equals;
    LongPrototype2.notEquals = function notEquals2(other) {
      return !this.eq(
        /* validates */
        other
      );
    };
    LongPrototype2.neq = LongPrototype2.notEquals;
    LongPrototype2.ne = LongPrototype2.notEquals;
    LongPrototype2.lessThan = function lessThan2(other) {
      return this.comp(
        /* validates */
        other
      ) < 0;
    };
    LongPrototype2.lt = LongPrototype2.lessThan;
    LongPrototype2.lessThanOrEqual = function lessThanOrEqual2(other) {
      return this.comp(
        /* validates */
        other
      ) <= 0;
    };
    LongPrototype2.lte = LongPrototype2.lessThanOrEqual;
    LongPrototype2.le = LongPrototype2.lessThanOrEqual;
    LongPrototype2.greaterThan = function greaterThan2(other) {
      return this.comp(
        /* validates */
        other
      ) > 0;
    };
    LongPrototype2.gt = LongPrototype2.greaterThan;
    LongPrototype2.greaterThanOrEqual = function greaterThanOrEqual2(other) {
      return this.comp(
        /* validates */
        other
      ) >= 0;
    };
    LongPrototype2.gte = LongPrototype2.greaterThanOrEqual;
    LongPrototype2.ge = LongPrototype2.greaterThanOrEqual;
    LongPrototype2.compare = function compare2(other) {
      if (!isLong2(other))
        other = fromValue2(other);
      if (this.eq(other))
        return 0;
      var thisNeg = this.isNegative(), otherNeg = other.isNegative();
      if (thisNeg && !otherNeg)
        return -1;
      if (!thisNeg && otherNeg)
        return 1;
      if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
      return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
    };
    LongPrototype2.comp = LongPrototype2.compare;
    LongPrototype2.negate = function negate2() {
      if (!this.unsigned && this.eq(MIN_VALUE2))
        return MIN_VALUE2;
      return this.not().add(ONE2);
    };
    LongPrototype2.neg = LongPrototype2.negate;
    LongPrototype2.add = function add2(addend) {
      if (!isLong2(addend))
        addend = fromValue2(addend);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = addend.high >>> 16;
      var b32 = addend.high & 65535;
      var b16 = addend.low >>> 16;
      var b00 = addend.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 + b48;
      c48 &= 65535;
      return fromBits2(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype2.subtract = function subtract2(subtrahend) {
      if (!isLong2(subtrahend))
        subtrahend = fromValue2(subtrahend);
      return this.add(subtrahend.neg());
    };
    LongPrototype2.sub = LongPrototype2.subtract;
    LongPrototype2.multiply = function multiply2(multiplier) {
      if (this.isZero())
        return ZERO2;
      if (!isLong2(multiplier))
        multiplier = fromValue2(multiplier);
      if (wasm2) {
        var low = wasm2.mul(
          this.low,
          this.high,
          multiplier.low,
          multiplier.high
        );
        return fromBits2(low, wasm2.get_high(), this.unsigned);
      }
      if (multiplier.isZero())
        return ZERO2;
      if (this.eq(MIN_VALUE2))
        return multiplier.isOdd() ? MIN_VALUE2 : ZERO2;
      if (multiplier.eq(MIN_VALUE2))
        return this.isOdd() ? MIN_VALUE2 : ZERO2;
      if (this.isNegative()) {
        if (multiplier.isNegative())
          return this.neg().mul(multiplier.neg());
        else
          return this.neg().mul(multiplier).neg();
      } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();
      if (this.lt(TWO_PWR_242) && multiplier.lt(TWO_PWR_242))
        return fromNumber2(this.toNumber() * multiplier.toNumber(), this.unsigned);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = multiplier.high >>> 16;
      var b32 = multiplier.high & 65535;
      var b16 = multiplier.low >>> 16;
      var b00 = multiplier.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 65535;
      return fromBits2(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype2.mul = LongPrototype2.multiply;
    LongPrototype2.divide = function divide2(divisor) {
      if (!isLong2(divisor))
        divisor = fromValue2(divisor);
      if (divisor.isZero())
        throw Error("division by zero");
      if (wasm2) {
        if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
          return this;
        }
        var low = (this.unsigned ? wasm2.div_u : wasm2.div_s)(
          this.low,
          this.high,
          divisor.low,
          divisor.high
        );
        return fromBits2(low, wasm2.get_high(), this.unsigned);
      }
      if (this.isZero())
        return this.unsigned ? UZERO2 : ZERO2;
      var approx, rem, res;
      if (!this.unsigned) {
        if (this.eq(MIN_VALUE2)) {
          if (divisor.eq(ONE2) || divisor.eq(NEG_ONE2))
            return MIN_VALUE2;
          else if (divisor.eq(MIN_VALUE2))
            return ONE2;
          else {
            var halfThis = this.shr(1);
            approx = halfThis.div(divisor).shl(1);
            if (approx.eq(ZERO2)) {
              return divisor.isNegative() ? ONE2 : NEG_ONE2;
            } else {
              rem = this.sub(divisor.mul(approx));
              res = approx.add(rem.div(divisor));
              return res;
            }
          }
        } else if (divisor.eq(MIN_VALUE2))
          return this.unsigned ? UZERO2 : ZERO2;
        if (this.isNegative()) {
          if (divisor.isNegative())
            return this.neg().div(divisor.neg());
          return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
          return this.div(divisor.neg()).neg();
        res = ZERO2;
      } else {
        if (!divisor.unsigned)
          divisor = divisor.toUnsigned();
        if (divisor.gt(this))
          return UZERO2;
        if (divisor.gt(this.shru(1)))
          return UONE2;
        res = UZERO2;
      }
      rem = this;
      while (rem.gte(divisor)) {
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
        var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl2(2, log2 - 48), approxRes = fromNumber2(approx), approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
          approx -= delta;
          approxRes = fromNumber2(approx, this.unsigned);
          approxRem = approxRes.mul(divisor);
        }
        if (approxRes.isZero())
          approxRes = ONE2;
        res = res.add(approxRes);
        rem = rem.sub(approxRem);
      }
      return res;
    };
    LongPrototype2.div = LongPrototype2.divide;
    LongPrototype2.modulo = function modulo2(divisor) {
      if (!isLong2(divisor))
        divisor = fromValue2(divisor);
      if (wasm2) {
        var low = (this.unsigned ? wasm2.rem_u : wasm2.rem_s)(
          this.low,
          this.high,
          divisor.low,
          divisor.high
        );
        return fromBits2(low, wasm2.get_high(), this.unsigned);
      }
      return this.sub(this.div(divisor).mul(divisor));
    };
    LongPrototype2.mod = LongPrototype2.modulo;
    LongPrototype2.rem = LongPrototype2.modulo;
    LongPrototype2.not = function not2() {
      return fromBits2(~this.low, ~this.high, this.unsigned);
    };
    LongPrototype2.and = function and2(other) {
      if (!isLong2(other))
        other = fromValue2(other);
      return fromBits2(this.low & other.low, this.high & other.high, this.unsigned);
    };
    LongPrototype2.or = function or4(other) {
      if (!isLong2(other))
        other = fromValue2(other);
      return fromBits2(this.low | other.low, this.high | other.high, this.unsigned);
    };
    LongPrototype2.xor = function xor2(other) {
      if (!isLong2(other))
        other = fromValue2(other);
      return fromBits2(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    };
    LongPrototype2.shiftLeft = function shiftLeft2(numBits) {
      if (isLong2(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits2(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
      else
        return fromBits2(0, this.low << numBits - 32, this.unsigned);
    };
    LongPrototype2.shl = LongPrototype2.shiftLeft;
    LongPrototype2.shiftRight = function shiftRight2(numBits) {
      if (isLong2(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits2(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
      else
        return fromBits2(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    };
    LongPrototype2.shr = LongPrototype2.shiftRight;
    LongPrototype2.shiftRightUnsigned = function shiftRightUnsigned2(numBits) {
      if (isLong2(numBits))
        numBits = numBits.toInt();
      numBits &= 63;
      if (numBits === 0)
        return this;
      else {
        var high = this.high;
        if (numBits < 32) {
          var low = this.low;
          return fromBits2(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
        } else if (numBits === 32)
          return fromBits2(high, 0, this.unsigned);
        else
          return fromBits2(high >>> numBits - 32, 0, this.unsigned);
      }
    };
    LongPrototype2.shru = LongPrototype2.shiftRightUnsigned;
    LongPrototype2.shr_u = LongPrototype2.shiftRightUnsigned;
    LongPrototype2.toSigned = function toSigned2() {
      if (!this.unsigned)
        return this;
      return fromBits2(this.low, this.high, false);
    };
    LongPrototype2.toUnsigned = function toUnsigned2() {
      if (this.unsigned)
        return this;
      return fromBits2(this.low, this.high, true);
    };
    LongPrototype2.toBytes = function toBytes2(le4) {
      return le4 ? this.toBytesLE() : this.toBytesBE();
    };
    LongPrototype2.toBytesLE = function toBytesLE2() {
      var hi2 = this.high, lo2 = this.low;
      return [
        lo2 & 255,
        lo2 >>> 8 & 255,
        lo2 >>> 16 & 255,
        lo2 >>> 24,
        hi2 & 255,
        hi2 >>> 8 & 255,
        hi2 >>> 16 & 255,
        hi2 >>> 24
      ];
    };
    LongPrototype2.toBytesBE = function toBytesBE2() {
      var hi2 = this.high, lo2 = this.low;
      return [
        hi2 >>> 24,
        hi2 >>> 16 & 255,
        hi2 >>> 8 & 255,
        hi2 & 255,
        lo2 >>> 24,
        lo2 >>> 16 & 255,
        lo2 >>> 8 & 255,
        lo2 & 255
      ];
    };
    Long2.fromBytes = function fromBytes2(bytes2, unsigned, le4) {
      return le4 ? Long2.fromBytesLE(bytes2, unsigned) : Long2.fromBytesBE(bytes2, unsigned);
    };
    Long2.fromBytesLE = function fromBytesLE2(bytes2, unsigned) {
      return new Long2(
        bytes2[0] | bytes2[1] << 8 | bytes2[2] << 16 | bytes2[3] << 24,
        bytes2[4] | bytes2[5] << 8 | bytes2[6] << 16 | bytes2[7] << 24,
        unsigned
      );
    };
    Long2.fromBytesBE = function fromBytesBE2(bytes2, unsigned) {
      return new Long2(
        bytes2[4] << 24 | bytes2[5] << 16 | bytes2[6] << 8 | bytes2[7],
        bytes2[0] << 24 | bytes2[1] << 16 | bytes2[2] << 8 | bytes2[3],
        unsigned
      );
    };
  }
});

// node_modules/.pnpm/indent-string@4.0.0/node_modules/indent-string/index.js
var require_indent_string = __commonJS({
  "node_modules/.pnpm/indent-string@4.0.0/node_modules/indent-string/index.js"(exports, module) {
    "use strict";
    module.exports = (string, count = 1, options) => {
      options = {
        indent: " ",
        includeEmptyLines: false,
        ...options
      };
      if (typeof string !== "string") {
        throw new TypeError(
          `Expected \`input\` to be a \`string\`, got \`${typeof string}\``
        );
      }
      if (typeof count !== "number") {
        throw new TypeError(
          `Expected \`count\` to be a \`number\`, got \`${typeof count}\``
        );
      }
      if (typeof options.indent !== "string") {
        throw new TypeError(
          `Expected \`options.indent\` to be a \`string\`, got \`${typeof options.indent}\``
        );
      }
      if (count === 0) {
        return string;
      }
      const regex = options.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
      return string.replace(regex, options.indent.repeat(count));
    };
  }
});

// browser-external:os
var require_os = __commonJS({
  "browser-external:os"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "os" has been externalized for browser compatibility. Cannot access "os.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/.pnpm/clean-stack@2.2.0/node_modules/clean-stack/index.js
var require_clean_stack = __commonJS({
  "node_modules/.pnpm/clean-stack@2.2.0/node_modules/clean-stack/index.js"(exports, module) {
    "use strict";
    var os2 = require_os();
    var extractPathRegex = /\s+at.*(?:\(|\s)(.*)\)?/;
    var pathRegex = /^(?:(?:(?:node|(?:internal\/[\w/]*|.*node_modules\/(?:babel-polyfill|pirates)\/.*)?\w+)\.js:\d+:\d+)|native)/;
    var homeDir = typeof os2.homedir === "undefined" ? "" : os2.homedir();
    module.exports = (stack, options) => {
      options = Object.assign({ pretty: false }, options);
      return stack.replace(/\\/g, "/").split("\n").filter((line) => {
        const pathMatches = line.match(extractPathRegex);
        if (pathMatches === null || !pathMatches[1]) {
          return true;
        }
        const match = pathMatches[1];
        if (match.includes(".app/Contents/Resources/electron.asar") || match.includes(".app/Contents/Resources/default_app.asar")) {
          return false;
        }
        return !pathRegex.test(match);
      }).filter((line) => line.trim() !== "").map((line) => {
        if (options.pretty) {
          return line.replace(extractPathRegex, (m3, p1) => m3.replace(p1, p1.replace(homeDir, "~")));
        }
        return line;
      }).join("\n");
    };
  }
});

// node_modules/.pnpm/aggregate-error@3.1.0/node_modules/aggregate-error/index.js
var require_aggregate_error = __commonJS({
  "node_modules/.pnpm/aggregate-error@3.1.0/node_modules/aggregate-error/index.js"(exports, module) {
    "use strict";
    var indentString = require_indent_string();
    var cleanStack = require_clean_stack();
    var cleanInternalStack = (stack) => stack.replace(/\s+at .*aggregate-error\/index.js:\d+:\d+\)?/g, "");
    var AggregateError = class extends Error {
      constructor(errors) {
        if (!Array.isArray(errors)) {
          throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);
        }
        errors = [...errors].map((error) => {
          if (error instanceof Error) {
            return error;
          }
          if (error !== null && typeof error === "object") {
            return Object.assign(new Error(error.message), error);
          }
          return new Error(error);
        });
        let message = errors.map((error) => {
          return typeof error.stack === "string" ? cleanInternalStack(cleanStack(error.stack)) : String(error);
        }).join("\n");
        message = "\n" + indentString(message, 4);
        super(message);
        this.name = "AggregateError";
        Object.defineProperty(this, "_errors", { value: errors });
      }
      *[Symbol.iterator]() {
        for (const error of this._errors) {
          yield error;
        }
      }
    };
    module.exports = AggregateError;
  }
});

// node_modules/.pnpm/p-map@4.0.0/node_modules/p-map/index.js
var require_p_map = __commonJS({
  "node_modules/.pnpm/p-map@4.0.0/node_modules/p-map/index.js"(exports, module) {
    "use strict";
    var AggregateError = require_aggregate_error();
    module.exports = async (iterable, mapper, {
      concurrency = Infinity,
      stopOnError = true
    } = {}) => {
      return new Promise((resolve, reject) => {
        if (typeof mapper !== "function") {
          throw new TypeError("Mapper function is required");
        }
        if (!((Number.isSafeInteger(concurrency) || concurrency === Infinity) && concurrency >= 1)) {
          throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${concurrency}\` (${typeof concurrency})`);
        }
        const result = [];
        const errors = [];
        const iterator = iterable[Symbol.iterator]();
        let isRejected = false;
        let isIterableDone = false;
        let resolvingCount = 0;
        let currentIndex = 0;
        const next = () => {
          if (isRejected) {
            return;
          }
          const nextItem = iterator.next();
          const index = currentIndex;
          currentIndex++;
          if (nextItem.done) {
            isIterableDone = true;
            if (resolvingCount === 0) {
              if (!stopOnError && errors.length !== 0) {
                reject(new AggregateError(errors));
              } else {
                resolve(result);
              }
            }
            return;
          }
          resolvingCount++;
          (async () => {
            try {
              const element = await nextItem.value;
              result[index] = await mapper(element, index);
              resolvingCount--;
              next();
            } catch (error) {
              if (stopOnError) {
                isRejected = true;
                reject(error);
              } else {
                errors.push(error);
                resolvingCount--;
                next();
              }
            }
          })();
        };
        for (let i3 = 0; i3 < concurrency; i3++) {
          next();
          if (isIterableDone) {
            break;
          }
        }
      });
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/utf8.js
var require_utf82 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/utf8.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.utf8Write = exports.utf8Read = exports.utf8Length = void 0;
    function utf8Length(str2) {
      let len = 0, c3 = 0;
      for (let i3 = 0; i3 < str2.length; ++i3) {
        c3 = str2.charCodeAt(i3);
        if (c3 < 128)
          len += 1;
        else if (c3 < 2048)
          len += 2;
        else if ((c3 & 64512) === 55296 && (str2.charCodeAt(i3 + 1) & 64512) === 56320) {
          ++i3;
          len += 4;
        } else
          len += 3;
      }
      return len;
    }
    exports.utf8Length = utf8Length;
    function utf8Read(buffer, start, end) {
      const len = end - start;
      if (len < 1)
        return "";
      const chunk = [];
      let parts = [], i3 = 0, t;
      while (start < end) {
        t = buffer[start++];
        if (t < 128)
          chunk[i3++] = t;
        else if (t > 191 && t < 224)
          chunk[i3++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
          chunk[i3++] = 55296 + (t >> 10);
          chunk[i3++] = 56320 + (t & 1023);
        } else
          chunk[i3++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i3 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode(...chunk));
          i3 = 0;
        }
      }
      if (parts) {
        if (i3)
          parts.push(String.fromCharCode(...chunk.slice(0, i3)));
        return parts.join("");
      }
      return String.fromCharCode(...chunk.slice(0, i3));
    }
    exports.utf8Read = utf8Read;
    function utf8Write(str2, buffer, offset) {
      const start = offset;
      let c1, c22;
      for (let i3 = 0; i3 < str2.length; ++i3) {
        c1 = str2.charCodeAt(i3);
        if (c1 < 128) {
          buffer[offset++] = c1;
        } else if (c1 < 2048) {
          buffer[offset++] = c1 >> 6 | 192;
          buffer[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c22 = str2.charCodeAt(i3 + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c22 & 1023);
          ++i3;
          buffer[offset++] = c1 >> 18 | 240;
          buffer[offset++] = c1 >> 12 & 63 | 128;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        } else {
          buffer[offset++] = c1 >> 12 | 224;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    }
    exports.utf8Write = utf8Write;
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/varint.js
var require_varint = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/varint.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.writeByte = exports.writeFixed32 = exports.int64Length = exports.writeVarint64 = exports.writeVarint32 = exports.readInt32 = exports.readUInt32 = exports.zzDecode = exports.zzEncode = exports.varint32read = exports.varint32write = exports.uInt64ToString = exports.int64ToString = exports.int64FromString = exports.varint64write = exports.varint64read = void 0;
    function varint64read() {
      let lowBits = 0;
      let highBits = 0;
      for (let shift = 0; shift < 28; shift += 7) {
        let b5 = this.buf[this.pos++];
        lowBits |= (b5 & 127) << shift;
        if ((b5 & 128) == 0) {
          this.assertBounds();
          return [lowBits, highBits];
        }
      }
      let middleByte = this.buf[this.pos++];
      lowBits |= (middleByte & 15) << 28;
      highBits = (middleByte & 112) >> 4;
      if ((middleByte & 128) == 0) {
        this.assertBounds();
        return [lowBits, highBits];
      }
      for (let shift = 3; shift <= 31; shift += 7) {
        let b5 = this.buf[this.pos++];
        highBits |= (b5 & 127) << shift;
        if ((b5 & 128) == 0) {
          this.assertBounds();
          return [lowBits, highBits];
        }
      }
      throw new Error("invalid varint");
    }
    exports.varint64read = varint64read;
    function varint64write(lo2, hi2, bytes2) {
      for (let i3 = 0; i3 < 28; i3 = i3 + 7) {
        const shift = lo2 >>> i3;
        const hasNext = !(shift >>> 7 == 0 && hi2 == 0);
        const byte = (hasNext ? shift | 128 : shift) & 255;
        bytes2.push(byte);
        if (!hasNext) {
          return;
        }
      }
      const splitBits = lo2 >>> 28 & 15 | (hi2 & 7) << 4;
      const hasMoreBits = !(hi2 >> 3 == 0);
      bytes2.push((hasMoreBits ? splitBits | 128 : splitBits) & 255);
      if (!hasMoreBits) {
        return;
      }
      for (let i3 = 3; i3 < 31; i3 = i3 + 7) {
        const shift = hi2 >>> i3;
        const hasNext = !(shift >>> 7 == 0);
        const byte = (hasNext ? shift | 128 : shift) & 255;
        bytes2.push(byte);
        if (!hasNext) {
          return;
        }
      }
      bytes2.push(hi2 >>> 31 & 1);
    }
    exports.varint64write = varint64write;
    var TWO_PWR_32_DBL2 = 4294967296;
    function int64FromString(dec) {
      const minus = dec[0] === "-";
      if (minus) {
        dec = dec.slice(1);
      }
      const base = 1e6;
      let lowBits = 0;
      let highBits = 0;
      function add1e6digit(begin, end) {
        const digit1e6 = Number(dec.slice(begin, end));
        highBits *= base;
        lowBits = lowBits * base + digit1e6;
        if (lowBits >= TWO_PWR_32_DBL2) {
          highBits = highBits + (lowBits / TWO_PWR_32_DBL2 | 0);
          lowBits = lowBits % TWO_PWR_32_DBL2;
        }
      }
      add1e6digit(-24, -18);
      add1e6digit(-18, -12);
      add1e6digit(-12, -6);
      add1e6digit(-6);
      return minus ? negate2(lowBits, highBits) : newBits(lowBits, highBits);
    }
    exports.int64FromString = int64FromString;
    function int64ToString(lo2, hi2) {
      let bits = newBits(lo2, hi2);
      const negative = bits.hi & 2147483648;
      if (negative) {
        bits = negate2(bits.lo, bits.hi);
      }
      const result = uInt64ToString(bits.lo, bits.hi);
      return negative ? "-" + result : result;
    }
    exports.int64ToString = int64ToString;
    function uInt64ToString(lo2, hi2) {
      ({ lo: lo2, hi: hi2 } = toUnsigned2(lo2, hi2));
      if (hi2 <= 2097151) {
        return String(TWO_PWR_32_DBL2 * hi2 + lo2);
      }
      const low = lo2 & 16777215;
      const mid = (lo2 >>> 24 | hi2 << 8) & 16777215;
      const high = hi2 >> 16 & 65535;
      let digitA = low + mid * 6777216 + high * 6710656;
      let digitB = mid + high * 8147497;
      let digitC = high * 2;
      const base = 1e7;
      if (digitA >= base) {
        digitB += Math.floor(digitA / base);
        digitA %= base;
      }
      if (digitB >= base) {
        digitC += Math.floor(digitB / base);
        digitB %= base;
      }
      return digitC.toString() + decimalFrom1e7WithLeadingZeros(digitB) + decimalFrom1e7WithLeadingZeros(digitA);
    }
    exports.uInt64ToString = uInt64ToString;
    function toUnsigned2(lo2, hi2) {
      return { lo: lo2 >>> 0, hi: hi2 >>> 0 };
    }
    function newBits(lo2, hi2) {
      return { lo: lo2 | 0, hi: hi2 | 0 };
    }
    function negate2(lowBits, highBits) {
      highBits = ~highBits;
      if (lowBits) {
        lowBits = ~lowBits + 1;
      } else {
        highBits += 1;
      }
      return newBits(lowBits, highBits);
    }
    var decimalFrom1e7WithLeadingZeros = (digit1e7) => {
      const partial = String(digit1e7);
      return "0000000".slice(partial.length) + partial;
    };
    function varint32write(value, bytes2) {
      if (value >= 0) {
        while (value > 127) {
          bytes2.push(value & 127 | 128);
          value = value >>> 7;
        }
        bytes2.push(value);
      } else {
        for (let i3 = 0; i3 < 9; i3++) {
          bytes2.push(value & 127 | 128);
          value = value >> 7;
        }
        bytes2.push(1);
      }
    }
    exports.varint32write = varint32write;
    function varint32read() {
      let b5 = this.buf[this.pos++];
      let result = b5 & 127;
      if ((b5 & 128) == 0) {
        this.assertBounds();
        return result;
      }
      b5 = this.buf[this.pos++];
      result |= (b5 & 127) << 7;
      if ((b5 & 128) == 0) {
        this.assertBounds();
        return result;
      }
      b5 = this.buf[this.pos++];
      result |= (b5 & 127) << 14;
      if ((b5 & 128) == 0) {
        this.assertBounds();
        return result;
      }
      b5 = this.buf[this.pos++];
      result |= (b5 & 127) << 21;
      if ((b5 & 128) == 0) {
        this.assertBounds();
        return result;
      }
      b5 = this.buf[this.pos++];
      result |= (b5 & 15) << 28;
      for (let readBytes = 5; (b5 & 128) !== 0 && readBytes < 10; readBytes++)
        b5 = this.buf[this.pos++];
      if ((b5 & 128) != 0)
        throw new Error("invalid varint");
      this.assertBounds();
      return result >>> 0;
    }
    exports.varint32read = varint32read;
    function zzEncode(lo2, hi2) {
      let mask = hi2 >> 31;
      hi2 = ((hi2 << 1 | lo2 >>> 31) ^ mask) >>> 0;
      lo2 = (lo2 << 1 ^ mask) >>> 0;
      return [lo2, hi2];
    }
    exports.zzEncode = zzEncode;
    function zzDecode(lo2, hi2) {
      let mask = -(lo2 & 1);
      lo2 = ((lo2 >>> 1 | hi2 << 31) ^ mask) >>> 0;
      hi2 = (hi2 >>> 1 ^ mask) >>> 0;
      return [lo2, hi2];
    }
    exports.zzDecode = zzDecode;
    function readUInt32(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + buf[pos + 3] * 16777216;
    }
    exports.readUInt32 = readUInt32;
    function readInt32(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + (buf[pos + 3] << 24);
    }
    exports.readInt32 = readInt32;
    function writeVarint32(val, buf, pos) {
      while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf[pos] = val;
    }
    exports.writeVarint32 = writeVarint32;
    function writeVarint64(val, buf, pos) {
      while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
    }
    exports.writeVarint64 = writeVarint64;
    function int64Length(lo2, hi2) {
      let part0 = lo2, part1 = (lo2 >>> 28 | hi2 << 4) >>> 0, part2 = hi2 >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    }
    exports.int64Length = int64Length;
    function writeFixed32(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    exports.writeFixed32 = writeFixed32;
    function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
    }
    exports.writeByte = writeByte;
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/binary.js
var require_binary = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/binary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BinaryWriter = exports.BinaryReader = exports.WireType = void 0;
    var utf8_1 = require_utf82();
    var varint_1 = require_varint();
    var WireType;
    (function(WireType2) {
      WireType2[WireType2["Varint"] = 0] = "Varint";
      WireType2[WireType2["Fixed64"] = 1] = "Fixed64";
      WireType2[WireType2["Bytes"] = 2] = "Bytes";
      WireType2[WireType2["Fixed32"] = 5] = "Fixed32";
    })(WireType || (exports.WireType = WireType = {}));
    var BinaryReader = class {
      assertBounds() {
        if (this.pos > this.len)
          throw new RangeError("premature EOF");
      }
      constructor(buf) {
        this.buf = buf ? new Uint8Array(buf) : new Uint8Array(0);
        this.pos = 0;
        this.type = 0;
        this.len = this.buf.length;
      }
      tag() {
        const tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
        if (fieldNo <= 0 || wireType < 0 || wireType > 5)
          throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
        return [fieldNo, wireType, tag];
      }
      skip(length) {
        if (typeof length === "number") {
          if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
          this.pos += length;
        } else {
          do {
            if (this.pos >= this.len)
              throw indexOutOfRange(this);
          } while (this.buf[this.pos++] & 128);
        }
        return this;
      }
      skipType(wireType) {
        switch (wireType) {
          case WireType.Varint:
            this.skip();
            break;
          case WireType.Fixed64:
            this.skip(8);
            break;
          case WireType.Bytes:
            this.skip(this.uint32());
            break;
          case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
              this.skipType(wireType);
            }
            break;
          case WireType.Fixed32:
            this.skip(4);
            break;
          /* istanbul ignore next */
          default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
        }
        return this;
      }
      uint32() {
        return varint_1.varint32read.bind(this)();
      }
      int32() {
        return this.uint32() | 0;
      }
      sint32() {
        const num = this.uint32();
        return num % 2 === 1 ? (num + 1) / -2 : num / 2;
      }
      fixed32() {
        const val = (0, varint_1.readUInt32)(this.buf, this.pos);
        this.pos += 4;
        return val;
      }
      sfixed32() {
        const val = (0, varint_1.readInt32)(this.buf, this.pos);
        this.pos += 4;
        return val;
      }
      int64() {
        const [lo2, hi2] = varint_1.varint64read.bind(this)();
        return BigInt((0, varint_1.int64ToString)(lo2, hi2));
      }
      uint64() {
        const [lo2, hi2] = varint_1.varint64read.bind(this)();
        return BigInt((0, varint_1.uInt64ToString)(lo2, hi2));
      }
      sint64() {
        let [lo2, hi2] = varint_1.varint64read.bind(this)();
        [lo2, hi2] = (0, varint_1.zzDecode)(lo2, hi2);
        return BigInt((0, varint_1.int64ToString)(lo2, hi2));
      }
      fixed64() {
        const lo2 = this.sfixed32();
        const hi2 = this.sfixed32();
        return BigInt((0, varint_1.uInt64ToString)(lo2, hi2));
      }
      sfixed64() {
        const lo2 = this.sfixed32();
        const hi2 = this.sfixed32();
        return BigInt((0, varint_1.int64ToString)(lo2, hi2));
      }
      float() {
        throw new Error("float not supported");
      }
      double() {
        throw new Error("double not supported");
      }
      bool() {
        const [lo2, hi2] = varint_1.varint64read.bind(this)();
        return lo2 !== 0 || hi2 !== 0;
      }
      bytes() {
        const len = this.uint32(), start = this.pos;
        this.pos += len;
        this.assertBounds();
        return this.buf.subarray(start, start + len);
      }
      string() {
        const bytes2 = this.bytes();
        return (0, utf8_1.utf8Read)(bytes2, 0, bytes2.length);
      }
    };
    exports.BinaryReader = BinaryReader;
    var Op = class {
      constructor(fn3, len, val) {
        this.fn = fn3;
        this.len = len;
        this.val = val;
      }
      proceed(buf, pos) {
        if (this.fn) {
          this.fn(this.val, buf, pos);
        }
      }
    };
    var State = class {
      constructor(writer) {
        this.head = writer.head;
        this.tail = writer.tail;
        this.len = writer.len;
        this.next = writer.states;
      }
    };
    var BinaryWriter = class _BinaryWriter {
      constructor() {
        this.len = 0;
        this.uint64 = _BinaryWriter.prototype.int64;
        this.sfixed64 = _BinaryWriter.prototype.fixed64;
        this.sfixed32 = _BinaryWriter.prototype.fixed32;
        this.head = new Op(null, 0, 0);
        this.tail = this.head;
        this.states = null;
      }
      static create() {
        return new _BinaryWriter();
      }
      static alloc(size) {
        if (typeof Uint8Array !== "undefined") {
          return pool((size2) => new Uint8Array(size2), Uint8Array.prototype.subarray)(size);
        } else {
          return new Array(size);
        }
      }
      _push(fn3, len, val) {
        this.tail = this.tail.next = new Op(fn3, len, val);
        this.len += len;
        return this;
      }
      finish() {
        let head = this.head.next, pos = 0;
        const buf = _BinaryWriter.alloc(this.len);
        while (head) {
          head.proceed(buf, pos);
          pos += head.len;
          head = head.next;
        }
        return buf;
      }
      fork() {
        this.states = new State(this);
        this.head = this.tail = new Op(null, 0, 0);
        this.len = 0;
        return this;
      }
      reset() {
        if (this.states) {
          this.head = this.states.head;
          this.tail = this.states.tail;
          this.len = this.states.len;
          this.states = this.states.next;
        } else {
          this.head = this.tail = new Op(null, 0, 0);
          this.len = 0;
        }
        return this;
      }
      ldelim() {
        const head = this.head, tail = this.tail, len = this.len;
        this.reset().uint32(len);
        if (len) {
          this.tail.next = head.next;
          this.tail = tail;
          this.len += len;
        }
        return this;
      }
      tag(fieldNo, type) {
        return this.uint32((fieldNo << 3 | type) >>> 0);
      }
      uint32(value) {
        this.len += (this.tail = this.tail.next = new Op(varint_1.writeVarint32, (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;
        return this;
      }
      int32(value) {
        return value < 0 ? this._push(varint_1.writeVarint64, 10, (0, varint_1.int64FromString)(value.toString())) : this.uint32(value);
      }
      sint32(value) {
        return this.uint32((value << 1 ^ value >> 31) >>> 0);
      }
      int64(value) {
        const { lo: lo2, hi: hi2 } = (0, varint_1.int64FromString)(value.toString());
        return this._push(varint_1.writeVarint64, (0, varint_1.int64Length)(lo2, hi2), { lo: lo2, hi: hi2 });
      }
      sint64(value) {
        let { lo: lo2, hi: hi2 } = (0, varint_1.int64FromString)(value.toString());
        [lo2, hi2] = (0, varint_1.zzEncode)(lo2, hi2);
        return this._push(varint_1.writeVarint64, (0, varint_1.int64Length)(lo2, hi2), { lo: lo2, hi: hi2 });
      }
      fixed64(value) {
        const { lo: lo2, hi: hi2 } = (0, varint_1.int64FromString)(value.toString());
        return this._push(varint_1.writeFixed32, 4, lo2)._push(varint_1.writeFixed32, 4, hi2);
      }
      bool(value) {
        return this._push(varint_1.writeByte, 1, value ? 1 : 0);
      }
      fixed32(value) {
        return this._push(varint_1.writeFixed32, 4, value >>> 0);
      }
      float(value) {
        throw new Error("float not supported" + value);
      }
      double(value) {
        throw new Error("double not supported" + value);
      }
      bytes(value) {
        const len = value.length >>> 0;
        if (!len)
          return this._push(varint_1.writeByte, 1, 0);
        return this.uint32(len)._push(writeBytes, len, value);
      }
      string(value) {
        const len = (0, utf8_1.utf8Length)(value);
        return len ? this.uint32(len)._push(utf8_1.utf8Write, len, value) : this._push(varint_1.writeByte, 1, 0);
      }
    };
    exports.BinaryWriter = BinaryWriter;
    function writeBytes(val, buf, pos) {
      if (typeof Uint8Array !== "undefined") {
        buf.set(val, pos);
      } else {
        for (let i3 = 0; i3 < val.length; ++i3)
          buf[pos + i3] = val[i3];
      }
    }
    function pool(alloc, slice, size) {
      const SIZE = size || 8192;
      const MAX = SIZE >>> 1;
      let slab = null;
      let offset = SIZE;
      return function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc(size2);
        if (offset + size2 > SIZE) {
          slab = alloc(SIZE);
          offset = 0;
        }
        const buf = slice.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf;
      };
    }
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/helpers.js
var require_helpers = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromJsonTimestamp = exports.fromTimestamp = exports.toTimestamp = exports.isRpc = exports.setPaginationParams = exports.isObject = exports.isSet = exports.fromDuration = exports.toDuration = exports.omitDefault = exports.base64FromBytes = exports.bytesFromBase64 = void 0;
    var globalThis2 = (() => {
      if (typeof globalThis2 !== "undefined")
        return globalThis2;
      if (typeof self !== "undefined")
        return self;
      if (typeof window !== "undefined")
        return window;
      if (typeof global !== "undefined")
        return global;
      throw "Unable to locate global object";
    })();
    var atob2 = globalThis2.atob || ((b64) => globalThis2.Buffer.from(b64, "base64").toString("binary"));
    function bytesFromBase64(b64) {
      const bin = atob2(b64);
      const arr = new Uint8Array(bin.length);
      for (let i3 = 0; i3 < bin.length; ++i3) {
        arr[i3] = bin.charCodeAt(i3);
      }
      return arr;
    }
    exports.bytesFromBase64 = bytesFromBase64;
    var btoa2 = globalThis2.btoa || ((bin) => globalThis2.Buffer.from(bin, "binary").toString("base64"));
    function base64FromBytes(arr) {
      const bin = [];
      arr.forEach((byte) => {
        bin.push(String.fromCharCode(byte));
      });
      return btoa2(bin.join(""));
    }
    exports.base64FromBytes = base64FromBytes;
    function omitDefault(input) {
      if (typeof input === "string") {
        return input === "" ? void 0 : input;
      }
      if (typeof input === "number") {
        return input === 0 ? void 0 : input;
      }
      if (typeof input === "boolean") {
        return input === false ? void 0 : input;
      }
      if (typeof input === "bigint") {
        return input === BigInt(0) ? void 0 : input;
      }
      throw new Error(`Got unsupported type ${typeof input}`);
    }
    exports.omitDefault = omitDefault;
    function toDuration(duration) {
      return {
        seconds: BigInt(Math.floor(parseInt(duration) / 1e9)),
        nanos: parseInt(duration) % 1e9
      };
    }
    exports.toDuration = toDuration;
    function fromDuration(duration) {
      return (parseInt(duration.seconds.toString()) * 1e9 + duration.nanos).toString();
    }
    exports.fromDuration = fromDuration;
    function isSet(value) {
      return value !== null && value !== void 0;
    }
    exports.isSet = isSet;
    function isObject(value) {
      return typeof value === "object" && value !== null;
    }
    exports.isObject = isObject;
    var setPaginationParams = (options, pagination) => {
      if (!pagination) {
        return options;
      }
      if (typeof pagination?.countTotal !== "undefined") {
        options.params["pagination.count_total"] = pagination.countTotal;
      }
      if (typeof pagination?.key !== "undefined") {
        options.params["pagination.key"] = Buffer.from(pagination.key).toString("base64");
      }
      if (typeof pagination?.limit !== "undefined") {
        options.params["pagination.limit"] = pagination.limit.toString();
      }
      if (typeof pagination?.offset !== "undefined") {
        options.params["pagination.offset"] = pagination.offset.toString();
      }
      if (typeof pagination?.reverse !== "undefined") {
        options.params["pagination.reverse"] = pagination.reverse;
      }
      return options;
    };
    exports.setPaginationParams = setPaginationParams;
    function isRpc(rpc) {
      return rpc !== null && rpc !== void 0 && typeof rpc.request === "function";
    }
    exports.isRpc = isRpc;
    function toTimestamp(date) {
      const seconds = numberToLong(date.getTime() / 1e3);
      const nanos = date.getTime() % 1e3 * 1e6;
      return {
        seconds,
        nanos
      };
    }
    exports.toTimestamp = toTimestamp;
    function fromTimestamp(t) {
      let millis = Number(t.seconds) * 1e3;
      millis += t.nanos / 1e6;
      return new Date(millis);
    }
    exports.fromTimestamp = fromTimestamp;
    var timestampFromJSON = (object) => {
      return {
        seconds: isSet(object.seconds) ? BigInt(object.seconds.toString()) : BigInt(0),
        nanos: isSet(object.nanos) ? Number(object.nanos) : 0
      };
    };
    function fromJsonTimestamp(o3) {
      if (o3 instanceof Date) {
        return toTimestamp(o3);
      } else if (typeof o3 === "string") {
        return toTimestamp(new Date(o3));
      } else {
        return timestampFromJSON(o3);
      }
    }
    exports.fromJsonTimestamp = fromJsonTimestamp;
    function numberToLong(number) {
      return BigInt(Math.trunc(number));
    }
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/google/protobuf/any.js
var require_any = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/google/protobuf/any.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Any = exports.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "google.protobuf";
    function createBaseAny() {
      return {
        typeUrl: "",
        value: new Uint8Array()
      };
    }
    exports.Any = {
      typeUrl: "/google.protobuf.Any",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.typeUrl !== "") {
          writer.uint32(10).string(message.typeUrl);
        }
        if (message.value.length !== 0) {
          writer.uint32(18).bytes(message.value);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAny();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.typeUrl = reader.string();
              break;
            case 2:
              message.value = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseAny();
        if ((0, helpers_1.isSet)(object.typeUrl))
          obj.typeUrl = String(object.typeUrl);
        if ((0, helpers_1.isSet)(object.value))
          obj.value = (0, helpers_1.bytesFromBase64)(object.value);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.typeUrl !== void 0 && (obj.typeUrl = message.typeUrl);
        message.value !== void 0 && (obj.value = (0, helpers_1.base64FromBytes)(message.value !== void 0 ? message.value : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseAny();
        message.typeUrl = object.typeUrl ?? "";
        message.value = object.value ?? new Uint8Array();
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/crypto/multisig/v1beta1/multisig.js
var require_multisig2 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/crypto/multisig/v1beta1/multisig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CompactBitArray = exports.MultiSignature = exports.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.crypto.multisig.v1beta1";
    function createBaseMultiSignature() {
      return {
        signatures: []
      };
    }
    exports.MultiSignature = {
      typeUrl: "/cosmos.crypto.multisig.v1beta1.MultiSignature",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.signatures) {
          writer.uint32(10).bytes(v9);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMultiSignature();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signatures.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMultiSignature();
        if (Array.isArray(object?.signatures))
          obj.signatures = object.signatures.map((e) => (0, helpers_1.bytesFromBase64)(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.signatures) {
          obj.signatures = message.signatures.map((e) => (0, helpers_1.base64FromBytes)(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.signatures = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMultiSignature();
        message.signatures = object.signatures?.map((e) => e) || [];
        return message;
      }
    };
    function createBaseCompactBitArray() {
      return {
        extraBitsStored: 0,
        elems: new Uint8Array()
      };
    }
    exports.CompactBitArray = {
      typeUrl: "/cosmos.crypto.multisig.v1beta1.CompactBitArray",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.extraBitsStored !== 0) {
          writer.uint32(8).uint32(message.extraBitsStored);
        }
        if (message.elems.length !== 0) {
          writer.uint32(18).bytes(message.elems);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCompactBitArray();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.extraBitsStored = reader.uint32();
              break;
            case 2:
              message.elems = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCompactBitArray();
        if ((0, helpers_1.isSet)(object.extraBitsStored))
          obj.extraBitsStored = Number(object.extraBitsStored);
        if ((0, helpers_1.isSet)(object.elems))
          obj.elems = (0, helpers_1.bytesFromBase64)(object.elems);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.extraBitsStored !== void 0 && (obj.extraBitsStored = Math.round(message.extraBitsStored));
        message.elems !== void 0 && (obj.elems = (0, helpers_1.base64FromBytes)(message.elems !== void 0 ? message.elems : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCompactBitArray();
        message.extraBitsStored = object.extraBitsStored ?? 0;
        message.elems = object.elems ?? new Uint8Array();
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/tx/signing/v1beta1/signing.js
var require_signing = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/tx/signing/v1beta1/signing.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SignatureDescriptor_Data_Multi = exports.SignatureDescriptor_Data_Single = exports.SignatureDescriptor_Data = exports.SignatureDescriptor = exports.SignatureDescriptors = exports.signModeToJSON = exports.signModeFromJSON = exports.SignMode = exports.protobufPackage = void 0;
    var multisig_1 = require_multisig2();
    var any_1 = require_any();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.tx.signing.v1beta1";
    var SignMode;
    (function(SignMode2) {
      SignMode2[SignMode2["SIGN_MODE_UNSPECIFIED"] = 0] = "SIGN_MODE_UNSPECIFIED";
      SignMode2[SignMode2["SIGN_MODE_DIRECT"] = 1] = "SIGN_MODE_DIRECT";
      SignMode2[SignMode2["SIGN_MODE_TEXTUAL"] = 2] = "SIGN_MODE_TEXTUAL";
      SignMode2[SignMode2["SIGN_MODE_DIRECT_AUX"] = 3] = "SIGN_MODE_DIRECT_AUX";
      SignMode2[SignMode2["SIGN_MODE_LEGACY_AMINO_JSON"] = 127] = "SIGN_MODE_LEGACY_AMINO_JSON";
      SignMode2[SignMode2["SIGN_MODE_EIP_191"] = 191] = "SIGN_MODE_EIP_191";
      SignMode2[SignMode2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(SignMode || (exports.SignMode = SignMode = {}));
    function signModeFromJSON(object) {
      switch (object) {
        case 0:
        case "SIGN_MODE_UNSPECIFIED":
          return SignMode.SIGN_MODE_UNSPECIFIED;
        case 1:
        case "SIGN_MODE_DIRECT":
          return SignMode.SIGN_MODE_DIRECT;
        case 2:
        case "SIGN_MODE_TEXTUAL":
          return SignMode.SIGN_MODE_TEXTUAL;
        case 3:
        case "SIGN_MODE_DIRECT_AUX":
          return SignMode.SIGN_MODE_DIRECT_AUX;
        case 127:
        case "SIGN_MODE_LEGACY_AMINO_JSON":
          return SignMode.SIGN_MODE_LEGACY_AMINO_JSON;
        case 191:
        case "SIGN_MODE_EIP_191":
          return SignMode.SIGN_MODE_EIP_191;
        case -1:
        case "UNRECOGNIZED":
        default:
          return SignMode.UNRECOGNIZED;
      }
    }
    exports.signModeFromJSON = signModeFromJSON;
    function signModeToJSON(object) {
      switch (object) {
        case SignMode.SIGN_MODE_UNSPECIFIED:
          return "SIGN_MODE_UNSPECIFIED";
        case SignMode.SIGN_MODE_DIRECT:
          return "SIGN_MODE_DIRECT";
        case SignMode.SIGN_MODE_TEXTUAL:
          return "SIGN_MODE_TEXTUAL";
        case SignMode.SIGN_MODE_DIRECT_AUX:
          return "SIGN_MODE_DIRECT_AUX";
        case SignMode.SIGN_MODE_LEGACY_AMINO_JSON:
          return "SIGN_MODE_LEGACY_AMINO_JSON";
        case SignMode.SIGN_MODE_EIP_191:
          return "SIGN_MODE_EIP_191";
        case SignMode.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.signModeToJSON = signModeToJSON;
    function createBaseSignatureDescriptors() {
      return {
        signatures: []
      };
    }
    exports.SignatureDescriptors = {
      typeUrl: "/cosmos.tx.signing.v1beta1.SignatureDescriptors",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.signatures) {
          exports.SignatureDescriptor.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignatureDescriptors();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signatures.push(exports.SignatureDescriptor.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSignatureDescriptors();
        if (Array.isArray(object?.signatures))
          obj.signatures = object.signatures.map((e) => exports.SignatureDescriptor.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.signatures) {
          obj.signatures = message.signatures.map((e) => e ? exports.SignatureDescriptor.toJSON(e) : void 0);
        } else {
          obj.signatures = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSignatureDescriptors();
        message.signatures = object.signatures?.map((e) => exports.SignatureDescriptor.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseSignatureDescriptor() {
      return {
        publicKey: void 0,
        data: void 0,
        sequence: BigInt(0)
      };
    }
    exports.SignatureDescriptor = {
      typeUrl: "/cosmos.tx.signing.v1beta1.SignatureDescriptor",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.publicKey !== void 0) {
          any_1.Any.encode(message.publicKey, writer.uint32(10).fork()).ldelim();
        }
        if (message.data !== void 0) {
          exports.SignatureDescriptor_Data.encode(message.data, writer.uint32(18).fork()).ldelim();
        }
        if (message.sequence !== BigInt(0)) {
          writer.uint32(24).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignatureDescriptor();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.publicKey = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.data = exports.SignatureDescriptor_Data.decode(reader, reader.uint32());
              break;
            case 3:
              message.sequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSignatureDescriptor();
        if ((0, helpers_1.isSet)(object.publicKey))
          obj.publicKey = any_1.Any.fromJSON(object.publicKey);
        if ((0, helpers_1.isSet)(object.data))
          obj.data = exports.SignatureDescriptor_Data.fromJSON(object.data);
        if ((0, helpers_1.isSet)(object.sequence))
          obj.sequence = BigInt(object.sequence.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.publicKey !== void 0 && (obj.publicKey = message.publicKey ? any_1.Any.toJSON(message.publicKey) : void 0);
        message.data !== void 0 && (obj.data = message.data ? exports.SignatureDescriptor_Data.toJSON(message.data) : void 0);
        message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSignatureDescriptor();
        if (object.publicKey !== void 0 && object.publicKey !== null) {
          message.publicKey = any_1.Any.fromPartial(object.publicKey);
        }
        if (object.data !== void 0 && object.data !== null) {
          message.data = exports.SignatureDescriptor_Data.fromPartial(object.data);
        }
        if (object.sequence !== void 0 && object.sequence !== null) {
          message.sequence = BigInt(object.sequence.toString());
        }
        return message;
      }
    };
    function createBaseSignatureDescriptor_Data() {
      return {
        single: void 0,
        multi: void 0
      };
    }
    exports.SignatureDescriptor_Data = {
      typeUrl: "/cosmos.tx.signing.v1beta1.Data",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.single !== void 0) {
          exports.SignatureDescriptor_Data_Single.encode(message.single, writer.uint32(10).fork()).ldelim();
        }
        if (message.multi !== void 0) {
          exports.SignatureDescriptor_Data_Multi.encode(message.multi, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignatureDescriptor_Data();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.single = exports.SignatureDescriptor_Data_Single.decode(reader, reader.uint32());
              break;
            case 2:
              message.multi = exports.SignatureDescriptor_Data_Multi.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSignatureDescriptor_Data();
        if ((0, helpers_1.isSet)(object.single))
          obj.single = exports.SignatureDescriptor_Data_Single.fromJSON(object.single);
        if ((0, helpers_1.isSet)(object.multi))
          obj.multi = exports.SignatureDescriptor_Data_Multi.fromJSON(object.multi);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.single !== void 0 && (obj.single = message.single ? exports.SignatureDescriptor_Data_Single.toJSON(message.single) : void 0);
        message.multi !== void 0 && (obj.multi = message.multi ? exports.SignatureDescriptor_Data_Multi.toJSON(message.multi) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSignatureDescriptor_Data();
        if (object.single !== void 0 && object.single !== null) {
          message.single = exports.SignatureDescriptor_Data_Single.fromPartial(object.single);
        }
        if (object.multi !== void 0 && object.multi !== null) {
          message.multi = exports.SignatureDescriptor_Data_Multi.fromPartial(object.multi);
        }
        return message;
      }
    };
    function createBaseSignatureDescriptor_Data_Single() {
      return {
        mode: 0,
        signature: new Uint8Array()
      };
    }
    exports.SignatureDescriptor_Data_Single = {
      typeUrl: "/cosmos.tx.signing.v1beta1.Single",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.mode !== 0) {
          writer.uint32(8).int32(message.mode);
        }
        if (message.signature.length !== 0) {
          writer.uint32(18).bytes(message.signature);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignatureDescriptor_Data_Single();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.mode = reader.int32();
              break;
            case 2:
              message.signature = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSignatureDescriptor_Data_Single();
        if ((0, helpers_1.isSet)(object.mode))
          obj.mode = signModeFromJSON(object.mode);
        if ((0, helpers_1.isSet)(object.signature))
          obj.signature = (0, helpers_1.bytesFromBase64)(object.signature);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.mode !== void 0 && (obj.mode = signModeToJSON(message.mode));
        message.signature !== void 0 && (obj.signature = (0, helpers_1.base64FromBytes)(message.signature !== void 0 ? message.signature : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSignatureDescriptor_Data_Single();
        message.mode = object.mode ?? 0;
        message.signature = object.signature ?? new Uint8Array();
        return message;
      }
    };
    function createBaseSignatureDescriptor_Data_Multi() {
      return {
        bitarray: void 0,
        signatures: []
      };
    }
    exports.SignatureDescriptor_Data_Multi = {
      typeUrl: "/cosmos.tx.signing.v1beta1.Multi",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.bitarray !== void 0) {
          multisig_1.CompactBitArray.encode(message.bitarray, writer.uint32(10).fork()).ldelim();
        }
        for (const v9 of message.signatures) {
          exports.SignatureDescriptor_Data.encode(v9, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignatureDescriptor_Data_Multi();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bitarray = multisig_1.CompactBitArray.decode(reader, reader.uint32());
              break;
            case 2:
              message.signatures.push(exports.SignatureDescriptor_Data.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSignatureDescriptor_Data_Multi();
        if ((0, helpers_1.isSet)(object.bitarray))
          obj.bitarray = multisig_1.CompactBitArray.fromJSON(object.bitarray);
        if (Array.isArray(object?.signatures))
          obj.signatures = object.signatures.map((e) => exports.SignatureDescriptor_Data.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.bitarray !== void 0 && (obj.bitarray = message.bitarray ? multisig_1.CompactBitArray.toJSON(message.bitarray) : void 0);
        if (message.signatures) {
          obj.signatures = message.signatures.map((e) => e ? exports.SignatureDescriptor_Data.toJSON(e) : void 0);
        } else {
          obj.signatures = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSignatureDescriptor_Data_Multi();
        if (object.bitarray !== void 0 && object.bitarray !== null) {
          message.bitarray = multisig_1.CompactBitArray.fromPartial(object.bitarray);
        }
        message.signatures = object.signatures?.map((e) => exports.SignatureDescriptor_Data.fromPartial(e)) || [];
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/base/v1beta1/coin.js
var require_coin = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/base/v1beta1/coin.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DecProto = exports.IntProto = exports.DecCoin = exports.Coin = exports.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.base.v1beta1";
    function createBaseCoin() {
      return {
        denom: "",
        amount: ""
      };
    }
    exports.Coin = {
      typeUrl: "/cosmos.base.v1beta1.Coin",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        if (message.amount !== "") {
          writer.uint32(18).string(message.amount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCoin();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            case 2:
              message.amount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCoin();
        if ((0, helpers_1.isSet)(object.denom))
          obj.denom = String(object.denom);
        if ((0, helpers_1.isSet)(object.amount))
          obj.amount = String(object.amount);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.denom !== void 0 && (obj.denom = message.denom);
        message.amount !== void 0 && (obj.amount = message.amount);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCoin();
        message.denom = object.denom ?? "";
        message.amount = object.amount ?? "";
        return message;
      }
    };
    function createBaseDecCoin() {
      return {
        denom: "",
        amount: ""
      };
    }
    exports.DecCoin = {
      typeUrl: "/cosmos.base.v1beta1.DecCoin",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        if (message.amount !== "") {
          writer.uint32(18).string(message.amount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDecCoin();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            case 2:
              message.amount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDecCoin();
        if ((0, helpers_1.isSet)(object.denom))
          obj.denom = String(object.denom);
        if ((0, helpers_1.isSet)(object.amount))
          obj.amount = String(object.amount);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.denom !== void 0 && (obj.denom = message.denom);
        message.amount !== void 0 && (obj.amount = message.amount);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDecCoin();
        message.denom = object.denom ?? "";
        message.amount = object.amount ?? "";
        return message;
      }
    };
    function createBaseIntProto() {
      return {
        int: ""
      };
    }
    exports.IntProto = {
      typeUrl: "/cosmos.base.v1beta1.IntProto",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.int !== "") {
          writer.uint32(10).string(message.int);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseIntProto();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.int = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseIntProto();
        if ((0, helpers_1.isSet)(object.int))
          obj.int = String(object.int);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.int !== void 0 && (obj.int = message.int);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseIntProto();
        message.int = object.int ?? "";
        return message;
      }
    };
    function createBaseDecProto() {
      return {
        dec: ""
      };
    }
    exports.DecProto = {
      typeUrl: "/cosmos.base.v1beta1.DecProto",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.dec !== "") {
          writer.uint32(10).string(message.dec);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDecProto();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.dec = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDecProto();
        if ((0, helpers_1.isSet)(object.dec))
          obj.dec = String(object.dec);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.dec !== void 0 && (obj.dec = message.dec);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDecProto();
        message.dec = object.dec ?? "";
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/tx/v1beta1/tx.js
var require_tx = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/tx/v1beta1/tx.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AuxSignerData = exports.Tip = exports.Fee = exports.ModeInfo_Multi = exports.ModeInfo_Single = exports.ModeInfo = exports.SignerInfo = exports.AuthInfo = exports.TxBody = exports.SignDocDirectAux = exports.SignDoc = exports.TxRaw = exports.Tx = exports.protobufPackage = void 0;
    var any_1 = require_any();
    var signing_1 = require_signing();
    var multisig_1 = require_multisig2();
    var coin_1 = require_coin();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.tx.v1beta1";
    function createBaseTx() {
      return {
        body: void 0,
        authInfo: void 0,
        signatures: []
      };
    }
    exports.Tx = {
      typeUrl: "/cosmos.tx.v1beta1.Tx",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.body !== void 0) {
          exports.TxBody.encode(message.body, writer.uint32(10).fork()).ldelim();
        }
        if (message.authInfo !== void 0) {
          exports.AuthInfo.encode(message.authInfo, writer.uint32(18).fork()).ldelim();
        }
        for (const v9 of message.signatures) {
          writer.uint32(26).bytes(v9);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTx();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.body = exports.TxBody.decode(reader, reader.uint32());
              break;
            case 2:
              message.authInfo = exports.AuthInfo.decode(reader, reader.uint32());
              break;
            case 3:
              message.signatures.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTx();
        if ((0, helpers_1.isSet)(object.body))
          obj.body = exports.TxBody.fromJSON(object.body);
        if ((0, helpers_1.isSet)(object.authInfo))
          obj.authInfo = exports.AuthInfo.fromJSON(object.authInfo);
        if (Array.isArray(object?.signatures))
          obj.signatures = object.signatures.map((e) => (0, helpers_1.bytesFromBase64)(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.body !== void 0 && (obj.body = message.body ? exports.TxBody.toJSON(message.body) : void 0);
        message.authInfo !== void 0 && (obj.authInfo = message.authInfo ? exports.AuthInfo.toJSON(message.authInfo) : void 0);
        if (message.signatures) {
          obj.signatures = message.signatures.map((e) => (0, helpers_1.base64FromBytes)(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.signatures = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTx();
        if (object.body !== void 0 && object.body !== null) {
          message.body = exports.TxBody.fromPartial(object.body);
        }
        if (object.authInfo !== void 0 && object.authInfo !== null) {
          message.authInfo = exports.AuthInfo.fromPartial(object.authInfo);
        }
        message.signatures = object.signatures?.map((e) => e) || [];
        return message;
      }
    };
    function createBaseTxRaw() {
      return {
        bodyBytes: new Uint8Array(),
        authInfoBytes: new Uint8Array(),
        signatures: []
      };
    }
    exports.TxRaw = {
      typeUrl: "/cosmos.tx.v1beta1.TxRaw",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.bodyBytes.length !== 0) {
          writer.uint32(10).bytes(message.bodyBytes);
        }
        if (message.authInfoBytes.length !== 0) {
          writer.uint32(18).bytes(message.authInfoBytes);
        }
        for (const v9 of message.signatures) {
          writer.uint32(26).bytes(v9);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxRaw();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bodyBytes = reader.bytes();
              break;
            case 2:
              message.authInfoBytes = reader.bytes();
              break;
            case 3:
              message.signatures.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxRaw();
        if ((0, helpers_1.isSet)(object.bodyBytes))
          obj.bodyBytes = (0, helpers_1.bytesFromBase64)(object.bodyBytes);
        if ((0, helpers_1.isSet)(object.authInfoBytes))
          obj.authInfoBytes = (0, helpers_1.bytesFromBase64)(object.authInfoBytes);
        if (Array.isArray(object?.signatures))
          obj.signatures = object.signatures.map((e) => (0, helpers_1.bytesFromBase64)(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.bodyBytes !== void 0 && (obj.bodyBytes = (0, helpers_1.base64FromBytes)(message.bodyBytes !== void 0 ? message.bodyBytes : new Uint8Array()));
        message.authInfoBytes !== void 0 && (obj.authInfoBytes = (0, helpers_1.base64FromBytes)(message.authInfoBytes !== void 0 ? message.authInfoBytes : new Uint8Array()));
        if (message.signatures) {
          obj.signatures = message.signatures.map((e) => (0, helpers_1.base64FromBytes)(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.signatures = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxRaw();
        message.bodyBytes = object.bodyBytes ?? new Uint8Array();
        message.authInfoBytes = object.authInfoBytes ?? new Uint8Array();
        message.signatures = object.signatures?.map((e) => e) || [];
        return message;
      }
    };
    function createBaseSignDoc() {
      return {
        bodyBytes: new Uint8Array(),
        authInfoBytes: new Uint8Array(),
        chainId: "",
        accountNumber: BigInt(0)
      };
    }
    exports.SignDoc = {
      typeUrl: "/cosmos.tx.v1beta1.SignDoc",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.bodyBytes.length !== 0) {
          writer.uint32(10).bytes(message.bodyBytes);
        }
        if (message.authInfoBytes.length !== 0) {
          writer.uint32(18).bytes(message.authInfoBytes);
        }
        if (message.chainId !== "") {
          writer.uint32(26).string(message.chainId);
        }
        if (message.accountNumber !== BigInt(0)) {
          writer.uint32(32).uint64(message.accountNumber);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignDoc();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bodyBytes = reader.bytes();
              break;
            case 2:
              message.authInfoBytes = reader.bytes();
              break;
            case 3:
              message.chainId = reader.string();
              break;
            case 4:
              message.accountNumber = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSignDoc();
        if ((0, helpers_1.isSet)(object.bodyBytes))
          obj.bodyBytes = (0, helpers_1.bytesFromBase64)(object.bodyBytes);
        if ((0, helpers_1.isSet)(object.authInfoBytes))
          obj.authInfoBytes = (0, helpers_1.bytesFromBase64)(object.authInfoBytes);
        if ((0, helpers_1.isSet)(object.chainId))
          obj.chainId = String(object.chainId);
        if ((0, helpers_1.isSet)(object.accountNumber))
          obj.accountNumber = BigInt(object.accountNumber.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.bodyBytes !== void 0 && (obj.bodyBytes = (0, helpers_1.base64FromBytes)(message.bodyBytes !== void 0 ? message.bodyBytes : new Uint8Array()));
        message.authInfoBytes !== void 0 && (obj.authInfoBytes = (0, helpers_1.base64FromBytes)(message.authInfoBytes !== void 0 ? message.authInfoBytes : new Uint8Array()));
        message.chainId !== void 0 && (obj.chainId = message.chainId);
        message.accountNumber !== void 0 && (obj.accountNumber = (message.accountNumber || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSignDoc();
        message.bodyBytes = object.bodyBytes ?? new Uint8Array();
        message.authInfoBytes = object.authInfoBytes ?? new Uint8Array();
        message.chainId = object.chainId ?? "";
        if (object.accountNumber !== void 0 && object.accountNumber !== null) {
          message.accountNumber = BigInt(object.accountNumber.toString());
        }
        return message;
      }
    };
    function createBaseSignDocDirectAux() {
      return {
        bodyBytes: new Uint8Array(),
        publicKey: void 0,
        chainId: "",
        accountNumber: BigInt(0),
        sequence: BigInt(0),
        tip: void 0
      };
    }
    exports.SignDocDirectAux = {
      typeUrl: "/cosmos.tx.v1beta1.SignDocDirectAux",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.bodyBytes.length !== 0) {
          writer.uint32(10).bytes(message.bodyBytes);
        }
        if (message.publicKey !== void 0) {
          any_1.Any.encode(message.publicKey, writer.uint32(18).fork()).ldelim();
        }
        if (message.chainId !== "") {
          writer.uint32(26).string(message.chainId);
        }
        if (message.accountNumber !== BigInt(0)) {
          writer.uint32(32).uint64(message.accountNumber);
        }
        if (message.sequence !== BigInt(0)) {
          writer.uint32(40).uint64(message.sequence);
        }
        if (message.tip !== void 0) {
          exports.Tip.encode(message.tip, writer.uint32(50).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignDocDirectAux();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bodyBytes = reader.bytes();
              break;
            case 2:
              message.publicKey = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.chainId = reader.string();
              break;
            case 4:
              message.accountNumber = reader.uint64();
              break;
            case 5:
              message.sequence = reader.uint64();
              break;
            case 6:
              message.tip = exports.Tip.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSignDocDirectAux();
        if ((0, helpers_1.isSet)(object.bodyBytes))
          obj.bodyBytes = (0, helpers_1.bytesFromBase64)(object.bodyBytes);
        if ((0, helpers_1.isSet)(object.publicKey))
          obj.publicKey = any_1.Any.fromJSON(object.publicKey);
        if ((0, helpers_1.isSet)(object.chainId))
          obj.chainId = String(object.chainId);
        if ((0, helpers_1.isSet)(object.accountNumber))
          obj.accountNumber = BigInt(object.accountNumber.toString());
        if ((0, helpers_1.isSet)(object.sequence))
          obj.sequence = BigInt(object.sequence.toString());
        if ((0, helpers_1.isSet)(object.tip))
          obj.tip = exports.Tip.fromJSON(object.tip);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.bodyBytes !== void 0 && (obj.bodyBytes = (0, helpers_1.base64FromBytes)(message.bodyBytes !== void 0 ? message.bodyBytes : new Uint8Array()));
        message.publicKey !== void 0 && (obj.publicKey = message.publicKey ? any_1.Any.toJSON(message.publicKey) : void 0);
        message.chainId !== void 0 && (obj.chainId = message.chainId);
        message.accountNumber !== void 0 && (obj.accountNumber = (message.accountNumber || BigInt(0)).toString());
        message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt(0)).toString());
        message.tip !== void 0 && (obj.tip = message.tip ? exports.Tip.toJSON(message.tip) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSignDocDirectAux();
        message.bodyBytes = object.bodyBytes ?? new Uint8Array();
        if (object.publicKey !== void 0 && object.publicKey !== null) {
          message.publicKey = any_1.Any.fromPartial(object.publicKey);
        }
        message.chainId = object.chainId ?? "";
        if (object.accountNumber !== void 0 && object.accountNumber !== null) {
          message.accountNumber = BigInt(object.accountNumber.toString());
        }
        if (object.sequence !== void 0 && object.sequence !== null) {
          message.sequence = BigInt(object.sequence.toString());
        }
        if (object.tip !== void 0 && object.tip !== null) {
          message.tip = exports.Tip.fromPartial(object.tip);
        }
        return message;
      }
    };
    function createBaseTxBody() {
      return {
        messages: [],
        memo: "",
        timeoutHeight: BigInt(0),
        extensionOptions: [],
        nonCriticalExtensionOptions: []
      };
    }
    exports.TxBody = {
      typeUrl: "/cosmos.tx.v1beta1.TxBody",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.messages) {
          any_1.Any.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.memo !== "") {
          writer.uint32(18).string(message.memo);
        }
        if (message.timeoutHeight !== BigInt(0)) {
          writer.uint32(24).uint64(message.timeoutHeight);
        }
        for (const v9 of message.extensionOptions) {
          any_1.Any.encode(v9, writer.uint32(8186).fork()).ldelim();
        }
        for (const v9 of message.nonCriticalExtensionOptions) {
          any_1.Any.encode(v9, writer.uint32(16378).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxBody();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.messages.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            case 2:
              message.memo = reader.string();
              break;
            case 3:
              message.timeoutHeight = reader.uint64();
              break;
            case 1023:
              message.extensionOptions.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            case 2047:
              message.nonCriticalExtensionOptions.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxBody();
        if (Array.isArray(object?.messages))
          obj.messages = object.messages.map((e) => any_1.Any.fromJSON(e));
        if ((0, helpers_1.isSet)(object.memo))
          obj.memo = String(object.memo);
        if ((0, helpers_1.isSet)(object.timeoutHeight))
          obj.timeoutHeight = BigInt(object.timeoutHeight.toString());
        if (Array.isArray(object?.extensionOptions))
          obj.extensionOptions = object.extensionOptions.map((e) => any_1.Any.fromJSON(e));
        if (Array.isArray(object?.nonCriticalExtensionOptions))
          obj.nonCriticalExtensionOptions = object.nonCriticalExtensionOptions.map((e) => any_1.Any.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.messages) {
          obj.messages = message.messages.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.messages = [];
        }
        message.memo !== void 0 && (obj.memo = message.memo);
        message.timeoutHeight !== void 0 && (obj.timeoutHeight = (message.timeoutHeight || BigInt(0)).toString());
        if (message.extensionOptions) {
          obj.extensionOptions = message.extensionOptions.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.extensionOptions = [];
        }
        if (message.nonCriticalExtensionOptions) {
          obj.nonCriticalExtensionOptions = message.nonCriticalExtensionOptions.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.nonCriticalExtensionOptions = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxBody();
        message.messages = object.messages?.map((e) => any_1.Any.fromPartial(e)) || [];
        message.memo = object.memo ?? "";
        if (object.timeoutHeight !== void 0 && object.timeoutHeight !== null) {
          message.timeoutHeight = BigInt(object.timeoutHeight.toString());
        }
        message.extensionOptions = object.extensionOptions?.map((e) => any_1.Any.fromPartial(e)) || [];
        message.nonCriticalExtensionOptions = object.nonCriticalExtensionOptions?.map((e) => any_1.Any.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseAuthInfo() {
      return {
        signerInfos: [],
        fee: void 0,
        tip: void 0
      };
    }
    exports.AuthInfo = {
      typeUrl: "/cosmos.tx.v1beta1.AuthInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.signerInfos) {
          exports.SignerInfo.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.fee !== void 0) {
          exports.Fee.encode(message.fee, writer.uint32(18).fork()).ldelim();
        }
        if (message.tip !== void 0) {
          exports.Tip.encode(message.tip, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAuthInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signerInfos.push(exports.SignerInfo.decode(reader, reader.uint32()));
              break;
            case 2:
              message.fee = exports.Fee.decode(reader, reader.uint32());
              break;
            case 3:
              message.tip = exports.Tip.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseAuthInfo();
        if (Array.isArray(object?.signerInfos))
          obj.signerInfos = object.signerInfos.map((e) => exports.SignerInfo.fromJSON(e));
        if ((0, helpers_1.isSet)(object.fee))
          obj.fee = exports.Fee.fromJSON(object.fee);
        if ((0, helpers_1.isSet)(object.tip))
          obj.tip = exports.Tip.fromJSON(object.tip);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.signerInfos) {
          obj.signerInfos = message.signerInfos.map((e) => e ? exports.SignerInfo.toJSON(e) : void 0);
        } else {
          obj.signerInfos = [];
        }
        message.fee !== void 0 && (obj.fee = message.fee ? exports.Fee.toJSON(message.fee) : void 0);
        message.tip !== void 0 && (obj.tip = message.tip ? exports.Tip.toJSON(message.tip) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseAuthInfo();
        message.signerInfos = object.signerInfos?.map((e) => exports.SignerInfo.fromPartial(e)) || [];
        if (object.fee !== void 0 && object.fee !== null) {
          message.fee = exports.Fee.fromPartial(object.fee);
        }
        if (object.tip !== void 0 && object.tip !== null) {
          message.tip = exports.Tip.fromPartial(object.tip);
        }
        return message;
      }
    };
    function createBaseSignerInfo() {
      return {
        publicKey: void 0,
        modeInfo: void 0,
        sequence: BigInt(0)
      };
    }
    exports.SignerInfo = {
      typeUrl: "/cosmos.tx.v1beta1.SignerInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.publicKey !== void 0) {
          any_1.Any.encode(message.publicKey, writer.uint32(10).fork()).ldelim();
        }
        if (message.modeInfo !== void 0) {
          exports.ModeInfo.encode(message.modeInfo, writer.uint32(18).fork()).ldelim();
        }
        if (message.sequence !== BigInt(0)) {
          writer.uint32(24).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignerInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.publicKey = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.modeInfo = exports.ModeInfo.decode(reader, reader.uint32());
              break;
            case 3:
              message.sequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSignerInfo();
        if ((0, helpers_1.isSet)(object.publicKey))
          obj.publicKey = any_1.Any.fromJSON(object.publicKey);
        if ((0, helpers_1.isSet)(object.modeInfo))
          obj.modeInfo = exports.ModeInfo.fromJSON(object.modeInfo);
        if ((0, helpers_1.isSet)(object.sequence))
          obj.sequence = BigInt(object.sequence.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.publicKey !== void 0 && (obj.publicKey = message.publicKey ? any_1.Any.toJSON(message.publicKey) : void 0);
        message.modeInfo !== void 0 && (obj.modeInfo = message.modeInfo ? exports.ModeInfo.toJSON(message.modeInfo) : void 0);
        message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSignerInfo();
        if (object.publicKey !== void 0 && object.publicKey !== null) {
          message.publicKey = any_1.Any.fromPartial(object.publicKey);
        }
        if (object.modeInfo !== void 0 && object.modeInfo !== null) {
          message.modeInfo = exports.ModeInfo.fromPartial(object.modeInfo);
        }
        if (object.sequence !== void 0 && object.sequence !== null) {
          message.sequence = BigInt(object.sequence.toString());
        }
        return message;
      }
    };
    function createBaseModeInfo() {
      return {
        single: void 0,
        multi: void 0
      };
    }
    exports.ModeInfo = {
      typeUrl: "/cosmos.tx.v1beta1.ModeInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.single !== void 0) {
          exports.ModeInfo_Single.encode(message.single, writer.uint32(10).fork()).ldelim();
        }
        if (message.multi !== void 0) {
          exports.ModeInfo_Multi.encode(message.multi, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseModeInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.single = exports.ModeInfo_Single.decode(reader, reader.uint32());
              break;
            case 2:
              message.multi = exports.ModeInfo_Multi.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseModeInfo();
        if ((0, helpers_1.isSet)(object.single))
          obj.single = exports.ModeInfo_Single.fromJSON(object.single);
        if ((0, helpers_1.isSet)(object.multi))
          obj.multi = exports.ModeInfo_Multi.fromJSON(object.multi);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.single !== void 0 && (obj.single = message.single ? exports.ModeInfo_Single.toJSON(message.single) : void 0);
        message.multi !== void 0 && (obj.multi = message.multi ? exports.ModeInfo_Multi.toJSON(message.multi) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseModeInfo();
        if (object.single !== void 0 && object.single !== null) {
          message.single = exports.ModeInfo_Single.fromPartial(object.single);
        }
        if (object.multi !== void 0 && object.multi !== null) {
          message.multi = exports.ModeInfo_Multi.fromPartial(object.multi);
        }
        return message;
      }
    };
    function createBaseModeInfo_Single() {
      return {
        mode: 0
      };
    }
    exports.ModeInfo_Single = {
      typeUrl: "/cosmos.tx.v1beta1.Single",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.mode !== 0) {
          writer.uint32(8).int32(message.mode);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseModeInfo_Single();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.mode = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseModeInfo_Single();
        if ((0, helpers_1.isSet)(object.mode))
          obj.mode = (0, signing_1.signModeFromJSON)(object.mode);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.mode !== void 0 && (obj.mode = (0, signing_1.signModeToJSON)(message.mode));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseModeInfo_Single();
        message.mode = object.mode ?? 0;
        return message;
      }
    };
    function createBaseModeInfo_Multi() {
      return {
        bitarray: void 0,
        modeInfos: []
      };
    }
    exports.ModeInfo_Multi = {
      typeUrl: "/cosmos.tx.v1beta1.Multi",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.bitarray !== void 0) {
          multisig_1.CompactBitArray.encode(message.bitarray, writer.uint32(10).fork()).ldelim();
        }
        for (const v9 of message.modeInfos) {
          exports.ModeInfo.encode(v9, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseModeInfo_Multi();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bitarray = multisig_1.CompactBitArray.decode(reader, reader.uint32());
              break;
            case 2:
              message.modeInfos.push(exports.ModeInfo.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseModeInfo_Multi();
        if ((0, helpers_1.isSet)(object.bitarray))
          obj.bitarray = multisig_1.CompactBitArray.fromJSON(object.bitarray);
        if (Array.isArray(object?.modeInfos))
          obj.modeInfos = object.modeInfos.map((e) => exports.ModeInfo.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.bitarray !== void 0 && (obj.bitarray = message.bitarray ? multisig_1.CompactBitArray.toJSON(message.bitarray) : void 0);
        if (message.modeInfos) {
          obj.modeInfos = message.modeInfos.map((e) => e ? exports.ModeInfo.toJSON(e) : void 0);
        } else {
          obj.modeInfos = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseModeInfo_Multi();
        if (object.bitarray !== void 0 && object.bitarray !== null) {
          message.bitarray = multisig_1.CompactBitArray.fromPartial(object.bitarray);
        }
        message.modeInfos = object.modeInfos?.map((e) => exports.ModeInfo.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseFee() {
      return {
        amount: [],
        gasLimit: BigInt(0),
        payer: "",
        granter: ""
      };
    }
    exports.Fee = {
      typeUrl: "/cosmos.tx.v1beta1.Fee",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.amount) {
          coin_1.Coin.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.gasLimit !== BigInt(0)) {
          writer.uint32(16).uint64(message.gasLimit);
        }
        if (message.payer !== "") {
          writer.uint32(26).string(message.payer);
        }
        if (message.granter !== "") {
          writer.uint32(34).string(message.granter);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseFee();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.gasLimit = reader.uint64();
              break;
            case 3:
              message.payer = reader.string();
              break;
            case 4:
              message.granter = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseFee();
        if (Array.isArray(object?.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.gasLimit))
          obj.gasLimit = BigInt(object.gasLimit.toString());
        if ((0, helpers_1.isSet)(object.payer))
          obj.payer = String(object.payer);
        if ((0, helpers_1.isSet)(object.granter))
          obj.granter = String(object.granter);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        message.gasLimit !== void 0 && (obj.gasLimit = (message.gasLimit || BigInt(0)).toString());
        message.payer !== void 0 && (obj.payer = message.payer);
        message.granter !== void 0 && (obj.granter = message.granter);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseFee();
        message.amount = object.amount?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        if (object.gasLimit !== void 0 && object.gasLimit !== null) {
          message.gasLimit = BigInt(object.gasLimit.toString());
        }
        message.payer = object.payer ?? "";
        message.granter = object.granter ?? "";
        return message;
      }
    };
    function createBaseTip() {
      return {
        amount: [],
        tipper: ""
      };
    }
    exports.Tip = {
      typeUrl: "/cosmos.tx.v1beta1.Tip",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.amount) {
          coin_1.Coin.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.tipper !== "") {
          writer.uint32(18).string(message.tipper);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTip();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.tipper = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTip();
        if (Array.isArray(object?.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.tipper))
          obj.tipper = String(object.tipper);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        message.tipper !== void 0 && (obj.tipper = message.tipper);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTip();
        message.amount = object.amount?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        message.tipper = object.tipper ?? "";
        return message;
      }
    };
    function createBaseAuxSignerData() {
      return {
        address: "",
        signDoc: void 0,
        mode: 0,
        sig: new Uint8Array()
      };
    }
    exports.AuxSignerData = {
      typeUrl: "/cosmos.tx.v1beta1.AuxSignerData",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.signDoc !== void 0) {
          exports.SignDocDirectAux.encode(message.signDoc, writer.uint32(18).fork()).ldelim();
        }
        if (message.mode !== 0) {
          writer.uint32(24).int32(message.mode);
        }
        if (message.sig.length !== 0) {
          writer.uint32(34).bytes(message.sig);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAuxSignerData();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.signDoc = exports.SignDocDirectAux.decode(reader, reader.uint32());
              break;
            case 3:
              message.mode = reader.int32();
              break;
            case 4:
              message.sig = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseAuxSignerData();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.signDoc))
          obj.signDoc = exports.SignDocDirectAux.fromJSON(object.signDoc);
        if ((0, helpers_1.isSet)(object.mode))
          obj.mode = (0, signing_1.signModeFromJSON)(object.mode);
        if ((0, helpers_1.isSet)(object.sig))
          obj.sig = (0, helpers_1.bytesFromBase64)(object.sig);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.signDoc !== void 0 && (obj.signDoc = message.signDoc ? exports.SignDocDirectAux.toJSON(message.signDoc) : void 0);
        message.mode !== void 0 && (obj.mode = (0, signing_1.signModeToJSON)(message.mode));
        message.sig !== void 0 && (obj.sig = (0, helpers_1.base64FromBytes)(message.sig !== void 0 ? message.sig : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseAuxSignerData();
        message.address = object.address ?? "";
        if (object.signDoc !== void 0 && object.signDoc !== null) {
          message.signDoc = exports.SignDocDirectAux.fromPartial(object.signDoc);
        }
        message.mode = object.mode ?? 0;
        message.sig = object.sig ?? new Uint8Array();
        return message;
      }
    };
  }
});

// node_modules/.pnpm/@cosmjs+proto-signing@0.37.0/node_modules/@cosmjs/proto-signing/build/decode.js
var require_decode = __commonJS({
  "node_modules/.pnpm/@cosmjs+proto-signing@0.37.0/node_modules/@cosmjs/proto-signing/build/decode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeTxRaw = decodeTxRaw;
    var tx_1 = require_tx();
    function decodeTxRaw(tx) {
      const txRaw = tx_1.TxRaw.decode(tx);
      return {
        authInfo: tx_1.AuthInfo.decode(txRaw.authInfoBytes),
        body: tx_1.TxBody.decode(txRaw.bodyBytes),
        signatures: txRaw.signatures
      };
    }
  }
});

// node_modules/.pnpm/@cosmjs+proto-signing@0.37.0/node_modules/@cosmjs/proto-signing/build/signing.js
var require_signing2 = __commonJS({
  "node_modules/.pnpm/@cosmjs+proto-signing@0.37.0/node_modules/@cosmjs/proto-signing/build/signing.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.makeAuthInfoBytes = makeAuthInfoBytes;
    exports.makeSignDoc = makeSignDoc;
    exports.makeSignBytes = makeSignBytes2;
    var utils_1 = require_build();
    var signing_1 = require_signing();
    var tx_1 = require_tx();
    function makeSignerInfos(signers, signMode) {
      return signers.map(({ pubkey, sequence }) => ({
        publicKey: pubkey,
        modeInfo: {
          single: { mode: signMode }
        },
        sequence: BigInt(sequence)
      }));
    }
    function makeAuthInfoBytes(signers, feeAmount, gasLimit, feeGranter, feePayer, signMode = signing_1.SignMode.SIGN_MODE_DIRECT) {
      (0, utils_1.assert)(feeGranter === void 0 || typeof feeGranter === "string", "feeGranter must be undefined or string");
      (0, utils_1.assert)(feePayer === void 0 || typeof feePayer === "string", "feePayer must be undefined or string");
      const authInfo = tx_1.AuthInfo.fromPartial({
        signerInfos: makeSignerInfos(signers, signMode),
        fee: {
          amount: [...feeAmount],
          gasLimit: BigInt(gasLimit),
          granter: feeGranter,
          payer: feePayer
        }
      });
      return tx_1.AuthInfo.encode(authInfo).finish();
    }
    function makeSignDoc(bodyBytes, authInfoBytes, chainId, accountNumber) {
      return {
        bodyBytes,
        authInfoBytes,
        chainId,
        accountNumber: BigInt(accountNumber)
      };
    }
    function makeSignBytes2({ accountNumber, authInfoBytes, bodyBytes, chainId }) {
      const signDoc = tx_1.SignDoc.fromPartial({
        accountNumber,
        authInfoBytes,
        bodyBytes,
        chainId
      });
      return tx_1.SignDoc.encode(signDoc).finish();
    }
  }
});

// node_modules/.pnpm/@cosmjs+proto-signing@0.37.0/node_modules/@cosmjs/proto-signing/build/wallet.js
var require_wallet2 = __commonJS({
  "node_modules/.pnpm/@cosmjs+proto-signing@0.37.0/node_modules/@cosmjs/proto-signing/build/wallet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.supportedAlgorithms = exports.cosmjsSalt = void 0;
    exports.executeKdf = executeKdf;
    exports.encrypt = encrypt;
    exports.decrypt = decrypt;
    var crypto_1 = require_build4();
    var encoding_1 = require_build2();
    var utils_1 = require_build();
    exports.cosmjsSalt = (0, encoding_1.toAscii)("The CosmJS salt.");
    async function executeKdf(password, configuration) {
      switch (configuration.algorithm) {
        case "argon2id": {
          const options = configuration.params;
          if (!(0, crypto_1.isArgon2idOptions)(options))
            throw new Error("Invalid format of argon2id params");
          const screamTest = (0, utils_1.sleep)(options.opsLimit * 250);
          const result = await crypto_1.Argon2id.execute(password, exports.cosmjsSalt, options);
          await screamTest;
          return result;
        }
        default:
          throw new Error("Unsupported KDF algorithm");
      }
    }
    exports.supportedAlgorithms = {
      xchacha20poly1305Ietf: "xchacha20poly1305-ietf"
    };
    async function encrypt(plaintext, encryptionKey, config) {
      switch (config.algorithm) {
        case exports.supportedAlgorithms.xchacha20poly1305Ietf: {
          const nonce = crypto_1.Random.getBytes(crypto_1.xchacha20NonceLength);
          return new Uint8Array([
            ...nonce,
            ...await crypto_1.Xchacha20poly1305Ietf.encrypt(plaintext, encryptionKey, nonce)
          ]);
        }
        default:
          throw new Error(`Unsupported encryption algorithm: '${config.algorithm}'`);
      }
    }
    async function decrypt(ciphertext, encryptionKey, config) {
      switch (config.algorithm) {
        case exports.supportedAlgorithms.xchacha20poly1305Ietf: {
          const nonce = ciphertext.slice(0, crypto_1.xchacha20NonceLength);
          return crypto_1.Xchacha20poly1305Ietf.decrypt(ciphertext.slice(crypto_1.xchacha20NonceLength), encryptionKey, nonce);
        }
        default:
          throw new Error(`Unsupported encryption algorithm: '${config.algorithm}'`);
      }
    }
  }
});

// node_modules/.pnpm/@cosmjs+proto-signing@0.37.0/node_modules/@cosmjs/proto-signing/build/directsecp256k1hdwallet.js
var require_directsecp256k1hdwallet = __commonJS({
  "node_modules/.pnpm/@cosmjs+proto-signing@0.37.0/node_modules/@cosmjs/proto-signing/build/directsecp256k1hdwallet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DirectSecp256k1HdWallet = void 0;
    exports.extractKdfConfiguration = extractKdfConfiguration;
    var amino_1 = require_build5();
    var crypto_1 = require_build4();
    var encoding_1 = require_build2();
    var utils_1 = require_build();
    var signing_1 = require_signing2();
    var wallet_1 = require_wallet2();
    var serializationTypeV1 = "directsecp256k1hdwallet-v1";
    var basicPasswordHashingOptions = {
      algorithm: "argon2id",
      params: {
        outputLength: 32,
        opsLimit: 24,
        memLimitKib: 12 * 1024
      }
    };
    function isDerivationJson(thing) {
      if (!(0, utils_1.isNonNullObject)(thing))
        return false;
      if (typeof thing.hdPath !== "string")
        return false;
      if (typeof thing.prefix !== "string")
        return false;
      return true;
    }
    function extractKdfConfigurationV1(doc) {
      return doc.kdf;
    }
    function extractKdfConfiguration(serialization) {
      const root = JSON.parse(serialization);
      if (!(0, utils_1.isNonNullObject)(root))
        throw new Error("Root document is not an object.");
      switch (root.type) {
        case serializationTypeV1:
          return extractKdfConfigurationV1(root);
        default:
          throw new Error("Unsupported serialization type");
      }
    }
    var defaultOptions = {
      bip39Password: "",
      hdPaths: [(0, amino_1.makeCosmoshubPath)(0)],
      prefix: "cosmos"
    };
    var DirectSecp256k1HdWallet = class _DirectSecp256k1HdWallet {
      /**
       * Restores a wallet from the given BIP39 mnemonic.
       *
       * @param mnemonic Any valid English mnemonic.
       * @param options An optional `DirectSecp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
       */
      static async fromMnemonic(mnemonic, options = {}) {
        const mnemonicChecked = new crypto_1.EnglishMnemonic(mnemonic);
        const seed = await crypto_1.Bip39.mnemonicToSeed(mnemonicChecked, options.bip39Password);
        return new _DirectSecp256k1HdWallet(mnemonicChecked, {
          ...options,
          seed
        });
      }
      /**
       * Generates a new wallet with a BIP39 mnemonic of the given length.
       *
       * @param length The number of words in the mnemonic (12, 15, 18, 21 or 24).
       * @param options An optional `DirectSecp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
       */
      static async generate(length = 12, options = {}) {
        const entropyLength = 4 * Math.floor(11 * length / 33);
        const entropy = crypto_1.Random.getBytes(entropyLength);
        const mnemonic = crypto_1.Bip39.encode(entropy);
        return _DirectSecp256k1HdWallet.fromMnemonic(mnemonic.toString(), options);
      }
      /**
       * Restores a wallet from an encrypted serialization.
       *
       * @param password The user provided password used to generate an encryption key via a KDF.
       *                 This is not normalized internally (see "Unicode normalization" to learn more).
       *
       * @deprecated Wallet encryption support will be removed from CosmJS in a future version.
       *             If you actually use this, please comment at https://github.com/cosmos/cosmjs/issues/1796.
       */
      static async deserialize(serialization, password) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root))
          throw new Error("Root document is not an object.");
        switch (root.type) {
          case serializationTypeV1:
            return _DirectSecp256k1HdWallet.deserializeTypeV1(serialization, password);
          default:
            throw new Error("Unsupported serialization type");
        }
      }
      /**
       * Restores a wallet from an encrypted serialization.
       *
       * This is an advanced alternative to calling `deserialize(serialization, password)` directly, which allows
       * you to offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
       *
       * The caller is responsible for ensuring the key was derived with the given KDF configuration. This can be
       * done using `extractKdfConfiguration(serialization)` and `executeKdf(password, kdfConfiguration)` from this package.
       *
       * @deprecated Wallet encryption support will be removed from CosmJS in a future version.
       *             If you actually use this, please comment at https://github.com/cosmos/cosmjs/issues/1796.
       */
      static async deserializeWithEncryptionKey(serialization, encryptionKey) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root))
          throw new Error("Root document is not an object.");
        const untypedRoot = root;
        switch (untypedRoot.type) {
          case serializationTypeV1: {
            const decryptedBytes = await (0, wallet_1.decrypt)((0, encoding_1.fromBase64)(untypedRoot.data), encryptionKey, untypedRoot.encryption);
            const decryptedDocument = JSON.parse((0, encoding_1.fromUtf8)(decryptedBytes));
            const { mnemonic, accounts } = decryptedDocument;
            (0, utils_1.assert)(typeof mnemonic === "string");
            if (!Array.isArray(accounts))
              throw new Error("Property 'accounts' is not an array");
            if (!accounts.every((account) => isDerivationJson(account))) {
              throw new Error("Account is not in the correct format.");
            }
            const firstPrefix = accounts[0].prefix;
            if (!accounts.every(({ prefix }) => prefix === firstPrefix)) {
              throw new Error("Accounts do not all have the same prefix");
            }
            const hdPaths = accounts.map(({ hdPath }) => (0, crypto_1.stringToPath)(hdPath));
            return _DirectSecp256k1HdWallet.fromMnemonic(mnemonic, {
              hdPaths,
              prefix: firstPrefix
            });
          }
          default:
            throw new Error("Unsupported serialization type");
        }
      }
      static async deserializeTypeV1(serialization, password) {
        const root = JSON.parse(serialization);
        if (!(0, utils_1.isNonNullObject)(root))
          throw new Error("Root document is not an object.");
        const encryptionKey = await (0, wallet_1.executeKdf)(password, root.kdf);
        return _DirectSecp256k1HdWallet.deserializeWithEncryptionKey(serialization, encryptionKey);
      }
      /** Base secret */
      secret;
      /** BIP39 seed */
      seed;
      /** Derivation instructions */
      accounts;
      constructor(mnemonic, options) {
        const prefix = options.prefix ?? defaultOptions.prefix;
        const hdPaths = options.hdPaths ?? defaultOptions.hdPaths;
        this.secret = mnemonic;
        this.seed = options.seed;
        this.accounts = hdPaths.map((hdPath) => ({
          hdPath,
          prefix
        }));
      }
      get mnemonic() {
        return this.secret.toString();
      }
      async getAccounts() {
        const accountsWithPrivkeys = await this.getAccountsWithPrivkeys();
        return accountsWithPrivkeys.map(({ algo, pubkey, address }) => ({
          algo,
          pubkey,
          address
        }));
      }
      async signDirect(signerAddress, signDoc) {
        const accounts = await this.getAccountsWithPrivkeys();
        const account = accounts.find(({ address }) => address === signerAddress);
        if (account === void 0) {
          throw new Error(`Address ${signerAddress} not found in wallet`);
        }
        const { privkey, pubkey } = account;
        const signBytes = (0, signing_1.makeSignBytes)(signDoc);
        const hashedMessage = (0, crypto_1.sha256)(signBytes);
        const signature = await crypto_1.Secp256k1.createSignature(hashedMessage, privkey);
        const signatureBytes = new Uint8Array([...signature.r(32), ...signature.s(32)]);
        const stdSignature = (0, amino_1.encodeSecp256k1Signature)(pubkey, signatureBytes);
        return {
          signed: signDoc,
          signature: stdSignature
        };
      }
      /**
       * Generates an encrypted serialization of this wallet.
       *
       * @param password The user provided password used to generate an encryption key via a KDF.
       *                 This is not normalized internally (see "Unicode normalization" to learn more).
       *
       * @deprecated Wallet encryption support will be removed from CosmJS in a future version.
       *             If you actually use this, please comment at https://github.com/cosmos/cosmjs/issues/1796.
       */
      async serialize(password) {
        const kdfConfiguration = basicPasswordHashingOptions;
        const encryptionKey = await (0, wallet_1.executeKdf)(password, kdfConfiguration);
        return this.serializeWithEncryptionKey(encryptionKey, kdfConfiguration);
      }
      /**
       * Generates an encrypted serialization of this wallet.
       *
       * This is an advanced alternative to calling `serialize(password)` directly, which allows you to
       * offload the KDF execution to a non-UI thread (e.g. in a WebWorker).
       *
       * The caller is responsible for ensuring the key was derived with the given KDF options. If this
       * is not the case, the wallet cannot be restored with the original password.
       *
       * @deprecated Wallet encryption support will be removed from CosmJS in a future version.
       *             If you actually use this, please comment at https://github.com/cosmos/cosmjs/issues/1796.
       */
      async serializeWithEncryptionKey(encryptionKey, kdfConfiguration) {
        const dataToEncrypt = {
          mnemonic: this.mnemonic,
          accounts: this.accounts.map(({ hdPath, prefix }) => ({
            hdPath: (0, crypto_1.pathToString)(hdPath),
            prefix
          }))
        };
        const dataToEncryptRaw = (0, encoding_1.toUtf8)(JSON.stringify(dataToEncrypt));
        const encryptionConfiguration = {
          algorithm: wallet_1.supportedAlgorithms.xchacha20poly1305Ietf
        };
        const encryptedData = await (0, wallet_1.encrypt)(dataToEncryptRaw, encryptionKey, encryptionConfiguration);
        const out = {
          type: serializationTypeV1,
          kdf: kdfConfiguration,
          encryption: encryptionConfiguration,
          data: (0, encoding_1.toBase64)(encryptedData)
        };
        return JSON.stringify(out);
      }
      async getKeyPair(hdPath) {
        const { privkey } = crypto_1.Slip10.derivePath(crypto_1.Slip10Curve.Secp256k1, this.seed, hdPath);
        const { pubkey } = await crypto_1.Secp256k1.makeKeypair(privkey);
        return {
          privkey,
          pubkey: crypto_1.Secp256k1.compressPubkey(pubkey)
        };
      }
      async getAccountsWithPrivkeys() {
        return Promise.all(this.accounts.map(async ({ hdPath, prefix }) => {
          const { privkey, pubkey } = await this.getKeyPair(hdPath);
          const address = (0, encoding_1.toBech32)(prefix, (0, amino_1.rawSecp256k1PubkeyToRawAddress)(pubkey));
          return {
            algo: "secp256k1",
            privkey,
            pubkey,
            address
          };
        }));
      }
    };
    exports.DirectSecp256k1HdWallet = DirectSecp256k1HdWallet;
  }
});

// node_modules/.pnpm/@cosmjs+proto-signing@0.37.0/node_modules/@cosmjs/proto-signing/build/directsecp256k1wallet.js
var require_directsecp256k1wallet = __commonJS({
  "node_modules/.pnpm/@cosmjs+proto-signing@0.37.0/node_modules/@cosmjs/proto-signing/build/directsecp256k1wallet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DirectSecp256k1Wallet = void 0;
    var amino_1 = require_build5();
    var crypto_1 = require_build4();
    var encoding_1 = require_build2();
    var signing_1 = require_signing2();
    var DirectSecp256k1Wallet = class _DirectSecp256k1Wallet {
      /**
       * Creates a DirectSecp256k1Wallet from the given private key
       *
       * @param privkey The private key.
       * @param prefix The bech32 address prefix (human readable part). Defaults to "cosmos".
       */
      static async fromKey(privkey, prefix = "cosmos") {
        const uncompressed = (await crypto_1.Secp256k1.makeKeypair(privkey)).pubkey;
        return new _DirectSecp256k1Wallet(privkey, crypto_1.Secp256k1.compressPubkey(uncompressed), prefix);
      }
      pubkey;
      privkey;
      prefix;
      constructor(privkey, pubkey, prefix) {
        this.privkey = privkey;
        this.pubkey = pubkey;
        this.prefix = prefix;
      }
      get address() {
        return (0, encoding_1.toBech32)(this.prefix, (0, amino_1.rawSecp256k1PubkeyToRawAddress)(this.pubkey));
      }
      async getAccounts() {
        return [
          {
            algo: "secp256k1",
            address: this.address,
            pubkey: this.pubkey
          }
        ];
      }
      async signDirect(address, signDoc) {
        const signBytes = (0, signing_1.makeSignBytes)(signDoc);
        if (address !== this.address) {
          throw new Error(`Address ${address} not found in wallet`);
        }
        const hashedMessage = (0, crypto_1.sha256)(signBytes);
        const signature = await crypto_1.Secp256k1.createSignature(hashedMessage, this.privkey);
        const signatureBytes = new Uint8Array([...signature.r(32), ...signature.s(32)]);
        const stdSignature = (0, amino_1.encodeSecp256k1Signature)(this.pubkey, signatureBytes);
        return {
          signed: signDoc,
          signature: stdSignature
        };
      }
    };
    exports.DirectSecp256k1Wallet = DirectSecp256k1Wallet;
  }
});

// node_modules/.pnpm/@cosmjs+proto-signing@0.37.0/node_modules/@cosmjs/proto-signing/build/paths.js
var require_paths2 = __commonJS({
  "node_modules/.pnpm/@cosmjs+proto-signing@0.37.0/node_modules/@cosmjs/proto-signing/build/paths.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.makeCosmoshubPath = makeCosmoshubPath;
    var crypto_1 = require_build4();
    function makeCosmoshubPath(a2) {
      return [
        crypto_1.Slip10RawIndex.hardened(44),
        crypto_1.Slip10RawIndex.hardened(118),
        crypto_1.Slip10RawIndex.hardened(0),
        crypto_1.Slip10RawIndex.normal(0),
        crypto_1.Slip10RawIndex.normal(a2)
      ];
    }
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/crypto/ed25519/keys.js
var require_keys = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/crypto/ed25519/keys.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PrivKey = exports.PubKey = exports.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.crypto.ed25519";
    function createBasePubKey() {
      return {
        key: new Uint8Array()
      };
    }
    exports.PubKey = {
      typeUrl: "/cosmos.crypto.ed25519.PubKey",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePubKey();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePubKey();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBasePubKey();
        message.key = object.key ?? new Uint8Array();
        return message;
      }
    };
    function createBasePrivKey() {
      return {
        key: new Uint8Array()
      };
    }
    exports.PrivKey = {
      typeUrl: "/cosmos.crypto.ed25519.PrivKey",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePrivKey();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePrivKey();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBasePrivKey();
        message.key = object.key ?? new Uint8Array();
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/crypto/multisig/keys.js
var require_keys2 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/crypto/multisig/keys.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LegacyAminoPubKey = exports.protobufPackage = void 0;
    var any_1 = require_any();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.crypto.multisig";
    function createBaseLegacyAminoPubKey() {
      return {
        threshold: 0,
        publicKeys: []
      };
    }
    exports.LegacyAminoPubKey = {
      typeUrl: "/cosmos.crypto.multisig.LegacyAminoPubKey",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.threshold !== 0) {
          writer.uint32(8).uint32(message.threshold);
        }
        for (const v9 of message.publicKeys) {
          any_1.Any.encode(v9, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLegacyAminoPubKey();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.threshold = reader.uint32();
              break;
            case 2:
              message.publicKeys.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseLegacyAminoPubKey();
        if ((0, helpers_1.isSet)(object.threshold))
          obj.threshold = Number(object.threshold);
        if (Array.isArray(object?.publicKeys))
          obj.publicKeys = object.publicKeys.map((e) => any_1.Any.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.threshold !== void 0 && (obj.threshold = Math.round(message.threshold));
        if (message.publicKeys) {
          obj.publicKeys = message.publicKeys.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.publicKeys = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseLegacyAminoPubKey();
        message.threshold = object.threshold ?? 0;
        message.publicKeys = object.publicKeys?.map((e) => any_1.Any.fromPartial(e)) || [];
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/crypto/secp256k1/keys.js
var require_keys3 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/crypto/secp256k1/keys.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PrivKey = exports.PubKey = exports.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.crypto.secp256k1";
    function createBasePubKey() {
      return {
        key: new Uint8Array()
      };
    }
    exports.PubKey = {
      typeUrl: "/cosmos.crypto.secp256k1.PubKey",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePubKey();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePubKey();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBasePubKey();
        message.key = object.key ?? new Uint8Array();
        return message;
      }
    };
    function createBasePrivKey() {
      return {
        key: new Uint8Array()
      };
    }
    exports.PrivKey = {
      typeUrl: "/cosmos.crypto.secp256k1.PrivKey",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePrivKey();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePrivKey();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBasePrivKey();
        message.key = object.key ?? new Uint8Array();
        return message;
      }
    };
  }
});

// node_modules/.pnpm/@cosmjs+proto-signing@0.37.0/node_modules/@cosmjs/proto-signing/build/pubkey.js
var require_pubkey = __commonJS({
  "node_modules/.pnpm/@cosmjs+proto-signing@0.37.0/node_modules/@cosmjs/proto-signing/build/pubkey.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodePubkey = encodePubkey;
    exports.anyToSinglePubkey = anyToSinglePubkey;
    exports.decodePubkey = decodePubkey;
    exports.decodeOptionalPubkey = decodeOptionalPubkey;
    var amino_1 = require_build5();
    var encoding_1 = require_build2();
    var math_1 = require_build3();
    var keys_1 = require_keys();
    var keys_2 = require_keys2();
    var keys_3 = require_keys3();
    var any_1 = require_any();
    function encodePubkey(pubkey) {
      if ((0, amino_1.isSecp256k1Pubkey)(pubkey)) {
        const pubkeyProto = keys_3.PubKey.fromPartial({
          key: (0, encoding_1.fromBase64)(pubkey.value)
        });
        return any_1.Any.fromPartial({
          typeUrl: "/cosmos.crypto.secp256k1.PubKey",
          value: Uint8Array.from(keys_3.PubKey.encode(pubkeyProto).finish())
        });
      } else if ((0, amino_1.isEd25519Pubkey)(pubkey)) {
        const pubkeyProto = keys_1.PubKey.fromPartial({
          key: (0, encoding_1.fromBase64)(pubkey.value)
        });
        return any_1.Any.fromPartial({
          typeUrl: "/cosmos.crypto.ed25519.PubKey",
          value: Uint8Array.from(keys_1.PubKey.encode(pubkeyProto).finish())
        });
      } else if ((0, amino_1.isMultisigThresholdPubkey)(pubkey)) {
        const pubkeyProto = keys_2.LegacyAminoPubKey.fromPartial({
          threshold: math_1.Uint53.fromString(pubkey.value.threshold).toNumber(),
          publicKeys: pubkey.value.pubkeys.map(encodePubkey)
        });
        return any_1.Any.fromPartial({
          typeUrl: "/cosmos.crypto.multisig.LegacyAminoPubKey",
          value: Uint8Array.from(keys_2.LegacyAminoPubKey.encode(pubkeyProto).finish())
        });
      } else {
        throw new Error(`Pubkey type ${pubkey.type} not recognized`);
      }
    }
    function anyToSinglePubkey(pubkey) {
      switch (pubkey.typeUrl) {
        case "/cosmos.crypto.secp256k1.PubKey": {
          const { key } = keys_3.PubKey.decode(pubkey.value);
          return (0, amino_1.encodeSecp256k1Pubkey)(key);
        }
        case "/cosmos.crypto.ed25519.PubKey": {
          const { key } = keys_1.PubKey.decode(pubkey.value);
          return (0, amino_1.encodeEd25519Pubkey)(key);
        }
        default:
          throw new Error(`Pubkey type_url ${pubkey.typeUrl} not recognized as single public key type`);
      }
    }
    function decodePubkey(pubkey) {
      switch (pubkey.typeUrl) {
        case "/cosmos.crypto.secp256k1.PubKey":
        case "/cosmos.crypto.ed25519.PubKey": {
          return anyToSinglePubkey(pubkey);
        }
        case "/cosmos.crypto.multisig.LegacyAminoPubKey": {
          const { threshold, publicKeys } = keys_2.LegacyAminoPubKey.decode(pubkey.value);
          const out = {
            type: "tendermint/PubKeyMultisigThreshold",
            value: {
              threshold: threshold.toString(),
              pubkeys: publicKeys.map(anyToSinglePubkey)
            }
          };
          return out;
        }
        default:
          throw new Error(`Pubkey type URL '${pubkey.typeUrl}' not recognized`);
      }
    }
    function decodeOptionalPubkey(pubkey) {
      if (!pubkey)
        return null;
      if (pubkey.typeUrl) {
        if (pubkey.value.length) {
          return decodePubkey(pubkey);
        } else {
          throw new Error(`Pubkey is an Any with type URL '${pubkey.typeUrl}' but an empty value`);
        }
      } else {
        if (pubkey.value.length) {
          throw new Error(`Pubkey is an Any with an empty type URL but a value set`);
        } else {
          return null;
        }
      }
    }
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/bank/v1beta1/bank.js
var require_bank = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/bank/v1beta1/bank.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Metadata = exports.DenomUnit = exports.Supply = exports.Output = exports.Input = exports.SendEnabled = exports.Params = exports.protobufPackage = void 0;
    var coin_1 = require_coin();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.bank.v1beta1";
    function createBaseParams() {
      return {
        sendEnabled: [],
        defaultSendEnabled: false
      };
    }
    exports.Params = {
      typeUrl: "/cosmos.bank.v1beta1.Params",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.sendEnabled) {
          exports.SendEnabled.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.defaultSendEnabled === true) {
          writer.uint32(16).bool(message.defaultSendEnabled);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sendEnabled.push(exports.SendEnabled.decode(reader, reader.uint32()));
              break;
            case 2:
              message.defaultSendEnabled = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseParams();
        if (Array.isArray(object?.sendEnabled))
          obj.sendEnabled = object.sendEnabled.map((e) => exports.SendEnabled.fromJSON(e));
        if ((0, helpers_1.isSet)(object.defaultSendEnabled))
          obj.defaultSendEnabled = Boolean(object.defaultSendEnabled);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.sendEnabled) {
          obj.sendEnabled = message.sendEnabled.map((e) => e ? exports.SendEnabled.toJSON(e) : void 0);
        } else {
          obj.sendEnabled = [];
        }
        message.defaultSendEnabled !== void 0 && (obj.defaultSendEnabled = message.defaultSendEnabled);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseParams();
        message.sendEnabled = object.sendEnabled?.map((e) => exports.SendEnabled.fromPartial(e)) || [];
        message.defaultSendEnabled = object.defaultSendEnabled ?? false;
        return message;
      }
    };
    function createBaseSendEnabled() {
      return {
        denom: "",
        enabled: false
      };
    }
    exports.SendEnabled = {
      typeUrl: "/cosmos.bank.v1beta1.SendEnabled",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        if (message.enabled === true) {
          writer.uint32(16).bool(message.enabled);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSendEnabled();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            case 2:
              message.enabled = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSendEnabled();
        if ((0, helpers_1.isSet)(object.denom))
          obj.denom = String(object.denom);
        if ((0, helpers_1.isSet)(object.enabled))
          obj.enabled = Boolean(object.enabled);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.denom !== void 0 && (obj.denom = message.denom);
        message.enabled !== void 0 && (obj.enabled = message.enabled);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSendEnabled();
        message.denom = object.denom ?? "";
        message.enabled = object.enabled ?? false;
        return message;
      }
    };
    function createBaseInput() {
      return {
        address: "",
        coins: []
      };
    }
    exports.Input = {
      typeUrl: "/cosmos.bank.v1beta1.Input",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        for (const v9 of message.coins) {
          coin_1.Coin.encode(v9, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseInput();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.coins.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseInput();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if (Array.isArray(object?.coins))
          obj.coins = object.coins.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        if (message.coins) {
          obj.coins = message.coins.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.coins = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseInput();
        message.address = object.address ?? "";
        message.coins = object.coins?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseOutput() {
      return {
        address: "",
        coins: []
      };
    }
    exports.Output = {
      typeUrl: "/cosmos.bank.v1beta1.Output",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        for (const v9 of message.coins) {
          coin_1.Coin.encode(v9, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseOutput();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.coins.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseOutput();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if (Array.isArray(object?.coins))
          obj.coins = object.coins.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        if (message.coins) {
          obj.coins = message.coins.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.coins = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseOutput();
        message.address = object.address ?? "";
        message.coins = object.coins?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseSupply() {
      return {
        total: []
      };
    }
    exports.Supply = {
      typeUrl: "/cosmos.bank.v1beta1.Supply",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.total) {
          coin_1.Coin.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSupply();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.total.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSupply();
        if (Array.isArray(object?.total))
          obj.total = object.total.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.total) {
          obj.total = message.total.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.total = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSupply();
        message.total = object.total?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseDenomUnit() {
      return {
        denom: "",
        exponent: 0,
        aliases: []
      };
    }
    exports.DenomUnit = {
      typeUrl: "/cosmos.bank.v1beta1.DenomUnit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        if (message.exponent !== 0) {
          writer.uint32(16).uint32(message.exponent);
        }
        for (const v9 of message.aliases) {
          writer.uint32(26).string(v9);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDenomUnit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            case 2:
              message.exponent = reader.uint32();
              break;
            case 3:
              message.aliases.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDenomUnit();
        if ((0, helpers_1.isSet)(object.denom))
          obj.denom = String(object.denom);
        if ((0, helpers_1.isSet)(object.exponent))
          obj.exponent = Number(object.exponent);
        if (Array.isArray(object?.aliases))
          obj.aliases = object.aliases.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.denom !== void 0 && (obj.denom = message.denom);
        message.exponent !== void 0 && (obj.exponent = Math.round(message.exponent));
        if (message.aliases) {
          obj.aliases = message.aliases.map((e) => e);
        } else {
          obj.aliases = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDenomUnit();
        message.denom = object.denom ?? "";
        message.exponent = object.exponent ?? 0;
        message.aliases = object.aliases?.map((e) => e) || [];
        return message;
      }
    };
    function createBaseMetadata() {
      return {
        description: "",
        denomUnits: [],
        base: "",
        display: "",
        name: "",
        symbol: "",
        uri: "",
        uriHash: ""
      };
    }
    exports.Metadata = {
      typeUrl: "/cosmos.bank.v1beta1.Metadata",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.description !== "") {
          writer.uint32(10).string(message.description);
        }
        for (const v9 of message.denomUnits) {
          exports.DenomUnit.encode(v9, writer.uint32(18).fork()).ldelim();
        }
        if (message.base !== "") {
          writer.uint32(26).string(message.base);
        }
        if (message.display !== "") {
          writer.uint32(34).string(message.display);
        }
        if (message.name !== "") {
          writer.uint32(42).string(message.name);
        }
        if (message.symbol !== "") {
          writer.uint32(50).string(message.symbol);
        }
        if (message.uri !== "") {
          writer.uint32(58).string(message.uri);
        }
        if (message.uriHash !== "") {
          writer.uint32(66).string(message.uriHash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMetadata();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.description = reader.string();
              break;
            case 2:
              message.denomUnits.push(exports.DenomUnit.decode(reader, reader.uint32()));
              break;
            case 3:
              message.base = reader.string();
              break;
            case 4:
              message.display = reader.string();
              break;
            case 5:
              message.name = reader.string();
              break;
            case 6:
              message.symbol = reader.string();
              break;
            case 7:
              message.uri = reader.string();
              break;
            case 8:
              message.uriHash = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMetadata();
        if ((0, helpers_1.isSet)(object.description))
          obj.description = String(object.description);
        if (Array.isArray(object?.denomUnits))
          obj.denomUnits = object.denomUnits.map((e) => exports.DenomUnit.fromJSON(e));
        if ((0, helpers_1.isSet)(object.base))
          obj.base = String(object.base);
        if ((0, helpers_1.isSet)(object.display))
          obj.display = String(object.display);
        if ((0, helpers_1.isSet)(object.name))
          obj.name = String(object.name);
        if ((0, helpers_1.isSet)(object.symbol))
          obj.symbol = String(object.symbol);
        if ((0, helpers_1.isSet)(object.uri))
          obj.uri = String(object.uri);
        if ((0, helpers_1.isSet)(object.uriHash))
          obj.uriHash = String(object.uriHash);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.description !== void 0 && (obj.description = message.description);
        if (message.denomUnits) {
          obj.denomUnits = message.denomUnits.map((e) => e ? exports.DenomUnit.toJSON(e) : void 0);
        } else {
          obj.denomUnits = [];
        }
        message.base !== void 0 && (obj.base = message.base);
        message.display !== void 0 && (obj.display = message.display);
        message.name !== void 0 && (obj.name = message.name);
        message.symbol !== void 0 && (obj.symbol = message.symbol);
        message.uri !== void 0 && (obj.uri = message.uri);
        message.uriHash !== void 0 && (obj.uriHash = message.uriHash);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMetadata();
        message.description = object.description ?? "";
        message.denomUnits = object.denomUnits?.map((e) => exports.DenomUnit.fromPartial(e)) || [];
        message.base = object.base ?? "";
        message.display = object.display ?? "";
        message.name = object.name ?? "";
        message.symbol = object.symbol ?? "";
        message.uri = object.uri ?? "";
        message.uriHash = object.uriHash ?? "";
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/bank/v1beta1/tx.js
var require_tx2 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/bank/v1beta1/tx.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MsgClientImpl = exports.MsgSetSendEnabledResponse = exports.MsgSetSendEnabled = exports.MsgUpdateParamsResponse = exports.MsgUpdateParams = exports.MsgMultiSendResponse = exports.MsgMultiSend = exports.MsgSendResponse = exports.MsgSend = exports.protobufPackage = void 0;
    var coin_1 = require_coin();
    var bank_1 = require_bank();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.bank.v1beta1";
    function createBaseMsgSend() {
      return {
        fromAddress: "",
        toAddress: "",
        amount: []
      };
    }
    exports.MsgSend = {
      typeUrl: "/cosmos.bank.v1beta1.MsgSend",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.fromAddress !== "") {
          writer.uint32(10).string(message.fromAddress);
        }
        if (message.toAddress !== "") {
          writer.uint32(18).string(message.toAddress);
        }
        for (const v9 of message.amount) {
          coin_1.Coin.encode(v9, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSend();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.fromAddress = reader.string();
              break;
            case 2:
              message.toAddress = reader.string();
              break;
            case 3:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgSend();
        if ((0, helpers_1.isSet)(object.fromAddress))
          obj.fromAddress = String(object.fromAddress);
        if ((0, helpers_1.isSet)(object.toAddress))
          obj.toAddress = String(object.toAddress);
        if (Array.isArray(object?.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.fromAddress !== void 0 && (obj.fromAddress = message.fromAddress);
        message.toAddress !== void 0 && (obj.toAddress = message.toAddress);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgSend();
        message.fromAddress = object.fromAddress ?? "";
        message.toAddress = object.toAddress ?? "";
        message.amount = object.amount?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseMsgSendResponse() {
      return {};
    }
    exports.MsgSendResponse = {
      typeUrl: "/cosmos.bank.v1beta1.MsgSendResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSendResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgSendResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgSendResponse();
        return message;
      }
    };
    function createBaseMsgMultiSend() {
      return {
        inputs: [],
        outputs: []
      };
    }
    exports.MsgMultiSend = {
      typeUrl: "/cosmos.bank.v1beta1.MsgMultiSend",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.inputs) {
          bank_1.Input.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        for (const v9 of message.outputs) {
          bank_1.Output.encode(v9, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgMultiSend();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.inputs.push(bank_1.Input.decode(reader, reader.uint32()));
              break;
            case 2:
              message.outputs.push(bank_1.Output.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgMultiSend();
        if (Array.isArray(object?.inputs))
          obj.inputs = object.inputs.map((e) => bank_1.Input.fromJSON(e));
        if (Array.isArray(object?.outputs))
          obj.outputs = object.outputs.map((e) => bank_1.Output.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.inputs) {
          obj.inputs = message.inputs.map((e) => e ? bank_1.Input.toJSON(e) : void 0);
        } else {
          obj.inputs = [];
        }
        if (message.outputs) {
          obj.outputs = message.outputs.map((e) => e ? bank_1.Output.toJSON(e) : void 0);
        } else {
          obj.outputs = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgMultiSend();
        message.inputs = object.inputs?.map((e) => bank_1.Input.fromPartial(e)) || [];
        message.outputs = object.outputs?.map((e) => bank_1.Output.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseMsgMultiSendResponse() {
      return {};
    }
    exports.MsgMultiSendResponse = {
      typeUrl: "/cosmos.bank.v1beta1.MsgMultiSendResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgMultiSendResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgMultiSendResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgMultiSendResponse();
        return message;
      }
    };
    function createBaseMsgUpdateParams() {
      return {
        authority: "",
        params: bank_1.Params.fromPartial({})
      };
    }
    exports.MsgUpdateParams = {
      typeUrl: "/cosmos.bank.v1beta1.MsgUpdateParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.authority !== "") {
          writer.uint32(10).string(message.authority);
        }
        if (message.params !== void 0) {
          bank_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.authority = reader.string();
              break;
            case 2:
              message.params = bank_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateParams();
        if ((0, helpers_1.isSet)(object.authority))
          obj.authority = String(object.authority);
        if ((0, helpers_1.isSet)(object.params))
          obj.params = bank_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.authority !== void 0 && (obj.authority = message.authority);
        message.params !== void 0 && (obj.params = message.params ? bank_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateParams();
        message.authority = object.authority ?? "";
        if (object.params !== void 0 && object.params !== null) {
          message.params = bank_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseMsgUpdateParamsResponse() {
      return {};
    }
    exports.MsgUpdateParamsResponse = {
      typeUrl: "/cosmos.bank.v1beta1.MsgUpdateParamsResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgUpdateParamsResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgUpdateParamsResponse();
        return message;
      }
    };
    function createBaseMsgSetSendEnabled() {
      return {
        authority: "",
        sendEnabled: [],
        useDefaultFor: []
      };
    }
    exports.MsgSetSendEnabled = {
      typeUrl: "/cosmos.bank.v1beta1.MsgSetSendEnabled",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.authority !== "") {
          writer.uint32(10).string(message.authority);
        }
        for (const v9 of message.sendEnabled) {
          bank_1.SendEnabled.encode(v9, writer.uint32(18).fork()).ldelim();
        }
        for (const v9 of message.useDefaultFor) {
          writer.uint32(26).string(v9);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSetSendEnabled();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.authority = reader.string();
              break;
            case 2:
              message.sendEnabled.push(bank_1.SendEnabled.decode(reader, reader.uint32()));
              break;
            case 3:
              message.useDefaultFor.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgSetSendEnabled();
        if ((0, helpers_1.isSet)(object.authority))
          obj.authority = String(object.authority);
        if (Array.isArray(object?.sendEnabled))
          obj.sendEnabled = object.sendEnabled.map((e) => bank_1.SendEnabled.fromJSON(e));
        if (Array.isArray(object?.useDefaultFor))
          obj.useDefaultFor = object.useDefaultFor.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.authority !== void 0 && (obj.authority = message.authority);
        if (message.sendEnabled) {
          obj.sendEnabled = message.sendEnabled.map((e) => e ? bank_1.SendEnabled.toJSON(e) : void 0);
        } else {
          obj.sendEnabled = [];
        }
        if (message.useDefaultFor) {
          obj.useDefaultFor = message.useDefaultFor.map((e) => e);
        } else {
          obj.useDefaultFor = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgSetSendEnabled();
        message.authority = object.authority ?? "";
        message.sendEnabled = object.sendEnabled?.map((e) => bank_1.SendEnabled.fromPartial(e)) || [];
        message.useDefaultFor = object.useDefaultFor?.map((e) => e) || [];
        return message;
      }
    };
    function createBaseMsgSetSendEnabledResponse() {
      return {};
    }
    exports.MsgSetSendEnabledResponse = {
      typeUrl: "/cosmos.bank.v1beta1.MsgSetSendEnabledResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSetSendEnabledResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgSetSendEnabledResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgSetSendEnabledResponse();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Send = this.Send.bind(this);
        this.MultiSend = this.MultiSend.bind(this);
        this.UpdateParams = this.UpdateParams.bind(this);
        this.SetSendEnabled = this.SetSendEnabled.bind(this);
      }
      Send(request) {
        const data2 = exports.MsgSend.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Msg", "Send", data2);
        return promise.then((data3) => exports.MsgSendResponse.decode(new binary_1.BinaryReader(data3)));
      }
      MultiSend(request) {
        const data2 = exports.MsgMultiSend.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Msg", "MultiSend", data2);
        return promise.then((data3) => exports.MsgMultiSendResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateParams(request) {
        const data2 = exports.MsgUpdateParams.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Msg", "UpdateParams", data2);
        return promise.then((data3) => exports.MsgUpdateParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      SetSendEnabled(request) {
        const data2 = exports.MsgSetSendEnabled.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Msg", "SetSendEnabled", data2);
        return promise.then((data3) => exports.MsgSetSendEnabledResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.MsgClientImpl = MsgClientImpl;
  }
});

// node_modules/.pnpm/@cosmjs+proto-signing@0.37.0/node_modules/@cosmjs/proto-signing/build/registry.js
var require_registry = __commonJS({
  "node_modules/.pnpm/@cosmjs+proto-signing@0.37.0/node_modules/@cosmjs/proto-signing/build/registry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Registry = void 0;
    exports.isTelescopeGeneratedType = isTelescopeGeneratedType;
    exports.isTsProtoGeneratedType = isTsProtoGeneratedType;
    exports.isPbjsGeneratedType = isPbjsGeneratedType;
    exports.isTxBodyEncodeObject = isTxBodyEncodeObject;
    var tx_1 = require_tx2();
    var coin_1 = require_coin();
    var tx_2 = require_tx();
    var any_1 = require_any();
    function isTelescopeGeneratedType(type) {
      const casted = type;
      return typeof casted.fromPartial === "function" && typeof casted.typeUrl == "string";
    }
    function isTsProtoGeneratedType(type) {
      return typeof type.fromPartial === "function";
    }
    function isPbjsGeneratedType(type) {
      return !isTsProtoGeneratedType(type);
    }
    var defaultTypeUrls = {
      cosmosCoin: "/cosmos.base.v1beta1.Coin",
      cosmosMsgSend: "/cosmos.bank.v1beta1.MsgSend",
      cosmosTxBody: "/cosmos.tx.v1beta1.TxBody",
      googleAny: "/google.protobuf.Any"
    };
    function isTxBodyEncodeObject(encodeObject) {
      return encodeObject.typeUrl === "/cosmos.tx.v1beta1.TxBody";
    }
    var Registry = class {
      types;
      /**
       * Creates a new Registry for mapping protobuf type identifiers/type URLs to
       * actual implementations. Those implementations are typically generated with ts-proto
       * but we also support protobuf.js as a type generator.
       *
       * If there is no parameter given, a `new Registry()` adds the types `Coin` and `MsgSend`
       * for historic reasons. Those can be overridden by customTypes.
       *
       * There are currently two methods for adding new types:
       * 1. Passing types to the constructor.
       * 2. Using the `register()` method
       */
      constructor(customTypes) {
        const { cosmosCoin, cosmosMsgSend } = defaultTypeUrls;
        this.types = customTypes ? new Map([...customTypes]) : /* @__PURE__ */ new Map([
          [cosmosCoin, coin_1.Coin],
          [cosmosMsgSend, tx_1.MsgSend]
        ]);
      }
      register(typeUrl, type) {
        this.types.set(typeUrl, type);
      }
      /**
       * Looks up a type that was previously added to the registry.
       *
       * The generator information (ts-proto or pbjs) gets lost along the way.
       * If you need to work with the result type in TypeScript, you can use:
       *
       * ```
       * import { assert } from "@cosmjs/utils";
       *
       * const Coin = registry.lookupType("/cosmos.base.v1beta1.Coin");
       * assert(Coin); // Ensures not unset
       * assert(isTsProtoGeneratedType(Coin)); // Ensures this is the type we expect
       *
       * // Coin is typed TsProtoGeneratedType now.
       * ```
       */
      lookupType(typeUrl) {
        return this.types.get(typeUrl);
      }
      lookupTypeWithError(typeUrl) {
        const type = this.lookupType(typeUrl);
        if (!type) {
          throw new Error(`Unregistered type url: ${typeUrl}`);
        }
        return type;
      }
      /**
       * Takes a typeUrl/value pair and encodes the value to protobuf if
       * the given type was previously registered.
       *
       * If the value has to be wrapped in an Any, this needs to be done
       * manually after this call. Or use `encodeAsAny` instead.
       */
      encode(encodeObject) {
        const { value, typeUrl } = encodeObject;
        if (isTxBodyEncodeObject(encodeObject)) {
          return this.encodeTxBody(value);
        }
        const type = this.lookupTypeWithError(typeUrl);
        const instance = isTelescopeGeneratedType(type) || isTsProtoGeneratedType(type) ? type.fromPartial(value) : type.create(value);
        return type.encode(instance).finish();
      }
      /**
       * Takes a typeUrl/value pair and encodes the value to an Any if
       * the given type was previously registered.
       */
      encodeAsAny(encodeObject) {
        const binaryValue = this.encode(encodeObject);
        return any_1.Any.fromPartial({
          typeUrl: encodeObject.typeUrl,
          value: binaryValue
        });
      }
      encodeTxBody(txBodyFields) {
        const wrappedMessages = txBodyFields.messages.map((message) => this.encodeAsAny(message));
        const txBody = tx_2.TxBody.fromPartial({
          ...txBodyFields,
          timeoutHeight: BigInt(txBodyFields.timeoutHeight?.toString() ?? "0"),
          messages: wrappedMessages
        });
        return tx_2.TxBody.encode(txBody).finish();
      }
      decode({ typeUrl, value }) {
        if (typeUrl === defaultTypeUrls.cosmosTxBody) {
          return this.decodeTxBody(value);
        }
        const type = this.lookupTypeWithError(typeUrl);
        const decoded = type.decode(value);
        Object.entries(decoded).forEach(([key, val]) => {
          if (typeof Buffer !== "undefined" && typeof Buffer.isBuffer !== "undefined" && Buffer.isBuffer(val)) {
            decoded[key] = Uint8Array.from(val);
          }
        });
        return decoded;
      }
      decodeTxBody(txBody) {
        const decodedTxBody = tx_2.TxBody.decode(txBody);
        return {
          ...decodedTxBody,
          messages: decodedTxBody.messages.map(({ typeUrl, value }) => {
            if (!typeUrl) {
              throw new Error("Missing type_url in Any");
            }
            if (!value) {
              throw new Error("Missing value in Any");
            }
            return this.decode({ typeUrl, value });
          })
        };
      }
    };
    exports.Registry = Registry;
  }
});

// node_modules/.pnpm/@cosmjs+proto-signing@0.37.0/node_modules/@cosmjs/proto-signing/build/signer.js
var require_signer = __commonJS({
  "node_modules/.pnpm/@cosmjs+proto-signing@0.37.0/node_modules/@cosmjs/proto-signing/build/signer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isOfflineDirectSigner = isOfflineDirectSigner;
    function isOfflineDirectSigner(signer) {
      return signer.signDirect !== void 0;
    }
  }
});

// node_modules/.pnpm/@cosmjs+proto-signing@0.37.0/node_modules/@cosmjs/proto-signing/build/index.js
var require_build6 = __commonJS({
  "node_modules/.pnpm/@cosmjs+proto-signing@0.37.0/node_modules/@cosmjs/proto-signing/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseCoins = exports.coins = exports.coin = exports.executeKdf = exports.makeSignDoc = exports.makeSignBytes = exports.makeAuthInfoBytes = exports.isOfflineDirectSigner = exports.Registry = exports.isTxBodyEncodeObject = exports.isTsProtoGeneratedType = exports.isPbjsGeneratedType = exports.encodePubkey = exports.decodePubkey = exports.decodeOptionalPubkey = exports.anyToSinglePubkey = exports.makeCosmoshubPath = exports.DirectSecp256k1Wallet = exports.extractKdfConfiguration = exports.DirectSecp256k1HdWallet = exports.decodeTxRaw = void 0;
    var decode_1 = require_decode();
    Object.defineProperty(exports, "decodeTxRaw", { enumerable: true, get: function() {
      return decode_1.decodeTxRaw;
    } });
    var directsecp256k1hdwallet_1 = require_directsecp256k1hdwallet();
    Object.defineProperty(exports, "DirectSecp256k1HdWallet", { enumerable: true, get: function() {
      return directsecp256k1hdwallet_1.DirectSecp256k1HdWallet;
    } });
    Object.defineProperty(exports, "extractKdfConfiguration", { enumerable: true, get: function() {
      return directsecp256k1hdwallet_1.extractKdfConfiguration;
    } });
    var directsecp256k1wallet_1 = require_directsecp256k1wallet();
    Object.defineProperty(exports, "DirectSecp256k1Wallet", { enumerable: true, get: function() {
      return directsecp256k1wallet_1.DirectSecp256k1Wallet;
    } });
    var paths_1 = require_paths2();
    Object.defineProperty(exports, "makeCosmoshubPath", { enumerable: true, get: function() {
      return paths_1.makeCosmoshubPath;
    } });
    var pubkey_1 = require_pubkey();
    Object.defineProperty(exports, "anyToSinglePubkey", { enumerable: true, get: function() {
      return pubkey_1.anyToSinglePubkey;
    } });
    Object.defineProperty(exports, "decodeOptionalPubkey", { enumerable: true, get: function() {
      return pubkey_1.decodeOptionalPubkey;
    } });
    Object.defineProperty(exports, "decodePubkey", { enumerable: true, get: function() {
      return pubkey_1.decodePubkey;
    } });
    Object.defineProperty(exports, "encodePubkey", { enumerable: true, get: function() {
      return pubkey_1.encodePubkey;
    } });
    var registry_1 = require_registry();
    Object.defineProperty(exports, "isPbjsGeneratedType", { enumerable: true, get: function() {
      return registry_1.isPbjsGeneratedType;
    } });
    Object.defineProperty(exports, "isTsProtoGeneratedType", { enumerable: true, get: function() {
      return registry_1.isTsProtoGeneratedType;
    } });
    Object.defineProperty(exports, "isTxBodyEncodeObject", { enumerable: true, get: function() {
      return registry_1.isTxBodyEncodeObject;
    } });
    Object.defineProperty(exports, "Registry", { enumerable: true, get: function() {
      return registry_1.Registry;
    } });
    var signer_1 = require_signer();
    Object.defineProperty(exports, "isOfflineDirectSigner", { enumerable: true, get: function() {
      return signer_1.isOfflineDirectSigner;
    } });
    var signing_1 = require_signing2();
    Object.defineProperty(exports, "makeAuthInfoBytes", { enumerable: true, get: function() {
      return signing_1.makeAuthInfoBytes;
    } });
    Object.defineProperty(exports, "makeSignBytes", { enumerable: true, get: function() {
      return signing_1.makeSignBytes;
    } });
    Object.defineProperty(exports, "makeSignDoc", { enumerable: true, get: function() {
      return signing_1.makeSignDoc;
    } });
    var wallet_1 = require_wallet2();
    Object.defineProperty(exports, "executeKdf", { enumerable: true, get: function() {
      return wallet_1.executeKdf;
    } });
    var amino_1 = require_build5();
    Object.defineProperty(exports, "coin", { enumerable: true, get: function() {
      return amino_1.coin;
    } });
    Object.defineProperty(exports, "coins", { enumerable: true, get: function() {
      return amino_1.coins;
    } });
    Object.defineProperty(exports, "parseCoins", { enumerable: true, get: function() {
      return amino_1.parseCoins;
    } });
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/auth/v1beta1/auth.js
var require_auth = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/auth/v1beta1/auth.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Params = exports.ModuleCredential = exports.ModuleAccount = exports.BaseAccount = exports.protobufPackage = void 0;
    var any_1 = require_any();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.auth.v1beta1";
    function createBaseBaseAccount() {
      return {
        address: "",
        pubKey: void 0,
        accountNumber: BigInt(0),
        sequence: BigInt(0)
      };
    }
    exports.BaseAccount = {
      typeUrl: "/cosmos.auth.v1beta1.BaseAccount",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.pubKey !== void 0) {
          any_1.Any.encode(message.pubKey, writer.uint32(18).fork()).ldelim();
        }
        if (message.accountNumber !== BigInt(0)) {
          writer.uint32(24).uint64(message.accountNumber);
        }
        if (message.sequence !== BigInt(0)) {
          writer.uint32(32).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBaseAccount();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.pubKey = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.accountNumber = reader.uint64();
              break;
            case 4:
              message.sequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBaseAccount();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.pubKey))
          obj.pubKey = any_1.Any.fromJSON(object.pubKey);
        if ((0, helpers_1.isSet)(object.accountNumber))
          obj.accountNumber = BigInt(object.accountNumber.toString());
        if ((0, helpers_1.isSet)(object.sequence))
          obj.sequence = BigInt(object.sequence.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.pubKey !== void 0 && (obj.pubKey = message.pubKey ? any_1.Any.toJSON(message.pubKey) : void 0);
        message.accountNumber !== void 0 && (obj.accountNumber = (message.accountNumber || BigInt(0)).toString());
        message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBaseAccount();
        message.address = object.address ?? "";
        if (object.pubKey !== void 0 && object.pubKey !== null) {
          message.pubKey = any_1.Any.fromPartial(object.pubKey);
        }
        if (object.accountNumber !== void 0 && object.accountNumber !== null) {
          message.accountNumber = BigInt(object.accountNumber.toString());
        }
        if (object.sequence !== void 0 && object.sequence !== null) {
          message.sequence = BigInt(object.sequence.toString());
        }
        return message;
      }
    };
    function createBaseModuleAccount() {
      return {
        baseAccount: void 0,
        name: "",
        permissions: []
      };
    }
    exports.ModuleAccount = {
      typeUrl: "/cosmos.auth.v1beta1.ModuleAccount",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.baseAccount !== void 0) {
          exports.BaseAccount.encode(message.baseAccount, writer.uint32(10).fork()).ldelim();
        }
        if (message.name !== "") {
          writer.uint32(18).string(message.name);
        }
        for (const v9 of message.permissions) {
          writer.uint32(26).string(v9);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseModuleAccount();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.baseAccount = exports.BaseAccount.decode(reader, reader.uint32());
              break;
            case 2:
              message.name = reader.string();
              break;
            case 3:
              message.permissions.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseModuleAccount();
        if ((0, helpers_1.isSet)(object.baseAccount))
          obj.baseAccount = exports.BaseAccount.fromJSON(object.baseAccount);
        if ((0, helpers_1.isSet)(object.name))
          obj.name = String(object.name);
        if (Array.isArray(object?.permissions))
          obj.permissions = object.permissions.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.baseAccount !== void 0 && (obj.baseAccount = message.baseAccount ? exports.BaseAccount.toJSON(message.baseAccount) : void 0);
        message.name !== void 0 && (obj.name = message.name);
        if (message.permissions) {
          obj.permissions = message.permissions.map((e) => e);
        } else {
          obj.permissions = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseModuleAccount();
        if (object.baseAccount !== void 0 && object.baseAccount !== null) {
          message.baseAccount = exports.BaseAccount.fromPartial(object.baseAccount);
        }
        message.name = object.name ?? "";
        message.permissions = object.permissions?.map((e) => e) || [];
        return message;
      }
    };
    function createBaseModuleCredential() {
      return {
        moduleName: "",
        derivationKeys: []
      };
    }
    exports.ModuleCredential = {
      typeUrl: "/cosmos.auth.v1beta1.ModuleCredential",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.moduleName !== "") {
          writer.uint32(10).string(message.moduleName);
        }
        for (const v9 of message.derivationKeys) {
          writer.uint32(18).bytes(v9);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseModuleCredential();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.moduleName = reader.string();
              break;
            case 2:
              message.derivationKeys.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseModuleCredential();
        if ((0, helpers_1.isSet)(object.moduleName))
          obj.moduleName = String(object.moduleName);
        if (Array.isArray(object?.derivationKeys))
          obj.derivationKeys = object.derivationKeys.map((e) => (0, helpers_1.bytesFromBase64)(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.moduleName !== void 0 && (obj.moduleName = message.moduleName);
        if (message.derivationKeys) {
          obj.derivationKeys = message.derivationKeys.map((e) => (0, helpers_1.base64FromBytes)(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.derivationKeys = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseModuleCredential();
        message.moduleName = object.moduleName ?? "";
        message.derivationKeys = object.derivationKeys?.map((e) => e) || [];
        return message;
      }
    };
    function createBaseParams() {
      return {
        maxMemoCharacters: BigInt(0),
        txSigLimit: BigInt(0),
        txSizeCostPerByte: BigInt(0),
        sigVerifyCostEd25519: BigInt(0),
        sigVerifyCostSecp256k1: BigInt(0)
      };
    }
    exports.Params = {
      typeUrl: "/cosmos.auth.v1beta1.Params",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.maxMemoCharacters !== BigInt(0)) {
          writer.uint32(8).uint64(message.maxMemoCharacters);
        }
        if (message.txSigLimit !== BigInt(0)) {
          writer.uint32(16).uint64(message.txSigLimit);
        }
        if (message.txSizeCostPerByte !== BigInt(0)) {
          writer.uint32(24).uint64(message.txSizeCostPerByte);
        }
        if (message.sigVerifyCostEd25519 !== BigInt(0)) {
          writer.uint32(32).uint64(message.sigVerifyCostEd25519);
        }
        if (message.sigVerifyCostSecp256k1 !== BigInt(0)) {
          writer.uint32(40).uint64(message.sigVerifyCostSecp256k1);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.maxMemoCharacters = reader.uint64();
              break;
            case 2:
              message.txSigLimit = reader.uint64();
              break;
            case 3:
              message.txSizeCostPerByte = reader.uint64();
              break;
            case 4:
              message.sigVerifyCostEd25519 = reader.uint64();
              break;
            case 5:
              message.sigVerifyCostSecp256k1 = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseParams();
        if ((0, helpers_1.isSet)(object.maxMemoCharacters))
          obj.maxMemoCharacters = BigInt(object.maxMemoCharacters.toString());
        if ((0, helpers_1.isSet)(object.txSigLimit))
          obj.txSigLimit = BigInt(object.txSigLimit.toString());
        if ((0, helpers_1.isSet)(object.txSizeCostPerByte))
          obj.txSizeCostPerByte = BigInt(object.txSizeCostPerByte.toString());
        if ((0, helpers_1.isSet)(object.sigVerifyCostEd25519))
          obj.sigVerifyCostEd25519 = BigInt(object.sigVerifyCostEd25519.toString());
        if ((0, helpers_1.isSet)(object.sigVerifyCostSecp256k1))
          obj.sigVerifyCostSecp256k1 = BigInt(object.sigVerifyCostSecp256k1.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.maxMemoCharacters !== void 0 && (obj.maxMemoCharacters = (message.maxMemoCharacters || BigInt(0)).toString());
        message.txSigLimit !== void 0 && (obj.txSigLimit = (message.txSigLimit || BigInt(0)).toString());
        message.txSizeCostPerByte !== void 0 && (obj.txSizeCostPerByte = (message.txSizeCostPerByte || BigInt(0)).toString());
        message.sigVerifyCostEd25519 !== void 0 && (obj.sigVerifyCostEd25519 = (message.sigVerifyCostEd25519 || BigInt(0)).toString());
        message.sigVerifyCostSecp256k1 !== void 0 && (obj.sigVerifyCostSecp256k1 = (message.sigVerifyCostSecp256k1 || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseParams();
        if (object.maxMemoCharacters !== void 0 && object.maxMemoCharacters !== null) {
          message.maxMemoCharacters = BigInt(object.maxMemoCharacters.toString());
        }
        if (object.txSigLimit !== void 0 && object.txSigLimit !== null) {
          message.txSigLimit = BigInt(object.txSigLimit.toString());
        }
        if (object.txSizeCostPerByte !== void 0 && object.txSizeCostPerByte !== null) {
          message.txSizeCostPerByte = BigInt(object.txSizeCostPerByte.toString());
        }
        if (object.sigVerifyCostEd25519 !== void 0 && object.sigVerifyCostEd25519 !== null) {
          message.sigVerifyCostEd25519 = BigInt(object.sigVerifyCostEd25519.toString());
        }
        if (object.sigVerifyCostSecp256k1 !== void 0 && object.sigVerifyCostSecp256k1 !== null) {
          message.sigVerifyCostSecp256k1 = BigInt(object.sigVerifyCostSecp256k1.toString());
        }
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/vesting/v1beta1/vesting.js
var require_vesting = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/vesting/v1beta1/vesting.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PermanentLockedAccount = exports.PeriodicVestingAccount = exports.Period = exports.DelayedVestingAccount = exports.ContinuousVestingAccount = exports.BaseVestingAccount = exports.protobufPackage = void 0;
    var auth_1 = require_auth();
    var coin_1 = require_coin();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.vesting.v1beta1";
    function createBaseBaseVestingAccount() {
      return {
        baseAccount: void 0,
        originalVesting: [],
        delegatedFree: [],
        delegatedVesting: [],
        endTime: BigInt(0)
      };
    }
    exports.BaseVestingAccount = {
      typeUrl: "/cosmos.vesting.v1beta1.BaseVestingAccount",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.baseAccount !== void 0) {
          auth_1.BaseAccount.encode(message.baseAccount, writer.uint32(10).fork()).ldelim();
        }
        for (const v9 of message.originalVesting) {
          coin_1.Coin.encode(v9, writer.uint32(18).fork()).ldelim();
        }
        for (const v9 of message.delegatedFree) {
          coin_1.Coin.encode(v9, writer.uint32(26).fork()).ldelim();
        }
        for (const v9 of message.delegatedVesting) {
          coin_1.Coin.encode(v9, writer.uint32(34).fork()).ldelim();
        }
        if (message.endTime !== BigInt(0)) {
          writer.uint32(40).int64(message.endTime);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBaseVestingAccount();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.baseAccount = auth_1.BaseAccount.decode(reader, reader.uint32());
              break;
            case 2:
              message.originalVesting.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 3:
              message.delegatedFree.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 4:
              message.delegatedVesting.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 5:
              message.endTime = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBaseVestingAccount();
        if ((0, helpers_1.isSet)(object.baseAccount))
          obj.baseAccount = auth_1.BaseAccount.fromJSON(object.baseAccount);
        if (Array.isArray(object?.originalVesting))
          obj.originalVesting = object.originalVesting.map((e) => coin_1.Coin.fromJSON(e));
        if (Array.isArray(object?.delegatedFree))
          obj.delegatedFree = object.delegatedFree.map((e) => coin_1.Coin.fromJSON(e));
        if (Array.isArray(object?.delegatedVesting))
          obj.delegatedVesting = object.delegatedVesting.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.endTime))
          obj.endTime = BigInt(object.endTime.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.baseAccount !== void 0 && (obj.baseAccount = message.baseAccount ? auth_1.BaseAccount.toJSON(message.baseAccount) : void 0);
        if (message.originalVesting) {
          obj.originalVesting = message.originalVesting.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.originalVesting = [];
        }
        if (message.delegatedFree) {
          obj.delegatedFree = message.delegatedFree.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.delegatedFree = [];
        }
        if (message.delegatedVesting) {
          obj.delegatedVesting = message.delegatedVesting.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.delegatedVesting = [];
        }
        message.endTime !== void 0 && (obj.endTime = (message.endTime || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBaseVestingAccount();
        if (object.baseAccount !== void 0 && object.baseAccount !== null) {
          message.baseAccount = auth_1.BaseAccount.fromPartial(object.baseAccount);
        }
        message.originalVesting = object.originalVesting?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        message.delegatedFree = object.delegatedFree?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        message.delegatedVesting = object.delegatedVesting?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        if (object.endTime !== void 0 && object.endTime !== null) {
          message.endTime = BigInt(object.endTime.toString());
        }
        return message;
      }
    };
    function createBaseContinuousVestingAccount() {
      return {
        baseVestingAccount: void 0,
        startTime: BigInt(0)
      };
    }
    exports.ContinuousVestingAccount = {
      typeUrl: "/cosmos.vesting.v1beta1.ContinuousVestingAccount",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.baseVestingAccount !== void 0) {
          exports.BaseVestingAccount.encode(message.baseVestingAccount, writer.uint32(10).fork()).ldelim();
        }
        if (message.startTime !== BigInt(0)) {
          writer.uint32(16).int64(message.startTime);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseContinuousVestingAccount();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.baseVestingAccount = exports.BaseVestingAccount.decode(reader, reader.uint32());
              break;
            case 2:
              message.startTime = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseContinuousVestingAccount();
        if ((0, helpers_1.isSet)(object.baseVestingAccount))
          obj.baseVestingAccount = exports.BaseVestingAccount.fromJSON(object.baseVestingAccount);
        if ((0, helpers_1.isSet)(object.startTime))
          obj.startTime = BigInt(object.startTime.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.baseVestingAccount !== void 0 && (obj.baseVestingAccount = message.baseVestingAccount ? exports.BaseVestingAccount.toJSON(message.baseVestingAccount) : void 0);
        message.startTime !== void 0 && (obj.startTime = (message.startTime || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseContinuousVestingAccount();
        if (object.baseVestingAccount !== void 0 && object.baseVestingAccount !== null) {
          message.baseVestingAccount = exports.BaseVestingAccount.fromPartial(object.baseVestingAccount);
        }
        if (object.startTime !== void 0 && object.startTime !== null) {
          message.startTime = BigInt(object.startTime.toString());
        }
        return message;
      }
    };
    function createBaseDelayedVestingAccount() {
      return {
        baseVestingAccount: void 0
      };
    }
    exports.DelayedVestingAccount = {
      typeUrl: "/cosmos.vesting.v1beta1.DelayedVestingAccount",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.baseVestingAccount !== void 0) {
          exports.BaseVestingAccount.encode(message.baseVestingAccount, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDelayedVestingAccount();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.baseVestingAccount = exports.BaseVestingAccount.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDelayedVestingAccount();
        if ((0, helpers_1.isSet)(object.baseVestingAccount))
          obj.baseVestingAccount = exports.BaseVestingAccount.fromJSON(object.baseVestingAccount);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.baseVestingAccount !== void 0 && (obj.baseVestingAccount = message.baseVestingAccount ? exports.BaseVestingAccount.toJSON(message.baseVestingAccount) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDelayedVestingAccount();
        if (object.baseVestingAccount !== void 0 && object.baseVestingAccount !== null) {
          message.baseVestingAccount = exports.BaseVestingAccount.fromPartial(object.baseVestingAccount);
        }
        return message;
      }
    };
    function createBasePeriod() {
      return {
        length: BigInt(0),
        amount: []
      };
    }
    exports.Period = {
      typeUrl: "/cosmos.vesting.v1beta1.Period",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.length !== BigInt(0)) {
          writer.uint32(8).int64(message.length);
        }
        for (const v9 of message.amount) {
          coin_1.Coin.encode(v9, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePeriod();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.length = reader.int64();
              break;
            case 2:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePeriod();
        if ((0, helpers_1.isSet)(object.length))
          obj.length = BigInt(object.length.toString());
        if (Array.isArray(object?.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.length !== void 0 && (obj.length = (message.length || BigInt(0)).toString());
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBasePeriod();
        if (object.length !== void 0 && object.length !== null) {
          message.length = BigInt(object.length.toString());
        }
        message.amount = object.amount?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        return message;
      }
    };
    function createBasePeriodicVestingAccount() {
      return {
        baseVestingAccount: void 0,
        startTime: BigInt(0),
        vestingPeriods: []
      };
    }
    exports.PeriodicVestingAccount = {
      typeUrl: "/cosmos.vesting.v1beta1.PeriodicVestingAccount",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.baseVestingAccount !== void 0) {
          exports.BaseVestingAccount.encode(message.baseVestingAccount, writer.uint32(10).fork()).ldelim();
        }
        if (message.startTime !== BigInt(0)) {
          writer.uint32(16).int64(message.startTime);
        }
        for (const v9 of message.vestingPeriods) {
          exports.Period.encode(v9, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePeriodicVestingAccount();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.baseVestingAccount = exports.BaseVestingAccount.decode(reader, reader.uint32());
              break;
            case 2:
              message.startTime = reader.int64();
              break;
            case 3:
              message.vestingPeriods.push(exports.Period.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePeriodicVestingAccount();
        if ((0, helpers_1.isSet)(object.baseVestingAccount))
          obj.baseVestingAccount = exports.BaseVestingAccount.fromJSON(object.baseVestingAccount);
        if ((0, helpers_1.isSet)(object.startTime))
          obj.startTime = BigInt(object.startTime.toString());
        if (Array.isArray(object?.vestingPeriods))
          obj.vestingPeriods = object.vestingPeriods.map((e) => exports.Period.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.baseVestingAccount !== void 0 && (obj.baseVestingAccount = message.baseVestingAccount ? exports.BaseVestingAccount.toJSON(message.baseVestingAccount) : void 0);
        message.startTime !== void 0 && (obj.startTime = (message.startTime || BigInt(0)).toString());
        if (message.vestingPeriods) {
          obj.vestingPeriods = message.vestingPeriods.map((e) => e ? exports.Period.toJSON(e) : void 0);
        } else {
          obj.vestingPeriods = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBasePeriodicVestingAccount();
        if (object.baseVestingAccount !== void 0 && object.baseVestingAccount !== null) {
          message.baseVestingAccount = exports.BaseVestingAccount.fromPartial(object.baseVestingAccount);
        }
        if (object.startTime !== void 0 && object.startTime !== null) {
          message.startTime = BigInt(object.startTime.toString());
        }
        message.vestingPeriods = object.vestingPeriods?.map((e) => exports.Period.fromPartial(e)) || [];
        return message;
      }
    };
    function createBasePermanentLockedAccount() {
      return {
        baseVestingAccount: void 0
      };
    }
    exports.PermanentLockedAccount = {
      typeUrl: "/cosmos.vesting.v1beta1.PermanentLockedAccount",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.baseVestingAccount !== void 0) {
          exports.BaseVestingAccount.encode(message.baseVestingAccount, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePermanentLockedAccount();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.baseVestingAccount = exports.BaseVestingAccount.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePermanentLockedAccount();
        if ((0, helpers_1.isSet)(object.baseVestingAccount))
          obj.baseVestingAccount = exports.BaseVestingAccount.fromJSON(object.baseVestingAccount);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.baseVestingAccount !== void 0 && (obj.baseVestingAccount = message.baseVestingAccount ? exports.BaseVestingAccount.toJSON(message.baseVestingAccount) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBasePermanentLockedAccount();
        if (object.baseVestingAccount !== void 0 && object.baseVestingAccount !== null) {
          message.baseVestingAccount = exports.BaseVestingAccount.fromPartial(object.baseVestingAccount);
        }
        return message;
      }
    };
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/accounts.js
var require_accounts = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/accounts.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.accountFromAny = accountFromAny;
    var math_1 = require_build3();
    var proto_signing_1 = require_build6();
    var utils_1 = require_build();
    var auth_1 = require_auth();
    var vesting_1 = require_vesting();
    function uint64FromProto(input) {
      return math_1.Uint64.fromString(input.toString());
    }
    function accountFromBaseAccount(input) {
      const { address, pubKey, accountNumber, sequence } = input;
      const pubkey = (0, proto_signing_1.decodeOptionalPubkey)(pubKey);
      return {
        address,
        pubkey,
        accountNumber: uint64FromProto(accountNumber).toNumber(),
        sequence: uint64FromProto(sequence).toNumber()
      };
    }
    function accountFromAny(input) {
      const { typeUrl, value } = input;
      switch (typeUrl) {
        // auth
        case "/cosmos.auth.v1beta1.BaseAccount":
          return accountFromBaseAccount(auth_1.BaseAccount.decode(value));
        case "/cosmos.auth.v1beta1.ModuleAccount": {
          const baseAccount = auth_1.ModuleAccount.decode(value).baseAccount;
          (0, utils_1.assert)(baseAccount);
          return accountFromBaseAccount(baseAccount);
        }
        // vesting
        case "/cosmos.vesting.v1beta1.BaseVestingAccount": {
          const baseAccount = vesting_1.BaseVestingAccount.decode(value)?.baseAccount;
          (0, utils_1.assert)(baseAccount);
          return accountFromBaseAccount(baseAccount);
        }
        case "/cosmos.vesting.v1beta1.ContinuousVestingAccount": {
          const baseAccount = vesting_1.ContinuousVestingAccount.decode(value)?.baseVestingAccount?.baseAccount;
          (0, utils_1.assert)(baseAccount);
          return accountFromBaseAccount(baseAccount);
        }
        case "/cosmos.vesting.v1beta1.DelayedVestingAccount": {
          const baseAccount = vesting_1.DelayedVestingAccount.decode(value)?.baseVestingAccount?.baseAccount;
          (0, utils_1.assert)(baseAccount);
          return accountFromBaseAccount(baseAccount);
        }
        case "/cosmos.vesting.v1beta1.PeriodicVestingAccount": {
          const baseAccount = vesting_1.PeriodicVestingAccount.decode(value)?.baseVestingAccount?.baseAccount;
          (0, utils_1.assert)(baseAccount);
          return accountFromBaseAccount(baseAccount);
        }
        default:
          throw new Error(`Unsupported type: '${typeUrl}'`);
      }
    }
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/aminotypes.js
var require_aminotypes = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/aminotypes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AminoTypes = void 0;
    var AminoTypes = class {
      // The map type here ensures uniqueness of the protobuf type URL in the key.
      // There is no uniqueness guarantee of the Amino type identifier in the type
      // system or constructor. Instead it's the user's responsibility to ensure
      // there is no overlap when fromAmino is called.
      register;
      constructor(types) {
        this.register = types;
      }
      toAmino({ typeUrl, value }) {
        const converter = this.register[typeUrl];
        if (!converter) {
          throw new Error(`Type URL '${typeUrl}' does not exist in the Amino message type register. If you need support for this message type, you can pass in additional entries to the AminoTypes constructor. If you think this message type should be included by default, please open an issue at https://github.com/cosmos/cosmjs/issues.`);
        }
        return {
          type: converter.aminoType,
          value: converter.toAmino(value)
        };
      }
      fromAmino({ type, value }) {
        const matches = Object.entries(this.register).filter(([_typeUrl, { aminoType }]) => aminoType === type);
        switch (matches.length) {
          case 0: {
            throw new Error(`Amino type identifier '${type}' does not exist in the Amino message type register. If you need support for this message type, you can pass in additional entries to the AminoTypes constructor. If you think this message type should be included by default, please open an issue at https://github.com/cosmos/cosmjs/issues.`);
          }
          case 1: {
            const [typeUrl, converter] = matches[0];
            return {
              typeUrl,
              value: converter.fromAmino(value)
            };
          }
          default:
            throw new Error(`Multiple types are registered with Amino type identifier '${type}': '` + matches.map(([key, _value]) => key).sort().join("', '") + "'. Thus fromAmino cannot be performed.");
        }
      }
    };
    exports.AminoTypes = AminoTypes;
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/events.js
var require_events2 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/events.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromTendermintEvent = fromTendermintEvent;
    var encoding_1 = require_build2();
    function fromTendermintEvent(event) {
      return {
        type: event.type,
        attributes: event.attributes.map((attr) => ({
          key: typeof attr.key == "string" ? attr.key : (0, encoding_1.fromUtf8)(attr.key, true),
          value: typeof attr.value == "string" ? attr.value : (0, encoding_1.fromUtf8)(attr.value, true)
        }))
      };
    }
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/fee.js
var require_fee = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/fee.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GasPrice = void 0;
    exports.calculateFee = calculateFee;
    var math_1 = require_build3();
    var proto_signing_1 = require_build6();
    function checkDenom(denom) {
      if (denom.length < 3 || denom.length > 128) {
        throw new Error("Denom must be between 3 and 128 characters");
      }
    }
    var GasPrice = class _GasPrice {
      amount;
      denom;
      constructor(amount, denom) {
        if (!denom) {
          throw new Error("denom must not be empty");
        }
        this.amount = amount;
        this.denom = denom;
      }
      /**
       * Parses a gas price formatted as `<amount><denom>`, e.g. `GasPrice.fromString("0.012utoken")`.
       *
       * The denom must match the Cosmos SDK 0.53 pattern (https://github.com/cosmos/cosmos-sdk/blob/v0.53.0/types/coin.go#L846).
       * See `GasPrice` in @cosmjs/stargate for a more generic matcher.
       *
       * Separators are not yet supported.
       */
      static fromString(gasPrice) {
        const matchResult = gasPrice.match(/^([0-9.]+)([a-zA-Z][a-zA-Z0-9/:._-]*)$/);
        if (!matchResult) {
          throw new Error("Invalid gas price string");
        }
        const [_2, amount, denom] = matchResult;
        checkDenom(denom);
        const fractionalDigits = 18;
        const decimalAmount = math_1.Decimal.fromUserInput(amount, fractionalDigits);
        return new _GasPrice(decimalAmount, denom);
      }
      /**
       * Returns a string representation of this gas price, e.g. "0.025uatom".
       * This can be used as an input to `GasPrice.fromString`.
       */
      toString() {
        return this.amount.toString() + this.denom;
      }
    };
    exports.GasPrice = GasPrice;
    function calculateFee(gasLimit, gasPrice) {
      const processedGasPrice = typeof gasPrice === "string" ? GasPrice.fromString(gasPrice) : gasPrice;
      const { denom, amount: gasPriceAmount } = processedGasPrice;
      const amount = gasPriceAmount.multiply(new math_1.Uint53(gasLimit)).ceil().toString();
      return {
        amount: (0, proto_signing_1.coins)(amount, denom),
        gas: gasLimit.toString()
      };
    }
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/logs.js
var require_logs = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/logs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseAttribute = parseAttribute;
    exports.parseEvent = parseEvent;
    exports.parseLog = parseLog;
    exports.parseLogs = parseLogs;
    exports.parseRawLog = parseRawLog;
    exports.findAttribute = findAttribute;
    var utils_1 = require_build();
    function parseAttribute(input) {
      if (!(0, utils_1.isNonNullObject)(input))
        throw new Error("Attribute must be a non-null object");
      const { key, value } = input;
      if (typeof key !== "string" || !key)
        throw new Error("Attribute's key must be a non-empty string");
      if (typeof value !== "string" && typeof value !== "undefined") {
        throw new Error("Attribute's value must be a string or unset");
      }
      return {
        key,
        value: value || ""
      };
    }
    function parseEvent(input) {
      if (!(0, utils_1.isNonNullObject)(input))
        throw new Error("Event must be a non-null object");
      const { type, attributes } = input;
      if (typeof type !== "string" || type === "") {
        throw new Error(`Event type must be a non-empty string`);
      }
      if (!Array.isArray(attributes))
        throw new Error("Event's attributes must be an array");
      return {
        type,
        attributes: attributes.map(parseAttribute)
      };
    }
    function parseLog(input) {
      if (!(0, utils_1.isNonNullObject)(input))
        throw new Error("Log must be a non-null object");
      const { msg_index, log, events } = input;
      if (typeof msg_index !== "number")
        throw new Error("Log's msg_index must be a number");
      if (typeof log !== "string")
        throw new Error("Log's log must be a string");
      if (!Array.isArray(events))
        throw new Error("Log's events must be an array");
      return {
        msg_index,
        log,
        events: events.map(parseEvent)
      };
    }
    function parseLogs(input) {
      if (!Array.isArray(input))
        throw new Error("Logs must be an array");
      return input.map(parseLog);
    }
    function parseRawLog(input) {
      if (!input)
        return [];
      const logsToParse = JSON.parse(input).map(({ events }, i3) => ({
        msg_index: i3,
        events,
        log: ""
      }));
      return parseLogs(logsToParse);
    }
    function findAttribute(logs, eventType, attrKey) {
      const firstLogs = logs.find(() => true);
      const out = firstLogs?.events.find((event) => event.type === eventType)?.attributes.find((attr) => attr.key === attrKey);
      if (!out) {
        throw new Error(`Could not find attribute '${attrKey}' in first event of type '${eventType}' in first log.`);
      }
      return out;
    }
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/base/query/v1beta1/pagination.js
var require_pagination = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/base/query/v1beta1/pagination.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PageResponse = exports.PageRequest = exports.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.base.query.v1beta1";
    function createBasePageRequest() {
      return {
        key: new Uint8Array(),
        offset: BigInt(0),
        limit: BigInt(0),
        countTotal: false,
        reverse: false
      };
    }
    exports.PageRequest = {
      typeUrl: "/cosmos.base.query.v1beta1.PageRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        if (message.offset !== BigInt(0)) {
          writer.uint32(16).uint64(message.offset);
        }
        if (message.limit !== BigInt(0)) {
          writer.uint32(24).uint64(message.limit);
        }
        if (message.countTotal === true) {
          writer.uint32(32).bool(message.countTotal);
        }
        if (message.reverse === true) {
          writer.uint32(40).bool(message.reverse);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePageRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            case 2:
              message.offset = reader.uint64();
              break;
            case 3:
              message.limit = reader.uint64();
              break;
            case 4:
              message.countTotal = reader.bool();
              break;
            case 5:
              message.reverse = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePageRequest();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        if ((0, helpers_1.isSet)(object.offset))
          obj.offset = BigInt(object.offset.toString());
        if ((0, helpers_1.isSet)(object.limit))
          obj.limit = BigInt(object.limit.toString());
        if ((0, helpers_1.isSet)(object.countTotal))
          obj.countTotal = Boolean(object.countTotal);
        if ((0, helpers_1.isSet)(object.reverse))
          obj.reverse = Boolean(object.reverse);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        message.offset !== void 0 && (obj.offset = (message.offset || BigInt(0)).toString());
        message.limit !== void 0 && (obj.limit = (message.limit || BigInt(0)).toString());
        message.countTotal !== void 0 && (obj.countTotal = message.countTotal);
        message.reverse !== void 0 && (obj.reverse = message.reverse);
        return obj;
      },
      fromPartial(object) {
        const message = createBasePageRequest();
        message.key = object.key ?? new Uint8Array();
        if (object.offset !== void 0 && object.offset !== null) {
          message.offset = BigInt(object.offset.toString());
        }
        if (object.limit !== void 0 && object.limit !== null) {
          message.limit = BigInt(object.limit.toString());
        }
        message.countTotal = object.countTotal ?? false;
        message.reverse = object.reverse ?? false;
        return message;
      }
    };
    function createBasePageResponse() {
      return {
        nextKey: new Uint8Array(),
        total: BigInt(0)
      };
    }
    exports.PageResponse = {
      typeUrl: "/cosmos.base.query.v1beta1.PageResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.nextKey.length !== 0) {
          writer.uint32(10).bytes(message.nextKey);
        }
        if (message.total !== BigInt(0)) {
          writer.uint32(16).uint64(message.total);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePageResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.nextKey = reader.bytes();
              break;
            case 2:
              message.total = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePageResponse();
        if ((0, helpers_1.isSet)(object.nextKey))
          obj.nextKey = (0, helpers_1.bytesFromBase64)(object.nextKey);
        if ((0, helpers_1.isSet)(object.total))
          obj.total = BigInt(object.total.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.nextKey !== void 0 && (obj.nextKey = (0, helpers_1.base64FromBytes)(message.nextKey !== void 0 ? message.nextKey : new Uint8Array()));
        message.total !== void 0 && (obj.total = (message.total || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBasePageResponse();
        message.nextKey = object.nextKey ?? new Uint8Array();
        if (object.total !== void 0 && object.total !== null) {
          message.total = BigInt(object.total.toString());
        }
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/auth/v1beta1/query.js
var require_query = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/auth/v1beta1/query.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryClientImpl = exports.QueryAccountInfoResponse = exports.QueryAccountInfoRequest = exports.QueryAccountAddressByIDResponse = exports.QueryAccountAddressByIDRequest = exports.AddressStringToBytesResponse = exports.AddressStringToBytesRequest = exports.AddressBytesToStringResponse = exports.AddressBytesToStringRequest = exports.Bech32PrefixResponse = exports.Bech32PrefixRequest = exports.QueryModuleAccountByNameResponse = exports.QueryModuleAccountByNameRequest = exports.QueryModuleAccountsResponse = exports.QueryModuleAccountsRequest = exports.QueryParamsResponse = exports.QueryParamsRequest = exports.QueryAccountResponse = exports.QueryAccountRequest = exports.QueryAccountsResponse = exports.QueryAccountsRequest = exports.protobufPackage = void 0;
    var pagination_1 = require_pagination();
    var any_1 = require_any();
    var auth_1 = require_auth();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.auth.v1beta1";
    function createBaseQueryAccountsRequest() {
      return {
        pagination: void 0
      };
    }
    exports.QueryAccountsRequest = {
      typeUrl: "/cosmos.auth.v1beta1.QueryAccountsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAccountsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAccountsRequest();
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAccountsRequest();
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryAccountsResponse() {
      return {
        accounts: [],
        pagination: void 0
      };
    }
    exports.QueryAccountsResponse = {
      typeUrl: "/cosmos.auth.v1beta1.QueryAccountsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.accounts) {
          any_1.Any.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAccountsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.accounts.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAccountsResponse();
        if (Array.isArray(object?.accounts))
          obj.accounts = object.accounts.map((e) => any_1.Any.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.accounts) {
          obj.accounts = message.accounts.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.accounts = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAccountsResponse();
        message.accounts = object.accounts?.map((e) => any_1.Any.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryAccountRequest() {
      return {
        address: ""
      };
    }
    exports.QueryAccountRequest = {
      typeUrl: "/cosmos.auth.v1beta1.QueryAccountRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAccountRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAccountRequest();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAccountRequest();
        message.address = object.address ?? "";
        return message;
      }
    };
    function createBaseQueryAccountResponse() {
      return {
        account: void 0
      };
    }
    exports.QueryAccountResponse = {
      typeUrl: "/cosmos.auth.v1beta1.QueryAccountResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.account !== void 0) {
          any_1.Any.encode(message.account, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAccountResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.account = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAccountResponse();
        if ((0, helpers_1.isSet)(object.account))
          obj.account = any_1.Any.fromJSON(object.account);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.account !== void 0 && (obj.account = message.account ? any_1.Any.toJSON(message.account) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAccountResponse();
        if (object.account !== void 0 && object.account !== null) {
          message.account = any_1.Any.fromPartial(object.account);
        }
        return message;
      }
    };
    function createBaseQueryParamsRequest() {
      return {};
    }
    exports.QueryParamsRequest = {
      typeUrl: "/cosmos.auth.v1beta1.QueryParamsRequest",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseQueryParamsRequest();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseQueryParamsRequest();
        return message;
      }
    };
    function createBaseQueryParamsResponse() {
      return {
        params: auth_1.Params.fromPartial({})
      };
    }
    exports.QueryParamsResponse = {
      typeUrl: "/cosmos.auth.v1beta1.QueryParamsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== void 0) {
          auth_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = auth_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryParamsResponse();
        if ((0, helpers_1.isSet)(object.params))
          obj.params = auth_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? auth_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryParamsResponse();
        if (object.params !== void 0 && object.params !== null) {
          message.params = auth_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseQueryModuleAccountsRequest() {
      return {};
    }
    exports.QueryModuleAccountsRequest = {
      typeUrl: "/cosmos.auth.v1beta1.QueryModuleAccountsRequest",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryModuleAccountsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseQueryModuleAccountsRequest();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseQueryModuleAccountsRequest();
        return message;
      }
    };
    function createBaseQueryModuleAccountsResponse() {
      return {
        accounts: []
      };
    }
    exports.QueryModuleAccountsResponse = {
      typeUrl: "/cosmos.auth.v1beta1.QueryModuleAccountsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.accounts) {
          any_1.Any.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryModuleAccountsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.accounts.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryModuleAccountsResponse();
        if (Array.isArray(object?.accounts))
          obj.accounts = object.accounts.map((e) => any_1.Any.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.accounts) {
          obj.accounts = message.accounts.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.accounts = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryModuleAccountsResponse();
        message.accounts = object.accounts?.map((e) => any_1.Any.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseQueryModuleAccountByNameRequest() {
      return {
        name: ""
      };
    }
    exports.QueryModuleAccountByNameRequest = {
      typeUrl: "/cosmos.auth.v1beta1.QueryModuleAccountByNameRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.name !== "") {
          writer.uint32(10).string(message.name);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryModuleAccountByNameRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.name = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryModuleAccountByNameRequest();
        if ((0, helpers_1.isSet)(object.name))
          obj.name = String(object.name);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.name !== void 0 && (obj.name = message.name);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryModuleAccountByNameRequest();
        message.name = object.name ?? "";
        return message;
      }
    };
    function createBaseQueryModuleAccountByNameResponse() {
      return {
        account: void 0
      };
    }
    exports.QueryModuleAccountByNameResponse = {
      typeUrl: "/cosmos.auth.v1beta1.QueryModuleAccountByNameResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.account !== void 0) {
          any_1.Any.encode(message.account, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryModuleAccountByNameResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.account = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryModuleAccountByNameResponse();
        if ((0, helpers_1.isSet)(object.account))
          obj.account = any_1.Any.fromJSON(object.account);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.account !== void 0 && (obj.account = message.account ? any_1.Any.toJSON(message.account) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryModuleAccountByNameResponse();
        if (object.account !== void 0 && object.account !== null) {
          message.account = any_1.Any.fromPartial(object.account);
        }
        return message;
      }
    };
    function createBaseBech32PrefixRequest() {
      return {};
    }
    exports.Bech32PrefixRequest = {
      typeUrl: "/cosmos.auth.v1beta1.Bech32PrefixRequest",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBech32PrefixRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseBech32PrefixRequest();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseBech32PrefixRequest();
        return message;
      }
    };
    function createBaseBech32PrefixResponse() {
      return {
        bech32Prefix: ""
      };
    }
    exports.Bech32PrefixResponse = {
      typeUrl: "/cosmos.auth.v1beta1.Bech32PrefixResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.bech32Prefix !== "") {
          writer.uint32(10).string(message.bech32Prefix);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBech32PrefixResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.bech32Prefix = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBech32PrefixResponse();
        if ((0, helpers_1.isSet)(object.bech32Prefix))
          obj.bech32Prefix = String(object.bech32Prefix);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.bech32Prefix !== void 0 && (obj.bech32Prefix = message.bech32Prefix);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBech32PrefixResponse();
        message.bech32Prefix = object.bech32Prefix ?? "";
        return message;
      }
    };
    function createBaseAddressBytesToStringRequest() {
      return {
        addressBytes: new Uint8Array()
      };
    }
    exports.AddressBytesToStringRequest = {
      typeUrl: "/cosmos.auth.v1beta1.AddressBytesToStringRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.addressBytes.length !== 0) {
          writer.uint32(10).bytes(message.addressBytes);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAddressBytesToStringRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.addressBytes = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseAddressBytesToStringRequest();
        if ((0, helpers_1.isSet)(object.addressBytes))
          obj.addressBytes = (0, helpers_1.bytesFromBase64)(object.addressBytes);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.addressBytes !== void 0 && (obj.addressBytes = (0, helpers_1.base64FromBytes)(message.addressBytes !== void 0 ? message.addressBytes : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseAddressBytesToStringRequest();
        message.addressBytes = object.addressBytes ?? new Uint8Array();
        return message;
      }
    };
    function createBaseAddressBytesToStringResponse() {
      return {
        addressString: ""
      };
    }
    exports.AddressBytesToStringResponse = {
      typeUrl: "/cosmos.auth.v1beta1.AddressBytesToStringResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.addressString !== "") {
          writer.uint32(10).string(message.addressString);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAddressBytesToStringResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.addressString = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseAddressBytesToStringResponse();
        if ((0, helpers_1.isSet)(object.addressString))
          obj.addressString = String(object.addressString);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.addressString !== void 0 && (obj.addressString = message.addressString);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseAddressBytesToStringResponse();
        message.addressString = object.addressString ?? "";
        return message;
      }
    };
    function createBaseAddressStringToBytesRequest() {
      return {
        addressString: ""
      };
    }
    exports.AddressStringToBytesRequest = {
      typeUrl: "/cosmos.auth.v1beta1.AddressStringToBytesRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.addressString !== "") {
          writer.uint32(10).string(message.addressString);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAddressStringToBytesRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.addressString = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseAddressStringToBytesRequest();
        if ((0, helpers_1.isSet)(object.addressString))
          obj.addressString = String(object.addressString);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.addressString !== void 0 && (obj.addressString = message.addressString);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseAddressStringToBytesRequest();
        message.addressString = object.addressString ?? "";
        return message;
      }
    };
    function createBaseAddressStringToBytesResponse() {
      return {
        addressBytes: new Uint8Array()
      };
    }
    exports.AddressStringToBytesResponse = {
      typeUrl: "/cosmos.auth.v1beta1.AddressStringToBytesResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.addressBytes.length !== 0) {
          writer.uint32(10).bytes(message.addressBytes);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAddressStringToBytesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.addressBytes = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseAddressStringToBytesResponse();
        if ((0, helpers_1.isSet)(object.addressBytes))
          obj.addressBytes = (0, helpers_1.bytesFromBase64)(object.addressBytes);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.addressBytes !== void 0 && (obj.addressBytes = (0, helpers_1.base64FromBytes)(message.addressBytes !== void 0 ? message.addressBytes : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseAddressStringToBytesResponse();
        message.addressBytes = object.addressBytes ?? new Uint8Array();
        return message;
      }
    };
    function createBaseQueryAccountAddressByIDRequest() {
      return {
        id: BigInt(0),
        accountId: BigInt(0)
      };
    }
    exports.QueryAccountAddressByIDRequest = {
      typeUrl: "/cosmos.auth.v1beta1.QueryAccountAddressByIDRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.id !== BigInt(0)) {
          writer.uint32(8).int64(message.id);
        }
        if (message.accountId !== BigInt(0)) {
          writer.uint32(16).uint64(message.accountId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAccountAddressByIDRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.int64();
              break;
            case 2:
              message.accountId = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAccountAddressByIDRequest();
        if ((0, helpers_1.isSet)(object.id))
          obj.id = BigInt(object.id.toString());
        if ((0, helpers_1.isSet)(object.accountId))
          obj.accountId = BigInt(object.accountId.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.id !== void 0 && (obj.id = (message.id || BigInt(0)).toString());
        message.accountId !== void 0 && (obj.accountId = (message.accountId || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAccountAddressByIDRequest();
        if (object.id !== void 0 && object.id !== null) {
          message.id = BigInt(object.id.toString());
        }
        if (object.accountId !== void 0 && object.accountId !== null) {
          message.accountId = BigInt(object.accountId.toString());
        }
        return message;
      }
    };
    function createBaseQueryAccountAddressByIDResponse() {
      return {
        accountAddress: ""
      };
    }
    exports.QueryAccountAddressByIDResponse = {
      typeUrl: "/cosmos.auth.v1beta1.QueryAccountAddressByIDResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.accountAddress !== "") {
          writer.uint32(10).string(message.accountAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAccountAddressByIDResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.accountAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAccountAddressByIDResponse();
        if ((0, helpers_1.isSet)(object.accountAddress))
          obj.accountAddress = String(object.accountAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.accountAddress !== void 0 && (obj.accountAddress = message.accountAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAccountAddressByIDResponse();
        message.accountAddress = object.accountAddress ?? "";
        return message;
      }
    };
    function createBaseQueryAccountInfoRequest() {
      return {
        address: ""
      };
    }
    exports.QueryAccountInfoRequest = {
      typeUrl: "/cosmos.auth.v1beta1.QueryAccountInfoRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAccountInfoRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAccountInfoRequest();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAccountInfoRequest();
        message.address = object.address ?? "";
        return message;
      }
    };
    function createBaseQueryAccountInfoResponse() {
      return {
        info: void 0
      };
    }
    exports.QueryAccountInfoResponse = {
      typeUrl: "/cosmos.auth.v1beta1.QueryAccountInfoResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.info !== void 0) {
          auth_1.BaseAccount.encode(message.info, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAccountInfoResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.info = auth_1.BaseAccount.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAccountInfoResponse();
        if ((0, helpers_1.isSet)(object.info))
          obj.info = auth_1.BaseAccount.fromJSON(object.info);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.info !== void 0 && (obj.info = message.info ? auth_1.BaseAccount.toJSON(message.info) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAccountInfoResponse();
        if (object.info !== void 0 && object.info !== null) {
          message.info = auth_1.BaseAccount.fromPartial(object.info);
        }
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Accounts = this.Accounts.bind(this);
        this.Account = this.Account.bind(this);
        this.AccountAddressByID = this.AccountAddressByID.bind(this);
        this.Params = this.Params.bind(this);
        this.ModuleAccounts = this.ModuleAccounts.bind(this);
        this.ModuleAccountByName = this.ModuleAccountByName.bind(this);
        this.Bech32Prefix = this.Bech32Prefix.bind(this);
        this.AddressBytesToString = this.AddressBytesToString.bind(this);
        this.AddressStringToBytes = this.AddressStringToBytes.bind(this);
        this.AccountInfo = this.AccountInfo.bind(this);
      }
      Accounts(request = {
        pagination: pagination_1.PageRequest.fromPartial({})
      }) {
        const data2 = exports.QueryAccountsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "Accounts", data2);
        return promise.then((data3) => exports.QueryAccountsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Account(request) {
        const data2 = exports.QueryAccountRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "Account", data2);
        return promise.then((data3) => exports.QueryAccountResponse.decode(new binary_1.BinaryReader(data3)));
      }
      AccountAddressByID(request) {
        const data2 = exports.QueryAccountAddressByIDRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "AccountAddressByID", data2);
        return promise.then((data3) => exports.QueryAccountAddressByIDResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Params(request = {}) {
        const data2 = exports.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "Params", data2);
        return promise.then((data3) => exports.QueryParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ModuleAccounts(request = {}) {
        const data2 = exports.QueryModuleAccountsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "ModuleAccounts", data2);
        return promise.then((data3) => exports.QueryModuleAccountsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ModuleAccountByName(request) {
        const data2 = exports.QueryModuleAccountByNameRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "ModuleAccountByName", data2);
        return promise.then((data3) => exports.QueryModuleAccountByNameResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Bech32Prefix(request = {}) {
        const data2 = exports.Bech32PrefixRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "Bech32Prefix", data2);
        return promise.then((data3) => exports.Bech32PrefixResponse.decode(new binary_1.BinaryReader(data3)));
      }
      AddressBytesToString(request) {
        const data2 = exports.AddressBytesToStringRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "AddressBytesToString", data2);
        return promise.then((data3) => exports.AddressBytesToStringResponse.decode(new binary_1.BinaryReader(data3)));
      }
      AddressStringToBytes(request) {
        const data2 = exports.AddressStringToBytesRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "AddressStringToBytes", data2);
        return promise.then((data3) => exports.AddressStringToBytesResponse.decode(new binary_1.BinaryReader(data3)));
      }
      AccountInfo(request) {
        const data2 = exports.QueryAccountInfoRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.auth.v1beta1.Query", "AccountInfo", data2);
        return promise.then((data3) => exports.QueryAccountInfoResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.QueryClientImpl = QueryClientImpl;
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/queryclient/queryclient.js
var require_queryclient = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/queryclient/queryclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryClient = void 0;
    var utils_1 = require_build();
    var QueryClient = class _QueryClient {
      static withExtensions(cometClient, ...extensionSetups) {
        const client = new _QueryClient(cometClient);
        const extensions = extensionSetups.map((setupExtension) => setupExtension(client));
        for (const extension of extensions) {
          (0, utils_1.assert)((0, utils_1.isNonNullObject)(extension), `Extension must be a non-null object`);
          for (const [moduleKey, moduleValue] of Object.entries(extension)) {
            (0, utils_1.assert)((0, utils_1.isNonNullObject)(moduleValue), `Module must be a non-null object. Found type ${typeof moduleValue} for module "${moduleKey}".`);
            const current = client[moduleKey] || {};
            client[moduleKey] = {
              ...current,
              ...moduleValue
            };
          }
        }
        return client;
      }
      cometClient;
      constructor(cometClient) {
        this.cometClient = cometClient;
      }
      /**
       * Performs an ABCI query to Tendermint without requesting a proof.
       *
       * If the `desiredHeight` is set, a particular height is requested. Otherwise
       * the latest height is requested. The response contains the actual height of
       * the query.
       */
      async queryAbci(path, request, desiredHeight) {
        const response = await this.cometClient.abciQuery({
          path,
          data: request,
          prove: false,
          height: desiredHeight
        });
        if (response.code) {
          throw new Error(`Query failed with (${response.code}): ${response.log}`);
        }
        if (!response.height) {
          throw new Error("No query height returned");
        }
        return {
          value: response.value,
          height: response.height
        };
      }
    };
    exports.QueryClient = QueryClient;
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/queryclient/utils.js
var require_utils5 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/queryclient/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toAccAddress = toAccAddress;
    exports.createPagination = createPagination;
    exports.createProtobufRpcClient = createProtobufRpcClient;
    exports.longify = longify;
    exports.decodeCosmosSdkDecFromProto = decodeCosmosSdkDecFromProto;
    var encoding_1 = require_build2();
    var math_1 = require_build3();
    var pagination_1 = require_pagination();
    function toAccAddress(address) {
      return (0, encoding_1.fromBech32)(address).data;
    }
    function createPagination(paginationKey) {
      return paginationKey ? pagination_1.PageRequest.fromPartial({ key: paginationKey }) : pagination_1.PageRequest.fromPartial({});
    }
    function createProtobufRpcClient(base) {
      return {
        request: async (service, method, data2) => {
          const path = `/${service}/${method}`;
          const response = await base.queryAbci(path, data2, void 0);
          return response.value;
        }
      };
    }
    function longify(value) {
      const checkedValue = math_1.Uint64.fromString(value.toString());
      return BigInt(checkedValue.toString());
    }
    function decodeCosmosSdkDecFromProto(input) {
      const asString = typeof input === "string" ? input : (0, encoding_1.fromAscii)(input);
      return math_1.Decimal.fromAtomics(asString, 18);
    }
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/queryclient/index.js
var require_queryclient2 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/queryclient/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.longify = exports.decodeCosmosSdkDecFromProto = exports.createProtobufRpcClient = exports.createPagination = exports.QueryClient = void 0;
    var queryclient_1 = require_queryclient();
    Object.defineProperty(exports, "QueryClient", { enumerable: true, get: function() {
      return queryclient_1.QueryClient;
    } });
    var utils_1 = require_utils5();
    Object.defineProperty(exports, "createPagination", { enumerable: true, get: function() {
      return utils_1.createPagination;
    } });
    Object.defineProperty(exports, "createProtobufRpcClient", { enumerable: true, get: function() {
      return utils_1.createProtobufRpcClient;
    } });
    Object.defineProperty(exports, "decodeCosmosSdkDecFromProto", { enumerable: true, get: function() {
      return utils_1.decodeCosmosSdkDecFromProto;
    } });
    Object.defineProperty(exports, "longify", { enumerable: true, get: function() {
      return utils_1.longify;
    } });
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/auth/queries.js
var require_queries = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/auth/queries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupAuthExtension = setupAuthExtension;
    var query_1 = require_query();
    var queryclient_1 = require_queryclient2();
    function setupAuthExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        auth: {
          account: async (address) => {
            const { account } = await queryService.Account({ address });
            return account ?? null;
          }
        }
      };
    }
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/authz/aminomessages.js
var require_aminomessages = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/authz/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createAuthzAminoConverters = createAuthzAminoConverters;
    function createAuthzAminoConverters() {
      return {
        // For Cosmos SDK < 0.46 the Amino JSON codec was broken on chain and thus inaccessible.
        // Now this can be implemented for 0.46+ chains, see
        // https://github.com/cosmos/cosmjs/issues/1092
        //
        // "/cosmos.authz.v1beta1.MsgGrant": IMPLEMENT ME,
        // "/cosmos.authz.v1beta1.MsgExec": IMPLEMENT ME,
        // "/cosmos.authz.v1beta1.MsgRevoke": IMPLEMENT ME,
      };
    }
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/google/protobuf/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/google/protobuf/timestamp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Timestamp = exports.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "google.protobuf";
    function createBaseTimestamp() {
      return {
        seconds: BigInt(0),
        nanos: 0
      };
    }
    exports.Timestamp = {
      typeUrl: "/google.protobuf.Timestamp",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.seconds !== BigInt(0)) {
          writer.uint32(8).int64(message.seconds);
        }
        if (message.nanos !== 0) {
          writer.uint32(16).int32(message.nanos);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTimestamp();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.seconds = reader.int64();
              break;
            case 2:
              message.nanos = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTimestamp();
        if ((0, helpers_1.isSet)(object.seconds))
          obj.seconds = BigInt(object.seconds.toString());
        if ((0, helpers_1.isSet)(object.nanos))
          obj.nanos = Number(object.nanos);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.seconds !== void 0 && (obj.seconds = (message.seconds || BigInt(0)).toString());
        message.nanos !== void 0 && (obj.nanos = Math.round(message.nanos));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTimestamp();
        if (object.seconds !== void 0 && object.seconds !== null) {
          message.seconds = BigInt(object.seconds.toString());
        }
        message.nanos = object.nanos ?? 0;
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/authz/v1beta1/authz.js
var require_authz = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/authz/v1beta1/authz.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GrantQueueItem = exports.GrantAuthorization = exports.Grant = exports.GenericAuthorization = exports.protobufPackage = void 0;
    var any_1 = require_any();
    var timestamp_1 = require_timestamp();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.authz.v1beta1";
    function createBaseGenericAuthorization() {
      return {
        msg: ""
      };
    }
    exports.GenericAuthorization = {
      typeUrl: "/cosmos.authz.v1beta1.GenericAuthorization",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.msg !== "") {
          writer.uint32(10).string(message.msg);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGenericAuthorization();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.msg = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGenericAuthorization();
        if ((0, helpers_1.isSet)(object.msg))
          obj.msg = String(object.msg);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.msg !== void 0 && (obj.msg = message.msg);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGenericAuthorization();
        message.msg = object.msg ?? "";
        return message;
      }
    };
    function createBaseGrant() {
      return {
        authorization: void 0,
        expiration: void 0
      };
    }
    exports.Grant = {
      typeUrl: "/cosmos.authz.v1beta1.Grant",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.authorization !== void 0) {
          any_1.Any.encode(message.authorization, writer.uint32(10).fork()).ldelim();
        }
        if (message.expiration !== void 0) {
          timestamp_1.Timestamp.encode(message.expiration, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGrant();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.authorization = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.expiration = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGrant();
        if ((0, helpers_1.isSet)(object.authorization))
          obj.authorization = any_1.Any.fromJSON(object.authorization);
        if ((0, helpers_1.isSet)(object.expiration))
          obj.expiration = (0, helpers_1.fromJsonTimestamp)(object.expiration);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.authorization !== void 0 && (obj.authorization = message.authorization ? any_1.Any.toJSON(message.authorization) : void 0);
        message.expiration !== void 0 && (obj.expiration = (0, helpers_1.fromTimestamp)(message.expiration).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGrant();
        if (object.authorization !== void 0 && object.authorization !== null) {
          message.authorization = any_1.Any.fromPartial(object.authorization);
        }
        if (object.expiration !== void 0 && object.expiration !== null) {
          message.expiration = timestamp_1.Timestamp.fromPartial(object.expiration);
        }
        return message;
      }
    };
    function createBaseGrantAuthorization() {
      return {
        granter: "",
        grantee: "",
        authorization: void 0,
        expiration: void 0
      };
    }
    exports.GrantAuthorization = {
      typeUrl: "/cosmos.authz.v1beta1.GrantAuthorization",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.grantee !== "") {
          writer.uint32(18).string(message.grantee);
        }
        if (message.authorization !== void 0) {
          any_1.Any.encode(message.authorization, writer.uint32(26).fork()).ldelim();
        }
        if (message.expiration !== void 0) {
          timestamp_1.Timestamp.encode(message.expiration, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGrantAuthorization();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.grantee = reader.string();
              break;
            case 3:
              message.authorization = any_1.Any.decode(reader, reader.uint32());
              break;
            case 4:
              message.expiration = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGrantAuthorization();
        if ((0, helpers_1.isSet)(object.granter))
          obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.grantee))
          obj.grantee = String(object.grantee);
        if ((0, helpers_1.isSet)(object.authorization))
          obj.authorization = any_1.Any.fromJSON(object.authorization);
        if ((0, helpers_1.isSet)(object.expiration))
          obj.expiration = (0, helpers_1.fromJsonTimestamp)(object.expiration);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        message.authorization !== void 0 && (obj.authorization = message.authorization ? any_1.Any.toJSON(message.authorization) : void 0);
        message.expiration !== void 0 && (obj.expiration = (0, helpers_1.fromTimestamp)(message.expiration).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGrantAuthorization();
        message.granter = object.granter ?? "";
        message.grantee = object.grantee ?? "";
        if (object.authorization !== void 0 && object.authorization !== null) {
          message.authorization = any_1.Any.fromPartial(object.authorization);
        }
        if (object.expiration !== void 0 && object.expiration !== null) {
          message.expiration = timestamp_1.Timestamp.fromPartial(object.expiration);
        }
        return message;
      }
    };
    function createBaseGrantQueueItem() {
      return {
        msgTypeUrls: []
      };
    }
    exports.GrantQueueItem = {
      typeUrl: "/cosmos.authz.v1beta1.GrantQueueItem",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.msgTypeUrls) {
          writer.uint32(10).string(v9);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGrantQueueItem();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.msgTypeUrls.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGrantQueueItem();
        if (Array.isArray(object?.msgTypeUrls))
          obj.msgTypeUrls = object.msgTypeUrls.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.msgTypeUrls) {
          obj.msgTypeUrls = message.msgTypeUrls.map((e) => e);
        } else {
          obj.msgTypeUrls = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGrantQueueItem();
        message.msgTypeUrls = object.msgTypeUrls?.map((e) => e) || [];
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/authz/v1beta1/tx.js
var require_tx3 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/authz/v1beta1/tx.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MsgClientImpl = exports.MsgRevokeResponse = exports.MsgRevoke = exports.MsgExecResponse = exports.MsgExec = exports.MsgGrantResponse = exports.MsgGrant = exports.protobufPackage = void 0;
    var authz_1 = require_authz();
    var any_1 = require_any();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.authz.v1beta1";
    function createBaseMsgGrant() {
      return {
        granter: "",
        grantee: "",
        grant: authz_1.Grant.fromPartial({})
      };
    }
    exports.MsgGrant = {
      typeUrl: "/cosmos.authz.v1beta1.MsgGrant",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.grantee !== "") {
          writer.uint32(18).string(message.grantee);
        }
        if (message.grant !== void 0) {
          authz_1.Grant.encode(message.grant, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgGrant();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.grantee = reader.string();
              break;
            case 3:
              message.grant = authz_1.Grant.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgGrant();
        if ((0, helpers_1.isSet)(object.granter))
          obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.grantee))
          obj.grantee = String(object.grantee);
        if ((0, helpers_1.isSet)(object.grant))
          obj.grant = authz_1.Grant.fromJSON(object.grant);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        message.grant !== void 0 && (obj.grant = message.grant ? authz_1.Grant.toJSON(message.grant) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgGrant();
        message.granter = object.granter ?? "";
        message.grantee = object.grantee ?? "";
        if (object.grant !== void 0 && object.grant !== null) {
          message.grant = authz_1.Grant.fromPartial(object.grant);
        }
        return message;
      }
    };
    function createBaseMsgGrantResponse() {
      return {};
    }
    exports.MsgGrantResponse = {
      typeUrl: "/cosmos.authz.v1beta1.MsgGrantResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgGrantResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgGrantResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgGrantResponse();
        return message;
      }
    };
    function createBaseMsgExec() {
      return {
        grantee: "",
        msgs: []
      };
    }
    exports.MsgExec = {
      typeUrl: "/cosmos.authz.v1beta1.MsgExec",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.grantee !== "") {
          writer.uint32(10).string(message.grantee);
        }
        for (const v9 of message.msgs) {
          any_1.Any.encode(v9, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgExec();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.grantee = reader.string();
              break;
            case 2:
              message.msgs.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgExec();
        if ((0, helpers_1.isSet)(object.grantee))
          obj.grantee = String(object.grantee);
        if (Array.isArray(object?.msgs))
          obj.msgs = object.msgs.map((e) => any_1.Any.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        if (message.msgs) {
          obj.msgs = message.msgs.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.msgs = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgExec();
        message.grantee = object.grantee ?? "";
        message.msgs = object.msgs?.map((e) => any_1.Any.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseMsgExecResponse() {
      return {
        results: []
      };
    }
    exports.MsgExecResponse = {
      typeUrl: "/cosmos.authz.v1beta1.MsgExecResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.results) {
          writer.uint32(10).bytes(v9);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgExecResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.results.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgExecResponse();
        if (Array.isArray(object?.results))
          obj.results = object.results.map((e) => (0, helpers_1.bytesFromBase64)(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.results) {
          obj.results = message.results.map((e) => (0, helpers_1.base64FromBytes)(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.results = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgExecResponse();
        message.results = object.results?.map((e) => e) || [];
        return message;
      }
    };
    function createBaseMsgRevoke() {
      return {
        granter: "",
        grantee: "",
        msgTypeUrl: ""
      };
    }
    exports.MsgRevoke = {
      typeUrl: "/cosmos.authz.v1beta1.MsgRevoke",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.grantee !== "") {
          writer.uint32(18).string(message.grantee);
        }
        if (message.msgTypeUrl !== "") {
          writer.uint32(26).string(message.msgTypeUrl);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRevoke();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.grantee = reader.string();
              break;
            case 3:
              message.msgTypeUrl = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgRevoke();
        if ((0, helpers_1.isSet)(object.granter))
          obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.grantee))
          obj.grantee = String(object.grantee);
        if ((0, helpers_1.isSet)(object.msgTypeUrl))
          obj.msgTypeUrl = String(object.msgTypeUrl);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        message.msgTypeUrl !== void 0 && (obj.msgTypeUrl = message.msgTypeUrl);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgRevoke();
        message.granter = object.granter ?? "";
        message.grantee = object.grantee ?? "";
        message.msgTypeUrl = object.msgTypeUrl ?? "";
        return message;
      }
    };
    function createBaseMsgRevokeResponse() {
      return {};
    }
    exports.MsgRevokeResponse = {
      typeUrl: "/cosmos.authz.v1beta1.MsgRevokeResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRevokeResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgRevokeResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgRevokeResponse();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Grant = this.Grant.bind(this);
        this.Exec = this.Exec.bind(this);
        this.Revoke = this.Revoke.bind(this);
      }
      Grant(request) {
        const data2 = exports.MsgGrant.encode(request).finish();
        const promise = this.rpc.request("cosmos.authz.v1beta1.Msg", "Grant", data2);
        return promise.then((data3) => exports.MsgGrantResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Exec(request) {
        const data2 = exports.MsgExec.encode(request).finish();
        const promise = this.rpc.request("cosmos.authz.v1beta1.Msg", "Exec", data2);
        return promise.then((data3) => exports.MsgExecResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Revoke(request) {
        const data2 = exports.MsgRevoke.encode(request).finish();
        const promise = this.rpc.request("cosmos.authz.v1beta1.Msg", "Revoke", data2);
        return promise.then((data3) => exports.MsgRevokeResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.MsgClientImpl = MsgClientImpl;
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/authz/messages.js
var require_messages = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/authz/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.authzTypes = void 0;
    var tx_1 = require_tx3();
    exports.authzTypes = [
      ["/cosmos.authz.v1beta1.MsgExec", tx_1.MsgExec],
      ["/cosmos.authz.v1beta1.MsgGrant", tx_1.MsgGrant],
      ["/cosmos.authz.v1beta1.MsgRevoke", tx_1.MsgRevoke]
    ];
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/authz/v1beta1/query.js
var require_query2 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/authz/v1beta1/query.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryClientImpl = exports.QueryGranteeGrantsResponse = exports.QueryGranteeGrantsRequest = exports.QueryGranterGrantsResponse = exports.QueryGranterGrantsRequest = exports.QueryGrantsResponse = exports.QueryGrantsRequest = exports.protobufPackage = void 0;
    var pagination_1 = require_pagination();
    var authz_1 = require_authz();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.authz.v1beta1";
    function createBaseQueryGrantsRequest() {
      return {
        granter: "",
        grantee: "",
        msgTypeUrl: "",
        pagination: void 0
      };
    }
    exports.QueryGrantsRequest = {
      typeUrl: "/cosmos.authz.v1beta1.QueryGrantsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.grantee !== "") {
          writer.uint32(18).string(message.grantee);
        }
        if (message.msgTypeUrl !== "") {
          writer.uint32(26).string(message.msgTypeUrl);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryGrantsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.grantee = reader.string();
              break;
            case 3:
              message.msgTypeUrl = reader.string();
              break;
            case 4:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryGrantsRequest();
        if ((0, helpers_1.isSet)(object.granter))
          obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.grantee))
          obj.grantee = String(object.grantee);
        if ((0, helpers_1.isSet)(object.msgTypeUrl))
          obj.msgTypeUrl = String(object.msgTypeUrl);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        message.msgTypeUrl !== void 0 && (obj.msgTypeUrl = message.msgTypeUrl);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryGrantsRequest();
        message.granter = object.granter ?? "";
        message.grantee = object.grantee ?? "";
        message.msgTypeUrl = object.msgTypeUrl ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryGrantsResponse() {
      return {
        grants: [],
        pagination: void 0
      };
    }
    exports.QueryGrantsResponse = {
      typeUrl: "/cosmos.authz.v1beta1.QueryGrantsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.grants) {
          authz_1.Grant.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryGrantsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.grants.push(authz_1.Grant.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryGrantsResponse();
        if (Array.isArray(object?.grants))
          obj.grants = object.grants.map((e) => authz_1.Grant.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.grants) {
          obj.grants = message.grants.map((e) => e ? authz_1.Grant.toJSON(e) : void 0);
        } else {
          obj.grants = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryGrantsResponse();
        message.grants = object.grants?.map((e) => authz_1.Grant.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryGranterGrantsRequest() {
      return {
        granter: "",
        pagination: void 0
      };
    }
    exports.QueryGranterGrantsRequest = {
      typeUrl: "/cosmos.authz.v1beta1.QueryGranterGrantsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryGranterGrantsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryGranterGrantsRequest();
        if ((0, helpers_1.isSet)(object.granter))
          obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryGranterGrantsRequest();
        message.granter = object.granter ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryGranterGrantsResponse() {
      return {
        grants: [],
        pagination: void 0
      };
    }
    exports.QueryGranterGrantsResponse = {
      typeUrl: "/cosmos.authz.v1beta1.QueryGranterGrantsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.grants) {
          authz_1.GrantAuthorization.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryGranterGrantsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.grants.push(authz_1.GrantAuthorization.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryGranterGrantsResponse();
        if (Array.isArray(object?.grants))
          obj.grants = object.grants.map((e) => authz_1.GrantAuthorization.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.grants) {
          obj.grants = message.grants.map((e) => e ? authz_1.GrantAuthorization.toJSON(e) : void 0);
        } else {
          obj.grants = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryGranterGrantsResponse();
        message.grants = object.grants?.map((e) => authz_1.GrantAuthorization.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryGranteeGrantsRequest() {
      return {
        grantee: "",
        pagination: void 0
      };
    }
    exports.QueryGranteeGrantsRequest = {
      typeUrl: "/cosmos.authz.v1beta1.QueryGranteeGrantsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.grantee !== "") {
          writer.uint32(10).string(message.grantee);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryGranteeGrantsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.grantee = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryGranteeGrantsRequest();
        if ((0, helpers_1.isSet)(object.grantee))
          obj.grantee = String(object.grantee);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryGranteeGrantsRequest();
        message.grantee = object.grantee ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryGranteeGrantsResponse() {
      return {
        grants: [],
        pagination: void 0
      };
    }
    exports.QueryGranteeGrantsResponse = {
      typeUrl: "/cosmos.authz.v1beta1.QueryGranteeGrantsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.grants) {
          authz_1.GrantAuthorization.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryGranteeGrantsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.grants.push(authz_1.GrantAuthorization.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryGranteeGrantsResponse();
        if (Array.isArray(object?.grants))
          obj.grants = object.grants.map((e) => authz_1.GrantAuthorization.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.grants) {
          obj.grants = message.grants.map((e) => e ? authz_1.GrantAuthorization.toJSON(e) : void 0);
        } else {
          obj.grants = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryGranteeGrantsResponse();
        message.grants = object.grants?.map((e) => authz_1.GrantAuthorization.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Grants = this.Grants.bind(this);
        this.GranterGrants = this.GranterGrants.bind(this);
        this.GranteeGrants = this.GranteeGrants.bind(this);
      }
      Grants(request) {
        const data2 = exports.QueryGrantsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.authz.v1beta1.Query", "Grants", data2);
        return promise.then((data3) => exports.QueryGrantsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      GranterGrants(request) {
        const data2 = exports.QueryGranterGrantsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.authz.v1beta1.Query", "GranterGrants", data2);
        return promise.then((data3) => exports.QueryGranterGrantsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      GranteeGrants(request) {
        const data2 = exports.QueryGranteeGrantsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.authz.v1beta1.Query", "GranteeGrants", data2);
        return promise.then((data3) => exports.QueryGranteeGrantsResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.QueryClientImpl = QueryClientImpl;
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/authz/queries.js
var require_queries2 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/authz/queries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupAuthzExtension = setupAuthzExtension;
    var query_1 = require_query2();
    var queryclient_1 = require_queryclient2();
    function setupAuthzExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        authz: {
          grants: async (granter, grantee, msgTypeUrl, paginationKey) => {
            return await queryService.Grants({
              granter,
              grantee,
              msgTypeUrl,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
          },
          granteeGrants: async (grantee, paginationKey) => {
            return await queryService.GranteeGrants({
              grantee,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
          },
          granterGrants: async (granter, paginationKey) => {
            return await queryService.GranterGrants({
              granter,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
          }
        }
      };
    }
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/bank/aminomessages.js
var require_aminomessages2 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/bank/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAminoMsgSend = isAminoMsgSend;
    exports.isAminoMsgMultiSend = isAminoMsgMultiSend;
    exports.createBankAminoConverters = createBankAminoConverters;
    function isAminoMsgSend(msg) {
      return msg.type === "cosmos-sdk/MsgSend";
    }
    function isAminoMsgMultiSend(msg) {
      return msg.type === "cosmos-sdk/MsgMultiSend";
    }
    function createBankAminoConverters() {
      return {
        "/cosmos.bank.v1beta1.MsgSend": {
          aminoType: "cosmos-sdk/MsgSend",
          toAmino: ({ fromAddress, toAddress, amount }) => ({
            from_address: fromAddress,
            to_address: toAddress,
            amount: [...amount]
          }),
          fromAmino: ({ from_address, to_address, amount }) => ({
            fromAddress: from_address,
            toAddress: to_address,
            amount: [...amount]
          })
        },
        "/cosmos.bank.v1beta1.MsgMultiSend": {
          aminoType: "cosmos-sdk/MsgMultiSend",
          toAmino: ({ inputs, outputs }) => ({
            inputs: inputs.map((input) => ({
              address: input.address,
              coins: [...input.coins]
            })),
            outputs: outputs.map((output) => ({
              address: output.address,
              coins: [...output.coins]
            }))
          }),
          fromAmino: ({ inputs, outputs }) => ({
            inputs: inputs.map((input) => ({
              address: input.address,
              coins: [...input.coins]
            })),
            outputs: outputs.map((output) => ({
              address: output.address,
              coins: [...output.coins]
            }))
          })
        }
      };
    }
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/bank/messages.js
var require_messages2 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/bank/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bankTypes = void 0;
    exports.isMsgSendEncodeObject = isMsgSendEncodeObject;
    var tx_1 = require_tx2();
    exports.bankTypes = [
      ["/cosmos.bank.v1beta1.MsgMultiSend", tx_1.MsgMultiSend],
      ["/cosmos.bank.v1beta1.MsgSend", tx_1.MsgSend]
    ];
    function isMsgSendEncodeObject(encodeObject) {
      return encodeObject.typeUrl === "/cosmos.bank.v1beta1.MsgSend";
    }
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/bank/v1beta1/query.js
var require_query3 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/bank/v1beta1/query.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryClientImpl = exports.QuerySendEnabledResponse = exports.QuerySendEnabledRequest = exports.QueryDenomOwnersByQueryResponse = exports.QueryDenomOwnersByQueryRequest = exports.QueryDenomOwnersResponse = exports.DenomOwner = exports.QueryDenomOwnersRequest = exports.QueryDenomMetadataByQueryStringResponse = exports.QueryDenomMetadataByQueryStringRequest = exports.QueryDenomMetadataResponse = exports.QueryDenomMetadataRequest = exports.QueryDenomsMetadataResponse = exports.QueryDenomsMetadataRequest = exports.QueryParamsResponse = exports.QueryParamsRequest = exports.QuerySupplyOfResponse = exports.QuerySupplyOfRequest = exports.QueryTotalSupplyResponse = exports.QueryTotalSupplyRequest = exports.QuerySpendableBalanceByDenomResponse = exports.QuerySpendableBalanceByDenomRequest = exports.QuerySpendableBalancesResponse = exports.QuerySpendableBalancesRequest = exports.QueryAllBalancesResponse = exports.QueryAllBalancesRequest = exports.QueryBalanceResponse = exports.QueryBalanceRequest = exports.protobufPackage = void 0;
    var pagination_1 = require_pagination();
    var coin_1 = require_coin();
    var bank_1 = require_bank();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.bank.v1beta1";
    function createBaseQueryBalanceRequest() {
      return {
        address: "",
        denom: ""
      };
    }
    exports.QueryBalanceRequest = {
      typeUrl: "/cosmos.bank.v1beta1.QueryBalanceRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.denom !== "") {
          writer.uint32(18).string(message.denom);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryBalanceRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.denom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryBalanceRequest();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.denom))
          obj.denom = String(object.denom);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.denom !== void 0 && (obj.denom = message.denom);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryBalanceRequest();
        message.address = object.address ?? "";
        message.denom = object.denom ?? "";
        return message;
      }
    };
    function createBaseQueryBalanceResponse() {
      return {
        balance: void 0
      };
    }
    exports.QueryBalanceResponse = {
      typeUrl: "/cosmos.bank.v1beta1.QueryBalanceResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.balance !== void 0) {
          coin_1.Coin.encode(message.balance, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryBalanceResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.balance = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryBalanceResponse();
        if ((0, helpers_1.isSet)(object.balance))
          obj.balance = coin_1.Coin.fromJSON(object.balance);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.balance !== void 0 && (obj.balance = message.balance ? coin_1.Coin.toJSON(message.balance) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryBalanceResponse();
        if (object.balance !== void 0 && object.balance !== null) {
          message.balance = coin_1.Coin.fromPartial(object.balance);
        }
        return message;
      }
    };
    function createBaseQueryAllBalancesRequest() {
      return {
        address: "",
        pagination: void 0,
        resolveDenom: false
      };
    }
    exports.QueryAllBalancesRequest = {
      typeUrl: "/cosmos.bank.v1beta1.QueryAllBalancesRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        if (message.resolveDenom === true) {
          writer.uint32(24).bool(message.resolveDenom);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAllBalancesRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            case 3:
              message.resolveDenom = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAllBalancesRequest();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        if ((0, helpers_1.isSet)(object.resolveDenom))
          obj.resolveDenom = Boolean(object.resolveDenom);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        message.resolveDenom !== void 0 && (obj.resolveDenom = message.resolveDenom);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAllBalancesRequest();
        message.address = object.address ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        message.resolveDenom = object.resolveDenom ?? false;
        return message;
      }
    };
    function createBaseQueryAllBalancesResponse() {
      return {
        balances: [],
        pagination: void 0
      };
    }
    exports.QueryAllBalancesResponse = {
      typeUrl: "/cosmos.bank.v1beta1.QueryAllBalancesResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.balances) {
          coin_1.Coin.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAllBalancesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.balances.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAllBalancesResponse();
        if (Array.isArray(object?.balances))
          obj.balances = object.balances.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.balances) {
          obj.balances = message.balances.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.balances = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAllBalancesResponse();
        message.balances = object.balances?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQuerySpendableBalancesRequest() {
      return {
        address: "",
        pagination: void 0
      };
    }
    exports.QuerySpendableBalancesRequest = {
      typeUrl: "/cosmos.bank.v1beta1.QuerySpendableBalancesRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySpendableBalancesRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQuerySpendableBalancesRequest();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQuerySpendableBalancesRequest();
        message.address = object.address ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQuerySpendableBalancesResponse() {
      return {
        balances: [],
        pagination: void 0
      };
    }
    exports.QuerySpendableBalancesResponse = {
      typeUrl: "/cosmos.bank.v1beta1.QuerySpendableBalancesResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.balances) {
          coin_1.Coin.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySpendableBalancesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.balances.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQuerySpendableBalancesResponse();
        if (Array.isArray(object?.balances))
          obj.balances = object.balances.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.balances) {
          obj.balances = message.balances.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.balances = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQuerySpendableBalancesResponse();
        message.balances = object.balances?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQuerySpendableBalanceByDenomRequest() {
      return {
        address: "",
        denom: ""
      };
    }
    exports.QuerySpendableBalanceByDenomRequest = {
      typeUrl: "/cosmos.bank.v1beta1.QuerySpendableBalanceByDenomRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.denom !== "") {
          writer.uint32(18).string(message.denom);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySpendableBalanceByDenomRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.denom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQuerySpendableBalanceByDenomRequest();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.denom))
          obj.denom = String(object.denom);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.denom !== void 0 && (obj.denom = message.denom);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQuerySpendableBalanceByDenomRequest();
        message.address = object.address ?? "";
        message.denom = object.denom ?? "";
        return message;
      }
    };
    function createBaseQuerySpendableBalanceByDenomResponse() {
      return {
        balance: void 0
      };
    }
    exports.QuerySpendableBalanceByDenomResponse = {
      typeUrl: "/cosmos.bank.v1beta1.QuerySpendableBalanceByDenomResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.balance !== void 0) {
          coin_1.Coin.encode(message.balance, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySpendableBalanceByDenomResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.balance = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQuerySpendableBalanceByDenomResponse();
        if ((0, helpers_1.isSet)(object.balance))
          obj.balance = coin_1.Coin.fromJSON(object.balance);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.balance !== void 0 && (obj.balance = message.balance ? coin_1.Coin.toJSON(message.balance) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQuerySpendableBalanceByDenomResponse();
        if (object.balance !== void 0 && object.balance !== null) {
          message.balance = coin_1.Coin.fromPartial(object.balance);
        }
        return message;
      }
    };
    function createBaseQueryTotalSupplyRequest() {
      return {
        pagination: void 0
      };
    }
    exports.QueryTotalSupplyRequest = {
      typeUrl: "/cosmos.bank.v1beta1.QueryTotalSupplyRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryTotalSupplyRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryTotalSupplyRequest();
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryTotalSupplyRequest();
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryTotalSupplyResponse() {
      return {
        supply: [],
        pagination: void 0
      };
    }
    exports.QueryTotalSupplyResponse = {
      typeUrl: "/cosmos.bank.v1beta1.QueryTotalSupplyResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.supply) {
          coin_1.Coin.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryTotalSupplyResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.supply.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryTotalSupplyResponse();
        if (Array.isArray(object?.supply))
          obj.supply = object.supply.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.supply) {
          obj.supply = message.supply.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.supply = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryTotalSupplyResponse();
        message.supply = object.supply?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQuerySupplyOfRequest() {
      return {
        denom: ""
      };
    }
    exports.QuerySupplyOfRequest = {
      typeUrl: "/cosmos.bank.v1beta1.QuerySupplyOfRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySupplyOfRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQuerySupplyOfRequest();
        if ((0, helpers_1.isSet)(object.denom))
          obj.denom = String(object.denom);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.denom !== void 0 && (obj.denom = message.denom);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQuerySupplyOfRequest();
        message.denom = object.denom ?? "";
        return message;
      }
    };
    function createBaseQuerySupplyOfResponse() {
      return {
        amount: coin_1.Coin.fromPartial({})
      };
    }
    exports.QuerySupplyOfResponse = {
      typeUrl: "/cosmos.bank.v1beta1.QuerySupplyOfResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.amount !== void 0) {
          coin_1.Coin.encode(message.amount, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySupplyOfResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.amount = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQuerySupplyOfResponse();
        if ((0, helpers_1.isSet)(object.amount))
          obj.amount = coin_1.Coin.fromJSON(object.amount);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.amount !== void 0 && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQuerySupplyOfResponse();
        if (object.amount !== void 0 && object.amount !== null) {
          message.amount = coin_1.Coin.fromPartial(object.amount);
        }
        return message;
      }
    };
    function createBaseQueryParamsRequest() {
      return {};
    }
    exports.QueryParamsRequest = {
      typeUrl: "/cosmos.bank.v1beta1.QueryParamsRequest",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseQueryParamsRequest();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseQueryParamsRequest();
        return message;
      }
    };
    function createBaseQueryParamsResponse() {
      return {
        params: bank_1.Params.fromPartial({})
      };
    }
    exports.QueryParamsResponse = {
      typeUrl: "/cosmos.bank.v1beta1.QueryParamsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== void 0) {
          bank_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = bank_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryParamsResponse();
        if ((0, helpers_1.isSet)(object.params))
          obj.params = bank_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? bank_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryParamsResponse();
        if (object.params !== void 0 && object.params !== null) {
          message.params = bank_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseQueryDenomsMetadataRequest() {
      return {
        pagination: void 0
      };
    }
    exports.QueryDenomsMetadataRequest = {
      typeUrl: "/cosmos.bank.v1beta1.QueryDenomsMetadataRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomsMetadataRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomsMetadataRequest();
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomsMetadataRequest();
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDenomsMetadataResponse() {
      return {
        metadatas: [],
        pagination: void 0
      };
    }
    exports.QueryDenomsMetadataResponse = {
      typeUrl: "/cosmos.bank.v1beta1.QueryDenomsMetadataResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.metadatas) {
          bank_1.Metadata.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomsMetadataResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.metadatas.push(bank_1.Metadata.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomsMetadataResponse();
        if (Array.isArray(object?.metadatas))
          obj.metadatas = object.metadatas.map((e) => bank_1.Metadata.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.metadatas) {
          obj.metadatas = message.metadatas.map((e) => e ? bank_1.Metadata.toJSON(e) : void 0);
        } else {
          obj.metadatas = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomsMetadataResponse();
        message.metadatas = object.metadatas?.map((e) => bank_1.Metadata.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDenomMetadataRequest() {
      return {
        denom: ""
      };
    }
    exports.QueryDenomMetadataRequest = {
      typeUrl: "/cosmos.bank.v1beta1.QueryDenomMetadataRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomMetadataRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomMetadataRequest();
        if ((0, helpers_1.isSet)(object.denom))
          obj.denom = String(object.denom);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.denom !== void 0 && (obj.denom = message.denom);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomMetadataRequest();
        message.denom = object.denom ?? "";
        return message;
      }
    };
    function createBaseQueryDenomMetadataResponse() {
      return {
        metadata: bank_1.Metadata.fromPartial({})
      };
    }
    exports.QueryDenomMetadataResponse = {
      typeUrl: "/cosmos.bank.v1beta1.QueryDenomMetadataResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.metadata !== void 0) {
          bank_1.Metadata.encode(message.metadata, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomMetadataResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.metadata = bank_1.Metadata.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomMetadataResponse();
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = bank_1.Metadata.fromJSON(object.metadata);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.metadata !== void 0 && (obj.metadata = message.metadata ? bank_1.Metadata.toJSON(message.metadata) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomMetadataResponse();
        if (object.metadata !== void 0 && object.metadata !== null) {
          message.metadata = bank_1.Metadata.fromPartial(object.metadata);
        }
        return message;
      }
    };
    function createBaseQueryDenomMetadataByQueryStringRequest() {
      return {
        denom: ""
      };
    }
    exports.QueryDenomMetadataByQueryStringRequest = {
      typeUrl: "/cosmos.bank.v1beta1.QueryDenomMetadataByQueryStringRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomMetadataByQueryStringRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomMetadataByQueryStringRequest();
        if ((0, helpers_1.isSet)(object.denom))
          obj.denom = String(object.denom);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.denom !== void 0 && (obj.denom = message.denom);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomMetadataByQueryStringRequest();
        message.denom = object.denom ?? "";
        return message;
      }
    };
    function createBaseQueryDenomMetadataByQueryStringResponse() {
      return {
        metadata: bank_1.Metadata.fromPartial({})
      };
    }
    exports.QueryDenomMetadataByQueryStringResponse = {
      typeUrl: "/cosmos.bank.v1beta1.QueryDenomMetadataByQueryStringResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.metadata !== void 0) {
          bank_1.Metadata.encode(message.metadata, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomMetadataByQueryStringResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.metadata = bank_1.Metadata.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomMetadataByQueryStringResponse();
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = bank_1.Metadata.fromJSON(object.metadata);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.metadata !== void 0 && (obj.metadata = message.metadata ? bank_1.Metadata.toJSON(message.metadata) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomMetadataByQueryStringResponse();
        if (object.metadata !== void 0 && object.metadata !== null) {
          message.metadata = bank_1.Metadata.fromPartial(object.metadata);
        }
        return message;
      }
    };
    function createBaseQueryDenomOwnersRequest() {
      return {
        denom: "",
        pagination: void 0
      };
    }
    exports.QueryDenomOwnersRequest = {
      typeUrl: "/cosmos.bank.v1beta1.QueryDenomOwnersRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomOwnersRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomOwnersRequest();
        if ((0, helpers_1.isSet)(object.denom))
          obj.denom = String(object.denom);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.denom !== void 0 && (obj.denom = message.denom);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomOwnersRequest();
        message.denom = object.denom ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseDenomOwner() {
      return {
        address: "",
        balance: coin_1.Coin.fromPartial({})
      };
    }
    exports.DenomOwner = {
      typeUrl: "/cosmos.bank.v1beta1.DenomOwner",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.balance !== void 0) {
          coin_1.Coin.encode(message.balance, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDenomOwner();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.balance = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDenomOwner();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.balance))
          obj.balance = coin_1.Coin.fromJSON(object.balance);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.balance !== void 0 && (obj.balance = message.balance ? coin_1.Coin.toJSON(message.balance) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDenomOwner();
        message.address = object.address ?? "";
        if (object.balance !== void 0 && object.balance !== null) {
          message.balance = coin_1.Coin.fromPartial(object.balance);
        }
        return message;
      }
    };
    function createBaseQueryDenomOwnersResponse() {
      return {
        denomOwners: [],
        pagination: void 0
      };
    }
    exports.QueryDenomOwnersResponse = {
      typeUrl: "/cosmos.bank.v1beta1.QueryDenomOwnersResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.denomOwners) {
          exports.DenomOwner.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomOwnersResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denomOwners.push(exports.DenomOwner.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomOwnersResponse();
        if (Array.isArray(object?.denomOwners))
          obj.denomOwners = object.denomOwners.map((e) => exports.DenomOwner.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.denomOwners) {
          obj.denomOwners = message.denomOwners.map((e) => e ? exports.DenomOwner.toJSON(e) : void 0);
        } else {
          obj.denomOwners = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomOwnersResponse();
        message.denomOwners = object.denomOwners?.map((e) => exports.DenomOwner.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDenomOwnersByQueryRequest() {
      return {
        denom: "",
        pagination: void 0
      };
    }
    exports.QueryDenomOwnersByQueryRequest = {
      typeUrl: "/cosmos.bank.v1beta1.QueryDenomOwnersByQueryRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomOwnersByQueryRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomOwnersByQueryRequest();
        if ((0, helpers_1.isSet)(object.denom))
          obj.denom = String(object.denom);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.denom !== void 0 && (obj.denom = message.denom);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomOwnersByQueryRequest();
        message.denom = object.denom ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDenomOwnersByQueryResponse() {
      return {
        denomOwners: [],
        pagination: void 0
      };
    }
    exports.QueryDenomOwnersByQueryResponse = {
      typeUrl: "/cosmos.bank.v1beta1.QueryDenomOwnersByQueryResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.denomOwners) {
          exports.DenomOwner.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomOwnersByQueryResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denomOwners.push(exports.DenomOwner.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomOwnersByQueryResponse();
        if (Array.isArray(object?.denomOwners))
          obj.denomOwners = object.denomOwners.map((e) => exports.DenomOwner.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.denomOwners) {
          obj.denomOwners = message.denomOwners.map((e) => e ? exports.DenomOwner.toJSON(e) : void 0);
        } else {
          obj.denomOwners = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomOwnersByQueryResponse();
        message.denomOwners = object.denomOwners?.map((e) => exports.DenomOwner.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQuerySendEnabledRequest() {
      return {
        denoms: [],
        pagination: void 0
      };
    }
    exports.QuerySendEnabledRequest = {
      typeUrl: "/cosmos.bank.v1beta1.QuerySendEnabledRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.denoms) {
          writer.uint32(10).string(v9);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(794).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySendEnabledRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denoms.push(reader.string());
              break;
            case 99:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQuerySendEnabledRequest();
        if (Array.isArray(object?.denoms))
          obj.denoms = object.denoms.map((e) => String(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.denoms) {
          obj.denoms = message.denoms.map((e) => e);
        } else {
          obj.denoms = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQuerySendEnabledRequest();
        message.denoms = object.denoms?.map((e) => e) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQuerySendEnabledResponse() {
      return {
        sendEnabled: [],
        pagination: void 0
      };
    }
    exports.QuerySendEnabledResponse = {
      typeUrl: "/cosmos.bank.v1beta1.QuerySendEnabledResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.sendEnabled) {
          bank_1.SendEnabled.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(794).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySendEnabledResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sendEnabled.push(bank_1.SendEnabled.decode(reader, reader.uint32()));
              break;
            case 99:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQuerySendEnabledResponse();
        if (Array.isArray(object?.sendEnabled))
          obj.sendEnabled = object.sendEnabled.map((e) => bank_1.SendEnabled.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.sendEnabled) {
          obj.sendEnabled = message.sendEnabled.map((e) => e ? bank_1.SendEnabled.toJSON(e) : void 0);
        } else {
          obj.sendEnabled = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQuerySendEnabledResponse();
        message.sendEnabled = object.sendEnabled?.map((e) => bank_1.SendEnabled.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Balance = this.Balance.bind(this);
        this.AllBalances = this.AllBalances.bind(this);
        this.SpendableBalances = this.SpendableBalances.bind(this);
        this.SpendableBalanceByDenom = this.SpendableBalanceByDenom.bind(this);
        this.TotalSupply = this.TotalSupply.bind(this);
        this.SupplyOf = this.SupplyOf.bind(this);
        this.Params = this.Params.bind(this);
        this.DenomMetadata = this.DenomMetadata.bind(this);
        this.DenomMetadataByQueryString = this.DenomMetadataByQueryString.bind(this);
        this.DenomsMetadata = this.DenomsMetadata.bind(this);
        this.DenomOwners = this.DenomOwners.bind(this);
        this.DenomOwnersByQuery = this.DenomOwnersByQuery.bind(this);
        this.SendEnabled = this.SendEnabled.bind(this);
      }
      Balance(request) {
        const data2 = exports.QueryBalanceRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "Balance", data2);
        return promise.then((data3) => exports.QueryBalanceResponse.decode(new binary_1.BinaryReader(data3)));
      }
      AllBalances(request) {
        const data2 = exports.QueryAllBalancesRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "AllBalances", data2);
        return promise.then((data3) => exports.QueryAllBalancesResponse.decode(new binary_1.BinaryReader(data3)));
      }
      SpendableBalances(request) {
        const data2 = exports.QuerySpendableBalancesRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "SpendableBalances", data2);
        return promise.then((data3) => exports.QuerySpendableBalancesResponse.decode(new binary_1.BinaryReader(data3)));
      }
      SpendableBalanceByDenom(request) {
        const data2 = exports.QuerySpendableBalanceByDenomRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "SpendableBalanceByDenom", data2);
        return promise.then((data3) => exports.QuerySpendableBalanceByDenomResponse.decode(new binary_1.BinaryReader(data3)));
      }
      TotalSupply(request = {
        pagination: pagination_1.PageRequest.fromPartial({})
      }) {
        const data2 = exports.QueryTotalSupplyRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "TotalSupply", data2);
        return promise.then((data3) => exports.QueryTotalSupplyResponse.decode(new binary_1.BinaryReader(data3)));
      }
      SupplyOf(request) {
        const data2 = exports.QuerySupplyOfRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "SupplyOf", data2);
        return promise.then((data3) => exports.QuerySupplyOfResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Params(request = {}) {
        const data2 = exports.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "Params", data2);
        return promise.then((data3) => exports.QueryParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DenomMetadata(request) {
        const data2 = exports.QueryDenomMetadataRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "DenomMetadata", data2);
        return promise.then((data3) => exports.QueryDenomMetadataResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DenomMetadataByQueryString(request) {
        const data2 = exports.QueryDenomMetadataByQueryStringRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "DenomMetadataByQueryString", data2);
        return promise.then((data3) => exports.QueryDenomMetadataByQueryStringResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DenomsMetadata(request = {
        pagination: pagination_1.PageRequest.fromPartial({})
      }) {
        const data2 = exports.QueryDenomsMetadataRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "DenomsMetadata", data2);
        return promise.then((data3) => exports.QueryDenomsMetadataResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DenomOwners(request) {
        const data2 = exports.QueryDenomOwnersRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "DenomOwners", data2);
        return promise.then((data3) => exports.QueryDenomOwnersResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DenomOwnersByQuery(request) {
        const data2 = exports.QueryDenomOwnersByQueryRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "DenomOwnersByQuery", data2);
        return promise.then((data3) => exports.QueryDenomOwnersByQueryResponse.decode(new binary_1.BinaryReader(data3)));
      }
      SendEnabled(request) {
        const data2 = exports.QuerySendEnabledRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.bank.v1beta1.Query", "SendEnabled", data2);
        return promise.then((data3) => exports.QuerySendEnabledResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.QueryClientImpl = QueryClientImpl;
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/bank/queries.js
var require_queries3 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/bank/queries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupBankExtension = setupBankExtension;
    var utils_1 = require_build();
    var query_1 = require_query3();
    var queryclient_1 = require_queryclient2();
    function setupBankExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        bank: {
          balance: async (address, denom) => {
            const { balance } = await queryService.Balance({ address, denom });
            (0, utils_1.assert)(balance);
            return balance;
          },
          allBalances: async (address) => {
            const { balances } = await queryService.AllBalances(query_1.QueryAllBalancesRequest.fromPartial({ address }));
            return balances;
          },
          totalSupply: async (paginationKey) => {
            const response = await queryService.TotalSupply({
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          supplyOf: async (denom) => {
            const { amount } = await queryService.SupplyOf({ denom });
            (0, utils_1.assert)(amount);
            return amount;
          },
          denomMetadata: async (denom) => {
            const { metadata } = await queryService.DenomMetadata({ denom });
            (0, utils_1.assert)(metadata);
            return metadata;
          },
          denomsMetadata: async () => {
            const { metadatas } = await queryService.DenomsMetadata(query_1.QueryDenomsMetadataRequest.fromPartial({
              pagination: void 0
              // Not implemented
            }));
            return metadatas;
          }
        }
      };
    }
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/crisis/aminomessages.js
var require_aminomessages3 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/crisis/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAminoMsgVerifyInvariant = isAminoMsgVerifyInvariant;
    exports.createCrysisAminoConverters = createCrysisAminoConverters;
    function isAminoMsgVerifyInvariant(msg) {
      return msg.type === "cosmos-sdk/MsgVerifyInvariant";
    }
    function createCrysisAminoConverters() {
      throw new Error("Not implemented");
    }
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/distribution/aminomessages.js
var require_aminomessages4 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/distribution/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAminoMsgSetWithdrawAddress = isAminoMsgSetWithdrawAddress;
    exports.isAminoMsgWithdrawDelegatorReward = isAminoMsgWithdrawDelegatorReward;
    exports.isAminoMsgWithdrawValidatorCommission = isAminoMsgWithdrawValidatorCommission;
    exports.isAminoMsgFundCommunityPool = isAminoMsgFundCommunityPool;
    exports.createDistributionAminoConverters = createDistributionAminoConverters;
    function isAminoMsgSetWithdrawAddress(msg) {
      return msg.type === "cosmos-sdk/MsgModifyWithdrawAddress";
    }
    function isAminoMsgWithdrawDelegatorReward(msg) {
      return msg.type === "cosmos-sdk/MsgWithdrawDelegationReward";
    }
    function isAminoMsgWithdrawValidatorCommission(msg) {
      return msg.type === "cosmos-sdk/MsgWithdrawValidatorCommission";
    }
    function isAminoMsgFundCommunityPool(msg) {
      return msg.type === "cosmos-sdk/MsgFundCommunityPool";
    }
    function createDistributionAminoConverters() {
      return {
        "/cosmos.distribution.v1beta1.MsgFundCommunityPool": {
          aminoType: "cosmos-sdk/MsgFundCommunityPool",
          toAmino: ({ amount, depositor }) => ({
            amount: [...amount],
            depositor
          }),
          fromAmino: ({ amount, depositor }) => ({
            amount: [...amount],
            depositor
          })
        },
        "/cosmos.distribution.v1beta1.MsgSetWithdrawAddress": {
          aminoType: "cosmos-sdk/MsgModifyWithdrawAddress",
          toAmino: ({ delegatorAddress, withdrawAddress }) => ({
            delegator_address: delegatorAddress,
            withdraw_address: withdrawAddress
          }),
          fromAmino: ({ delegator_address, withdraw_address }) => ({
            delegatorAddress: delegator_address,
            withdrawAddress: withdraw_address
          })
        },
        "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward": {
          aminoType: "cosmos-sdk/MsgWithdrawDelegationReward",
          toAmino: ({ delegatorAddress, validatorAddress }) => ({
            delegator_address: delegatorAddress,
            validator_address: validatorAddress
          }),
          fromAmino: ({ delegator_address, validator_address }) => ({
            delegatorAddress: delegator_address,
            validatorAddress: validator_address
          })
        },
        "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission": {
          aminoType: "cosmos-sdk/MsgWithdrawValidatorCommission",
          toAmino: ({ validatorAddress }) => ({
            validator_address: validatorAddress
          }),
          fromAmino: ({ validator_address }) => ({
            validatorAddress: validator_address
          })
        }
      };
    }
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/distribution/v1beta1/distribution.js
var require_distribution = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/distribution/v1beta1/distribution.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CommunityPoolSpendProposalWithDeposit = exports.DelegationDelegatorReward = exports.DelegatorStartingInfo = exports.CommunityPoolSpendProposal = exports.FeePool = exports.ValidatorSlashEvents = exports.ValidatorSlashEvent = exports.ValidatorOutstandingRewards = exports.ValidatorAccumulatedCommission = exports.ValidatorCurrentRewards = exports.ValidatorHistoricalRewards = exports.Params = exports.protobufPackage = void 0;
    var coin_1 = require_coin();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.distribution.v1beta1";
    function createBaseParams() {
      return {
        communityTax: "",
        baseProposerReward: "",
        bonusProposerReward: "",
        withdrawAddrEnabled: false
      };
    }
    exports.Params = {
      typeUrl: "/cosmos.distribution.v1beta1.Params",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.communityTax !== "") {
          writer.uint32(10).string(message.communityTax);
        }
        if (message.baseProposerReward !== "") {
          writer.uint32(18).string(message.baseProposerReward);
        }
        if (message.bonusProposerReward !== "") {
          writer.uint32(26).string(message.bonusProposerReward);
        }
        if (message.withdrawAddrEnabled === true) {
          writer.uint32(32).bool(message.withdrawAddrEnabled);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.communityTax = reader.string();
              break;
            case 2:
              message.baseProposerReward = reader.string();
              break;
            case 3:
              message.bonusProposerReward = reader.string();
              break;
            case 4:
              message.withdrawAddrEnabled = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseParams();
        if ((0, helpers_1.isSet)(object.communityTax))
          obj.communityTax = String(object.communityTax);
        if ((0, helpers_1.isSet)(object.baseProposerReward))
          obj.baseProposerReward = String(object.baseProposerReward);
        if ((0, helpers_1.isSet)(object.bonusProposerReward))
          obj.bonusProposerReward = String(object.bonusProposerReward);
        if ((0, helpers_1.isSet)(object.withdrawAddrEnabled))
          obj.withdrawAddrEnabled = Boolean(object.withdrawAddrEnabled);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.communityTax !== void 0 && (obj.communityTax = message.communityTax);
        message.baseProposerReward !== void 0 && (obj.baseProposerReward = message.baseProposerReward);
        message.bonusProposerReward !== void 0 && (obj.bonusProposerReward = message.bonusProposerReward);
        message.withdrawAddrEnabled !== void 0 && (obj.withdrawAddrEnabled = message.withdrawAddrEnabled);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseParams();
        message.communityTax = object.communityTax ?? "";
        message.baseProposerReward = object.baseProposerReward ?? "";
        message.bonusProposerReward = object.bonusProposerReward ?? "";
        message.withdrawAddrEnabled = object.withdrawAddrEnabled ?? false;
        return message;
      }
    };
    function createBaseValidatorHistoricalRewards() {
      return {
        cumulativeRewardRatio: [],
        referenceCount: 0
      };
    }
    exports.ValidatorHistoricalRewards = {
      typeUrl: "/cosmos.distribution.v1beta1.ValidatorHistoricalRewards",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.cumulativeRewardRatio) {
          coin_1.DecCoin.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.referenceCount !== 0) {
          writer.uint32(16).uint32(message.referenceCount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorHistoricalRewards();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.cumulativeRewardRatio.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.referenceCount = reader.uint32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidatorHistoricalRewards();
        if (Array.isArray(object?.cumulativeRewardRatio))
          obj.cumulativeRewardRatio = object.cumulativeRewardRatio.map((e) => coin_1.DecCoin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.referenceCount))
          obj.referenceCount = Number(object.referenceCount);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.cumulativeRewardRatio) {
          obj.cumulativeRewardRatio = message.cumulativeRewardRatio.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.cumulativeRewardRatio = [];
        }
        message.referenceCount !== void 0 && (obj.referenceCount = Math.round(message.referenceCount));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseValidatorHistoricalRewards();
        message.cumulativeRewardRatio = object.cumulativeRewardRatio?.map((e) => coin_1.DecCoin.fromPartial(e)) || [];
        message.referenceCount = object.referenceCount ?? 0;
        return message;
      }
    };
    function createBaseValidatorCurrentRewards() {
      return {
        rewards: [],
        period: BigInt(0)
      };
    }
    exports.ValidatorCurrentRewards = {
      typeUrl: "/cosmos.distribution.v1beta1.ValidatorCurrentRewards",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.rewards) {
          coin_1.DecCoin.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.period !== BigInt(0)) {
          writer.uint32(16).uint64(message.period);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorCurrentRewards();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rewards.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.period = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidatorCurrentRewards();
        if (Array.isArray(object?.rewards))
          obj.rewards = object.rewards.map((e) => coin_1.DecCoin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.period))
          obj.period = BigInt(object.period.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.rewards) {
          obj.rewards = message.rewards.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.rewards = [];
        }
        message.period !== void 0 && (obj.period = (message.period || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseValidatorCurrentRewards();
        message.rewards = object.rewards?.map((e) => coin_1.DecCoin.fromPartial(e)) || [];
        if (object.period !== void 0 && object.period !== null) {
          message.period = BigInt(object.period.toString());
        }
        return message;
      }
    };
    function createBaseValidatorAccumulatedCommission() {
      return {
        commission: []
      };
    }
    exports.ValidatorAccumulatedCommission = {
      typeUrl: "/cosmos.distribution.v1beta1.ValidatorAccumulatedCommission",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.commission) {
          coin_1.DecCoin.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorAccumulatedCommission();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.commission.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidatorAccumulatedCommission();
        if (Array.isArray(object?.commission))
          obj.commission = object.commission.map((e) => coin_1.DecCoin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.commission) {
          obj.commission = message.commission.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.commission = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseValidatorAccumulatedCommission();
        message.commission = object.commission?.map((e) => coin_1.DecCoin.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseValidatorOutstandingRewards() {
      return {
        rewards: []
      };
    }
    exports.ValidatorOutstandingRewards = {
      typeUrl: "/cosmos.distribution.v1beta1.ValidatorOutstandingRewards",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.rewards) {
          coin_1.DecCoin.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorOutstandingRewards();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rewards.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidatorOutstandingRewards();
        if (Array.isArray(object?.rewards))
          obj.rewards = object.rewards.map((e) => coin_1.DecCoin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.rewards) {
          obj.rewards = message.rewards.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.rewards = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseValidatorOutstandingRewards();
        message.rewards = object.rewards?.map((e) => coin_1.DecCoin.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseValidatorSlashEvent() {
      return {
        validatorPeriod: BigInt(0),
        fraction: ""
      };
    }
    exports.ValidatorSlashEvent = {
      typeUrl: "/cosmos.distribution.v1beta1.ValidatorSlashEvent",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorPeriod !== BigInt(0)) {
          writer.uint32(8).uint64(message.validatorPeriod);
        }
        if (message.fraction !== "") {
          writer.uint32(18).string(message.fraction);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorSlashEvent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorPeriod = reader.uint64();
              break;
            case 2:
              message.fraction = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidatorSlashEvent();
        if ((0, helpers_1.isSet)(object.validatorPeriod))
          obj.validatorPeriod = BigInt(object.validatorPeriod.toString());
        if ((0, helpers_1.isSet)(object.fraction))
          obj.fraction = String(object.fraction);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validatorPeriod !== void 0 && (obj.validatorPeriod = (message.validatorPeriod || BigInt(0)).toString());
        message.fraction !== void 0 && (obj.fraction = message.fraction);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseValidatorSlashEvent();
        if (object.validatorPeriod !== void 0 && object.validatorPeriod !== null) {
          message.validatorPeriod = BigInt(object.validatorPeriod.toString());
        }
        message.fraction = object.fraction ?? "";
        return message;
      }
    };
    function createBaseValidatorSlashEvents() {
      return {
        validatorSlashEvents: []
      };
    }
    exports.ValidatorSlashEvents = {
      typeUrl: "/cosmos.distribution.v1beta1.ValidatorSlashEvents",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.validatorSlashEvents) {
          exports.ValidatorSlashEvent.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorSlashEvents();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorSlashEvents.push(exports.ValidatorSlashEvent.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidatorSlashEvents();
        if (Array.isArray(object?.validatorSlashEvents))
          obj.validatorSlashEvents = object.validatorSlashEvents.map((e) => exports.ValidatorSlashEvent.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.validatorSlashEvents) {
          obj.validatorSlashEvents = message.validatorSlashEvents.map((e) => e ? exports.ValidatorSlashEvent.toJSON(e) : void 0);
        } else {
          obj.validatorSlashEvents = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseValidatorSlashEvents();
        message.validatorSlashEvents = object.validatorSlashEvents?.map((e) => exports.ValidatorSlashEvent.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseFeePool() {
      return {
        communityPool: []
      };
    }
    exports.FeePool = {
      typeUrl: "/cosmos.distribution.v1beta1.FeePool",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.communityPool) {
          coin_1.DecCoin.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseFeePool();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.communityPool.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseFeePool();
        if (Array.isArray(object?.communityPool))
          obj.communityPool = object.communityPool.map((e) => coin_1.DecCoin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.communityPool) {
          obj.communityPool = message.communityPool.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.communityPool = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseFeePool();
        message.communityPool = object.communityPool?.map((e) => coin_1.DecCoin.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseCommunityPoolSpendProposal() {
      return {
        title: "",
        description: "",
        recipient: "",
        amount: []
      };
    }
    exports.CommunityPoolSpendProposal = {
      typeUrl: "/cosmos.distribution.v1beta1.CommunityPoolSpendProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        if (message.recipient !== "") {
          writer.uint32(26).string(message.recipient);
        }
        for (const v9 of message.amount) {
          coin_1.Coin.encode(v9, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommunityPoolSpendProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            case 3:
              message.recipient = reader.string();
              break;
            case 4:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCommunityPoolSpendProposal();
        if ((0, helpers_1.isSet)(object.title))
          obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.description))
          obj.description = String(object.description);
        if ((0, helpers_1.isSet)(object.recipient))
          obj.recipient = String(object.recipient);
        if (Array.isArray(object?.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        message.recipient !== void 0 && (obj.recipient = message.recipient);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCommunityPoolSpendProposal();
        message.title = object.title ?? "";
        message.description = object.description ?? "";
        message.recipient = object.recipient ?? "";
        message.amount = object.amount?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseDelegatorStartingInfo() {
      return {
        previousPeriod: BigInt(0),
        stake: "",
        height: BigInt(0)
      };
    }
    exports.DelegatorStartingInfo = {
      typeUrl: "/cosmos.distribution.v1beta1.DelegatorStartingInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.previousPeriod !== BigInt(0)) {
          writer.uint32(8).uint64(message.previousPeriod);
        }
        if (message.stake !== "") {
          writer.uint32(18).string(message.stake);
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(24).uint64(message.height);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDelegatorStartingInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.previousPeriod = reader.uint64();
              break;
            case 2:
              message.stake = reader.string();
              break;
            case 3:
              message.height = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDelegatorStartingInfo();
        if ((0, helpers_1.isSet)(object.previousPeriod))
          obj.previousPeriod = BigInt(object.previousPeriod.toString());
        if ((0, helpers_1.isSet)(object.stake))
          obj.stake = String(object.stake);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.previousPeriod !== void 0 && (obj.previousPeriod = (message.previousPeriod || BigInt(0)).toString());
        message.stake !== void 0 && (obj.stake = message.stake);
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDelegatorStartingInfo();
        if (object.previousPeriod !== void 0 && object.previousPeriod !== null) {
          message.previousPeriod = BigInt(object.previousPeriod.toString());
        }
        message.stake = object.stake ?? "";
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        return message;
      }
    };
    function createBaseDelegationDelegatorReward() {
      return {
        validatorAddress: "",
        reward: []
      };
    }
    exports.DelegationDelegatorReward = {
      typeUrl: "/cosmos.distribution.v1beta1.DelegationDelegatorReward",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorAddress !== "") {
          writer.uint32(10).string(message.validatorAddress);
        }
        for (const v9 of message.reward) {
          coin_1.DecCoin.encode(v9, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDelegationDelegatorReward();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddress = reader.string();
              break;
            case 2:
              message.reward.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDelegationDelegatorReward();
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        if (Array.isArray(object?.reward))
          obj.reward = object.reward.map((e) => coin_1.DecCoin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        if (message.reward) {
          obj.reward = message.reward.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.reward = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDelegationDelegatorReward();
        message.validatorAddress = object.validatorAddress ?? "";
        message.reward = object.reward?.map((e) => coin_1.DecCoin.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseCommunityPoolSpendProposalWithDeposit() {
      return {
        title: "",
        description: "",
        recipient: "",
        amount: "",
        deposit: ""
      };
    }
    exports.CommunityPoolSpendProposalWithDeposit = {
      typeUrl: "/cosmos.distribution.v1beta1.CommunityPoolSpendProposalWithDeposit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        if (message.recipient !== "") {
          writer.uint32(26).string(message.recipient);
        }
        if (message.amount !== "") {
          writer.uint32(34).string(message.amount);
        }
        if (message.deposit !== "") {
          writer.uint32(42).string(message.deposit);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommunityPoolSpendProposalWithDeposit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            case 3:
              message.recipient = reader.string();
              break;
            case 4:
              message.amount = reader.string();
              break;
            case 5:
              message.deposit = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCommunityPoolSpendProposalWithDeposit();
        if ((0, helpers_1.isSet)(object.title))
          obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.description))
          obj.description = String(object.description);
        if ((0, helpers_1.isSet)(object.recipient))
          obj.recipient = String(object.recipient);
        if ((0, helpers_1.isSet)(object.amount))
          obj.amount = String(object.amount);
        if ((0, helpers_1.isSet)(object.deposit))
          obj.deposit = String(object.deposit);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        message.recipient !== void 0 && (obj.recipient = message.recipient);
        message.amount !== void 0 && (obj.amount = message.amount);
        message.deposit !== void 0 && (obj.deposit = message.deposit);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCommunityPoolSpendProposalWithDeposit();
        message.title = object.title ?? "";
        message.description = object.description ?? "";
        message.recipient = object.recipient ?? "";
        message.amount = object.amount ?? "";
        message.deposit = object.deposit ?? "";
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/distribution/v1beta1/tx.js
var require_tx4 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/distribution/v1beta1/tx.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MsgClientImpl = exports.MsgDepositValidatorRewardsPoolResponse = exports.MsgDepositValidatorRewardsPool = exports.MsgCommunityPoolSpendResponse = exports.MsgCommunityPoolSpend = exports.MsgUpdateParamsResponse = exports.MsgUpdateParams = exports.MsgFundCommunityPoolResponse = exports.MsgFundCommunityPool = exports.MsgWithdrawValidatorCommissionResponse = exports.MsgWithdrawValidatorCommission = exports.MsgWithdrawDelegatorRewardResponse = exports.MsgWithdrawDelegatorReward = exports.MsgSetWithdrawAddressResponse = exports.MsgSetWithdrawAddress = exports.protobufPackage = void 0;
    var coin_1 = require_coin();
    var distribution_1 = require_distribution();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.distribution.v1beta1";
    function createBaseMsgSetWithdrawAddress() {
      return {
        delegatorAddress: "",
        withdrawAddress: ""
      };
    }
    exports.MsgSetWithdrawAddress = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgSetWithdrawAddress",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.withdrawAddress !== "") {
          writer.uint32(18).string(message.withdrawAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSetWithdrawAddress();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.withdrawAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgSetWithdrawAddress();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.withdrawAddress))
          obj.withdrawAddress = String(object.withdrawAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.withdrawAddress !== void 0 && (obj.withdrawAddress = message.withdrawAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgSetWithdrawAddress();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.withdrawAddress = object.withdrawAddress ?? "";
        return message;
      }
    };
    function createBaseMsgSetWithdrawAddressResponse() {
      return {};
    }
    exports.MsgSetWithdrawAddressResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgSetWithdrawAddressResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSetWithdrawAddressResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgSetWithdrawAddressResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgSetWithdrawAddressResponse();
        return message;
      }
    };
    function createBaseMsgWithdrawDelegatorReward() {
      return {
        delegatorAddress: "",
        validatorAddress: ""
      };
    }
    exports.MsgWithdrawDelegatorReward = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawDelegatorReward();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgWithdrawDelegatorReward();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgWithdrawDelegatorReward();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        return message;
      }
    };
    function createBaseMsgWithdrawDelegatorRewardResponse() {
      return {
        amount: []
      };
    }
    exports.MsgWithdrawDelegatorRewardResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorRewardResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.amount) {
          coin_1.Coin.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawDelegatorRewardResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgWithdrawDelegatorRewardResponse();
        if (Array.isArray(object?.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgWithdrawDelegatorRewardResponse();
        message.amount = object.amount?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseMsgWithdrawValidatorCommission() {
      return {
        validatorAddress: ""
      };
    }
    exports.MsgWithdrawValidatorCommission = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorAddress !== "") {
          writer.uint32(10).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawValidatorCommission();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgWithdrawValidatorCommission();
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgWithdrawValidatorCommission();
        message.validatorAddress = object.validatorAddress ?? "";
        return message;
      }
    };
    function createBaseMsgWithdrawValidatorCommissionResponse() {
      return {
        amount: []
      };
    }
    exports.MsgWithdrawValidatorCommissionResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommissionResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.amount) {
          coin_1.Coin.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawValidatorCommissionResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgWithdrawValidatorCommissionResponse();
        if (Array.isArray(object?.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgWithdrawValidatorCommissionResponse();
        message.amount = object.amount?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseMsgFundCommunityPool() {
      return {
        amount: [],
        depositor: ""
      };
    }
    exports.MsgFundCommunityPool = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgFundCommunityPool",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.amount) {
          coin_1.Coin.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.depositor !== "") {
          writer.uint32(18).string(message.depositor);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgFundCommunityPool();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.depositor = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgFundCommunityPool();
        if (Array.isArray(object?.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.depositor))
          obj.depositor = String(object.depositor);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        message.depositor !== void 0 && (obj.depositor = message.depositor);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgFundCommunityPool();
        message.amount = object.amount?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        message.depositor = object.depositor ?? "";
        return message;
      }
    };
    function createBaseMsgFundCommunityPoolResponse() {
      return {};
    }
    exports.MsgFundCommunityPoolResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgFundCommunityPoolResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgFundCommunityPoolResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgFundCommunityPoolResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgFundCommunityPoolResponse();
        return message;
      }
    };
    function createBaseMsgUpdateParams() {
      return {
        authority: "",
        params: distribution_1.Params.fromPartial({})
      };
    }
    exports.MsgUpdateParams = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgUpdateParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.authority !== "") {
          writer.uint32(10).string(message.authority);
        }
        if (message.params !== void 0) {
          distribution_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.authority = reader.string();
              break;
            case 2:
              message.params = distribution_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateParams();
        if ((0, helpers_1.isSet)(object.authority))
          obj.authority = String(object.authority);
        if ((0, helpers_1.isSet)(object.params))
          obj.params = distribution_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.authority !== void 0 && (obj.authority = message.authority);
        message.params !== void 0 && (obj.params = message.params ? distribution_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateParams();
        message.authority = object.authority ?? "";
        if (object.params !== void 0 && object.params !== null) {
          message.params = distribution_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseMsgUpdateParamsResponse() {
      return {};
    }
    exports.MsgUpdateParamsResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgUpdateParamsResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgUpdateParamsResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgUpdateParamsResponse();
        return message;
      }
    };
    function createBaseMsgCommunityPoolSpend() {
      return {
        authority: "",
        recipient: "",
        amount: []
      };
    }
    exports.MsgCommunityPoolSpend = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgCommunityPoolSpend",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.authority !== "") {
          writer.uint32(10).string(message.authority);
        }
        if (message.recipient !== "") {
          writer.uint32(18).string(message.recipient);
        }
        for (const v9 of message.amount) {
          coin_1.Coin.encode(v9, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCommunityPoolSpend();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.authority = reader.string();
              break;
            case 2:
              message.recipient = reader.string();
              break;
            case 3:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCommunityPoolSpend();
        if ((0, helpers_1.isSet)(object.authority))
          obj.authority = String(object.authority);
        if ((0, helpers_1.isSet)(object.recipient))
          obj.recipient = String(object.recipient);
        if (Array.isArray(object?.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.authority !== void 0 && (obj.authority = message.authority);
        message.recipient !== void 0 && (obj.recipient = message.recipient);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgCommunityPoolSpend();
        message.authority = object.authority ?? "";
        message.recipient = object.recipient ?? "";
        message.amount = object.amount?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseMsgCommunityPoolSpendResponse() {
      return {};
    }
    exports.MsgCommunityPoolSpendResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgCommunityPoolSpendResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCommunityPoolSpendResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgCommunityPoolSpendResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgCommunityPoolSpendResponse();
        return message;
      }
    };
    function createBaseMsgDepositValidatorRewardsPool() {
      return {
        depositor: "",
        validatorAddress: "",
        amount: []
      };
    }
    exports.MsgDepositValidatorRewardsPool = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgDepositValidatorRewardsPool",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.depositor !== "") {
          writer.uint32(10).string(message.depositor);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        for (const v9 of message.amount) {
          coin_1.Coin.encode(v9, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDepositValidatorRewardsPool();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.depositor = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgDepositValidatorRewardsPool();
        if ((0, helpers_1.isSet)(object.depositor))
          obj.depositor = String(object.depositor);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        if (Array.isArray(object?.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.depositor !== void 0 && (obj.depositor = message.depositor);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgDepositValidatorRewardsPool();
        message.depositor = object.depositor ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        message.amount = object.amount?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseMsgDepositValidatorRewardsPoolResponse() {
      return {};
    }
    exports.MsgDepositValidatorRewardsPoolResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.MsgDepositValidatorRewardsPoolResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDepositValidatorRewardsPoolResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgDepositValidatorRewardsPoolResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgDepositValidatorRewardsPoolResponse();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.SetWithdrawAddress = this.SetWithdrawAddress.bind(this);
        this.WithdrawDelegatorReward = this.WithdrawDelegatorReward.bind(this);
        this.WithdrawValidatorCommission = this.WithdrawValidatorCommission.bind(this);
        this.FundCommunityPool = this.FundCommunityPool.bind(this);
        this.UpdateParams = this.UpdateParams.bind(this);
        this.CommunityPoolSpend = this.CommunityPoolSpend.bind(this);
        this.DepositValidatorRewardsPool = this.DepositValidatorRewardsPool.bind(this);
      }
      SetWithdrawAddress(request) {
        const data2 = exports.MsgSetWithdrawAddress.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "SetWithdrawAddress", data2);
        return promise.then((data3) => exports.MsgSetWithdrawAddressResponse.decode(new binary_1.BinaryReader(data3)));
      }
      WithdrawDelegatorReward(request) {
        const data2 = exports.MsgWithdrawDelegatorReward.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "WithdrawDelegatorReward", data2);
        return promise.then((data3) => exports.MsgWithdrawDelegatorRewardResponse.decode(new binary_1.BinaryReader(data3)));
      }
      WithdrawValidatorCommission(request) {
        const data2 = exports.MsgWithdrawValidatorCommission.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "WithdrawValidatorCommission", data2);
        return promise.then((data3) => exports.MsgWithdrawValidatorCommissionResponse.decode(new binary_1.BinaryReader(data3)));
      }
      FundCommunityPool(request) {
        const data2 = exports.MsgFundCommunityPool.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "FundCommunityPool", data2);
        return promise.then((data3) => exports.MsgFundCommunityPoolResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateParams(request) {
        const data2 = exports.MsgUpdateParams.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "UpdateParams", data2);
        return promise.then((data3) => exports.MsgUpdateParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      CommunityPoolSpend(request) {
        const data2 = exports.MsgCommunityPoolSpend.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "CommunityPoolSpend", data2);
        return promise.then((data3) => exports.MsgCommunityPoolSpendResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DepositValidatorRewardsPool(request) {
        const data2 = exports.MsgDepositValidatorRewardsPool.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Msg", "DepositValidatorRewardsPool", data2);
        return promise.then((data3) => exports.MsgDepositValidatorRewardsPoolResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.MsgClientImpl = MsgClientImpl;
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/distribution/messages.js
var require_messages3 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/distribution/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.distributionTypes = void 0;
    exports.isMsgWithdrawDelegatorRewardEncodeObject = isMsgWithdrawDelegatorRewardEncodeObject;
    var tx_1 = require_tx4();
    exports.distributionTypes = [
      ["/cosmos.distribution.v1beta1.MsgFundCommunityPool", tx_1.MsgFundCommunityPool],
      ["/cosmos.distribution.v1beta1.MsgSetWithdrawAddress", tx_1.MsgSetWithdrawAddress],
      ["/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward", tx_1.MsgWithdrawDelegatorReward],
      ["/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission", tx_1.MsgWithdrawValidatorCommission]
    ];
    function isMsgWithdrawDelegatorRewardEncodeObject(object) {
      return object.typeUrl === "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward";
    }
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/distribution/v1beta1/query.js
var require_query4 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/distribution/v1beta1/query.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryClientImpl = exports.QueryCommunityPoolResponse = exports.QueryCommunityPoolRequest = exports.QueryDelegatorWithdrawAddressResponse = exports.QueryDelegatorWithdrawAddressRequest = exports.QueryDelegatorValidatorsResponse = exports.QueryDelegatorValidatorsRequest = exports.QueryDelegationTotalRewardsResponse = exports.QueryDelegationTotalRewardsRequest = exports.QueryDelegationRewardsResponse = exports.QueryDelegationRewardsRequest = exports.QueryValidatorSlashesResponse = exports.QueryValidatorSlashesRequest = exports.QueryValidatorCommissionResponse = exports.QueryValidatorCommissionRequest = exports.QueryValidatorOutstandingRewardsResponse = exports.QueryValidatorOutstandingRewardsRequest = exports.QueryValidatorDistributionInfoResponse = exports.QueryValidatorDistributionInfoRequest = exports.QueryParamsResponse = exports.QueryParamsRequest = exports.protobufPackage = void 0;
    var pagination_1 = require_pagination();
    var distribution_1 = require_distribution();
    var coin_1 = require_coin();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.distribution.v1beta1";
    function createBaseQueryParamsRequest() {
      return {};
    }
    exports.QueryParamsRequest = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryParamsRequest",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseQueryParamsRequest();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseQueryParamsRequest();
        return message;
      }
    };
    function createBaseQueryParamsResponse() {
      return {
        params: distribution_1.Params.fromPartial({})
      };
    }
    exports.QueryParamsResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryParamsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== void 0) {
          distribution_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = distribution_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryParamsResponse();
        if ((0, helpers_1.isSet)(object.params))
          obj.params = distribution_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? distribution_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryParamsResponse();
        if (object.params !== void 0 && object.params !== null) {
          message.params = distribution_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseQueryValidatorDistributionInfoRequest() {
      return {
        validatorAddress: ""
      };
    }
    exports.QueryValidatorDistributionInfoRequest = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorDistributionInfoRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorAddress !== "") {
          writer.uint32(10).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorDistributionInfoRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorDistributionInfoRequest();
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorDistributionInfoRequest();
        message.validatorAddress = object.validatorAddress ?? "";
        return message;
      }
    };
    function createBaseQueryValidatorDistributionInfoResponse() {
      return {
        operatorAddress: "",
        selfBondRewards: [],
        commission: []
      };
    }
    exports.QueryValidatorDistributionInfoResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorDistributionInfoResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.operatorAddress !== "") {
          writer.uint32(10).string(message.operatorAddress);
        }
        for (const v9 of message.selfBondRewards) {
          coin_1.DecCoin.encode(v9, writer.uint32(18).fork()).ldelim();
        }
        for (const v9 of message.commission) {
          coin_1.DecCoin.encode(v9, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorDistributionInfoResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.operatorAddress = reader.string();
              break;
            case 2:
              message.selfBondRewards.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            case 3:
              message.commission.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorDistributionInfoResponse();
        if ((0, helpers_1.isSet)(object.operatorAddress))
          obj.operatorAddress = String(object.operatorAddress);
        if (Array.isArray(object?.selfBondRewards))
          obj.selfBondRewards = object.selfBondRewards.map((e) => coin_1.DecCoin.fromJSON(e));
        if (Array.isArray(object?.commission))
          obj.commission = object.commission.map((e) => coin_1.DecCoin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.operatorAddress !== void 0 && (obj.operatorAddress = message.operatorAddress);
        if (message.selfBondRewards) {
          obj.selfBondRewards = message.selfBondRewards.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.selfBondRewards = [];
        }
        if (message.commission) {
          obj.commission = message.commission.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.commission = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorDistributionInfoResponse();
        message.operatorAddress = object.operatorAddress ?? "";
        message.selfBondRewards = object.selfBondRewards?.map((e) => coin_1.DecCoin.fromPartial(e)) || [];
        message.commission = object.commission?.map((e) => coin_1.DecCoin.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseQueryValidatorOutstandingRewardsRequest() {
      return {
        validatorAddress: ""
      };
    }
    exports.QueryValidatorOutstandingRewardsRequest = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorOutstandingRewardsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorAddress !== "") {
          writer.uint32(10).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorOutstandingRewardsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorOutstandingRewardsRequest();
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorOutstandingRewardsRequest();
        message.validatorAddress = object.validatorAddress ?? "";
        return message;
      }
    };
    function createBaseQueryValidatorOutstandingRewardsResponse() {
      return {
        rewards: distribution_1.ValidatorOutstandingRewards.fromPartial({})
      };
    }
    exports.QueryValidatorOutstandingRewardsResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorOutstandingRewardsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.rewards !== void 0) {
          distribution_1.ValidatorOutstandingRewards.encode(message.rewards, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorOutstandingRewardsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rewards = distribution_1.ValidatorOutstandingRewards.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorOutstandingRewardsResponse();
        if ((0, helpers_1.isSet)(object.rewards))
          obj.rewards = distribution_1.ValidatorOutstandingRewards.fromJSON(object.rewards);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.rewards !== void 0 && (obj.rewards = message.rewards ? distribution_1.ValidatorOutstandingRewards.toJSON(message.rewards) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorOutstandingRewardsResponse();
        if (object.rewards !== void 0 && object.rewards !== null) {
          message.rewards = distribution_1.ValidatorOutstandingRewards.fromPartial(object.rewards);
        }
        return message;
      }
    };
    function createBaseQueryValidatorCommissionRequest() {
      return {
        validatorAddress: ""
      };
    }
    exports.QueryValidatorCommissionRequest = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorCommissionRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorAddress !== "") {
          writer.uint32(10).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorCommissionRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorCommissionRequest();
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorCommissionRequest();
        message.validatorAddress = object.validatorAddress ?? "";
        return message;
      }
    };
    function createBaseQueryValidatorCommissionResponse() {
      return {
        commission: distribution_1.ValidatorAccumulatedCommission.fromPartial({})
      };
    }
    exports.QueryValidatorCommissionResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorCommissionResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.commission !== void 0) {
          distribution_1.ValidatorAccumulatedCommission.encode(message.commission, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorCommissionResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.commission = distribution_1.ValidatorAccumulatedCommission.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorCommissionResponse();
        if ((0, helpers_1.isSet)(object.commission))
          obj.commission = distribution_1.ValidatorAccumulatedCommission.fromJSON(object.commission);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.commission !== void 0 && (obj.commission = message.commission ? distribution_1.ValidatorAccumulatedCommission.toJSON(message.commission) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorCommissionResponse();
        if (object.commission !== void 0 && object.commission !== null) {
          message.commission = distribution_1.ValidatorAccumulatedCommission.fromPartial(object.commission);
        }
        return message;
      }
    };
    function createBaseQueryValidatorSlashesRequest() {
      return {
        validatorAddress: "",
        startingHeight: BigInt(0),
        endingHeight: BigInt(0),
        pagination: void 0
      };
    }
    exports.QueryValidatorSlashesRequest = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorSlashesRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorAddress !== "") {
          writer.uint32(10).string(message.validatorAddress);
        }
        if (message.startingHeight !== BigInt(0)) {
          writer.uint32(16).uint64(message.startingHeight);
        }
        if (message.endingHeight !== BigInt(0)) {
          writer.uint32(24).uint64(message.endingHeight);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorSlashesRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddress = reader.string();
              break;
            case 2:
              message.startingHeight = reader.uint64();
              break;
            case 3:
              message.endingHeight = reader.uint64();
              break;
            case 4:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorSlashesRequest();
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.startingHeight))
          obj.startingHeight = BigInt(object.startingHeight.toString());
        if ((0, helpers_1.isSet)(object.endingHeight))
          obj.endingHeight = BigInt(object.endingHeight.toString());
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.startingHeight !== void 0 && (obj.startingHeight = (message.startingHeight || BigInt(0)).toString());
        message.endingHeight !== void 0 && (obj.endingHeight = (message.endingHeight || BigInt(0)).toString());
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorSlashesRequest();
        message.validatorAddress = object.validatorAddress ?? "";
        if (object.startingHeight !== void 0 && object.startingHeight !== null) {
          message.startingHeight = BigInt(object.startingHeight.toString());
        }
        if (object.endingHeight !== void 0 && object.endingHeight !== null) {
          message.endingHeight = BigInt(object.endingHeight.toString());
        }
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryValidatorSlashesResponse() {
      return {
        slashes: [],
        pagination: void 0
      };
    }
    exports.QueryValidatorSlashesResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryValidatorSlashesResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.slashes) {
          distribution_1.ValidatorSlashEvent.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorSlashesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.slashes.push(distribution_1.ValidatorSlashEvent.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorSlashesResponse();
        if (Array.isArray(object?.slashes))
          obj.slashes = object.slashes.map((e) => distribution_1.ValidatorSlashEvent.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.slashes) {
          obj.slashes = message.slashes.map((e) => e ? distribution_1.ValidatorSlashEvent.toJSON(e) : void 0);
        } else {
          obj.slashes = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorSlashesResponse();
        message.slashes = object.slashes?.map((e) => distribution_1.ValidatorSlashEvent.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDelegationRewardsRequest() {
      return {
        delegatorAddress: "",
        validatorAddress: ""
      };
    }
    exports.QueryDelegationRewardsRequest = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryDelegationRewardsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegationRewardsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegationRewardsRequest();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegationRewardsRequest();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        return message;
      }
    };
    function createBaseQueryDelegationRewardsResponse() {
      return {
        rewards: []
      };
    }
    exports.QueryDelegationRewardsResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryDelegationRewardsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.rewards) {
          coin_1.DecCoin.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegationRewardsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rewards.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegationRewardsResponse();
        if (Array.isArray(object?.rewards))
          obj.rewards = object.rewards.map((e) => coin_1.DecCoin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.rewards) {
          obj.rewards = message.rewards.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.rewards = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegationRewardsResponse();
        message.rewards = object.rewards?.map((e) => coin_1.DecCoin.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseQueryDelegationTotalRewardsRequest() {
      return {
        delegatorAddress: ""
      };
    }
    exports.QueryDelegationTotalRewardsRequest = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryDelegationTotalRewardsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegationTotalRewardsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegationTotalRewardsRequest();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegationTotalRewardsRequest();
        message.delegatorAddress = object.delegatorAddress ?? "";
        return message;
      }
    };
    function createBaseQueryDelegationTotalRewardsResponse() {
      return {
        rewards: [],
        total: []
      };
    }
    exports.QueryDelegationTotalRewardsResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryDelegationTotalRewardsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.rewards) {
          distribution_1.DelegationDelegatorReward.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        for (const v9 of message.total) {
          coin_1.DecCoin.encode(v9, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegationTotalRewardsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rewards.push(distribution_1.DelegationDelegatorReward.decode(reader, reader.uint32()));
              break;
            case 2:
              message.total.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegationTotalRewardsResponse();
        if (Array.isArray(object?.rewards))
          obj.rewards = object.rewards.map((e) => distribution_1.DelegationDelegatorReward.fromJSON(e));
        if (Array.isArray(object?.total))
          obj.total = object.total.map((e) => coin_1.DecCoin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.rewards) {
          obj.rewards = message.rewards.map((e) => e ? distribution_1.DelegationDelegatorReward.toJSON(e) : void 0);
        } else {
          obj.rewards = [];
        }
        if (message.total) {
          obj.total = message.total.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.total = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegationTotalRewardsResponse();
        message.rewards = object.rewards?.map((e) => distribution_1.DelegationDelegatorReward.fromPartial(e)) || [];
        message.total = object.total?.map((e) => coin_1.DecCoin.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseQueryDelegatorValidatorsRequest() {
      return {
        delegatorAddress: ""
      };
    }
    exports.QueryDelegatorValidatorsRequest = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryDelegatorValidatorsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorValidatorsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorValidatorsRequest();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegatorValidatorsRequest();
        message.delegatorAddress = object.delegatorAddress ?? "";
        return message;
      }
    };
    function createBaseQueryDelegatorValidatorsResponse() {
      return {
        validators: []
      };
    }
    exports.QueryDelegatorValidatorsResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryDelegatorValidatorsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.validators) {
          writer.uint32(10).string(v9);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorValidatorsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validators.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorValidatorsResponse();
        if (Array.isArray(object?.validators))
          obj.validators = object.validators.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.validators) {
          obj.validators = message.validators.map((e) => e);
        } else {
          obj.validators = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegatorValidatorsResponse();
        message.validators = object.validators?.map((e) => e) || [];
        return message;
      }
    };
    function createBaseQueryDelegatorWithdrawAddressRequest() {
      return {
        delegatorAddress: ""
      };
    }
    exports.QueryDelegatorWithdrawAddressRequest = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryDelegatorWithdrawAddressRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorWithdrawAddressRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorWithdrawAddressRequest();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegatorWithdrawAddressRequest();
        message.delegatorAddress = object.delegatorAddress ?? "";
        return message;
      }
    };
    function createBaseQueryDelegatorWithdrawAddressResponse() {
      return {
        withdrawAddress: ""
      };
    }
    exports.QueryDelegatorWithdrawAddressResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryDelegatorWithdrawAddressResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.withdrawAddress !== "") {
          writer.uint32(10).string(message.withdrawAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorWithdrawAddressResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.withdrawAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorWithdrawAddressResponse();
        if ((0, helpers_1.isSet)(object.withdrawAddress))
          obj.withdrawAddress = String(object.withdrawAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.withdrawAddress !== void 0 && (obj.withdrawAddress = message.withdrawAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegatorWithdrawAddressResponse();
        message.withdrawAddress = object.withdrawAddress ?? "";
        return message;
      }
    };
    function createBaseQueryCommunityPoolRequest() {
      return {};
    }
    exports.QueryCommunityPoolRequest = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryCommunityPoolRequest",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryCommunityPoolRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseQueryCommunityPoolRequest();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseQueryCommunityPoolRequest();
        return message;
      }
    };
    function createBaseQueryCommunityPoolResponse() {
      return {
        pool: []
      };
    }
    exports.QueryCommunityPoolResponse = {
      typeUrl: "/cosmos.distribution.v1beta1.QueryCommunityPoolResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.pool) {
          coin_1.DecCoin.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryCommunityPoolResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pool.push(coin_1.DecCoin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryCommunityPoolResponse();
        if (Array.isArray(object?.pool))
          obj.pool = object.pool.map((e) => coin_1.DecCoin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.pool) {
          obj.pool = message.pool.map((e) => e ? coin_1.DecCoin.toJSON(e) : void 0);
        } else {
          obj.pool = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryCommunityPoolResponse();
        message.pool = object.pool?.map((e) => coin_1.DecCoin.fromPartial(e)) || [];
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Params = this.Params.bind(this);
        this.ValidatorDistributionInfo = this.ValidatorDistributionInfo.bind(this);
        this.ValidatorOutstandingRewards = this.ValidatorOutstandingRewards.bind(this);
        this.ValidatorCommission = this.ValidatorCommission.bind(this);
        this.ValidatorSlashes = this.ValidatorSlashes.bind(this);
        this.DelegationRewards = this.DelegationRewards.bind(this);
        this.DelegationTotalRewards = this.DelegationTotalRewards.bind(this);
        this.DelegatorValidators = this.DelegatorValidators.bind(this);
        this.DelegatorWithdrawAddress = this.DelegatorWithdrawAddress.bind(this);
        this.CommunityPool = this.CommunityPool.bind(this);
      }
      Params(request = {}) {
        const data2 = exports.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "Params", data2);
        return promise.then((data3) => exports.QueryParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ValidatorDistributionInfo(request) {
        const data2 = exports.QueryValidatorDistributionInfoRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "ValidatorDistributionInfo", data2);
        return promise.then((data3) => exports.QueryValidatorDistributionInfoResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ValidatorOutstandingRewards(request) {
        const data2 = exports.QueryValidatorOutstandingRewardsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "ValidatorOutstandingRewards", data2);
        return promise.then((data3) => exports.QueryValidatorOutstandingRewardsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ValidatorCommission(request) {
        const data2 = exports.QueryValidatorCommissionRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "ValidatorCommission", data2);
        return promise.then((data3) => exports.QueryValidatorCommissionResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ValidatorSlashes(request) {
        const data2 = exports.QueryValidatorSlashesRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "ValidatorSlashes", data2);
        return promise.then((data3) => exports.QueryValidatorSlashesResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DelegationRewards(request) {
        const data2 = exports.QueryDelegationRewardsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegationRewards", data2);
        return promise.then((data3) => exports.QueryDelegationRewardsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DelegationTotalRewards(request) {
        const data2 = exports.QueryDelegationTotalRewardsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegationTotalRewards", data2);
        return promise.then((data3) => exports.QueryDelegationTotalRewardsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DelegatorValidators(request) {
        const data2 = exports.QueryDelegatorValidatorsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegatorValidators", data2);
        return promise.then((data3) => exports.QueryDelegatorValidatorsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DelegatorWithdrawAddress(request) {
        const data2 = exports.QueryDelegatorWithdrawAddressRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "DelegatorWithdrawAddress", data2);
        return promise.then((data3) => exports.QueryDelegatorWithdrawAddressResponse.decode(new binary_1.BinaryReader(data3)));
      }
      CommunityPool(request = {}) {
        const data2 = exports.QueryCommunityPoolRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.distribution.v1beta1.Query", "CommunityPool", data2);
        return promise.then((data3) => exports.QueryCommunityPoolResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.QueryClientImpl = QueryClientImpl;
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/distribution/queries.js
var require_queries4 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/distribution/queries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupDistributionExtension = setupDistributionExtension;
    var query_1 = require_query4();
    var queryclient_1 = require_queryclient2();
    function setupDistributionExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        distribution: {
          communityPool: async () => {
            const response = await queryService.CommunityPool({});
            return response;
          },
          delegationRewards: async (delegatorAddress, validatorAddress) => {
            const response = await queryService.DelegationRewards({
              delegatorAddress,
              validatorAddress
            });
            return response;
          },
          delegationTotalRewards: async (delegatorAddress) => {
            const response = await queryService.DelegationTotalRewards({
              delegatorAddress
            });
            return response;
          },
          delegatorValidators: async (delegatorAddress) => {
            const response = await queryService.DelegatorValidators({
              delegatorAddress
            });
            return response;
          },
          delegatorWithdrawAddress: async (delegatorAddress) => {
            const response = await queryService.DelegatorWithdrawAddress({
              delegatorAddress
            });
            return response;
          },
          params: async () => {
            const response = await queryService.Params({});
            return response;
          },
          validatorCommission: async (validatorAddress) => {
            const response = await queryService.ValidatorCommission({
              validatorAddress
            });
            return response;
          },
          validatorOutstandingRewards: async (validatorAddress) => {
            const response = await queryService.ValidatorOutstandingRewards({
              validatorAddress
            });
            return response;
          },
          validatorSlashes: async (validatorAddress, startingHeight, endingHeight, paginationKey) => {
            const response = await queryService.ValidatorSlashes({
              validatorAddress,
              startingHeight: BigInt(startingHeight),
              endingHeight: BigInt(endingHeight),
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          }
        }
      };
    }
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/evidence/aminomessages.js
var require_aminomessages5 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/evidence/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAminoMsgSubmitEvidence = isAminoMsgSubmitEvidence;
    exports.createEvidenceAminoConverters = createEvidenceAminoConverters;
    function isAminoMsgSubmitEvidence(msg) {
      return msg.type === "cosmos-sdk/MsgSubmitEvidence";
    }
    function createEvidenceAminoConverters() {
      throw new Error("Not implemented");
    }
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/feegrant/aminomessages.js
var require_aminomessages6 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/feegrant/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createFeegrantAminoConverters = createFeegrantAminoConverters;
    function createFeegrantAminoConverters() {
      return {
        // For Cosmos SDK < 0.46 the Amino JSON codec was broken on chain and thus inaccessible.
        // Now this can be implemented for 0.46+ chains, see
        // https://github.com/cosmos/cosmjs/issues/1092
        //
        // "/cosmos.feegrant.v1beta1.MsgGrantAllowance": IMPLEMENT_ME,
        // "/cosmos.feegrant.v1beta1.MsgRevokeAllowance": IMPLEMENT_ME,
      };
    }
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/feegrant/v1beta1/tx.js
var require_tx5 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/feegrant/v1beta1/tx.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MsgClientImpl = exports.MsgPruneAllowancesResponse = exports.MsgPruneAllowances = exports.MsgRevokeAllowanceResponse = exports.MsgRevokeAllowance = exports.MsgGrantAllowanceResponse = exports.MsgGrantAllowance = exports.protobufPackage = void 0;
    var any_1 = require_any();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.feegrant.v1beta1";
    function createBaseMsgGrantAllowance() {
      return {
        granter: "",
        grantee: "",
        allowance: void 0
      };
    }
    exports.MsgGrantAllowance = {
      typeUrl: "/cosmos.feegrant.v1beta1.MsgGrantAllowance",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.grantee !== "") {
          writer.uint32(18).string(message.grantee);
        }
        if (message.allowance !== void 0) {
          any_1.Any.encode(message.allowance, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgGrantAllowance();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.grantee = reader.string();
              break;
            case 3:
              message.allowance = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgGrantAllowance();
        if ((0, helpers_1.isSet)(object.granter))
          obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.grantee))
          obj.grantee = String(object.grantee);
        if ((0, helpers_1.isSet)(object.allowance))
          obj.allowance = any_1.Any.fromJSON(object.allowance);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        message.allowance !== void 0 && (obj.allowance = message.allowance ? any_1.Any.toJSON(message.allowance) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgGrantAllowance();
        message.granter = object.granter ?? "";
        message.grantee = object.grantee ?? "";
        if (object.allowance !== void 0 && object.allowance !== null) {
          message.allowance = any_1.Any.fromPartial(object.allowance);
        }
        return message;
      }
    };
    function createBaseMsgGrantAllowanceResponse() {
      return {};
    }
    exports.MsgGrantAllowanceResponse = {
      typeUrl: "/cosmos.feegrant.v1beta1.MsgGrantAllowanceResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgGrantAllowanceResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgGrantAllowanceResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgGrantAllowanceResponse();
        return message;
      }
    };
    function createBaseMsgRevokeAllowance() {
      return {
        granter: "",
        grantee: ""
      };
    }
    exports.MsgRevokeAllowance = {
      typeUrl: "/cosmos.feegrant.v1beta1.MsgRevokeAllowance",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.grantee !== "") {
          writer.uint32(18).string(message.grantee);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRevokeAllowance();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.grantee = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgRevokeAllowance();
        if ((0, helpers_1.isSet)(object.granter))
          obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.grantee))
          obj.grantee = String(object.grantee);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgRevokeAllowance();
        message.granter = object.granter ?? "";
        message.grantee = object.grantee ?? "";
        return message;
      }
    };
    function createBaseMsgRevokeAllowanceResponse() {
      return {};
    }
    exports.MsgRevokeAllowanceResponse = {
      typeUrl: "/cosmos.feegrant.v1beta1.MsgRevokeAllowanceResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRevokeAllowanceResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgRevokeAllowanceResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgRevokeAllowanceResponse();
        return message;
      }
    };
    function createBaseMsgPruneAllowances() {
      return {
        pruner: ""
      };
    }
    exports.MsgPruneAllowances = {
      typeUrl: "/cosmos.feegrant.v1beta1.MsgPruneAllowances",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pruner !== "") {
          writer.uint32(10).string(message.pruner);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgPruneAllowances();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pruner = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgPruneAllowances();
        if ((0, helpers_1.isSet)(object.pruner))
          obj.pruner = String(object.pruner);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.pruner !== void 0 && (obj.pruner = message.pruner);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgPruneAllowances();
        message.pruner = object.pruner ?? "";
        return message;
      }
    };
    function createBaseMsgPruneAllowancesResponse() {
      return {};
    }
    exports.MsgPruneAllowancesResponse = {
      typeUrl: "/cosmos.feegrant.v1beta1.MsgPruneAllowancesResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgPruneAllowancesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgPruneAllowancesResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgPruneAllowancesResponse();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.GrantAllowance = this.GrantAllowance.bind(this);
        this.RevokeAllowance = this.RevokeAllowance.bind(this);
        this.PruneAllowances = this.PruneAllowances.bind(this);
      }
      GrantAllowance(request) {
        const data2 = exports.MsgGrantAllowance.encode(request).finish();
        const promise = this.rpc.request("cosmos.feegrant.v1beta1.Msg", "GrantAllowance", data2);
        return promise.then((data3) => exports.MsgGrantAllowanceResponse.decode(new binary_1.BinaryReader(data3)));
      }
      RevokeAllowance(request) {
        const data2 = exports.MsgRevokeAllowance.encode(request).finish();
        const promise = this.rpc.request("cosmos.feegrant.v1beta1.Msg", "RevokeAllowance", data2);
        return promise.then((data3) => exports.MsgRevokeAllowanceResponse.decode(new binary_1.BinaryReader(data3)));
      }
      PruneAllowances(request) {
        const data2 = exports.MsgPruneAllowances.encode(request).finish();
        const promise = this.rpc.request("cosmos.feegrant.v1beta1.Msg", "PruneAllowances", data2);
        return promise.then((data3) => exports.MsgPruneAllowancesResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.MsgClientImpl = MsgClientImpl;
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/feegrant/messages.js
var require_messages4 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/feegrant/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.feegrantTypes = void 0;
    var tx_1 = require_tx5();
    exports.feegrantTypes = [
      ["/cosmos.feegrant.v1beta1.MsgGrantAllowance", tx_1.MsgGrantAllowance],
      ["/cosmos.feegrant.v1beta1.MsgRevokeAllowance", tx_1.MsgRevokeAllowance]
    ];
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/google/protobuf/duration.js
var require_duration = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/google/protobuf/duration.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Duration = exports.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "google.protobuf";
    function createBaseDuration() {
      return {
        seconds: BigInt(0),
        nanos: 0
      };
    }
    exports.Duration = {
      typeUrl: "/google.protobuf.Duration",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.seconds !== BigInt(0)) {
          writer.uint32(8).int64(message.seconds);
        }
        if (message.nanos !== 0) {
          writer.uint32(16).int32(message.nanos);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDuration();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.seconds = reader.int64();
              break;
            case 2:
              message.nanos = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDuration();
        if ((0, helpers_1.isSet)(object.seconds))
          obj.seconds = BigInt(object.seconds.toString());
        if ((0, helpers_1.isSet)(object.nanos))
          obj.nanos = Number(object.nanos);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.seconds !== void 0 && (obj.seconds = (message.seconds || BigInt(0)).toString());
        message.nanos !== void 0 && (obj.nanos = Math.round(message.nanos));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDuration();
        if (object.seconds !== void 0 && object.seconds !== null) {
          message.seconds = BigInt(object.seconds.toString());
        }
        message.nanos = object.nanos ?? 0;
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/feegrant/v1beta1/feegrant.js
var require_feegrant = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/feegrant/v1beta1/feegrant.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Grant = exports.AllowedMsgAllowance = exports.PeriodicAllowance = exports.BasicAllowance = exports.protobufPackage = void 0;
    var coin_1 = require_coin();
    var timestamp_1 = require_timestamp();
    var duration_1 = require_duration();
    var any_1 = require_any();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.feegrant.v1beta1";
    function createBaseBasicAllowance() {
      return {
        spendLimit: [],
        expiration: void 0
      };
    }
    exports.BasicAllowance = {
      typeUrl: "/cosmos.feegrant.v1beta1.BasicAllowance",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.spendLimit) {
          coin_1.Coin.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.expiration !== void 0) {
          timestamp_1.Timestamp.encode(message.expiration, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBasicAllowance();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.spendLimit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.expiration = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBasicAllowance();
        if (Array.isArray(object?.spendLimit))
          obj.spendLimit = object.spendLimit.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.expiration))
          obj.expiration = (0, helpers_1.fromJsonTimestamp)(object.expiration);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.spendLimit) {
          obj.spendLimit = message.spendLimit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.spendLimit = [];
        }
        message.expiration !== void 0 && (obj.expiration = (0, helpers_1.fromTimestamp)(message.expiration).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBasicAllowance();
        message.spendLimit = object.spendLimit?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        if (object.expiration !== void 0 && object.expiration !== null) {
          message.expiration = timestamp_1.Timestamp.fromPartial(object.expiration);
        }
        return message;
      }
    };
    function createBasePeriodicAllowance() {
      return {
        basic: exports.BasicAllowance.fromPartial({}),
        period: duration_1.Duration.fromPartial({}),
        periodSpendLimit: [],
        periodCanSpend: [],
        periodReset: timestamp_1.Timestamp.fromPartial({})
      };
    }
    exports.PeriodicAllowance = {
      typeUrl: "/cosmos.feegrant.v1beta1.PeriodicAllowance",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.basic !== void 0) {
          exports.BasicAllowance.encode(message.basic, writer.uint32(10).fork()).ldelim();
        }
        if (message.period !== void 0) {
          duration_1.Duration.encode(message.period, writer.uint32(18).fork()).ldelim();
        }
        for (const v9 of message.periodSpendLimit) {
          coin_1.Coin.encode(v9, writer.uint32(26).fork()).ldelim();
        }
        for (const v9 of message.periodCanSpend) {
          coin_1.Coin.encode(v9, writer.uint32(34).fork()).ldelim();
        }
        if (message.periodReset !== void 0) {
          timestamp_1.Timestamp.encode(message.periodReset, writer.uint32(42).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePeriodicAllowance();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.basic = exports.BasicAllowance.decode(reader, reader.uint32());
              break;
            case 2:
              message.period = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 3:
              message.periodSpendLimit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 4:
              message.periodCanSpend.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 5:
              message.periodReset = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePeriodicAllowance();
        if ((0, helpers_1.isSet)(object.basic))
          obj.basic = exports.BasicAllowance.fromJSON(object.basic);
        if ((0, helpers_1.isSet)(object.period))
          obj.period = duration_1.Duration.fromJSON(object.period);
        if (Array.isArray(object?.periodSpendLimit))
          obj.periodSpendLimit = object.periodSpendLimit.map((e) => coin_1.Coin.fromJSON(e));
        if (Array.isArray(object?.periodCanSpend))
          obj.periodCanSpend = object.periodCanSpend.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.periodReset))
          obj.periodReset = (0, helpers_1.fromJsonTimestamp)(object.periodReset);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.basic !== void 0 && (obj.basic = message.basic ? exports.BasicAllowance.toJSON(message.basic) : void 0);
        message.period !== void 0 && (obj.period = message.period ? duration_1.Duration.toJSON(message.period) : void 0);
        if (message.periodSpendLimit) {
          obj.periodSpendLimit = message.periodSpendLimit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.periodSpendLimit = [];
        }
        if (message.periodCanSpend) {
          obj.periodCanSpend = message.periodCanSpend.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.periodCanSpend = [];
        }
        message.periodReset !== void 0 && (obj.periodReset = (0, helpers_1.fromTimestamp)(message.periodReset).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBasePeriodicAllowance();
        if (object.basic !== void 0 && object.basic !== null) {
          message.basic = exports.BasicAllowance.fromPartial(object.basic);
        }
        if (object.period !== void 0 && object.period !== null) {
          message.period = duration_1.Duration.fromPartial(object.period);
        }
        message.periodSpendLimit = object.periodSpendLimit?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        message.periodCanSpend = object.periodCanSpend?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        if (object.periodReset !== void 0 && object.periodReset !== null) {
          message.periodReset = timestamp_1.Timestamp.fromPartial(object.periodReset);
        }
        return message;
      }
    };
    function createBaseAllowedMsgAllowance() {
      return {
        allowance: void 0,
        allowedMessages: []
      };
    }
    exports.AllowedMsgAllowance = {
      typeUrl: "/cosmos.feegrant.v1beta1.AllowedMsgAllowance",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.allowance !== void 0) {
          any_1.Any.encode(message.allowance, writer.uint32(10).fork()).ldelim();
        }
        for (const v9 of message.allowedMessages) {
          writer.uint32(18).string(v9);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAllowedMsgAllowance();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.allowance = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.allowedMessages.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseAllowedMsgAllowance();
        if ((0, helpers_1.isSet)(object.allowance))
          obj.allowance = any_1.Any.fromJSON(object.allowance);
        if (Array.isArray(object?.allowedMessages))
          obj.allowedMessages = object.allowedMessages.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.allowance !== void 0 && (obj.allowance = message.allowance ? any_1.Any.toJSON(message.allowance) : void 0);
        if (message.allowedMessages) {
          obj.allowedMessages = message.allowedMessages.map((e) => e);
        } else {
          obj.allowedMessages = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseAllowedMsgAllowance();
        if (object.allowance !== void 0 && object.allowance !== null) {
          message.allowance = any_1.Any.fromPartial(object.allowance);
        }
        message.allowedMessages = object.allowedMessages?.map((e) => e) || [];
        return message;
      }
    };
    function createBaseGrant() {
      return {
        granter: "",
        grantee: "",
        allowance: void 0
      };
    }
    exports.Grant = {
      typeUrl: "/cosmos.feegrant.v1beta1.Grant",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.grantee !== "") {
          writer.uint32(18).string(message.grantee);
        }
        if (message.allowance !== void 0) {
          any_1.Any.encode(message.allowance, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGrant();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.grantee = reader.string();
              break;
            case 3:
              message.allowance = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGrant();
        if ((0, helpers_1.isSet)(object.granter))
          obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.grantee))
          obj.grantee = String(object.grantee);
        if ((0, helpers_1.isSet)(object.allowance))
          obj.allowance = any_1.Any.fromJSON(object.allowance);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        message.allowance !== void 0 && (obj.allowance = message.allowance ? any_1.Any.toJSON(message.allowance) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGrant();
        message.granter = object.granter ?? "";
        message.grantee = object.grantee ?? "";
        if (object.allowance !== void 0 && object.allowance !== null) {
          message.allowance = any_1.Any.fromPartial(object.allowance);
        }
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/feegrant/v1beta1/query.js
var require_query5 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/feegrant/v1beta1/query.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryClientImpl = exports.QueryAllowancesByGranterResponse = exports.QueryAllowancesByGranterRequest = exports.QueryAllowancesResponse = exports.QueryAllowancesRequest = exports.QueryAllowanceResponse = exports.QueryAllowanceRequest = exports.protobufPackage = void 0;
    var pagination_1 = require_pagination();
    var feegrant_1 = require_feegrant();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.feegrant.v1beta1";
    function createBaseQueryAllowanceRequest() {
      return {
        granter: "",
        grantee: ""
      };
    }
    exports.QueryAllowanceRequest = {
      typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowanceRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.grantee !== "") {
          writer.uint32(18).string(message.grantee);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAllowanceRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.grantee = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAllowanceRequest();
        if ((0, helpers_1.isSet)(object.granter))
          obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.grantee))
          obj.grantee = String(object.grantee);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAllowanceRequest();
        message.granter = object.granter ?? "";
        message.grantee = object.grantee ?? "";
        return message;
      }
    };
    function createBaseQueryAllowanceResponse() {
      return {
        allowance: void 0
      };
    }
    exports.QueryAllowanceResponse = {
      typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowanceResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.allowance !== void 0) {
          feegrant_1.Grant.encode(message.allowance, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAllowanceResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.allowance = feegrant_1.Grant.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAllowanceResponse();
        if ((0, helpers_1.isSet)(object.allowance))
          obj.allowance = feegrant_1.Grant.fromJSON(object.allowance);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.allowance !== void 0 && (obj.allowance = message.allowance ? feegrant_1.Grant.toJSON(message.allowance) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAllowanceResponse();
        if (object.allowance !== void 0 && object.allowance !== null) {
          message.allowance = feegrant_1.Grant.fromPartial(object.allowance);
        }
        return message;
      }
    };
    function createBaseQueryAllowancesRequest() {
      return {
        grantee: "",
        pagination: void 0
      };
    }
    exports.QueryAllowancesRequest = {
      typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowancesRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.grantee !== "") {
          writer.uint32(10).string(message.grantee);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAllowancesRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.grantee = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAllowancesRequest();
        if ((0, helpers_1.isSet)(object.grantee))
          obj.grantee = String(object.grantee);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.grantee !== void 0 && (obj.grantee = message.grantee);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAllowancesRequest();
        message.grantee = object.grantee ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryAllowancesResponse() {
      return {
        allowances: [],
        pagination: void 0
      };
    }
    exports.QueryAllowancesResponse = {
      typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowancesResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.allowances) {
          feegrant_1.Grant.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAllowancesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.allowances.push(feegrant_1.Grant.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAllowancesResponse();
        if (Array.isArray(object?.allowances))
          obj.allowances = object.allowances.map((e) => feegrant_1.Grant.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.allowances) {
          obj.allowances = message.allowances.map((e) => e ? feegrant_1.Grant.toJSON(e) : void 0);
        } else {
          obj.allowances = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAllowancesResponse();
        message.allowances = object.allowances?.map((e) => feegrant_1.Grant.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryAllowancesByGranterRequest() {
      return {
        granter: "",
        pagination: void 0
      };
    }
    exports.QueryAllowancesByGranterRequest = {
      typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowancesByGranterRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.granter !== "") {
          writer.uint32(10).string(message.granter);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAllowancesByGranterRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.granter = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAllowancesByGranterRequest();
        if ((0, helpers_1.isSet)(object.granter))
          obj.granter = String(object.granter);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.granter !== void 0 && (obj.granter = message.granter);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAllowancesByGranterRequest();
        message.granter = object.granter ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryAllowancesByGranterResponse() {
      return {
        allowances: [],
        pagination: void 0
      };
    }
    exports.QueryAllowancesByGranterResponse = {
      typeUrl: "/cosmos.feegrant.v1beta1.QueryAllowancesByGranterResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.allowances) {
          feegrant_1.Grant.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAllowancesByGranterResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.allowances.push(feegrant_1.Grant.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAllowancesByGranterResponse();
        if (Array.isArray(object?.allowances))
          obj.allowances = object.allowances.map((e) => feegrant_1.Grant.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.allowances) {
          obj.allowances = message.allowances.map((e) => e ? feegrant_1.Grant.toJSON(e) : void 0);
        } else {
          obj.allowances = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAllowancesByGranterResponse();
        message.allowances = object.allowances?.map((e) => feegrant_1.Grant.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Allowance = this.Allowance.bind(this);
        this.Allowances = this.Allowances.bind(this);
        this.AllowancesByGranter = this.AllowancesByGranter.bind(this);
      }
      Allowance(request) {
        const data2 = exports.QueryAllowanceRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.feegrant.v1beta1.Query", "Allowance", data2);
        return promise.then((data3) => exports.QueryAllowanceResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Allowances(request) {
        const data2 = exports.QueryAllowancesRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.feegrant.v1beta1.Query", "Allowances", data2);
        return promise.then((data3) => exports.QueryAllowancesResponse.decode(new binary_1.BinaryReader(data3)));
      }
      AllowancesByGranter(request) {
        const data2 = exports.QueryAllowancesByGranterRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.feegrant.v1beta1.Query", "AllowancesByGranter", data2);
        return promise.then((data3) => exports.QueryAllowancesByGranterResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.QueryClientImpl = QueryClientImpl;
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/feegrant/queries.js
var require_queries5 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/feegrant/queries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupFeegrantExtension = setupFeegrantExtension;
    var query_1 = require_query5();
    var queryclient_1 = require_queryclient2();
    function setupFeegrantExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        feegrant: {
          allowance: async (granter, grantee) => {
            const response = await queryService.Allowance({
              granter,
              grantee
            });
            return response;
          },
          allowances: async (grantee, paginationKey) => {
            const response = await queryService.Allowances({
              grantee,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          }
        }
      };
    }
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/gov/v1beta1/gov.js
var require_gov = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/gov/v1beta1/gov.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TallyParams = exports.VotingParams = exports.DepositParams = exports.Vote = exports.TallyResult = exports.Proposal = exports.Deposit = exports.TextProposal = exports.WeightedVoteOption = exports.proposalStatusToJSON = exports.proposalStatusFromJSON = exports.ProposalStatus = exports.voteOptionToJSON = exports.voteOptionFromJSON = exports.VoteOption = exports.protobufPackage = void 0;
    var coin_1 = require_coin();
    var any_1 = require_any();
    var timestamp_1 = require_timestamp();
    var duration_1 = require_duration();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.gov.v1beta1";
    var VoteOption;
    (function(VoteOption2) {
      VoteOption2[VoteOption2["VOTE_OPTION_UNSPECIFIED"] = 0] = "VOTE_OPTION_UNSPECIFIED";
      VoteOption2[VoteOption2["VOTE_OPTION_YES"] = 1] = "VOTE_OPTION_YES";
      VoteOption2[VoteOption2["VOTE_OPTION_ABSTAIN"] = 2] = "VOTE_OPTION_ABSTAIN";
      VoteOption2[VoteOption2["VOTE_OPTION_NO"] = 3] = "VOTE_OPTION_NO";
      VoteOption2[VoteOption2["VOTE_OPTION_NO_WITH_VETO"] = 4] = "VOTE_OPTION_NO_WITH_VETO";
      VoteOption2[VoteOption2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(VoteOption || (exports.VoteOption = VoteOption = {}));
    function voteOptionFromJSON(object) {
      switch (object) {
        case 0:
        case "VOTE_OPTION_UNSPECIFIED":
          return VoteOption.VOTE_OPTION_UNSPECIFIED;
        case 1:
        case "VOTE_OPTION_YES":
          return VoteOption.VOTE_OPTION_YES;
        case 2:
        case "VOTE_OPTION_ABSTAIN":
          return VoteOption.VOTE_OPTION_ABSTAIN;
        case 3:
        case "VOTE_OPTION_NO":
          return VoteOption.VOTE_OPTION_NO;
        case 4:
        case "VOTE_OPTION_NO_WITH_VETO":
          return VoteOption.VOTE_OPTION_NO_WITH_VETO;
        case -1:
        case "UNRECOGNIZED":
        default:
          return VoteOption.UNRECOGNIZED;
      }
    }
    exports.voteOptionFromJSON = voteOptionFromJSON;
    function voteOptionToJSON(object) {
      switch (object) {
        case VoteOption.VOTE_OPTION_UNSPECIFIED:
          return "VOTE_OPTION_UNSPECIFIED";
        case VoteOption.VOTE_OPTION_YES:
          return "VOTE_OPTION_YES";
        case VoteOption.VOTE_OPTION_ABSTAIN:
          return "VOTE_OPTION_ABSTAIN";
        case VoteOption.VOTE_OPTION_NO:
          return "VOTE_OPTION_NO";
        case VoteOption.VOTE_OPTION_NO_WITH_VETO:
          return "VOTE_OPTION_NO_WITH_VETO";
        case VoteOption.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.voteOptionToJSON = voteOptionToJSON;
    var ProposalStatus;
    (function(ProposalStatus2) {
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_UNSPECIFIED"] = 0] = "PROPOSAL_STATUS_UNSPECIFIED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_DEPOSIT_PERIOD"] = 1] = "PROPOSAL_STATUS_DEPOSIT_PERIOD";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_VOTING_PERIOD"] = 2] = "PROPOSAL_STATUS_VOTING_PERIOD";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_PASSED"] = 3] = "PROPOSAL_STATUS_PASSED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_REJECTED"] = 4] = "PROPOSAL_STATUS_REJECTED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_FAILED"] = 5] = "PROPOSAL_STATUS_FAILED";
      ProposalStatus2[ProposalStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ProposalStatus || (exports.ProposalStatus = ProposalStatus = {}));
    function proposalStatusFromJSON(object) {
      switch (object) {
        case 0:
        case "PROPOSAL_STATUS_UNSPECIFIED":
          return ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED;
        case 1:
        case "PROPOSAL_STATUS_DEPOSIT_PERIOD":
          return ProposalStatus.PROPOSAL_STATUS_DEPOSIT_PERIOD;
        case 2:
        case "PROPOSAL_STATUS_VOTING_PERIOD":
          return ProposalStatus.PROPOSAL_STATUS_VOTING_PERIOD;
        case 3:
        case "PROPOSAL_STATUS_PASSED":
          return ProposalStatus.PROPOSAL_STATUS_PASSED;
        case 4:
        case "PROPOSAL_STATUS_REJECTED":
          return ProposalStatus.PROPOSAL_STATUS_REJECTED;
        case 5:
        case "PROPOSAL_STATUS_FAILED":
          return ProposalStatus.PROPOSAL_STATUS_FAILED;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ProposalStatus.UNRECOGNIZED;
      }
    }
    exports.proposalStatusFromJSON = proposalStatusFromJSON;
    function proposalStatusToJSON(object) {
      switch (object) {
        case ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED:
          return "PROPOSAL_STATUS_UNSPECIFIED";
        case ProposalStatus.PROPOSAL_STATUS_DEPOSIT_PERIOD:
          return "PROPOSAL_STATUS_DEPOSIT_PERIOD";
        case ProposalStatus.PROPOSAL_STATUS_VOTING_PERIOD:
          return "PROPOSAL_STATUS_VOTING_PERIOD";
        case ProposalStatus.PROPOSAL_STATUS_PASSED:
          return "PROPOSAL_STATUS_PASSED";
        case ProposalStatus.PROPOSAL_STATUS_REJECTED:
          return "PROPOSAL_STATUS_REJECTED";
        case ProposalStatus.PROPOSAL_STATUS_FAILED:
          return "PROPOSAL_STATUS_FAILED";
        case ProposalStatus.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.proposalStatusToJSON = proposalStatusToJSON;
    function createBaseWeightedVoteOption() {
      return {
        option: 0,
        weight: ""
      };
    }
    exports.WeightedVoteOption = {
      typeUrl: "/cosmos.gov.v1beta1.WeightedVoteOption",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.option !== 0) {
          writer.uint32(8).int32(message.option);
        }
        if (message.weight !== "") {
          writer.uint32(18).string(message.weight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWeightedVoteOption();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.option = reader.int32();
              break;
            case 2:
              message.weight = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseWeightedVoteOption();
        if ((0, helpers_1.isSet)(object.option))
          obj.option = voteOptionFromJSON(object.option);
        if ((0, helpers_1.isSet)(object.weight))
          obj.weight = String(object.weight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.option !== void 0 && (obj.option = voteOptionToJSON(message.option));
        message.weight !== void 0 && (obj.weight = message.weight);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseWeightedVoteOption();
        message.option = object.option ?? 0;
        message.weight = object.weight ?? "";
        return message;
      }
    };
    function createBaseTextProposal() {
      return {
        title: "",
        description: ""
      };
    }
    exports.TextProposal = {
      typeUrl: "/cosmos.gov.v1beta1.TextProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTextProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTextProposal();
        if ((0, helpers_1.isSet)(object.title))
          obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.description))
          obj.description = String(object.description);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTextProposal();
        message.title = object.title ?? "";
        message.description = object.description ?? "";
        return message;
      }
    };
    function createBaseDeposit() {
      return {
        proposalId: BigInt(0),
        depositor: "",
        amount: []
      };
    }
    exports.Deposit = {
      typeUrl: "/cosmos.gov.v1beta1.Deposit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.depositor !== "") {
          writer.uint32(18).string(message.depositor);
        }
        for (const v9 of message.amount) {
          coin_1.Coin.encode(v9, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDeposit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.depositor = reader.string();
              break;
            case 3:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDeposit();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.depositor))
          obj.depositor = String(object.depositor);
        if (Array.isArray(object?.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.depositor !== void 0 && (obj.depositor = message.depositor);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDeposit();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.depositor = object.depositor ?? "";
        message.amount = object.amount?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseProposal() {
      return {
        proposalId: BigInt(0),
        content: void 0,
        status: 0,
        finalTallyResult: exports.TallyResult.fromPartial({}),
        submitTime: timestamp_1.Timestamp.fromPartial({}),
        depositEndTime: timestamp_1.Timestamp.fromPartial({}),
        totalDeposit: [],
        votingStartTime: timestamp_1.Timestamp.fromPartial({}),
        votingEndTime: timestamp_1.Timestamp.fromPartial({})
      };
    }
    exports.Proposal = {
      typeUrl: "/cosmos.gov.v1beta1.Proposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.content !== void 0) {
          any_1.Any.encode(message.content, writer.uint32(18).fork()).ldelim();
        }
        if (message.status !== 0) {
          writer.uint32(24).int32(message.status);
        }
        if (message.finalTallyResult !== void 0) {
          exports.TallyResult.encode(message.finalTallyResult, writer.uint32(34).fork()).ldelim();
        }
        if (message.submitTime !== void 0) {
          timestamp_1.Timestamp.encode(message.submitTime, writer.uint32(42).fork()).ldelim();
        }
        if (message.depositEndTime !== void 0) {
          timestamp_1.Timestamp.encode(message.depositEndTime, writer.uint32(50).fork()).ldelim();
        }
        for (const v9 of message.totalDeposit) {
          coin_1.Coin.encode(v9, writer.uint32(58).fork()).ldelim();
        }
        if (message.votingStartTime !== void 0) {
          timestamp_1.Timestamp.encode(message.votingStartTime, writer.uint32(66).fork()).ldelim();
        }
        if (message.votingEndTime !== void 0) {
          timestamp_1.Timestamp.encode(message.votingEndTime, writer.uint32(74).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.content = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.status = reader.int32();
              break;
            case 4:
              message.finalTallyResult = exports.TallyResult.decode(reader, reader.uint32());
              break;
            case 5:
              message.submitTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 6:
              message.depositEndTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 7:
              message.totalDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 8:
              message.votingStartTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 9:
              message.votingEndTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseProposal();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.content))
          obj.content = any_1.Any.fromJSON(object.content);
        if ((0, helpers_1.isSet)(object.status))
          obj.status = proposalStatusFromJSON(object.status);
        if ((0, helpers_1.isSet)(object.finalTallyResult))
          obj.finalTallyResult = exports.TallyResult.fromJSON(object.finalTallyResult);
        if ((0, helpers_1.isSet)(object.submitTime))
          obj.submitTime = (0, helpers_1.fromJsonTimestamp)(object.submitTime);
        if ((0, helpers_1.isSet)(object.depositEndTime))
          obj.depositEndTime = (0, helpers_1.fromJsonTimestamp)(object.depositEndTime);
        if (Array.isArray(object?.totalDeposit))
          obj.totalDeposit = object.totalDeposit.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.votingStartTime))
          obj.votingStartTime = (0, helpers_1.fromJsonTimestamp)(object.votingStartTime);
        if ((0, helpers_1.isSet)(object.votingEndTime))
          obj.votingEndTime = (0, helpers_1.fromJsonTimestamp)(object.votingEndTime);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.content !== void 0 && (obj.content = message.content ? any_1.Any.toJSON(message.content) : void 0);
        message.status !== void 0 && (obj.status = proposalStatusToJSON(message.status));
        message.finalTallyResult !== void 0 && (obj.finalTallyResult = message.finalTallyResult ? exports.TallyResult.toJSON(message.finalTallyResult) : void 0);
        message.submitTime !== void 0 && (obj.submitTime = (0, helpers_1.fromTimestamp)(message.submitTime).toISOString());
        message.depositEndTime !== void 0 && (obj.depositEndTime = (0, helpers_1.fromTimestamp)(message.depositEndTime).toISOString());
        if (message.totalDeposit) {
          obj.totalDeposit = message.totalDeposit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.totalDeposit = [];
        }
        message.votingStartTime !== void 0 && (obj.votingStartTime = (0, helpers_1.fromTimestamp)(message.votingStartTime).toISOString());
        message.votingEndTime !== void 0 && (obj.votingEndTime = (0, helpers_1.fromTimestamp)(message.votingEndTime).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseProposal();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        if (object.content !== void 0 && object.content !== null) {
          message.content = any_1.Any.fromPartial(object.content);
        }
        message.status = object.status ?? 0;
        if (object.finalTallyResult !== void 0 && object.finalTallyResult !== null) {
          message.finalTallyResult = exports.TallyResult.fromPartial(object.finalTallyResult);
        }
        if (object.submitTime !== void 0 && object.submitTime !== null) {
          message.submitTime = timestamp_1.Timestamp.fromPartial(object.submitTime);
        }
        if (object.depositEndTime !== void 0 && object.depositEndTime !== null) {
          message.depositEndTime = timestamp_1.Timestamp.fromPartial(object.depositEndTime);
        }
        message.totalDeposit = object.totalDeposit?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        if (object.votingStartTime !== void 0 && object.votingStartTime !== null) {
          message.votingStartTime = timestamp_1.Timestamp.fromPartial(object.votingStartTime);
        }
        if (object.votingEndTime !== void 0 && object.votingEndTime !== null) {
          message.votingEndTime = timestamp_1.Timestamp.fromPartial(object.votingEndTime);
        }
        return message;
      }
    };
    function createBaseTallyResult() {
      return {
        yes: "",
        abstain: "",
        no: "",
        noWithVeto: ""
      };
    }
    exports.TallyResult = {
      typeUrl: "/cosmos.gov.v1beta1.TallyResult",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.yes !== "") {
          writer.uint32(10).string(message.yes);
        }
        if (message.abstain !== "") {
          writer.uint32(18).string(message.abstain);
        }
        if (message.no !== "") {
          writer.uint32(26).string(message.no);
        }
        if (message.noWithVeto !== "") {
          writer.uint32(34).string(message.noWithVeto);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTallyResult();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.yes = reader.string();
              break;
            case 2:
              message.abstain = reader.string();
              break;
            case 3:
              message.no = reader.string();
              break;
            case 4:
              message.noWithVeto = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTallyResult();
        if ((0, helpers_1.isSet)(object.yes))
          obj.yes = String(object.yes);
        if ((0, helpers_1.isSet)(object.abstain))
          obj.abstain = String(object.abstain);
        if ((0, helpers_1.isSet)(object.no))
          obj.no = String(object.no);
        if ((0, helpers_1.isSet)(object.noWithVeto))
          obj.noWithVeto = String(object.noWithVeto);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.yes !== void 0 && (obj.yes = message.yes);
        message.abstain !== void 0 && (obj.abstain = message.abstain);
        message.no !== void 0 && (obj.no = message.no);
        message.noWithVeto !== void 0 && (obj.noWithVeto = message.noWithVeto);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTallyResult();
        message.yes = object.yes ?? "";
        message.abstain = object.abstain ?? "";
        message.no = object.no ?? "";
        message.noWithVeto = object.noWithVeto ?? "";
        return message;
      }
    };
    function createBaseVote() {
      return {
        proposalId: BigInt(0),
        voter: "",
        option: 0,
        options: []
      };
    }
    exports.Vote = {
      typeUrl: "/cosmos.gov.v1beta1.Vote",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        if (message.option !== 0) {
          writer.uint32(24).int32(message.option);
        }
        for (const v9 of message.options) {
          exports.WeightedVoteOption.encode(v9, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVote();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 3:
              message.option = reader.int32();
              break;
            case 4:
              message.options.push(exports.WeightedVoteOption.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseVote();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.voter))
          obj.voter = String(object.voter);
        if ((0, helpers_1.isSet)(object.option))
          obj.option = voteOptionFromJSON(object.option);
        if (Array.isArray(object?.options))
          obj.options = object.options.map((e) => exports.WeightedVoteOption.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.voter !== void 0 && (obj.voter = message.voter);
        message.option !== void 0 && (obj.option = voteOptionToJSON(message.option));
        if (message.options) {
          obj.options = message.options.map((e) => e ? exports.WeightedVoteOption.toJSON(e) : void 0);
        } else {
          obj.options = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseVote();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.voter = object.voter ?? "";
        message.option = object.option ?? 0;
        message.options = object.options?.map((e) => exports.WeightedVoteOption.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseDepositParams() {
      return {
        minDeposit: [],
        maxDepositPeriod: duration_1.Duration.fromPartial({})
      };
    }
    exports.DepositParams = {
      typeUrl: "/cosmos.gov.v1beta1.DepositParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.minDeposit) {
          coin_1.Coin.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.maxDepositPeriod !== void 0) {
          duration_1.Duration.encode(message.maxDepositPeriod, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDepositParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.minDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.maxDepositPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDepositParams();
        if (Array.isArray(object?.minDeposit))
          obj.minDeposit = object.minDeposit.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.maxDepositPeriod))
          obj.maxDepositPeriod = duration_1.Duration.fromJSON(object.maxDepositPeriod);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.minDeposit) {
          obj.minDeposit = message.minDeposit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.minDeposit = [];
        }
        message.maxDepositPeriod !== void 0 && (obj.maxDepositPeriod = message.maxDepositPeriod ? duration_1.Duration.toJSON(message.maxDepositPeriod) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDepositParams();
        message.minDeposit = object.minDeposit?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        if (object.maxDepositPeriod !== void 0 && object.maxDepositPeriod !== null) {
          message.maxDepositPeriod = duration_1.Duration.fromPartial(object.maxDepositPeriod);
        }
        return message;
      }
    };
    function createBaseVotingParams() {
      return {
        votingPeriod: duration_1.Duration.fromPartial({})
      };
    }
    exports.VotingParams = {
      typeUrl: "/cosmos.gov.v1beta1.VotingParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.votingPeriod !== void 0) {
          duration_1.Duration.encode(message.votingPeriod, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVotingParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.votingPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseVotingParams();
        if ((0, helpers_1.isSet)(object.votingPeriod))
          obj.votingPeriod = duration_1.Duration.fromJSON(object.votingPeriod);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.votingPeriod !== void 0 && (obj.votingPeriod = message.votingPeriod ? duration_1.Duration.toJSON(message.votingPeriod) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseVotingParams();
        if (object.votingPeriod !== void 0 && object.votingPeriod !== null) {
          message.votingPeriod = duration_1.Duration.fromPartial(object.votingPeriod);
        }
        return message;
      }
    };
    function createBaseTallyParams() {
      return {
        quorum: new Uint8Array(),
        threshold: new Uint8Array(),
        vetoThreshold: new Uint8Array()
      };
    }
    exports.TallyParams = {
      typeUrl: "/cosmos.gov.v1beta1.TallyParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.quorum.length !== 0) {
          writer.uint32(10).bytes(message.quorum);
        }
        if (message.threshold.length !== 0) {
          writer.uint32(18).bytes(message.threshold);
        }
        if (message.vetoThreshold.length !== 0) {
          writer.uint32(26).bytes(message.vetoThreshold);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTallyParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.quorum = reader.bytes();
              break;
            case 2:
              message.threshold = reader.bytes();
              break;
            case 3:
              message.vetoThreshold = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTallyParams();
        if ((0, helpers_1.isSet)(object.quorum))
          obj.quorum = (0, helpers_1.bytesFromBase64)(object.quorum);
        if ((0, helpers_1.isSet)(object.threshold))
          obj.threshold = (0, helpers_1.bytesFromBase64)(object.threshold);
        if ((0, helpers_1.isSet)(object.vetoThreshold))
          obj.vetoThreshold = (0, helpers_1.bytesFromBase64)(object.vetoThreshold);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.quorum !== void 0 && (obj.quorum = (0, helpers_1.base64FromBytes)(message.quorum !== void 0 ? message.quorum : new Uint8Array()));
        message.threshold !== void 0 && (obj.threshold = (0, helpers_1.base64FromBytes)(message.threshold !== void 0 ? message.threshold : new Uint8Array()));
        message.vetoThreshold !== void 0 && (obj.vetoThreshold = (0, helpers_1.base64FromBytes)(message.vetoThreshold !== void 0 ? message.vetoThreshold : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTallyParams();
        message.quorum = object.quorum ?? new Uint8Array();
        message.threshold = object.threshold ?? new Uint8Array();
        message.vetoThreshold = object.vetoThreshold ?? new Uint8Array();
        return message;
      }
    };
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/gov/aminomessages.js
var require_aminomessages7 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/gov/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAminoMsgSubmitProposal = isAminoMsgSubmitProposal;
    exports.isAminoMsgVote = isAminoMsgVote;
    exports.isAminoMsgVoteWeighted = isAminoMsgVoteWeighted;
    exports.isAminoMsgDeposit = isAminoMsgDeposit;
    exports.createGovAminoConverters = createGovAminoConverters;
    var math_1 = require_build3();
    var utils_1 = require_build();
    var gov_1 = require_gov();
    var any_1 = require_any();
    var queryclient_1 = require_queryclient2();
    function isAminoMsgSubmitProposal(msg) {
      return msg.type === "cosmos-sdk/MsgSubmitProposal";
    }
    function isAminoMsgVote(msg) {
      return msg.type === "cosmos-sdk/MsgVote";
    }
    function isAminoMsgVoteWeighted(msg) {
      return msg.type === "cosmos-sdk/MsgVoteWeighted";
    }
    function isAminoMsgDeposit(msg) {
      return msg.type === "cosmos-sdk/MsgDeposit";
    }
    function createGovAminoConverters() {
      return {
        "/cosmos.gov.v1beta1.MsgDeposit": {
          aminoType: "cosmos-sdk/MsgDeposit",
          toAmino: ({ amount, depositor, proposalId }) => {
            return {
              amount,
              depositor,
              proposal_id: proposalId.toString()
            };
          },
          fromAmino: ({ amount, depositor, proposal_id }) => {
            return {
              amount: Array.from(amount),
              depositor,
              proposalId: BigInt(proposal_id)
            };
          }
        },
        "/cosmos.gov.v1beta1.MsgVote": {
          aminoType: "cosmos-sdk/MsgVote",
          toAmino: ({ option, proposalId, voter }) => {
            return {
              option,
              proposal_id: proposalId.toString(),
              voter
            };
          },
          fromAmino: ({ option, proposal_id, voter }) => {
            return {
              option: (0, gov_1.voteOptionFromJSON)(option),
              proposalId: BigInt(proposal_id),
              voter
            };
          }
        },
        "/cosmos.gov.v1beta1.MsgVoteWeighted": {
          aminoType: "cosmos-sdk/MsgVoteWeighted",
          toAmino: ({ options, proposalId, voter }) => {
            return {
              options: options.map((o3) => ({
                option: o3.option,
                // Weight is between 0 and 1, so we always have 20 characters when printing all trailing
                // zeros (e.g. "0.700000000000000000" or "1.000000000000000000")
                weight: (0, queryclient_1.decodeCosmosSdkDecFromProto)(o3.weight).toString().padEnd(20, "0")
              })),
              proposal_id: proposalId.toString(),
              voter
            };
          },
          fromAmino: ({ options, proposal_id, voter }) => {
            return {
              proposalId: BigInt(proposal_id),
              voter,
              options: options.map((o3) => ({
                option: (0, gov_1.voteOptionFromJSON)(o3.option),
                weight: math_1.Decimal.fromUserInput(o3.weight, 18).atomics
              }))
            };
          }
        },
        "/cosmos.gov.v1beta1.MsgSubmitProposal": {
          aminoType: "cosmos-sdk/MsgSubmitProposal",
          toAmino: ({ initialDeposit, proposer, content }) => {
            (0, utils_1.assertDefinedAndNotNull)(content);
            let proposal;
            switch (content.typeUrl) {
              case "/cosmos.gov.v1beta1.TextProposal": {
                const textProposal = gov_1.TextProposal.decode(content.value);
                proposal = {
                  type: "cosmos-sdk/TextProposal",
                  value: {
                    description: textProposal.description,
                    title: textProposal.title
                  }
                };
                break;
              }
              default:
                throw new Error(`Unsupported proposal type: '${content.typeUrl}'`);
            }
            return {
              initial_deposit: initialDeposit,
              proposer,
              content: proposal
            };
          },
          fromAmino: ({ initial_deposit, proposer, content }) => {
            let any_content;
            switch (content.type) {
              case "cosmos-sdk/TextProposal": {
                const { value } = content;
                (0, utils_1.assert)((0, utils_1.isNonNullObject)(value));
                const { title, description } = value;
                (0, utils_1.assert)(typeof title === "string");
                (0, utils_1.assert)(typeof description === "string");
                any_content = any_1.Any.fromPartial({
                  typeUrl: "/cosmos.gov.v1beta1.TextProposal",
                  value: gov_1.TextProposal.encode(gov_1.TextProposal.fromPartial({
                    title,
                    description
                  })).finish()
                });
                break;
              }
              default:
                throw new Error(`Unsupported proposal type: '${content.type}'`);
            }
            return {
              initialDeposit: Array.from(initial_deposit),
              proposer,
              content: any_content
            };
          }
        }
      };
    }
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/gov/v1/gov.js
var require_gov2 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/gov/v1/gov.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Params = exports.TallyParams = exports.VotingParams = exports.DepositParams = exports.Vote = exports.TallyResult = exports.Proposal = exports.Deposit = exports.WeightedVoteOption = exports.proposalStatusToJSON = exports.proposalStatusFromJSON = exports.ProposalStatus = exports.voteOptionToJSON = exports.voteOptionFromJSON = exports.VoteOption = exports.protobufPackage = void 0;
    var coin_1 = require_coin();
    var any_1 = require_any();
    var timestamp_1 = require_timestamp();
    var duration_1 = require_duration();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.gov.v1";
    var VoteOption;
    (function(VoteOption2) {
      VoteOption2[VoteOption2["VOTE_OPTION_UNSPECIFIED"] = 0] = "VOTE_OPTION_UNSPECIFIED";
      VoteOption2[VoteOption2["VOTE_OPTION_YES"] = 1] = "VOTE_OPTION_YES";
      VoteOption2[VoteOption2["VOTE_OPTION_ABSTAIN"] = 2] = "VOTE_OPTION_ABSTAIN";
      VoteOption2[VoteOption2["VOTE_OPTION_NO"] = 3] = "VOTE_OPTION_NO";
      VoteOption2[VoteOption2["VOTE_OPTION_NO_WITH_VETO"] = 4] = "VOTE_OPTION_NO_WITH_VETO";
      VoteOption2[VoteOption2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(VoteOption || (exports.VoteOption = VoteOption = {}));
    function voteOptionFromJSON(object) {
      switch (object) {
        case 0:
        case "VOTE_OPTION_UNSPECIFIED":
          return VoteOption.VOTE_OPTION_UNSPECIFIED;
        case 1:
        case "VOTE_OPTION_YES":
          return VoteOption.VOTE_OPTION_YES;
        case 2:
        case "VOTE_OPTION_ABSTAIN":
          return VoteOption.VOTE_OPTION_ABSTAIN;
        case 3:
        case "VOTE_OPTION_NO":
          return VoteOption.VOTE_OPTION_NO;
        case 4:
        case "VOTE_OPTION_NO_WITH_VETO":
          return VoteOption.VOTE_OPTION_NO_WITH_VETO;
        case -1:
        case "UNRECOGNIZED":
        default:
          return VoteOption.UNRECOGNIZED;
      }
    }
    exports.voteOptionFromJSON = voteOptionFromJSON;
    function voteOptionToJSON(object) {
      switch (object) {
        case VoteOption.VOTE_OPTION_UNSPECIFIED:
          return "VOTE_OPTION_UNSPECIFIED";
        case VoteOption.VOTE_OPTION_YES:
          return "VOTE_OPTION_YES";
        case VoteOption.VOTE_OPTION_ABSTAIN:
          return "VOTE_OPTION_ABSTAIN";
        case VoteOption.VOTE_OPTION_NO:
          return "VOTE_OPTION_NO";
        case VoteOption.VOTE_OPTION_NO_WITH_VETO:
          return "VOTE_OPTION_NO_WITH_VETO";
        case VoteOption.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.voteOptionToJSON = voteOptionToJSON;
    var ProposalStatus;
    (function(ProposalStatus2) {
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_UNSPECIFIED"] = 0] = "PROPOSAL_STATUS_UNSPECIFIED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_DEPOSIT_PERIOD"] = 1] = "PROPOSAL_STATUS_DEPOSIT_PERIOD";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_VOTING_PERIOD"] = 2] = "PROPOSAL_STATUS_VOTING_PERIOD";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_PASSED"] = 3] = "PROPOSAL_STATUS_PASSED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_REJECTED"] = 4] = "PROPOSAL_STATUS_REJECTED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_FAILED"] = 5] = "PROPOSAL_STATUS_FAILED";
      ProposalStatus2[ProposalStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ProposalStatus || (exports.ProposalStatus = ProposalStatus = {}));
    function proposalStatusFromJSON(object) {
      switch (object) {
        case 0:
        case "PROPOSAL_STATUS_UNSPECIFIED":
          return ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED;
        case 1:
        case "PROPOSAL_STATUS_DEPOSIT_PERIOD":
          return ProposalStatus.PROPOSAL_STATUS_DEPOSIT_PERIOD;
        case 2:
        case "PROPOSAL_STATUS_VOTING_PERIOD":
          return ProposalStatus.PROPOSAL_STATUS_VOTING_PERIOD;
        case 3:
        case "PROPOSAL_STATUS_PASSED":
          return ProposalStatus.PROPOSAL_STATUS_PASSED;
        case 4:
        case "PROPOSAL_STATUS_REJECTED":
          return ProposalStatus.PROPOSAL_STATUS_REJECTED;
        case 5:
        case "PROPOSAL_STATUS_FAILED":
          return ProposalStatus.PROPOSAL_STATUS_FAILED;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ProposalStatus.UNRECOGNIZED;
      }
    }
    exports.proposalStatusFromJSON = proposalStatusFromJSON;
    function proposalStatusToJSON(object) {
      switch (object) {
        case ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED:
          return "PROPOSAL_STATUS_UNSPECIFIED";
        case ProposalStatus.PROPOSAL_STATUS_DEPOSIT_PERIOD:
          return "PROPOSAL_STATUS_DEPOSIT_PERIOD";
        case ProposalStatus.PROPOSAL_STATUS_VOTING_PERIOD:
          return "PROPOSAL_STATUS_VOTING_PERIOD";
        case ProposalStatus.PROPOSAL_STATUS_PASSED:
          return "PROPOSAL_STATUS_PASSED";
        case ProposalStatus.PROPOSAL_STATUS_REJECTED:
          return "PROPOSAL_STATUS_REJECTED";
        case ProposalStatus.PROPOSAL_STATUS_FAILED:
          return "PROPOSAL_STATUS_FAILED";
        case ProposalStatus.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.proposalStatusToJSON = proposalStatusToJSON;
    function createBaseWeightedVoteOption() {
      return {
        option: 0,
        weight: ""
      };
    }
    exports.WeightedVoteOption = {
      typeUrl: "/cosmos.gov.v1.WeightedVoteOption",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.option !== 0) {
          writer.uint32(8).int32(message.option);
        }
        if (message.weight !== "") {
          writer.uint32(18).string(message.weight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWeightedVoteOption();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.option = reader.int32();
              break;
            case 2:
              message.weight = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseWeightedVoteOption();
        if ((0, helpers_1.isSet)(object.option))
          obj.option = voteOptionFromJSON(object.option);
        if ((0, helpers_1.isSet)(object.weight))
          obj.weight = String(object.weight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.option !== void 0 && (obj.option = voteOptionToJSON(message.option));
        message.weight !== void 0 && (obj.weight = message.weight);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseWeightedVoteOption();
        message.option = object.option ?? 0;
        message.weight = object.weight ?? "";
        return message;
      }
    };
    function createBaseDeposit() {
      return {
        proposalId: BigInt(0),
        depositor: "",
        amount: []
      };
    }
    exports.Deposit = {
      typeUrl: "/cosmos.gov.v1.Deposit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.depositor !== "") {
          writer.uint32(18).string(message.depositor);
        }
        for (const v9 of message.amount) {
          coin_1.Coin.encode(v9, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDeposit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.depositor = reader.string();
              break;
            case 3:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDeposit();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.depositor))
          obj.depositor = String(object.depositor);
        if (Array.isArray(object?.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.depositor !== void 0 && (obj.depositor = message.depositor);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDeposit();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.depositor = object.depositor ?? "";
        message.amount = object.amount?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseProposal() {
      return {
        id: BigInt(0),
        messages: [],
        status: 0,
        finalTallyResult: void 0,
        submitTime: void 0,
        depositEndTime: void 0,
        totalDeposit: [],
        votingStartTime: void 0,
        votingEndTime: void 0,
        metadata: "",
        title: "",
        summary: "",
        proposer: "",
        expedited: false,
        failedReason: ""
      };
    }
    exports.Proposal = {
      typeUrl: "/cosmos.gov.v1.Proposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.id !== BigInt(0)) {
          writer.uint32(8).uint64(message.id);
        }
        for (const v9 of message.messages) {
          any_1.Any.encode(v9, writer.uint32(18).fork()).ldelim();
        }
        if (message.status !== 0) {
          writer.uint32(24).int32(message.status);
        }
        if (message.finalTallyResult !== void 0) {
          exports.TallyResult.encode(message.finalTallyResult, writer.uint32(34).fork()).ldelim();
        }
        if (message.submitTime !== void 0) {
          timestamp_1.Timestamp.encode(message.submitTime, writer.uint32(42).fork()).ldelim();
        }
        if (message.depositEndTime !== void 0) {
          timestamp_1.Timestamp.encode(message.depositEndTime, writer.uint32(50).fork()).ldelim();
        }
        for (const v9 of message.totalDeposit) {
          coin_1.Coin.encode(v9, writer.uint32(58).fork()).ldelim();
        }
        if (message.votingStartTime !== void 0) {
          timestamp_1.Timestamp.encode(message.votingStartTime, writer.uint32(66).fork()).ldelim();
        }
        if (message.votingEndTime !== void 0) {
          timestamp_1.Timestamp.encode(message.votingEndTime, writer.uint32(74).fork()).ldelim();
        }
        if (message.metadata !== "") {
          writer.uint32(82).string(message.metadata);
        }
        if (message.title !== "") {
          writer.uint32(90).string(message.title);
        }
        if (message.summary !== "") {
          writer.uint32(98).string(message.summary);
        }
        if (message.proposer !== "") {
          writer.uint32(106).string(message.proposer);
        }
        if (message.expedited === true) {
          writer.uint32(112).bool(message.expedited);
        }
        if (message.failedReason !== "") {
          writer.uint32(122).string(message.failedReason);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.uint64();
              break;
            case 2:
              message.messages.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            case 3:
              message.status = reader.int32();
              break;
            case 4:
              message.finalTallyResult = exports.TallyResult.decode(reader, reader.uint32());
              break;
            case 5:
              message.submitTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 6:
              message.depositEndTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 7:
              message.totalDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 8:
              message.votingStartTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 9:
              message.votingEndTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 10:
              message.metadata = reader.string();
              break;
            case 11:
              message.title = reader.string();
              break;
            case 12:
              message.summary = reader.string();
              break;
            case 13:
              message.proposer = reader.string();
              break;
            case 14:
              message.expedited = reader.bool();
              break;
            case 15:
              message.failedReason = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseProposal();
        if ((0, helpers_1.isSet)(object.id))
          obj.id = BigInt(object.id.toString());
        if (Array.isArray(object?.messages))
          obj.messages = object.messages.map((e) => any_1.Any.fromJSON(e));
        if ((0, helpers_1.isSet)(object.status))
          obj.status = proposalStatusFromJSON(object.status);
        if ((0, helpers_1.isSet)(object.finalTallyResult))
          obj.finalTallyResult = exports.TallyResult.fromJSON(object.finalTallyResult);
        if ((0, helpers_1.isSet)(object.submitTime))
          obj.submitTime = (0, helpers_1.fromJsonTimestamp)(object.submitTime);
        if ((0, helpers_1.isSet)(object.depositEndTime))
          obj.depositEndTime = (0, helpers_1.fromJsonTimestamp)(object.depositEndTime);
        if (Array.isArray(object?.totalDeposit))
          obj.totalDeposit = object.totalDeposit.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.votingStartTime))
          obj.votingStartTime = (0, helpers_1.fromJsonTimestamp)(object.votingStartTime);
        if ((0, helpers_1.isSet)(object.votingEndTime))
          obj.votingEndTime = (0, helpers_1.fromJsonTimestamp)(object.votingEndTime);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        if ((0, helpers_1.isSet)(object.title))
          obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.summary))
          obj.summary = String(object.summary);
        if ((0, helpers_1.isSet)(object.proposer))
          obj.proposer = String(object.proposer);
        if ((0, helpers_1.isSet)(object.expedited))
          obj.expedited = Boolean(object.expedited);
        if ((0, helpers_1.isSet)(object.failedReason))
          obj.failedReason = String(object.failedReason);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.id !== void 0 && (obj.id = (message.id || BigInt(0)).toString());
        if (message.messages) {
          obj.messages = message.messages.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.messages = [];
        }
        message.status !== void 0 && (obj.status = proposalStatusToJSON(message.status));
        message.finalTallyResult !== void 0 && (obj.finalTallyResult = message.finalTallyResult ? exports.TallyResult.toJSON(message.finalTallyResult) : void 0);
        message.submitTime !== void 0 && (obj.submitTime = (0, helpers_1.fromTimestamp)(message.submitTime).toISOString());
        message.depositEndTime !== void 0 && (obj.depositEndTime = (0, helpers_1.fromTimestamp)(message.depositEndTime).toISOString());
        if (message.totalDeposit) {
          obj.totalDeposit = message.totalDeposit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.totalDeposit = [];
        }
        message.votingStartTime !== void 0 && (obj.votingStartTime = (0, helpers_1.fromTimestamp)(message.votingStartTime).toISOString());
        message.votingEndTime !== void 0 && (obj.votingEndTime = (0, helpers_1.fromTimestamp)(message.votingEndTime).toISOString());
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        message.title !== void 0 && (obj.title = message.title);
        message.summary !== void 0 && (obj.summary = message.summary);
        message.proposer !== void 0 && (obj.proposer = message.proposer);
        message.expedited !== void 0 && (obj.expedited = message.expedited);
        message.failedReason !== void 0 && (obj.failedReason = message.failedReason);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseProposal();
        if (object.id !== void 0 && object.id !== null) {
          message.id = BigInt(object.id.toString());
        }
        message.messages = object.messages?.map((e) => any_1.Any.fromPartial(e)) || [];
        message.status = object.status ?? 0;
        if (object.finalTallyResult !== void 0 && object.finalTallyResult !== null) {
          message.finalTallyResult = exports.TallyResult.fromPartial(object.finalTallyResult);
        }
        if (object.submitTime !== void 0 && object.submitTime !== null) {
          message.submitTime = timestamp_1.Timestamp.fromPartial(object.submitTime);
        }
        if (object.depositEndTime !== void 0 && object.depositEndTime !== null) {
          message.depositEndTime = timestamp_1.Timestamp.fromPartial(object.depositEndTime);
        }
        message.totalDeposit = object.totalDeposit?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        if (object.votingStartTime !== void 0 && object.votingStartTime !== null) {
          message.votingStartTime = timestamp_1.Timestamp.fromPartial(object.votingStartTime);
        }
        if (object.votingEndTime !== void 0 && object.votingEndTime !== null) {
          message.votingEndTime = timestamp_1.Timestamp.fromPartial(object.votingEndTime);
        }
        message.metadata = object.metadata ?? "";
        message.title = object.title ?? "";
        message.summary = object.summary ?? "";
        message.proposer = object.proposer ?? "";
        message.expedited = object.expedited ?? false;
        message.failedReason = object.failedReason ?? "";
        return message;
      }
    };
    function createBaseTallyResult() {
      return {
        yesCount: "",
        abstainCount: "",
        noCount: "",
        noWithVetoCount: ""
      };
    }
    exports.TallyResult = {
      typeUrl: "/cosmos.gov.v1.TallyResult",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.yesCount !== "") {
          writer.uint32(10).string(message.yesCount);
        }
        if (message.abstainCount !== "") {
          writer.uint32(18).string(message.abstainCount);
        }
        if (message.noCount !== "") {
          writer.uint32(26).string(message.noCount);
        }
        if (message.noWithVetoCount !== "") {
          writer.uint32(34).string(message.noWithVetoCount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTallyResult();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.yesCount = reader.string();
              break;
            case 2:
              message.abstainCount = reader.string();
              break;
            case 3:
              message.noCount = reader.string();
              break;
            case 4:
              message.noWithVetoCount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTallyResult();
        if ((0, helpers_1.isSet)(object.yesCount))
          obj.yesCount = String(object.yesCount);
        if ((0, helpers_1.isSet)(object.abstainCount))
          obj.abstainCount = String(object.abstainCount);
        if ((0, helpers_1.isSet)(object.noCount))
          obj.noCount = String(object.noCount);
        if ((0, helpers_1.isSet)(object.noWithVetoCount))
          obj.noWithVetoCount = String(object.noWithVetoCount);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.yesCount !== void 0 && (obj.yesCount = message.yesCount);
        message.abstainCount !== void 0 && (obj.abstainCount = message.abstainCount);
        message.noCount !== void 0 && (obj.noCount = message.noCount);
        message.noWithVetoCount !== void 0 && (obj.noWithVetoCount = message.noWithVetoCount);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTallyResult();
        message.yesCount = object.yesCount ?? "";
        message.abstainCount = object.abstainCount ?? "";
        message.noCount = object.noCount ?? "";
        message.noWithVetoCount = object.noWithVetoCount ?? "";
        return message;
      }
    };
    function createBaseVote() {
      return {
        proposalId: BigInt(0),
        voter: "",
        options: [],
        metadata: ""
      };
    }
    exports.Vote = {
      typeUrl: "/cosmos.gov.v1.Vote",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        for (const v9 of message.options) {
          exports.WeightedVoteOption.encode(v9, writer.uint32(34).fork()).ldelim();
        }
        if (message.metadata !== "") {
          writer.uint32(42).string(message.metadata);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVote();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 4:
              message.options.push(exports.WeightedVoteOption.decode(reader, reader.uint32()));
              break;
            case 5:
              message.metadata = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseVote();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.voter))
          obj.voter = String(object.voter);
        if (Array.isArray(object?.options))
          obj.options = object.options.map((e) => exports.WeightedVoteOption.fromJSON(e));
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.voter !== void 0 && (obj.voter = message.voter);
        if (message.options) {
          obj.options = message.options.map((e) => e ? exports.WeightedVoteOption.toJSON(e) : void 0);
        } else {
          obj.options = [];
        }
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseVote();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.voter = object.voter ?? "";
        message.options = object.options?.map((e) => exports.WeightedVoteOption.fromPartial(e)) || [];
        message.metadata = object.metadata ?? "";
        return message;
      }
    };
    function createBaseDepositParams() {
      return {
        minDeposit: [],
        maxDepositPeriod: void 0
      };
    }
    exports.DepositParams = {
      typeUrl: "/cosmos.gov.v1.DepositParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.minDeposit) {
          coin_1.Coin.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.maxDepositPeriod !== void 0) {
          duration_1.Duration.encode(message.maxDepositPeriod, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDepositParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.minDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.maxDepositPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDepositParams();
        if (Array.isArray(object?.minDeposit))
          obj.minDeposit = object.minDeposit.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.maxDepositPeriod))
          obj.maxDepositPeriod = duration_1.Duration.fromJSON(object.maxDepositPeriod);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.minDeposit) {
          obj.minDeposit = message.minDeposit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.minDeposit = [];
        }
        message.maxDepositPeriod !== void 0 && (obj.maxDepositPeriod = message.maxDepositPeriod ? duration_1.Duration.toJSON(message.maxDepositPeriod) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDepositParams();
        message.minDeposit = object.minDeposit?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        if (object.maxDepositPeriod !== void 0 && object.maxDepositPeriod !== null) {
          message.maxDepositPeriod = duration_1.Duration.fromPartial(object.maxDepositPeriod);
        }
        return message;
      }
    };
    function createBaseVotingParams() {
      return {
        votingPeriod: void 0
      };
    }
    exports.VotingParams = {
      typeUrl: "/cosmos.gov.v1.VotingParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.votingPeriod !== void 0) {
          duration_1.Duration.encode(message.votingPeriod, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVotingParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.votingPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseVotingParams();
        if ((0, helpers_1.isSet)(object.votingPeriod))
          obj.votingPeriod = duration_1.Duration.fromJSON(object.votingPeriod);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.votingPeriod !== void 0 && (obj.votingPeriod = message.votingPeriod ? duration_1.Duration.toJSON(message.votingPeriod) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseVotingParams();
        if (object.votingPeriod !== void 0 && object.votingPeriod !== null) {
          message.votingPeriod = duration_1.Duration.fromPartial(object.votingPeriod);
        }
        return message;
      }
    };
    function createBaseTallyParams() {
      return {
        quorum: "",
        threshold: "",
        vetoThreshold: ""
      };
    }
    exports.TallyParams = {
      typeUrl: "/cosmos.gov.v1.TallyParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.quorum !== "") {
          writer.uint32(10).string(message.quorum);
        }
        if (message.threshold !== "") {
          writer.uint32(18).string(message.threshold);
        }
        if (message.vetoThreshold !== "") {
          writer.uint32(26).string(message.vetoThreshold);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTallyParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.quorum = reader.string();
              break;
            case 2:
              message.threshold = reader.string();
              break;
            case 3:
              message.vetoThreshold = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTallyParams();
        if ((0, helpers_1.isSet)(object.quorum))
          obj.quorum = String(object.quorum);
        if ((0, helpers_1.isSet)(object.threshold))
          obj.threshold = String(object.threshold);
        if ((0, helpers_1.isSet)(object.vetoThreshold))
          obj.vetoThreshold = String(object.vetoThreshold);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.quorum !== void 0 && (obj.quorum = message.quorum);
        message.threshold !== void 0 && (obj.threshold = message.threshold);
        message.vetoThreshold !== void 0 && (obj.vetoThreshold = message.vetoThreshold);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTallyParams();
        message.quorum = object.quorum ?? "";
        message.threshold = object.threshold ?? "";
        message.vetoThreshold = object.vetoThreshold ?? "";
        return message;
      }
    };
    function createBaseParams() {
      return {
        minDeposit: [],
        maxDepositPeriod: void 0,
        votingPeriod: void 0,
        quorum: "",
        threshold: "",
        vetoThreshold: "",
        minInitialDepositRatio: "",
        proposalCancelRatio: "",
        proposalCancelDest: "",
        expeditedVotingPeriod: void 0,
        expeditedThreshold: "",
        expeditedMinDeposit: [],
        burnVoteQuorum: false,
        burnProposalDepositPrevote: false,
        burnVoteVeto: false,
        minDepositRatio: ""
      };
    }
    exports.Params = {
      typeUrl: "/cosmos.gov.v1.Params",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.minDeposit) {
          coin_1.Coin.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.maxDepositPeriod !== void 0) {
          duration_1.Duration.encode(message.maxDepositPeriod, writer.uint32(18).fork()).ldelim();
        }
        if (message.votingPeriod !== void 0) {
          duration_1.Duration.encode(message.votingPeriod, writer.uint32(26).fork()).ldelim();
        }
        if (message.quorum !== "") {
          writer.uint32(34).string(message.quorum);
        }
        if (message.threshold !== "") {
          writer.uint32(42).string(message.threshold);
        }
        if (message.vetoThreshold !== "") {
          writer.uint32(50).string(message.vetoThreshold);
        }
        if (message.minInitialDepositRatio !== "") {
          writer.uint32(58).string(message.minInitialDepositRatio);
        }
        if (message.proposalCancelRatio !== "") {
          writer.uint32(66).string(message.proposalCancelRatio);
        }
        if (message.proposalCancelDest !== "") {
          writer.uint32(74).string(message.proposalCancelDest);
        }
        if (message.expeditedVotingPeriod !== void 0) {
          duration_1.Duration.encode(message.expeditedVotingPeriod, writer.uint32(82).fork()).ldelim();
        }
        if (message.expeditedThreshold !== "") {
          writer.uint32(90).string(message.expeditedThreshold);
        }
        for (const v9 of message.expeditedMinDeposit) {
          coin_1.Coin.encode(v9, writer.uint32(98).fork()).ldelim();
        }
        if (message.burnVoteQuorum === true) {
          writer.uint32(104).bool(message.burnVoteQuorum);
        }
        if (message.burnProposalDepositPrevote === true) {
          writer.uint32(112).bool(message.burnProposalDepositPrevote);
        }
        if (message.burnVoteVeto === true) {
          writer.uint32(120).bool(message.burnVoteVeto);
        }
        if (message.minDepositRatio !== "") {
          writer.uint32(130).string(message.minDepositRatio);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.minDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 2:
              message.maxDepositPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 3:
              message.votingPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 4:
              message.quorum = reader.string();
              break;
            case 5:
              message.threshold = reader.string();
              break;
            case 6:
              message.vetoThreshold = reader.string();
              break;
            case 7:
              message.minInitialDepositRatio = reader.string();
              break;
            case 8:
              message.proposalCancelRatio = reader.string();
              break;
            case 9:
              message.proposalCancelDest = reader.string();
              break;
            case 10:
              message.expeditedVotingPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 11:
              message.expeditedThreshold = reader.string();
              break;
            case 12:
              message.expeditedMinDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 13:
              message.burnVoteQuorum = reader.bool();
              break;
            case 14:
              message.burnProposalDepositPrevote = reader.bool();
              break;
            case 15:
              message.burnVoteVeto = reader.bool();
              break;
            case 16:
              message.minDepositRatio = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseParams();
        if (Array.isArray(object?.minDeposit))
          obj.minDeposit = object.minDeposit.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.maxDepositPeriod))
          obj.maxDepositPeriod = duration_1.Duration.fromJSON(object.maxDepositPeriod);
        if ((0, helpers_1.isSet)(object.votingPeriod))
          obj.votingPeriod = duration_1.Duration.fromJSON(object.votingPeriod);
        if ((0, helpers_1.isSet)(object.quorum))
          obj.quorum = String(object.quorum);
        if ((0, helpers_1.isSet)(object.threshold))
          obj.threshold = String(object.threshold);
        if ((0, helpers_1.isSet)(object.vetoThreshold))
          obj.vetoThreshold = String(object.vetoThreshold);
        if ((0, helpers_1.isSet)(object.minInitialDepositRatio))
          obj.minInitialDepositRatio = String(object.minInitialDepositRatio);
        if ((0, helpers_1.isSet)(object.proposalCancelRatio))
          obj.proposalCancelRatio = String(object.proposalCancelRatio);
        if ((0, helpers_1.isSet)(object.proposalCancelDest))
          obj.proposalCancelDest = String(object.proposalCancelDest);
        if ((0, helpers_1.isSet)(object.expeditedVotingPeriod))
          obj.expeditedVotingPeriod = duration_1.Duration.fromJSON(object.expeditedVotingPeriod);
        if ((0, helpers_1.isSet)(object.expeditedThreshold))
          obj.expeditedThreshold = String(object.expeditedThreshold);
        if (Array.isArray(object?.expeditedMinDeposit))
          obj.expeditedMinDeposit = object.expeditedMinDeposit.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.burnVoteQuorum))
          obj.burnVoteQuorum = Boolean(object.burnVoteQuorum);
        if ((0, helpers_1.isSet)(object.burnProposalDepositPrevote))
          obj.burnProposalDepositPrevote = Boolean(object.burnProposalDepositPrevote);
        if ((0, helpers_1.isSet)(object.burnVoteVeto))
          obj.burnVoteVeto = Boolean(object.burnVoteVeto);
        if ((0, helpers_1.isSet)(object.minDepositRatio))
          obj.minDepositRatio = String(object.minDepositRatio);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.minDeposit) {
          obj.minDeposit = message.minDeposit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.minDeposit = [];
        }
        message.maxDepositPeriod !== void 0 && (obj.maxDepositPeriod = message.maxDepositPeriod ? duration_1.Duration.toJSON(message.maxDepositPeriod) : void 0);
        message.votingPeriod !== void 0 && (obj.votingPeriod = message.votingPeriod ? duration_1.Duration.toJSON(message.votingPeriod) : void 0);
        message.quorum !== void 0 && (obj.quorum = message.quorum);
        message.threshold !== void 0 && (obj.threshold = message.threshold);
        message.vetoThreshold !== void 0 && (obj.vetoThreshold = message.vetoThreshold);
        message.minInitialDepositRatio !== void 0 && (obj.minInitialDepositRatio = message.minInitialDepositRatio);
        message.proposalCancelRatio !== void 0 && (obj.proposalCancelRatio = message.proposalCancelRatio);
        message.proposalCancelDest !== void 0 && (obj.proposalCancelDest = message.proposalCancelDest);
        message.expeditedVotingPeriod !== void 0 && (obj.expeditedVotingPeriod = message.expeditedVotingPeriod ? duration_1.Duration.toJSON(message.expeditedVotingPeriod) : void 0);
        message.expeditedThreshold !== void 0 && (obj.expeditedThreshold = message.expeditedThreshold);
        if (message.expeditedMinDeposit) {
          obj.expeditedMinDeposit = message.expeditedMinDeposit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.expeditedMinDeposit = [];
        }
        message.burnVoteQuorum !== void 0 && (obj.burnVoteQuorum = message.burnVoteQuorum);
        message.burnProposalDepositPrevote !== void 0 && (obj.burnProposalDepositPrevote = message.burnProposalDepositPrevote);
        message.burnVoteVeto !== void 0 && (obj.burnVoteVeto = message.burnVoteVeto);
        message.minDepositRatio !== void 0 && (obj.minDepositRatio = message.minDepositRatio);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseParams();
        message.minDeposit = object.minDeposit?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        if (object.maxDepositPeriod !== void 0 && object.maxDepositPeriod !== null) {
          message.maxDepositPeriod = duration_1.Duration.fromPartial(object.maxDepositPeriod);
        }
        if (object.votingPeriod !== void 0 && object.votingPeriod !== null) {
          message.votingPeriod = duration_1.Duration.fromPartial(object.votingPeriod);
        }
        message.quorum = object.quorum ?? "";
        message.threshold = object.threshold ?? "";
        message.vetoThreshold = object.vetoThreshold ?? "";
        message.minInitialDepositRatio = object.minInitialDepositRatio ?? "";
        message.proposalCancelRatio = object.proposalCancelRatio ?? "";
        message.proposalCancelDest = object.proposalCancelDest ?? "";
        if (object.expeditedVotingPeriod !== void 0 && object.expeditedVotingPeriod !== null) {
          message.expeditedVotingPeriod = duration_1.Duration.fromPartial(object.expeditedVotingPeriod);
        }
        message.expeditedThreshold = object.expeditedThreshold ?? "";
        message.expeditedMinDeposit = object.expeditedMinDeposit?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        message.burnVoteQuorum = object.burnVoteQuorum ?? false;
        message.burnProposalDepositPrevote = object.burnProposalDepositPrevote ?? false;
        message.burnVoteVeto = object.burnVoteVeto ?? false;
        message.minDepositRatio = object.minDepositRatio ?? "";
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/gov/v1/tx.js
var require_tx6 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/gov/v1/tx.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MsgClientImpl = exports.MsgCancelProposalResponse = exports.MsgCancelProposal = exports.MsgUpdateParamsResponse = exports.MsgUpdateParams = exports.MsgDepositResponse = exports.MsgDeposit = exports.MsgVoteWeightedResponse = exports.MsgVoteWeighted = exports.MsgVoteResponse = exports.MsgVote = exports.MsgExecLegacyContentResponse = exports.MsgExecLegacyContent = exports.MsgSubmitProposalResponse = exports.MsgSubmitProposal = exports.protobufPackage = void 0;
    var any_1 = require_any();
    var coin_1 = require_coin();
    var gov_1 = require_gov2();
    var timestamp_1 = require_timestamp();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.gov.v1";
    function createBaseMsgSubmitProposal() {
      return {
        messages: [],
        initialDeposit: [],
        proposer: "",
        metadata: "",
        title: "",
        summary: "",
        expedited: false
      };
    }
    exports.MsgSubmitProposal = {
      typeUrl: "/cosmos.gov.v1.MsgSubmitProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.messages) {
          any_1.Any.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        for (const v9 of message.initialDeposit) {
          coin_1.Coin.encode(v9, writer.uint32(18).fork()).ldelim();
        }
        if (message.proposer !== "") {
          writer.uint32(26).string(message.proposer);
        }
        if (message.metadata !== "") {
          writer.uint32(34).string(message.metadata);
        }
        if (message.title !== "") {
          writer.uint32(42).string(message.title);
        }
        if (message.summary !== "") {
          writer.uint32(50).string(message.summary);
        }
        if (message.expedited === true) {
          writer.uint32(56).bool(message.expedited);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.messages.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            case 2:
              message.initialDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 3:
              message.proposer = reader.string();
              break;
            case 4:
              message.metadata = reader.string();
              break;
            case 5:
              message.title = reader.string();
              break;
            case 6:
              message.summary = reader.string();
              break;
            case 7:
              message.expedited = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgSubmitProposal();
        if (Array.isArray(object?.messages))
          obj.messages = object.messages.map((e) => any_1.Any.fromJSON(e));
        if (Array.isArray(object?.initialDeposit))
          obj.initialDeposit = object.initialDeposit.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.proposer))
          obj.proposer = String(object.proposer);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        if ((0, helpers_1.isSet)(object.title))
          obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.summary))
          obj.summary = String(object.summary);
        if ((0, helpers_1.isSet)(object.expedited))
          obj.expedited = Boolean(object.expedited);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.messages) {
          obj.messages = message.messages.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.messages = [];
        }
        if (message.initialDeposit) {
          obj.initialDeposit = message.initialDeposit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.initialDeposit = [];
        }
        message.proposer !== void 0 && (obj.proposer = message.proposer);
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        message.title !== void 0 && (obj.title = message.title);
        message.summary !== void 0 && (obj.summary = message.summary);
        message.expedited !== void 0 && (obj.expedited = message.expedited);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgSubmitProposal();
        message.messages = object.messages?.map((e) => any_1.Any.fromPartial(e)) || [];
        message.initialDeposit = object.initialDeposit?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        message.proposer = object.proposer ?? "";
        message.metadata = object.metadata ?? "";
        message.title = object.title ?? "";
        message.summary = object.summary ?? "";
        message.expedited = object.expedited ?? false;
        return message;
      }
    };
    function createBaseMsgSubmitProposalResponse() {
      return {
        proposalId: BigInt(0)
      };
    }
    exports.MsgSubmitProposalResponse = {
      typeUrl: "/cosmos.gov.v1.MsgSubmitProposalResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitProposalResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgSubmitProposalResponse();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgSubmitProposalResponse();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        return message;
      }
    };
    function createBaseMsgExecLegacyContent() {
      return {
        content: void 0,
        authority: ""
      };
    }
    exports.MsgExecLegacyContent = {
      typeUrl: "/cosmos.gov.v1.MsgExecLegacyContent",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.content !== void 0) {
          any_1.Any.encode(message.content, writer.uint32(10).fork()).ldelim();
        }
        if (message.authority !== "") {
          writer.uint32(18).string(message.authority);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgExecLegacyContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.content = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.authority = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgExecLegacyContent();
        if ((0, helpers_1.isSet)(object.content))
          obj.content = any_1.Any.fromJSON(object.content);
        if ((0, helpers_1.isSet)(object.authority))
          obj.authority = String(object.authority);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.content !== void 0 && (obj.content = message.content ? any_1.Any.toJSON(message.content) : void 0);
        message.authority !== void 0 && (obj.authority = message.authority);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgExecLegacyContent();
        if (object.content !== void 0 && object.content !== null) {
          message.content = any_1.Any.fromPartial(object.content);
        }
        message.authority = object.authority ?? "";
        return message;
      }
    };
    function createBaseMsgExecLegacyContentResponse() {
      return {};
    }
    exports.MsgExecLegacyContentResponse = {
      typeUrl: "/cosmos.gov.v1.MsgExecLegacyContentResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgExecLegacyContentResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgExecLegacyContentResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgExecLegacyContentResponse();
        return message;
      }
    };
    function createBaseMsgVote() {
      return {
        proposalId: BigInt(0),
        voter: "",
        option: 0,
        metadata: ""
      };
    }
    exports.MsgVote = {
      typeUrl: "/cosmos.gov.v1.MsgVote",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        if (message.option !== 0) {
          writer.uint32(24).int32(message.option);
        }
        if (message.metadata !== "") {
          writer.uint32(34).string(message.metadata);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVote();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 3:
              message.option = reader.int32();
              break;
            case 4:
              message.metadata = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgVote();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.voter))
          obj.voter = String(object.voter);
        if ((0, helpers_1.isSet)(object.option))
          obj.option = (0, gov_1.voteOptionFromJSON)(object.option);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.voter !== void 0 && (obj.voter = message.voter);
        message.option !== void 0 && (obj.option = (0, gov_1.voteOptionToJSON)(message.option));
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgVote();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.voter = object.voter ?? "";
        message.option = object.option ?? 0;
        message.metadata = object.metadata ?? "";
        return message;
      }
    };
    function createBaseMsgVoteResponse() {
      return {};
    }
    exports.MsgVoteResponse = {
      typeUrl: "/cosmos.gov.v1.MsgVoteResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVoteResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgVoteResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgVoteResponse();
        return message;
      }
    };
    function createBaseMsgVoteWeighted() {
      return {
        proposalId: BigInt(0),
        voter: "",
        options: [],
        metadata: ""
      };
    }
    exports.MsgVoteWeighted = {
      typeUrl: "/cosmos.gov.v1.MsgVoteWeighted",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        for (const v9 of message.options) {
          gov_1.WeightedVoteOption.encode(v9, writer.uint32(26).fork()).ldelim();
        }
        if (message.metadata !== "") {
          writer.uint32(34).string(message.metadata);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVoteWeighted();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 3:
              message.options.push(gov_1.WeightedVoteOption.decode(reader, reader.uint32()));
              break;
            case 4:
              message.metadata = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgVoteWeighted();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.voter))
          obj.voter = String(object.voter);
        if (Array.isArray(object?.options))
          obj.options = object.options.map((e) => gov_1.WeightedVoteOption.fromJSON(e));
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.voter !== void 0 && (obj.voter = message.voter);
        if (message.options) {
          obj.options = message.options.map((e) => e ? gov_1.WeightedVoteOption.toJSON(e) : void 0);
        } else {
          obj.options = [];
        }
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgVoteWeighted();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.voter = object.voter ?? "";
        message.options = object.options?.map((e) => gov_1.WeightedVoteOption.fromPartial(e)) || [];
        message.metadata = object.metadata ?? "";
        return message;
      }
    };
    function createBaseMsgVoteWeightedResponse() {
      return {};
    }
    exports.MsgVoteWeightedResponse = {
      typeUrl: "/cosmos.gov.v1.MsgVoteWeightedResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVoteWeightedResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgVoteWeightedResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgVoteWeightedResponse();
        return message;
      }
    };
    function createBaseMsgDeposit() {
      return {
        proposalId: BigInt(0),
        depositor: "",
        amount: []
      };
    }
    exports.MsgDeposit = {
      typeUrl: "/cosmos.gov.v1.MsgDeposit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.depositor !== "") {
          writer.uint32(18).string(message.depositor);
        }
        for (const v9 of message.amount) {
          coin_1.Coin.encode(v9, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDeposit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.depositor = reader.string();
              break;
            case 3:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgDeposit();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.depositor))
          obj.depositor = String(object.depositor);
        if (Array.isArray(object?.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.depositor !== void 0 && (obj.depositor = message.depositor);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgDeposit();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.depositor = object.depositor ?? "";
        message.amount = object.amount?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseMsgDepositResponse() {
      return {};
    }
    exports.MsgDepositResponse = {
      typeUrl: "/cosmos.gov.v1.MsgDepositResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDepositResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgDepositResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgDepositResponse();
        return message;
      }
    };
    function createBaseMsgUpdateParams() {
      return {
        authority: "",
        params: gov_1.Params.fromPartial({})
      };
    }
    exports.MsgUpdateParams = {
      typeUrl: "/cosmos.gov.v1.MsgUpdateParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.authority !== "") {
          writer.uint32(10).string(message.authority);
        }
        if (message.params !== void 0) {
          gov_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.authority = reader.string();
              break;
            case 2:
              message.params = gov_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateParams();
        if ((0, helpers_1.isSet)(object.authority))
          obj.authority = String(object.authority);
        if ((0, helpers_1.isSet)(object.params))
          obj.params = gov_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.authority !== void 0 && (obj.authority = message.authority);
        message.params !== void 0 && (obj.params = message.params ? gov_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateParams();
        message.authority = object.authority ?? "";
        if (object.params !== void 0 && object.params !== null) {
          message.params = gov_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseMsgUpdateParamsResponse() {
      return {};
    }
    exports.MsgUpdateParamsResponse = {
      typeUrl: "/cosmos.gov.v1.MsgUpdateParamsResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgUpdateParamsResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgUpdateParamsResponse();
        return message;
      }
    };
    function createBaseMsgCancelProposal() {
      return {
        proposalId: BigInt(0),
        proposer: ""
      };
    }
    exports.MsgCancelProposal = {
      typeUrl: "/cosmos.gov.v1.MsgCancelProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.proposer !== "") {
          writer.uint32(18).string(message.proposer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCancelProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.proposer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCancelProposal();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.proposer))
          obj.proposer = String(object.proposer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.proposer !== void 0 && (obj.proposer = message.proposer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgCancelProposal();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.proposer = object.proposer ?? "";
        return message;
      }
    };
    function createBaseMsgCancelProposalResponse() {
      return {
        proposalId: BigInt(0),
        canceledTime: timestamp_1.Timestamp.fromPartial({}),
        canceledHeight: BigInt(0)
      };
    }
    exports.MsgCancelProposalResponse = {
      typeUrl: "/cosmos.gov.v1.MsgCancelProposalResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.canceledTime !== void 0) {
          timestamp_1.Timestamp.encode(message.canceledTime, writer.uint32(18).fork()).ldelim();
        }
        if (message.canceledHeight !== BigInt(0)) {
          writer.uint32(24).uint64(message.canceledHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCancelProposalResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.canceledTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 3:
              message.canceledHeight = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCancelProposalResponse();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.canceledTime))
          obj.canceledTime = (0, helpers_1.fromJsonTimestamp)(object.canceledTime);
        if ((0, helpers_1.isSet)(object.canceledHeight))
          obj.canceledHeight = BigInt(object.canceledHeight.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.canceledTime !== void 0 && (obj.canceledTime = (0, helpers_1.fromTimestamp)(message.canceledTime).toISOString());
        message.canceledHeight !== void 0 && (obj.canceledHeight = (message.canceledHeight || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgCancelProposalResponse();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        if (object.canceledTime !== void 0 && object.canceledTime !== null) {
          message.canceledTime = timestamp_1.Timestamp.fromPartial(object.canceledTime);
        }
        if (object.canceledHeight !== void 0 && object.canceledHeight !== null) {
          message.canceledHeight = BigInt(object.canceledHeight.toString());
        }
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.SubmitProposal = this.SubmitProposal.bind(this);
        this.ExecLegacyContent = this.ExecLegacyContent.bind(this);
        this.Vote = this.Vote.bind(this);
        this.VoteWeighted = this.VoteWeighted.bind(this);
        this.Deposit = this.Deposit.bind(this);
        this.UpdateParams = this.UpdateParams.bind(this);
        this.CancelProposal = this.CancelProposal.bind(this);
      }
      SubmitProposal(request) {
        const data2 = exports.MsgSubmitProposal.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1.Msg", "SubmitProposal", data2);
        return promise.then((data3) => exports.MsgSubmitProposalResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ExecLegacyContent(request) {
        const data2 = exports.MsgExecLegacyContent.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1.Msg", "ExecLegacyContent", data2);
        return promise.then((data3) => exports.MsgExecLegacyContentResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Vote(request) {
        const data2 = exports.MsgVote.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1.Msg", "Vote", data2);
        return promise.then((data3) => exports.MsgVoteResponse.decode(new binary_1.BinaryReader(data3)));
      }
      VoteWeighted(request) {
        const data2 = exports.MsgVoteWeighted.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1.Msg", "VoteWeighted", data2);
        return promise.then((data3) => exports.MsgVoteWeightedResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Deposit(request) {
        const data2 = exports.MsgDeposit.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1.Msg", "Deposit", data2);
        return promise.then((data3) => exports.MsgDepositResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateParams(request) {
        const data2 = exports.MsgUpdateParams.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1.Msg", "UpdateParams", data2);
        return promise.then((data3) => exports.MsgUpdateParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      CancelProposal(request) {
        const data2 = exports.MsgCancelProposal.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1.Msg", "CancelProposal", data2);
        return promise.then((data3) => exports.MsgCancelProposalResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.MsgClientImpl = MsgClientImpl;
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/gov/v1beta1/tx.js
var require_tx7 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/gov/v1beta1/tx.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MsgClientImpl = exports.MsgDepositResponse = exports.MsgDeposit = exports.MsgVoteWeightedResponse = exports.MsgVoteWeighted = exports.MsgVoteResponse = exports.MsgVote = exports.MsgSubmitProposalResponse = exports.MsgSubmitProposal = exports.protobufPackage = void 0;
    var any_1 = require_any();
    var coin_1 = require_coin();
    var gov_1 = require_gov();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.gov.v1beta1";
    function createBaseMsgSubmitProposal() {
      return {
        content: void 0,
        initialDeposit: [],
        proposer: ""
      };
    }
    exports.MsgSubmitProposal = {
      typeUrl: "/cosmos.gov.v1beta1.MsgSubmitProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.content !== void 0) {
          any_1.Any.encode(message.content, writer.uint32(10).fork()).ldelim();
        }
        for (const v9 of message.initialDeposit) {
          coin_1.Coin.encode(v9, writer.uint32(18).fork()).ldelim();
        }
        if (message.proposer !== "") {
          writer.uint32(26).string(message.proposer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.content = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.initialDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 3:
              message.proposer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgSubmitProposal();
        if ((0, helpers_1.isSet)(object.content))
          obj.content = any_1.Any.fromJSON(object.content);
        if (Array.isArray(object?.initialDeposit))
          obj.initialDeposit = object.initialDeposit.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.proposer))
          obj.proposer = String(object.proposer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.content !== void 0 && (obj.content = message.content ? any_1.Any.toJSON(message.content) : void 0);
        if (message.initialDeposit) {
          obj.initialDeposit = message.initialDeposit.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.initialDeposit = [];
        }
        message.proposer !== void 0 && (obj.proposer = message.proposer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgSubmitProposal();
        if (object.content !== void 0 && object.content !== null) {
          message.content = any_1.Any.fromPartial(object.content);
        }
        message.initialDeposit = object.initialDeposit?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        message.proposer = object.proposer ?? "";
        return message;
      }
    };
    function createBaseMsgSubmitProposalResponse() {
      return {
        proposalId: BigInt(0)
      };
    }
    exports.MsgSubmitProposalResponse = {
      typeUrl: "/cosmos.gov.v1beta1.MsgSubmitProposalResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitProposalResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgSubmitProposalResponse();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgSubmitProposalResponse();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        return message;
      }
    };
    function createBaseMsgVote() {
      return {
        proposalId: BigInt(0),
        voter: "",
        option: 0
      };
    }
    exports.MsgVote = {
      typeUrl: "/cosmos.gov.v1beta1.MsgVote",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        if (message.option !== 0) {
          writer.uint32(24).int32(message.option);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVote();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 3:
              message.option = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgVote();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.voter))
          obj.voter = String(object.voter);
        if ((0, helpers_1.isSet)(object.option))
          obj.option = (0, gov_1.voteOptionFromJSON)(object.option);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.voter !== void 0 && (obj.voter = message.voter);
        message.option !== void 0 && (obj.option = (0, gov_1.voteOptionToJSON)(message.option));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgVote();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.voter = object.voter ?? "";
        message.option = object.option ?? 0;
        return message;
      }
    };
    function createBaseMsgVoteResponse() {
      return {};
    }
    exports.MsgVoteResponse = {
      typeUrl: "/cosmos.gov.v1beta1.MsgVoteResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVoteResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgVoteResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgVoteResponse();
        return message;
      }
    };
    function createBaseMsgVoteWeighted() {
      return {
        proposalId: BigInt(0),
        voter: "",
        options: []
      };
    }
    exports.MsgVoteWeighted = {
      typeUrl: "/cosmos.gov.v1beta1.MsgVoteWeighted",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        for (const v9 of message.options) {
          gov_1.WeightedVoteOption.encode(v9, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVoteWeighted();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 3:
              message.options.push(gov_1.WeightedVoteOption.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgVoteWeighted();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.voter))
          obj.voter = String(object.voter);
        if (Array.isArray(object?.options))
          obj.options = object.options.map((e) => gov_1.WeightedVoteOption.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.voter !== void 0 && (obj.voter = message.voter);
        if (message.options) {
          obj.options = message.options.map((e) => e ? gov_1.WeightedVoteOption.toJSON(e) : void 0);
        } else {
          obj.options = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgVoteWeighted();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.voter = object.voter ?? "";
        message.options = object.options?.map((e) => gov_1.WeightedVoteOption.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseMsgVoteWeightedResponse() {
      return {};
    }
    exports.MsgVoteWeightedResponse = {
      typeUrl: "/cosmos.gov.v1beta1.MsgVoteWeightedResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVoteWeightedResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgVoteWeightedResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgVoteWeightedResponse();
        return message;
      }
    };
    function createBaseMsgDeposit() {
      return {
        proposalId: BigInt(0),
        depositor: "",
        amount: []
      };
    }
    exports.MsgDeposit = {
      typeUrl: "/cosmos.gov.v1beta1.MsgDeposit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.depositor !== "") {
          writer.uint32(18).string(message.depositor);
        }
        for (const v9 of message.amount) {
          coin_1.Coin.encode(v9, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDeposit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.depositor = reader.string();
              break;
            case 3:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgDeposit();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.depositor))
          obj.depositor = String(object.depositor);
        if (Array.isArray(object?.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.depositor !== void 0 && (obj.depositor = message.depositor);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgDeposit();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.depositor = object.depositor ?? "";
        message.amount = object.amount?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseMsgDepositResponse() {
      return {};
    }
    exports.MsgDepositResponse = {
      typeUrl: "/cosmos.gov.v1beta1.MsgDepositResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDepositResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgDepositResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgDepositResponse();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.SubmitProposal = this.SubmitProposal.bind(this);
        this.Vote = this.Vote.bind(this);
        this.VoteWeighted = this.VoteWeighted.bind(this);
        this.Deposit = this.Deposit.bind(this);
      }
      SubmitProposal(request) {
        const data2 = exports.MsgSubmitProposal.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Msg", "SubmitProposal", data2);
        return promise.then((data3) => exports.MsgSubmitProposalResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Vote(request) {
        const data2 = exports.MsgVote.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Msg", "Vote", data2);
        return promise.then((data3) => exports.MsgVoteResponse.decode(new binary_1.BinaryReader(data3)));
      }
      VoteWeighted(request) {
        const data2 = exports.MsgVoteWeighted.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Msg", "VoteWeighted", data2);
        return promise.then((data3) => exports.MsgVoteWeightedResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Deposit(request) {
        const data2 = exports.MsgDeposit.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Msg", "Deposit", data2);
        return promise.then((data3) => exports.MsgDepositResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.MsgClientImpl = MsgClientImpl;
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/gov/messages.js
var require_messages5 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/gov/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.govTypes = void 0;
    exports.isMsgDepositEncodeObject = isMsgDepositEncodeObject;
    exports.isMsgSubmitProposalEncodeObject = isMsgSubmitProposalEncodeObject;
    exports.isMsgVoteEncodeObject = isMsgVoteEncodeObject;
    exports.isMsgVoteWeightedEncodeObject = isMsgVoteWeightedEncodeObject;
    var tx_1 = require_tx6();
    var tx_2 = require_tx7();
    exports.govTypes = [
      ["/cosmos.gov.v1.MsgDeposit", tx_1.MsgDeposit],
      ["/cosmos.gov.v1.MsgSubmitProposal", tx_1.MsgSubmitProposal],
      ["/cosmos.gov.v1.MsgUpdateParams", tx_1.MsgUpdateParams],
      ["/cosmos.gov.v1.MsgVote", tx_1.MsgVote],
      ["/cosmos.gov.v1.MsgVoteWeighted", tx_1.MsgVoteWeighted],
      ["/cosmos.gov.v1beta1.MsgDeposit", tx_2.MsgDeposit],
      ["/cosmos.gov.v1beta1.MsgSubmitProposal", tx_2.MsgSubmitProposal],
      ["/cosmos.gov.v1beta1.MsgVote", tx_2.MsgVote],
      ["/cosmos.gov.v1beta1.MsgVoteWeighted", tx_2.MsgVoteWeighted]
    ];
    function isMsgDepositEncodeObject(object) {
      return object.typeUrl === "/cosmos.gov.v1beta1.MsgDeposit";
    }
    function isMsgSubmitProposalEncodeObject(object) {
      return object.typeUrl === "/cosmos.gov.v1beta1.MsgSubmitProposal";
    }
    function isMsgVoteEncodeObject(object) {
      return object.typeUrl === "/cosmos.gov.v1beta1.MsgVote";
    }
    function isMsgVoteWeightedEncodeObject(object) {
      return object.typeUrl === "/cosmos.gov.v1beta1.MsgVoteWeighted";
    }
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/gov/v1beta1/query.js
var require_query6 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/gov/v1beta1/query.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryClientImpl = exports.QueryTallyResultResponse = exports.QueryTallyResultRequest = exports.QueryDepositsResponse = exports.QueryDepositsRequest = exports.QueryDepositResponse = exports.QueryDepositRequest = exports.QueryParamsResponse = exports.QueryParamsRequest = exports.QueryVotesResponse = exports.QueryVotesRequest = exports.QueryVoteResponse = exports.QueryVoteRequest = exports.QueryProposalsResponse = exports.QueryProposalsRequest = exports.QueryProposalResponse = exports.QueryProposalRequest = exports.protobufPackage = void 0;
    var gov_1 = require_gov();
    var pagination_1 = require_pagination();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.gov.v1beta1";
    function createBaseQueryProposalRequest() {
      return {
        proposalId: BigInt(0)
      };
    }
    exports.QueryProposalRequest = {
      typeUrl: "/cosmos.gov.v1beta1.QueryProposalRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryProposalRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryProposalRequest();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryProposalRequest();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        return message;
      }
    };
    function createBaseQueryProposalResponse() {
      return {
        proposal: gov_1.Proposal.fromPartial({})
      };
    }
    exports.QueryProposalResponse = {
      typeUrl: "/cosmos.gov.v1beta1.QueryProposalResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposal !== void 0) {
          gov_1.Proposal.encode(message.proposal, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryProposalResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposal = gov_1.Proposal.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryProposalResponse();
        if ((0, helpers_1.isSet)(object.proposal))
          obj.proposal = gov_1.Proposal.fromJSON(object.proposal);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposal !== void 0 && (obj.proposal = message.proposal ? gov_1.Proposal.toJSON(message.proposal) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryProposalResponse();
        if (object.proposal !== void 0 && object.proposal !== null) {
          message.proposal = gov_1.Proposal.fromPartial(object.proposal);
        }
        return message;
      }
    };
    function createBaseQueryProposalsRequest() {
      return {
        proposalStatus: 0,
        voter: "",
        depositor: "",
        pagination: void 0
      };
    }
    exports.QueryProposalsRequest = {
      typeUrl: "/cosmos.gov.v1beta1.QueryProposalsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalStatus !== 0) {
          writer.uint32(8).int32(message.proposalStatus);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        if (message.depositor !== "") {
          writer.uint32(26).string(message.depositor);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryProposalsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalStatus = reader.int32();
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 3:
              message.depositor = reader.string();
              break;
            case 4:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryProposalsRequest();
        if ((0, helpers_1.isSet)(object.proposalStatus))
          obj.proposalStatus = (0, gov_1.proposalStatusFromJSON)(object.proposalStatus);
        if ((0, helpers_1.isSet)(object.voter))
          obj.voter = String(object.voter);
        if ((0, helpers_1.isSet)(object.depositor))
          obj.depositor = String(object.depositor);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalStatus !== void 0 && (obj.proposalStatus = (0, gov_1.proposalStatusToJSON)(message.proposalStatus));
        message.voter !== void 0 && (obj.voter = message.voter);
        message.depositor !== void 0 && (obj.depositor = message.depositor);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryProposalsRequest();
        message.proposalStatus = object.proposalStatus ?? 0;
        message.voter = object.voter ?? "";
        message.depositor = object.depositor ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryProposalsResponse() {
      return {
        proposals: [],
        pagination: void 0
      };
    }
    exports.QueryProposalsResponse = {
      typeUrl: "/cosmos.gov.v1beta1.QueryProposalsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.proposals) {
          gov_1.Proposal.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryProposalsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposals.push(gov_1.Proposal.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryProposalsResponse();
        if (Array.isArray(object?.proposals))
          obj.proposals = object.proposals.map((e) => gov_1.Proposal.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.proposals) {
          obj.proposals = message.proposals.map((e) => e ? gov_1.Proposal.toJSON(e) : void 0);
        } else {
          obj.proposals = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryProposalsResponse();
        message.proposals = object.proposals?.map((e) => gov_1.Proposal.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryVoteRequest() {
      return {
        proposalId: BigInt(0),
        voter: ""
      };
    }
    exports.QueryVoteRequest = {
      typeUrl: "/cosmos.gov.v1beta1.QueryVoteRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryVoteRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.voter = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryVoteRequest();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.voter))
          obj.voter = String(object.voter);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.voter !== void 0 && (obj.voter = message.voter);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryVoteRequest();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.voter = object.voter ?? "";
        return message;
      }
    };
    function createBaseQueryVoteResponse() {
      return {
        vote: gov_1.Vote.fromPartial({})
      };
    }
    exports.QueryVoteResponse = {
      typeUrl: "/cosmos.gov.v1beta1.QueryVoteResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.vote !== void 0) {
          gov_1.Vote.encode(message.vote, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryVoteResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.vote = gov_1.Vote.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryVoteResponse();
        if ((0, helpers_1.isSet)(object.vote))
          obj.vote = gov_1.Vote.fromJSON(object.vote);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.vote !== void 0 && (obj.vote = message.vote ? gov_1.Vote.toJSON(message.vote) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryVoteResponse();
        if (object.vote !== void 0 && object.vote !== null) {
          message.vote = gov_1.Vote.fromPartial(object.vote);
        }
        return message;
      }
    };
    function createBaseQueryVotesRequest() {
      return {
        proposalId: BigInt(0),
        pagination: void 0
      };
    }
    exports.QueryVotesRequest = {
      typeUrl: "/cosmos.gov.v1beta1.QueryVotesRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryVotesRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryVotesRequest();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryVotesRequest();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryVotesResponse() {
      return {
        votes: [],
        pagination: void 0
      };
    }
    exports.QueryVotesResponse = {
      typeUrl: "/cosmos.gov.v1beta1.QueryVotesResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.votes) {
          gov_1.Vote.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryVotesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.votes.push(gov_1.Vote.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryVotesResponse();
        if (Array.isArray(object?.votes))
          obj.votes = object.votes.map((e) => gov_1.Vote.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.votes) {
          obj.votes = message.votes.map((e) => e ? gov_1.Vote.toJSON(e) : void 0);
        } else {
          obj.votes = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryVotesResponse();
        message.votes = object.votes?.map((e) => gov_1.Vote.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryParamsRequest() {
      return {
        paramsType: ""
      };
    }
    exports.QueryParamsRequest = {
      typeUrl: "/cosmos.gov.v1beta1.QueryParamsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.paramsType !== "") {
          writer.uint32(10).string(message.paramsType);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.paramsType = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryParamsRequest();
        if ((0, helpers_1.isSet)(object.paramsType))
          obj.paramsType = String(object.paramsType);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.paramsType !== void 0 && (obj.paramsType = message.paramsType);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryParamsRequest();
        message.paramsType = object.paramsType ?? "";
        return message;
      }
    };
    function createBaseQueryParamsResponse() {
      return {
        votingParams: gov_1.VotingParams.fromPartial({}),
        depositParams: gov_1.DepositParams.fromPartial({}),
        tallyParams: gov_1.TallyParams.fromPartial({})
      };
    }
    exports.QueryParamsResponse = {
      typeUrl: "/cosmos.gov.v1beta1.QueryParamsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.votingParams !== void 0) {
          gov_1.VotingParams.encode(message.votingParams, writer.uint32(10).fork()).ldelim();
        }
        if (message.depositParams !== void 0) {
          gov_1.DepositParams.encode(message.depositParams, writer.uint32(18).fork()).ldelim();
        }
        if (message.tallyParams !== void 0) {
          gov_1.TallyParams.encode(message.tallyParams, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.votingParams = gov_1.VotingParams.decode(reader, reader.uint32());
              break;
            case 2:
              message.depositParams = gov_1.DepositParams.decode(reader, reader.uint32());
              break;
            case 3:
              message.tallyParams = gov_1.TallyParams.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryParamsResponse();
        if ((0, helpers_1.isSet)(object.votingParams))
          obj.votingParams = gov_1.VotingParams.fromJSON(object.votingParams);
        if ((0, helpers_1.isSet)(object.depositParams))
          obj.depositParams = gov_1.DepositParams.fromJSON(object.depositParams);
        if ((0, helpers_1.isSet)(object.tallyParams))
          obj.tallyParams = gov_1.TallyParams.fromJSON(object.tallyParams);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.votingParams !== void 0 && (obj.votingParams = message.votingParams ? gov_1.VotingParams.toJSON(message.votingParams) : void 0);
        message.depositParams !== void 0 && (obj.depositParams = message.depositParams ? gov_1.DepositParams.toJSON(message.depositParams) : void 0);
        message.tallyParams !== void 0 && (obj.tallyParams = message.tallyParams ? gov_1.TallyParams.toJSON(message.tallyParams) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryParamsResponse();
        if (object.votingParams !== void 0 && object.votingParams !== null) {
          message.votingParams = gov_1.VotingParams.fromPartial(object.votingParams);
        }
        if (object.depositParams !== void 0 && object.depositParams !== null) {
          message.depositParams = gov_1.DepositParams.fromPartial(object.depositParams);
        }
        if (object.tallyParams !== void 0 && object.tallyParams !== null) {
          message.tallyParams = gov_1.TallyParams.fromPartial(object.tallyParams);
        }
        return message;
      }
    };
    function createBaseQueryDepositRequest() {
      return {
        proposalId: BigInt(0),
        depositor: ""
      };
    }
    exports.QueryDepositRequest = {
      typeUrl: "/cosmos.gov.v1beta1.QueryDepositRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.depositor !== "") {
          writer.uint32(18).string(message.depositor);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDepositRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.depositor = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDepositRequest();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.depositor))
          obj.depositor = String(object.depositor);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.depositor !== void 0 && (obj.depositor = message.depositor);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDepositRequest();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.depositor = object.depositor ?? "";
        return message;
      }
    };
    function createBaseQueryDepositResponse() {
      return {
        deposit: gov_1.Deposit.fromPartial({})
      };
    }
    exports.QueryDepositResponse = {
      typeUrl: "/cosmos.gov.v1beta1.QueryDepositResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.deposit !== void 0) {
          gov_1.Deposit.encode(message.deposit, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDepositResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.deposit = gov_1.Deposit.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDepositResponse();
        if ((0, helpers_1.isSet)(object.deposit))
          obj.deposit = gov_1.Deposit.fromJSON(object.deposit);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.deposit !== void 0 && (obj.deposit = message.deposit ? gov_1.Deposit.toJSON(message.deposit) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDepositResponse();
        if (object.deposit !== void 0 && object.deposit !== null) {
          message.deposit = gov_1.Deposit.fromPartial(object.deposit);
        }
        return message;
      }
    };
    function createBaseQueryDepositsRequest() {
      return {
        proposalId: BigInt(0),
        pagination: void 0
      };
    }
    exports.QueryDepositsRequest = {
      typeUrl: "/cosmos.gov.v1beta1.QueryDepositsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDepositsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDepositsRequest();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDepositsRequest();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDepositsResponse() {
      return {
        deposits: [],
        pagination: void 0
      };
    }
    exports.QueryDepositsResponse = {
      typeUrl: "/cosmos.gov.v1beta1.QueryDepositsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.deposits) {
          gov_1.Deposit.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDepositsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.deposits.push(gov_1.Deposit.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDepositsResponse();
        if (Array.isArray(object?.deposits))
          obj.deposits = object.deposits.map((e) => gov_1.Deposit.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.deposits) {
          obj.deposits = message.deposits.map((e) => e ? gov_1.Deposit.toJSON(e) : void 0);
        } else {
          obj.deposits = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDepositsResponse();
        message.deposits = object.deposits?.map((e) => gov_1.Deposit.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryTallyResultRequest() {
      return {
        proposalId: BigInt(0)
      };
    }
    exports.QueryTallyResultRequest = {
      typeUrl: "/cosmos.gov.v1beta1.QueryTallyResultRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryTallyResultRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryTallyResultRequest();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryTallyResultRequest();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        return message;
      }
    };
    function createBaseQueryTallyResultResponse() {
      return {
        tally: gov_1.TallyResult.fromPartial({})
      };
    }
    exports.QueryTallyResultResponse = {
      typeUrl: "/cosmos.gov.v1beta1.QueryTallyResultResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.tally !== void 0) {
          gov_1.TallyResult.encode(message.tally, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryTallyResultResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.tally = gov_1.TallyResult.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryTallyResultResponse();
        if ((0, helpers_1.isSet)(object.tally))
          obj.tally = gov_1.TallyResult.fromJSON(object.tally);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.tally !== void 0 && (obj.tally = message.tally ? gov_1.TallyResult.toJSON(message.tally) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryTallyResultResponse();
        if (object.tally !== void 0 && object.tally !== null) {
          message.tally = gov_1.TallyResult.fromPartial(object.tally);
        }
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Proposal = this.Proposal.bind(this);
        this.Proposals = this.Proposals.bind(this);
        this.Vote = this.Vote.bind(this);
        this.Votes = this.Votes.bind(this);
        this.Params = this.Params.bind(this);
        this.Deposit = this.Deposit.bind(this);
        this.Deposits = this.Deposits.bind(this);
        this.TallyResult = this.TallyResult.bind(this);
      }
      Proposal(request) {
        const data2 = exports.QueryProposalRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Proposal", data2);
        return promise.then((data3) => exports.QueryProposalResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Proposals(request) {
        const data2 = exports.QueryProposalsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Proposals", data2);
        return promise.then((data3) => exports.QueryProposalsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Vote(request) {
        const data2 = exports.QueryVoteRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Vote", data2);
        return promise.then((data3) => exports.QueryVoteResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Votes(request) {
        const data2 = exports.QueryVotesRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Votes", data2);
        return promise.then((data3) => exports.QueryVotesResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Params(request) {
        const data2 = exports.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Params", data2);
        return promise.then((data3) => exports.QueryParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Deposit(request) {
        const data2 = exports.QueryDepositRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Deposit", data2);
        return promise.then((data3) => exports.QueryDepositResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Deposits(request) {
        const data2 = exports.QueryDepositsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "Deposits", data2);
        return promise.then((data3) => exports.QueryDepositsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      TallyResult(request) {
        const data2 = exports.QueryTallyResultRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.gov.v1beta1.Query", "TallyResult", data2);
        return promise.then((data3) => exports.QueryTallyResultResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.QueryClientImpl = QueryClientImpl;
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/gov/queries.js
var require_queries6 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/gov/queries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupGovExtension = setupGovExtension;
    var query_1 = require_query6();
    var queryclient_1 = require_queryclient2();
    function setupGovExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        gov: {
          params: async (parametersType) => {
            const response = await queryService.Params({ paramsType: parametersType });
            return response;
          },
          proposals: async (proposalStatus, depositorAddress, voterAddress, paginationKey) => {
            const response = await queryService.Proposals({
              proposalStatus,
              depositor: depositorAddress,
              voter: voterAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          proposal: async (proposalId) => {
            const response = await queryService.Proposal({ proposalId: (0, queryclient_1.longify)(proposalId) });
            return response;
          },
          deposits: async (proposalId, paginationKey) => {
            const response = await queryService.Deposits({
              proposalId: (0, queryclient_1.longify)(proposalId),
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          deposit: async (proposalId, depositorAddress) => {
            const response = await queryService.Deposit({
              proposalId: (0, queryclient_1.longify)(proposalId),
              depositor: depositorAddress
            });
            return response;
          },
          tally: async (proposalId) => {
            const response = await queryService.TallyResult({
              proposalId: (0, queryclient_1.longify)(proposalId)
            });
            return response;
          },
          votes: async (proposalId, paginationKey) => {
            const response = await queryService.Votes({
              proposalId: (0, queryclient_1.longify)(proposalId),
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          vote: async (proposalId, voterAddress) => {
            const response = await queryService.Vote({
              proposalId: (0, queryclient_1.longify)(proposalId),
              voter: voterAddress
            });
            return response;
          }
        }
      };
    }
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/group/aminomessages.js
var require_aminomessages8 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/group/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createGroupAminoConverters = createGroupAminoConverters;
    function createGroupAminoConverters() {
      return {};
    }
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/group/v1/types.js
var require_types = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/group/v1/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Vote = exports.TallyResult = exports.Proposal = exports.GroupPolicyInfo = exports.GroupMember = exports.GroupInfo = exports.DecisionPolicyWindows = exports.PercentageDecisionPolicy = exports.ThresholdDecisionPolicy = exports.MemberRequest = exports.Member = exports.proposalExecutorResultToJSON = exports.proposalExecutorResultFromJSON = exports.ProposalExecutorResult = exports.proposalStatusToJSON = exports.proposalStatusFromJSON = exports.ProposalStatus = exports.voteOptionToJSON = exports.voteOptionFromJSON = exports.VoteOption = exports.protobufPackage = void 0;
    var timestamp_1 = require_timestamp();
    var duration_1 = require_duration();
    var any_1 = require_any();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.group.v1";
    var VoteOption;
    (function(VoteOption2) {
      VoteOption2[VoteOption2["VOTE_OPTION_UNSPECIFIED"] = 0] = "VOTE_OPTION_UNSPECIFIED";
      VoteOption2[VoteOption2["VOTE_OPTION_YES"] = 1] = "VOTE_OPTION_YES";
      VoteOption2[VoteOption2["VOTE_OPTION_ABSTAIN"] = 2] = "VOTE_OPTION_ABSTAIN";
      VoteOption2[VoteOption2["VOTE_OPTION_NO"] = 3] = "VOTE_OPTION_NO";
      VoteOption2[VoteOption2["VOTE_OPTION_NO_WITH_VETO"] = 4] = "VOTE_OPTION_NO_WITH_VETO";
      VoteOption2[VoteOption2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(VoteOption || (exports.VoteOption = VoteOption = {}));
    function voteOptionFromJSON(object) {
      switch (object) {
        case 0:
        case "VOTE_OPTION_UNSPECIFIED":
          return VoteOption.VOTE_OPTION_UNSPECIFIED;
        case 1:
        case "VOTE_OPTION_YES":
          return VoteOption.VOTE_OPTION_YES;
        case 2:
        case "VOTE_OPTION_ABSTAIN":
          return VoteOption.VOTE_OPTION_ABSTAIN;
        case 3:
        case "VOTE_OPTION_NO":
          return VoteOption.VOTE_OPTION_NO;
        case 4:
        case "VOTE_OPTION_NO_WITH_VETO":
          return VoteOption.VOTE_OPTION_NO_WITH_VETO;
        case -1:
        case "UNRECOGNIZED":
        default:
          return VoteOption.UNRECOGNIZED;
      }
    }
    exports.voteOptionFromJSON = voteOptionFromJSON;
    function voteOptionToJSON(object) {
      switch (object) {
        case VoteOption.VOTE_OPTION_UNSPECIFIED:
          return "VOTE_OPTION_UNSPECIFIED";
        case VoteOption.VOTE_OPTION_YES:
          return "VOTE_OPTION_YES";
        case VoteOption.VOTE_OPTION_ABSTAIN:
          return "VOTE_OPTION_ABSTAIN";
        case VoteOption.VOTE_OPTION_NO:
          return "VOTE_OPTION_NO";
        case VoteOption.VOTE_OPTION_NO_WITH_VETO:
          return "VOTE_OPTION_NO_WITH_VETO";
        case VoteOption.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.voteOptionToJSON = voteOptionToJSON;
    var ProposalStatus;
    (function(ProposalStatus2) {
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_UNSPECIFIED"] = 0] = "PROPOSAL_STATUS_UNSPECIFIED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_SUBMITTED"] = 1] = "PROPOSAL_STATUS_SUBMITTED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_ACCEPTED"] = 2] = "PROPOSAL_STATUS_ACCEPTED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_REJECTED"] = 3] = "PROPOSAL_STATUS_REJECTED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_ABORTED"] = 4] = "PROPOSAL_STATUS_ABORTED";
      ProposalStatus2[ProposalStatus2["PROPOSAL_STATUS_WITHDRAWN"] = 5] = "PROPOSAL_STATUS_WITHDRAWN";
      ProposalStatus2[ProposalStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ProposalStatus || (exports.ProposalStatus = ProposalStatus = {}));
    function proposalStatusFromJSON(object) {
      switch (object) {
        case 0:
        case "PROPOSAL_STATUS_UNSPECIFIED":
          return ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED;
        case 1:
        case "PROPOSAL_STATUS_SUBMITTED":
          return ProposalStatus.PROPOSAL_STATUS_SUBMITTED;
        case 2:
        case "PROPOSAL_STATUS_ACCEPTED":
          return ProposalStatus.PROPOSAL_STATUS_ACCEPTED;
        case 3:
        case "PROPOSAL_STATUS_REJECTED":
          return ProposalStatus.PROPOSAL_STATUS_REJECTED;
        case 4:
        case "PROPOSAL_STATUS_ABORTED":
          return ProposalStatus.PROPOSAL_STATUS_ABORTED;
        case 5:
        case "PROPOSAL_STATUS_WITHDRAWN":
          return ProposalStatus.PROPOSAL_STATUS_WITHDRAWN;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ProposalStatus.UNRECOGNIZED;
      }
    }
    exports.proposalStatusFromJSON = proposalStatusFromJSON;
    function proposalStatusToJSON(object) {
      switch (object) {
        case ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED:
          return "PROPOSAL_STATUS_UNSPECIFIED";
        case ProposalStatus.PROPOSAL_STATUS_SUBMITTED:
          return "PROPOSAL_STATUS_SUBMITTED";
        case ProposalStatus.PROPOSAL_STATUS_ACCEPTED:
          return "PROPOSAL_STATUS_ACCEPTED";
        case ProposalStatus.PROPOSAL_STATUS_REJECTED:
          return "PROPOSAL_STATUS_REJECTED";
        case ProposalStatus.PROPOSAL_STATUS_ABORTED:
          return "PROPOSAL_STATUS_ABORTED";
        case ProposalStatus.PROPOSAL_STATUS_WITHDRAWN:
          return "PROPOSAL_STATUS_WITHDRAWN";
        case ProposalStatus.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.proposalStatusToJSON = proposalStatusToJSON;
    var ProposalExecutorResult;
    (function(ProposalExecutorResult2) {
      ProposalExecutorResult2[ProposalExecutorResult2["PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED"] = 0] = "PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED";
      ProposalExecutorResult2[ProposalExecutorResult2["PROPOSAL_EXECUTOR_RESULT_NOT_RUN"] = 1] = "PROPOSAL_EXECUTOR_RESULT_NOT_RUN";
      ProposalExecutorResult2[ProposalExecutorResult2["PROPOSAL_EXECUTOR_RESULT_SUCCESS"] = 2] = "PROPOSAL_EXECUTOR_RESULT_SUCCESS";
      ProposalExecutorResult2[ProposalExecutorResult2["PROPOSAL_EXECUTOR_RESULT_FAILURE"] = 3] = "PROPOSAL_EXECUTOR_RESULT_FAILURE";
      ProposalExecutorResult2[ProposalExecutorResult2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ProposalExecutorResult || (exports.ProposalExecutorResult = ProposalExecutorResult = {}));
    function proposalExecutorResultFromJSON(object) {
      switch (object) {
        case 0:
        case "PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED":
          return ProposalExecutorResult.PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED;
        case 1:
        case "PROPOSAL_EXECUTOR_RESULT_NOT_RUN":
          return ProposalExecutorResult.PROPOSAL_EXECUTOR_RESULT_NOT_RUN;
        case 2:
        case "PROPOSAL_EXECUTOR_RESULT_SUCCESS":
          return ProposalExecutorResult.PROPOSAL_EXECUTOR_RESULT_SUCCESS;
        case 3:
        case "PROPOSAL_EXECUTOR_RESULT_FAILURE":
          return ProposalExecutorResult.PROPOSAL_EXECUTOR_RESULT_FAILURE;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ProposalExecutorResult.UNRECOGNIZED;
      }
    }
    exports.proposalExecutorResultFromJSON = proposalExecutorResultFromJSON;
    function proposalExecutorResultToJSON(object) {
      switch (object) {
        case ProposalExecutorResult.PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED:
          return "PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED";
        case ProposalExecutorResult.PROPOSAL_EXECUTOR_RESULT_NOT_RUN:
          return "PROPOSAL_EXECUTOR_RESULT_NOT_RUN";
        case ProposalExecutorResult.PROPOSAL_EXECUTOR_RESULT_SUCCESS:
          return "PROPOSAL_EXECUTOR_RESULT_SUCCESS";
        case ProposalExecutorResult.PROPOSAL_EXECUTOR_RESULT_FAILURE:
          return "PROPOSAL_EXECUTOR_RESULT_FAILURE";
        case ProposalExecutorResult.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.proposalExecutorResultToJSON = proposalExecutorResultToJSON;
    function createBaseMember() {
      return {
        address: "",
        weight: "",
        metadata: "",
        addedAt: timestamp_1.Timestamp.fromPartial({})
      };
    }
    exports.Member = {
      typeUrl: "/cosmos.group.v1.Member",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.weight !== "") {
          writer.uint32(18).string(message.weight);
        }
        if (message.metadata !== "") {
          writer.uint32(26).string(message.metadata);
        }
        if (message.addedAt !== void 0) {
          timestamp_1.Timestamp.encode(message.addedAt, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMember();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.weight = reader.string();
              break;
            case 3:
              message.metadata = reader.string();
              break;
            case 4:
              message.addedAt = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMember();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.weight))
          obj.weight = String(object.weight);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        if ((0, helpers_1.isSet)(object.addedAt))
          obj.addedAt = (0, helpers_1.fromJsonTimestamp)(object.addedAt);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.weight !== void 0 && (obj.weight = message.weight);
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        message.addedAt !== void 0 && (obj.addedAt = (0, helpers_1.fromTimestamp)(message.addedAt).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMember();
        message.address = object.address ?? "";
        message.weight = object.weight ?? "";
        message.metadata = object.metadata ?? "";
        if (object.addedAt !== void 0 && object.addedAt !== null) {
          message.addedAt = timestamp_1.Timestamp.fromPartial(object.addedAt);
        }
        return message;
      }
    };
    function createBaseMemberRequest() {
      return {
        address: "",
        weight: "",
        metadata: ""
      };
    }
    exports.MemberRequest = {
      typeUrl: "/cosmos.group.v1.MemberRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.weight !== "") {
          writer.uint32(18).string(message.weight);
        }
        if (message.metadata !== "") {
          writer.uint32(26).string(message.metadata);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMemberRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.weight = reader.string();
              break;
            case 3:
              message.metadata = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMemberRequest();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.weight))
          obj.weight = String(object.weight);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.weight !== void 0 && (obj.weight = message.weight);
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMemberRequest();
        message.address = object.address ?? "";
        message.weight = object.weight ?? "";
        message.metadata = object.metadata ?? "";
        return message;
      }
    };
    function createBaseThresholdDecisionPolicy() {
      return {
        threshold: "",
        windows: void 0
      };
    }
    exports.ThresholdDecisionPolicy = {
      typeUrl: "/cosmos.group.v1.ThresholdDecisionPolicy",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.threshold !== "") {
          writer.uint32(10).string(message.threshold);
        }
        if (message.windows !== void 0) {
          exports.DecisionPolicyWindows.encode(message.windows, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseThresholdDecisionPolicy();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.threshold = reader.string();
              break;
            case 2:
              message.windows = exports.DecisionPolicyWindows.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseThresholdDecisionPolicy();
        if ((0, helpers_1.isSet)(object.threshold))
          obj.threshold = String(object.threshold);
        if ((0, helpers_1.isSet)(object.windows))
          obj.windows = exports.DecisionPolicyWindows.fromJSON(object.windows);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.threshold !== void 0 && (obj.threshold = message.threshold);
        message.windows !== void 0 && (obj.windows = message.windows ? exports.DecisionPolicyWindows.toJSON(message.windows) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseThresholdDecisionPolicy();
        message.threshold = object.threshold ?? "";
        if (object.windows !== void 0 && object.windows !== null) {
          message.windows = exports.DecisionPolicyWindows.fromPartial(object.windows);
        }
        return message;
      }
    };
    function createBasePercentageDecisionPolicy() {
      return {
        percentage: "",
        windows: void 0
      };
    }
    exports.PercentageDecisionPolicy = {
      typeUrl: "/cosmos.group.v1.PercentageDecisionPolicy",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.percentage !== "") {
          writer.uint32(10).string(message.percentage);
        }
        if (message.windows !== void 0) {
          exports.DecisionPolicyWindows.encode(message.windows, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePercentageDecisionPolicy();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.percentage = reader.string();
              break;
            case 2:
              message.windows = exports.DecisionPolicyWindows.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePercentageDecisionPolicy();
        if ((0, helpers_1.isSet)(object.percentage))
          obj.percentage = String(object.percentage);
        if ((0, helpers_1.isSet)(object.windows))
          obj.windows = exports.DecisionPolicyWindows.fromJSON(object.windows);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.percentage !== void 0 && (obj.percentage = message.percentage);
        message.windows !== void 0 && (obj.windows = message.windows ? exports.DecisionPolicyWindows.toJSON(message.windows) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBasePercentageDecisionPolicy();
        message.percentage = object.percentage ?? "";
        if (object.windows !== void 0 && object.windows !== null) {
          message.windows = exports.DecisionPolicyWindows.fromPartial(object.windows);
        }
        return message;
      }
    };
    function createBaseDecisionPolicyWindows() {
      return {
        votingPeriod: duration_1.Duration.fromPartial({}),
        minExecutionPeriod: duration_1.Duration.fromPartial({})
      };
    }
    exports.DecisionPolicyWindows = {
      typeUrl: "/cosmos.group.v1.DecisionPolicyWindows",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.votingPeriod !== void 0) {
          duration_1.Duration.encode(message.votingPeriod, writer.uint32(10).fork()).ldelim();
        }
        if (message.minExecutionPeriod !== void 0) {
          duration_1.Duration.encode(message.minExecutionPeriod, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDecisionPolicyWindows();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.votingPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 2:
              message.minExecutionPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDecisionPolicyWindows();
        if ((0, helpers_1.isSet)(object.votingPeriod))
          obj.votingPeriod = duration_1.Duration.fromJSON(object.votingPeriod);
        if ((0, helpers_1.isSet)(object.minExecutionPeriod))
          obj.minExecutionPeriod = duration_1.Duration.fromJSON(object.minExecutionPeriod);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.votingPeriod !== void 0 && (obj.votingPeriod = message.votingPeriod ? duration_1.Duration.toJSON(message.votingPeriod) : void 0);
        message.minExecutionPeriod !== void 0 && (obj.minExecutionPeriod = message.minExecutionPeriod ? duration_1.Duration.toJSON(message.minExecutionPeriod) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDecisionPolicyWindows();
        if (object.votingPeriod !== void 0 && object.votingPeriod !== null) {
          message.votingPeriod = duration_1.Duration.fromPartial(object.votingPeriod);
        }
        if (object.minExecutionPeriod !== void 0 && object.minExecutionPeriod !== null) {
          message.minExecutionPeriod = duration_1.Duration.fromPartial(object.minExecutionPeriod);
        }
        return message;
      }
    };
    function createBaseGroupInfo() {
      return {
        id: BigInt(0),
        admin: "",
        metadata: "",
        version: BigInt(0),
        totalWeight: "",
        createdAt: timestamp_1.Timestamp.fromPartial({})
      };
    }
    exports.GroupInfo = {
      typeUrl: "/cosmos.group.v1.GroupInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.id !== BigInt(0)) {
          writer.uint32(8).uint64(message.id);
        }
        if (message.admin !== "") {
          writer.uint32(18).string(message.admin);
        }
        if (message.metadata !== "") {
          writer.uint32(26).string(message.metadata);
        }
        if (message.version !== BigInt(0)) {
          writer.uint32(32).uint64(message.version);
        }
        if (message.totalWeight !== "") {
          writer.uint32(42).string(message.totalWeight);
        }
        if (message.createdAt !== void 0) {
          timestamp_1.Timestamp.encode(message.createdAt, writer.uint32(50).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGroupInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.uint64();
              break;
            case 2:
              message.admin = reader.string();
              break;
            case 3:
              message.metadata = reader.string();
              break;
            case 4:
              message.version = reader.uint64();
              break;
            case 5:
              message.totalWeight = reader.string();
              break;
            case 6:
              message.createdAt = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGroupInfo();
        if ((0, helpers_1.isSet)(object.id))
          obj.id = BigInt(object.id.toString());
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        if ((0, helpers_1.isSet)(object.version))
          obj.version = BigInt(object.version.toString());
        if ((0, helpers_1.isSet)(object.totalWeight))
          obj.totalWeight = String(object.totalWeight);
        if ((0, helpers_1.isSet)(object.createdAt))
          obj.createdAt = (0, helpers_1.fromJsonTimestamp)(object.createdAt);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.id !== void 0 && (obj.id = (message.id || BigInt(0)).toString());
        message.admin !== void 0 && (obj.admin = message.admin);
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        message.version !== void 0 && (obj.version = (message.version || BigInt(0)).toString());
        message.totalWeight !== void 0 && (obj.totalWeight = message.totalWeight);
        message.createdAt !== void 0 && (obj.createdAt = (0, helpers_1.fromTimestamp)(message.createdAt).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGroupInfo();
        if (object.id !== void 0 && object.id !== null) {
          message.id = BigInt(object.id.toString());
        }
        message.admin = object.admin ?? "";
        message.metadata = object.metadata ?? "";
        if (object.version !== void 0 && object.version !== null) {
          message.version = BigInt(object.version.toString());
        }
        message.totalWeight = object.totalWeight ?? "";
        if (object.createdAt !== void 0 && object.createdAt !== null) {
          message.createdAt = timestamp_1.Timestamp.fromPartial(object.createdAt);
        }
        return message;
      }
    };
    function createBaseGroupMember() {
      return {
        groupId: BigInt(0),
        member: void 0
      };
    }
    exports.GroupMember = {
      typeUrl: "/cosmos.group.v1.GroupMember",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.groupId !== BigInt(0)) {
          writer.uint32(8).uint64(message.groupId);
        }
        if (message.member !== void 0) {
          exports.Member.encode(message.member, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGroupMember();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.groupId = reader.uint64();
              break;
            case 2:
              message.member = exports.Member.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGroupMember();
        if ((0, helpers_1.isSet)(object.groupId))
          obj.groupId = BigInt(object.groupId.toString());
        if ((0, helpers_1.isSet)(object.member))
          obj.member = exports.Member.fromJSON(object.member);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.groupId !== void 0 && (obj.groupId = (message.groupId || BigInt(0)).toString());
        message.member !== void 0 && (obj.member = message.member ? exports.Member.toJSON(message.member) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGroupMember();
        if (object.groupId !== void 0 && object.groupId !== null) {
          message.groupId = BigInt(object.groupId.toString());
        }
        if (object.member !== void 0 && object.member !== null) {
          message.member = exports.Member.fromPartial(object.member);
        }
        return message;
      }
    };
    function createBaseGroupPolicyInfo() {
      return {
        address: "",
        groupId: BigInt(0),
        admin: "",
        metadata: "",
        version: BigInt(0),
        decisionPolicy: void 0,
        createdAt: timestamp_1.Timestamp.fromPartial({})
      };
    }
    exports.GroupPolicyInfo = {
      typeUrl: "/cosmos.group.v1.GroupPolicyInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.groupId !== BigInt(0)) {
          writer.uint32(16).uint64(message.groupId);
        }
        if (message.admin !== "") {
          writer.uint32(26).string(message.admin);
        }
        if (message.metadata !== "") {
          writer.uint32(34).string(message.metadata);
        }
        if (message.version !== BigInt(0)) {
          writer.uint32(40).uint64(message.version);
        }
        if (message.decisionPolicy !== void 0) {
          any_1.Any.encode(message.decisionPolicy, writer.uint32(50).fork()).ldelim();
        }
        if (message.createdAt !== void 0) {
          timestamp_1.Timestamp.encode(message.createdAt, writer.uint32(58).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGroupPolicyInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.groupId = reader.uint64();
              break;
            case 3:
              message.admin = reader.string();
              break;
            case 4:
              message.metadata = reader.string();
              break;
            case 5:
              message.version = reader.uint64();
              break;
            case 6:
              message.decisionPolicy = any_1.Any.decode(reader, reader.uint32());
              break;
            case 7:
              message.createdAt = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGroupPolicyInfo();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.groupId))
          obj.groupId = BigInt(object.groupId.toString());
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        if ((0, helpers_1.isSet)(object.version))
          obj.version = BigInt(object.version.toString());
        if ((0, helpers_1.isSet)(object.decisionPolicy))
          obj.decisionPolicy = any_1.Any.fromJSON(object.decisionPolicy);
        if ((0, helpers_1.isSet)(object.createdAt))
          obj.createdAt = (0, helpers_1.fromJsonTimestamp)(object.createdAt);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.groupId !== void 0 && (obj.groupId = (message.groupId || BigInt(0)).toString());
        message.admin !== void 0 && (obj.admin = message.admin);
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        message.version !== void 0 && (obj.version = (message.version || BigInt(0)).toString());
        message.decisionPolicy !== void 0 && (obj.decisionPolicy = message.decisionPolicy ? any_1.Any.toJSON(message.decisionPolicy) : void 0);
        message.createdAt !== void 0 && (obj.createdAt = (0, helpers_1.fromTimestamp)(message.createdAt).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGroupPolicyInfo();
        message.address = object.address ?? "";
        if (object.groupId !== void 0 && object.groupId !== null) {
          message.groupId = BigInt(object.groupId.toString());
        }
        message.admin = object.admin ?? "";
        message.metadata = object.metadata ?? "";
        if (object.version !== void 0 && object.version !== null) {
          message.version = BigInt(object.version.toString());
        }
        if (object.decisionPolicy !== void 0 && object.decisionPolicy !== null) {
          message.decisionPolicy = any_1.Any.fromPartial(object.decisionPolicy);
        }
        if (object.createdAt !== void 0 && object.createdAt !== null) {
          message.createdAt = timestamp_1.Timestamp.fromPartial(object.createdAt);
        }
        return message;
      }
    };
    function createBaseProposal() {
      return {
        id: BigInt(0),
        groupPolicyAddress: "",
        metadata: "",
        proposers: [],
        submitTime: timestamp_1.Timestamp.fromPartial({}),
        groupVersion: BigInt(0),
        groupPolicyVersion: BigInt(0),
        status: 0,
        finalTallyResult: exports.TallyResult.fromPartial({}),
        votingPeriodEnd: timestamp_1.Timestamp.fromPartial({}),
        executorResult: 0,
        messages: [],
        title: "",
        summary: ""
      };
    }
    exports.Proposal = {
      typeUrl: "/cosmos.group.v1.Proposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.id !== BigInt(0)) {
          writer.uint32(8).uint64(message.id);
        }
        if (message.groupPolicyAddress !== "") {
          writer.uint32(18).string(message.groupPolicyAddress);
        }
        if (message.metadata !== "") {
          writer.uint32(26).string(message.metadata);
        }
        for (const v9 of message.proposers) {
          writer.uint32(34).string(v9);
        }
        if (message.submitTime !== void 0) {
          timestamp_1.Timestamp.encode(message.submitTime, writer.uint32(42).fork()).ldelim();
        }
        if (message.groupVersion !== BigInt(0)) {
          writer.uint32(48).uint64(message.groupVersion);
        }
        if (message.groupPolicyVersion !== BigInt(0)) {
          writer.uint32(56).uint64(message.groupPolicyVersion);
        }
        if (message.status !== 0) {
          writer.uint32(64).int32(message.status);
        }
        if (message.finalTallyResult !== void 0) {
          exports.TallyResult.encode(message.finalTallyResult, writer.uint32(74).fork()).ldelim();
        }
        if (message.votingPeriodEnd !== void 0) {
          timestamp_1.Timestamp.encode(message.votingPeriodEnd, writer.uint32(82).fork()).ldelim();
        }
        if (message.executorResult !== 0) {
          writer.uint32(88).int32(message.executorResult);
        }
        for (const v9 of message.messages) {
          any_1.Any.encode(v9, writer.uint32(98).fork()).ldelim();
        }
        if (message.title !== "") {
          writer.uint32(106).string(message.title);
        }
        if (message.summary !== "") {
          writer.uint32(114).string(message.summary);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.uint64();
              break;
            case 2:
              message.groupPolicyAddress = reader.string();
              break;
            case 3:
              message.metadata = reader.string();
              break;
            case 4:
              message.proposers.push(reader.string());
              break;
            case 5:
              message.submitTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 6:
              message.groupVersion = reader.uint64();
              break;
            case 7:
              message.groupPolicyVersion = reader.uint64();
              break;
            case 8:
              message.status = reader.int32();
              break;
            case 9:
              message.finalTallyResult = exports.TallyResult.decode(reader, reader.uint32());
              break;
            case 10:
              message.votingPeriodEnd = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 11:
              message.executorResult = reader.int32();
              break;
            case 12:
              message.messages.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            case 13:
              message.title = reader.string();
              break;
            case 14:
              message.summary = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseProposal();
        if ((0, helpers_1.isSet)(object.id))
          obj.id = BigInt(object.id.toString());
        if ((0, helpers_1.isSet)(object.groupPolicyAddress))
          obj.groupPolicyAddress = String(object.groupPolicyAddress);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        if (Array.isArray(object?.proposers))
          obj.proposers = object.proposers.map((e) => String(e));
        if ((0, helpers_1.isSet)(object.submitTime))
          obj.submitTime = (0, helpers_1.fromJsonTimestamp)(object.submitTime);
        if ((0, helpers_1.isSet)(object.groupVersion))
          obj.groupVersion = BigInt(object.groupVersion.toString());
        if ((0, helpers_1.isSet)(object.groupPolicyVersion))
          obj.groupPolicyVersion = BigInt(object.groupPolicyVersion.toString());
        if ((0, helpers_1.isSet)(object.status))
          obj.status = proposalStatusFromJSON(object.status);
        if ((0, helpers_1.isSet)(object.finalTallyResult))
          obj.finalTallyResult = exports.TallyResult.fromJSON(object.finalTallyResult);
        if ((0, helpers_1.isSet)(object.votingPeriodEnd))
          obj.votingPeriodEnd = (0, helpers_1.fromJsonTimestamp)(object.votingPeriodEnd);
        if ((0, helpers_1.isSet)(object.executorResult))
          obj.executorResult = proposalExecutorResultFromJSON(object.executorResult);
        if (Array.isArray(object?.messages))
          obj.messages = object.messages.map((e) => any_1.Any.fromJSON(e));
        if ((0, helpers_1.isSet)(object.title))
          obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.summary))
          obj.summary = String(object.summary);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.id !== void 0 && (obj.id = (message.id || BigInt(0)).toString());
        message.groupPolicyAddress !== void 0 && (obj.groupPolicyAddress = message.groupPolicyAddress);
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        if (message.proposers) {
          obj.proposers = message.proposers.map((e) => e);
        } else {
          obj.proposers = [];
        }
        message.submitTime !== void 0 && (obj.submitTime = (0, helpers_1.fromTimestamp)(message.submitTime).toISOString());
        message.groupVersion !== void 0 && (obj.groupVersion = (message.groupVersion || BigInt(0)).toString());
        message.groupPolicyVersion !== void 0 && (obj.groupPolicyVersion = (message.groupPolicyVersion || BigInt(0)).toString());
        message.status !== void 0 && (obj.status = proposalStatusToJSON(message.status));
        message.finalTallyResult !== void 0 && (obj.finalTallyResult = message.finalTallyResult ? exports.TallyResult.toJSON(message.finalTallyResult) : void 0);
        message.votingPeriodEnd !== void 0 && (obj.votingPeriodEnd = (0, helpers_1.fromTimestamp)(message.votingPeriodEnd).toISOString());
        message.executorResult !== void 0 && (obj.executorResult = proposalExecutorResultToJSON(message.executorResult));
        if (message.messages) {
          obj.messages = message.messages.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.messages = [];
        }
        message.title !== void 0 && (obj.title = message.title);
        message.summary !== void 0 && (obj.summary = message.summary);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseProposal();
        if (object.id !== void 0 && object.id !== null) {
          message.id = BigInt(object.id.toString());
        }
        message.groupPolicyAddress = object.groupPolicyAddress ?? "";
        message.metadata = object.metadata ?? "";
        message.proposers = object.proposers?.map((e) => e) || [];
        if (object.submitTime !== void 0 && object.submitTime !== null) {
          message.submitTime = timestamp_1.Timestamp.fromPartial(object.submitTime);
        }
        if (object.groupVersion !== void 0 && object.groupVersion !== null) {
          message.groupVersion = BigInt(object.groupVersion.toString());
        }
        if (object.groupPolicyVersion !== void 0 && object.groupPolicyVersion !== null) {
          message.groupPolicyVersion = BigInt(object.groupPolicyVersion.toString());
        }
        message.status = object.status ?? 0;
        if (object.finalTallyResult !== void 0 && object.finalTallyResult !== null) {
          message.finalTallyResult = exports.TallyResult.fromPartial(object.finalTallyResult);
        }
        if (object.votingPeriodEnd !== void 0 && object.votingPeriodEnd !== null) {
          message.votingPeriodEnd = timestamp_1.Timestamp.fromPartial(object.votingPeriodEnd);
        }
        message.executorResult = object.executorResult ?? 0;
        message.messages = object.messages?.map((e) => any_1.Any.fromPartial(e)) || [];
        message.title = object.title ?? "";
        message.summary = object.summary ?? "";
        return message;
      }
    };
    function createBaseTallyResult() {
      return {
        yesCount: "",
        abstainCount: "",
        noCount: "",
        noWithVetoCount: ""
      };
    }
    exports.TallyResult = {
      typeUrl: "/cosmos.group.v1.TallyResult",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.yesCount !== "") {
          writer.uint32(10).string(message.yesCount);
        }
        if (message.abstainCount !== "") {
          writer.uint32(18).string(message.abstainCount);
        }
        if (message.noCount !== "") {
          writer.uint32(26).string(message.noCount);
        }
        if (message.noWithVetoCount !== "") {
          writer.uint32(34).string(message.noWithVetoCount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTallyResult();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.yesCount = reader.string();
              break;
            case 2:
              message.abstainCount = reader.string();
              break;
            case 3:
              message.noCount = reader.string();
              break;
            case 4:
              message.noWithVetoCount = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTallyResult();
        if ((0, helpers_1.isSet)(object.yesCount))
          obj.yesCount = String(object.yesCount);
        if ((0, helpers_1.isSet)(object.abstainCount))
          obj.abstainCount = String(object.abstainCount);
        if ((0, helpers_1.isSet)(object.noCount))
          obj.noCount = String(object.noCount);
        if ((0, helpers_1.isSet)(object.noWithVetoCount))
          obj.noWithVetoCount = String(object.noWithVetoCount);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.yesCount !== void 0 && (obj.yesCount = message.yesCount);
        message.abstainCount !== void 0 && (obj.abstainCount = message.abstainCount);
        message.noCount !== void 0 && (obj.noCount = message.noCount);
        message.noWithVetoCount !== void 0 && (obj.noWithVetoCount = message.noWithVetoCount);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTallyResult();
        message.yesCount = object.yesCount ?? "";
        message.abstainCount = object.abstainCount ?? "";
        message.noCount = object.noCount ?? "";
        message.noWithVetoCount = object.noWithVetoCount ?? "";
        return message;
      }
    };
    function createBaseVote() {
      return {
        proposalId: BigInt(0),
        voter: "",
        option: 0,
        metadata: "",
        submitTime: timestamp_1.Timestamp.fromPartial({})
      };
    }
    exports.Vote = {
      typeUrl: "/cosmos.group.v1.Vote",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        if (message.option !== 0) {
          writer.uint32(24).int32(message.option);
        }
        if (message.metadata !== "") {
          writer.uint32(34).string(message.metadata);
        }
        if (message.submitTime !== void 0) {
          timestamp_1.Timestamp.encode(message.submitTime, writer.uint32(42).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVote();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 3:
              message.option = reader.int32();
              break;
            case 4:
              message.metadata = reader.string();
              break;
            case 5:
              message.submitTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseVote();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.voter))
          obj.voter = String(object.voter);
        if ((0, helpers_1.isSet)(object.option))
          obj.option = voteOptionFromJSON(object.option);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        if ((0, helpers_1.isSet)(object.submitTime))
          obj.submitTime = (0, helpers_1.fromJsonTimestamp)(object.submitTime);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.voter !== void 0 && (obj.voter = message.voter);
        message.option !== void 0 && (obj.option = voteOptionToJSON(message.option));
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        message.submitTime !== void 0 && (obj.submitTime = (0, helpers_1.fromTimestamp)(message.submitTime).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseVote();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.voter = object.voter ?? "";
        message.option = object.option ?? 0;
        message.metadata = object.metadata ?? "";
        if (object.submitTime !== void 0 && object.submitTime !== null) {
          message.submitTime = timestamp_1.Timestamp.fromPartial(object.submitTime);
        }
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/group/v1/tx.js
var require_tx8 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/group/v1/tx.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MsgClientImpl = exports.MsgLeaveGroupResponse = exports.MsgLeaveGroup = exports.MsgExecResponse = exports.MsgExec = exports.MsgVoteResponse = exports.MsgVote = exports.MsgWithdrawProposalResponse = exports.MsgWithdrawProposal = exports.MsgSubmitProposalResponse = exports.MsgSubmitProposal = exports.MsgUpdateGroupPolicyMetadataResponse = exports.MsgUpdateGroupPolicyMetadata = exports.MsgUpdateGroupPolicyDecisionPolicyResponse = exports.MsgUpdateGroupPolicyDecisionPolicy = exports.MsgCreateGroupWithPolicyResponse = exports.MsgCreateGroupWithPolicy = exports.MsgUpdateGroupPolicyAdminResponse = exports.MsgUpdateGroupPolicyAdmin = exports.MsgCreateGroupPolicyResponse = exports.MsgCreateGroupPolicy = exports.MsgUpdateGroupMetadataResponse = exports.MsgUpdateGroupMetadata = exports.MsgUpdateGroupAdminResponse = exports.MsgUpdateGroupAdmin = exports.MsgUpdateGroupMembersResponse = exports.MsgUpdateGroupMembers = exports.MsgCreateGroupResponse = exports.MsgCreateGroup = exports.execToJSON = exports.execFromJSON = exports.Exec = exports.protobufPackage = void 0;
    var types_1 = require_types();
    var any_1 = require_any();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.group.v1";
    var Exec;
    (function(Exec2) {
      Exec2[Exec2["EXEC_UNSPECIFIED"] = 0] = "EXEC_UNSPECIFIED";
      Exec2[Exec2["EXEC_TRY"] = 1] = "EXEC_TRY";
      Exec2[Exec2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(Exec || (exports.Exec = Exec = {}));
    function execFromJSON(object) {
      switch (object) {
        case 0:
        case "EXEC_UNSPECIFIED":
          return Exec.EXEC_UNSPECIFIED;
        case 1:
        case "EXEC_TRY":
          return Exec.EXEC_TRY;
        case -1:
        case "UNRECOGNIZED":
        default:
          return Exec.UNRECOGNIZED;
      }
    }
    exports.execFromJSON = execFromJSON;
    function execToJSON(object) {
      switch (object) {
        case Exec.EXEC_UNSPECIFIED:
          return "EXEC_UNSPECIFIED";
        case Exec.EXEC_TRY:
          return "EXEC_TRY";
        case Exec.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.execToJSON = execToJSON;
    function createBaseMsgCreateGroup() {
      return {
        admin: "",
        members: [],
        metadata: ""
      };
    }
    exports.MsgCreateGroup = {
      typeUrl: "/cosmos.group.v1.MsgCreateGroup",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.admin !== "") {
          writer.uint32(10).string(message.admin);
        }
        for (const v9 of message.members) {
          types_1.MemberRequest.encode(v9, writer.uint32(18).fork()).ldelim();
        }
        if (message.metadata !== "") {
          writer.uint32(26).string(message.metadata);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateGroup();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.admin = reader.string();
              break;
            case 2:
              message.members.push(types_1.MemberRequest.decode(reader, reader.uint32()));
              break;
            case 3:
              message.metadata = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCreateGroup();
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if (Array.isArray(object?.members))
          obj.members = object.members.map((e) => types_1.MemberRequest.fromJSON(e));
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.admin !== void 0 && (obj.admin = message.admin);
        if (message.members) {
          obj.members = message.members.map((e) => e ? types_1.MemberRequest.toJSON(e) : void 0);
        } else {
          obj.members = [];
        }
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgCreateGroup();
        message.admin = object.admin ?? "";
        message.members = object.members?.map((e) => types_1.MemberRequest.fromPartial(e)) || [];
        message.metadata = object.metadata ?? "";
        return message;
      }
    };
    function createBaseMsgCreateGroupResponse() {
      return {
        groupId: BigInt(0)
      };
    }
    exports.MsgCreateGroupResponse = {
      typeUrl: "/cosmos.group.v1.MsgCreateGroupResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.groupId !== BigInt(0)) {
          writer.uint32(8).uint64(message.groupId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateGroupResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.groupId = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCreateGroupResponse();
        if ((0, helpers_1.isSet)(object.groupId))
          obj.groupId = BigInt(object.groupId.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.groupId !== void 0 && (obj.groupId = (message.groupId || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgCreateGroupResponse();
        if (object.groupId !== void 0 && object.groupId !== null) {
          message.groupId = BigInt(object.groupId.toString());
        }
        return message;
      }
    };
    function createBaseMsgUpdateGroupMembers() {
      return {
        admin: "",
        groupId: BigInt(0),
        memberUpdates: []
      };
    }
    exports.MsgUpdateGroupMembers = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupMembers",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.admin !== "") {
          writer.uint32(10).string(message.admin);
        }
        if (message.groupId !== BigInt(0)) {
          writer.uint32(16).uint64(message.groupId);
        }
        for (const v9 of message.memberUpdates) {
          types_1.MemberRequest.encode(v9, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupMembers();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.admin = reader.string();
              break;
            case 2:
              message.groupId = reader.uint64();
              break;
            case 3:
              message.memberUpdates.push(types_1.MemberRequest.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateGroupMembers();
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.groupId))
          obj.groupId = BigInt(object.groupId.toString());
        if (Array.isArray(object?.memberUpdates))
          obj.memberUpdates = object.memberUpdates.map((e) => types_1.MemberRequest.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.admin !== void 0 && (obj.admin = message.admin);
        message.groupId !== void 0 && (obj.groupId = (message.groupId || BigInt(0)).toString());
        if (message.memberUpdates) {
          obj.memberUpdates = message.memberUpdates.map((e) => e ? types_1.MemberRequest.toJSON(e) : void 0);
        } else {
          obj.memberUpdates = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateGroupMembers();
        message.admin = object.admin ?? "";
        if (object.groupId !== void 0 && object.groupId !== null) {
          message.groupId = BigInt(object.groupId.toString());
        }
        message.memberUpdates = object.memberUpdates?.map((e) => types_1.MemberRequest.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseMsgUpdateGroupMembersResponse() {
      return {};
    }
    exports.MsgUpdateGroupMembersResponse = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupMembersResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupMembersResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgUpdateGroupMembersResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgUpdateGroupMembersResponse();
        return message;
      }
    };
    function createBaseMsgUpdateGroupAdmin() {
      return {
        admin: "",
        groupId: BigInt(0),
        newAdmin: ""
      };
    }
    exports.MsgUpdateGroupAdmin = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupAdmin",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.admin !== "") {
          writer.uint32(10).string(message.admin);
        }
        if (message.groupId !== BigInt(0)) {
          writer.uint32(16).uint64(message.groupId);
        }
        if (message.newAdmin !== "") {
          writer.uint32(26).string(message.newAdmin);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupAdmin();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.admin = reader.string();
              break;
            case 2:
              message.groupId = reader.uint64();
              break;
            case 3:
              message.newAdmin = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateGroupAdmin();
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.groupId))
          obj.groupId = BigInt(object.groupId.toString());
        if ((0, helpers_1.isSet)(object.newAdmin))
          obj.newAdmin = String(object.newAdmin);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.admin !== void 0 && (obj.admin = message.admin);
        message.groupId !== void 0 && (obj.groupId = (message.groupId || BigInt(0)).toString());
        message.newAdmin !== void 0 && (obj.newAdmin = message.newAdmin);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateGroupAdmin();
        message.admin = object.admin ?? "";
        if (object.groupId !== void 0 && object.groupId !== null) {
          message.groupId = BigInt(object.groupId.toString());
        }
        message.newAdmin = object.newAdmin ?? "";
        return message;
      }
    };
    function createBaseMsgUpdateGroupAdminResponse() {
      return {};
    }
    exports.MsgUpdateGroupAdminResponse = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupAdminResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupAdminResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgUpdateGroupAdminResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgUpdateGroupAdminResponse();
        return message;
      }
    };
    function createBaseMsgUpdateGroupMetadata() {
      return {
        admin: "",
        groupId: BigInt(0),
        metadata: ""
      };
    }
    exports.MsgUpdateGroupMetadata = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupMetadata",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.admin !== "") {
          writer.uint32(10).string(message.admin);
        }
        if (message.groupId !== BigInt(0)) {
          writer.uint32(16).uint64(message.groupId);
        }
        if (message.metadata !== "") {
          writer.uint32(26).string(message.metadata);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupMetadata();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.admin = reader.string();
              break;
            case 2:
              message.groupId = reader.uint64();
              break;
            case 3:
              message.metadata = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateGroupMetadata();
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.groupId))
          obj.groupId = BigInt(object.groupId.toString());
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.admin !== void 0 && (obj.admin = message.admin);
        message.groupId !== void 0 && (obj.groupId = (message.groupId || BigInt(0)).toString());
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateGroupMetadata();
        message.admin = object.admin ?? "";
        if (object.groupId !== void 0 && object.groupId !== null) {
          message.groupId = BigInt(object.groupId.toString());
        }
        message.metadata = object.metadata ?? "";
        return message;
      }
    };
    function createBaseMsgUpdateGroupMetadataResponse() {
      return {};
    }
    exports.MsgUpdateGroupMetadataResponse = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupMetadataResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupMetadataResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgUpdateGroupMetadataResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgUpdateGroupMetadataResponse();
        return message;
      }
    };
    function createBaseMsgCreateGroupPolicy() {
      return {
        admin: "",
        groupId: BigInt(0),
        metadata: "",
        decisionPolicy: void 0
      };
    }
    exports.MsgCreateGroupPolicy = {
      typeUrl: "/cosmos.group.v1.MsgCreateGroupPolicy",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.admin !== "") {
          writer.uint32(10).string(message.admin);
        }
        if (message.groupId !== BigInt(0)) {
          writer.uint32(16).uint64(message.groupId);
        }
        if (message.metadata !== "") {
          writer.uint32(26).string(message.metadata);
        }
        if (message.decisionPolicy !== void 0) {
          any_1.Any.encode(message.decisionPolicy, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateGroupPolicy();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.admin = reader.string();
              break;
            case 2:
              message.groupId = reader.uint64();
              break;
            case 3:
              message.metadata = reader.string();
              break;
            case 4:
              message.decisionPolicy = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCreateGroupPolicy();
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.groupId))
          obj.groupId = BigInt(object.groupId.toString());
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        if ((0, helpers_1.isSet)(object.decisionPolicy))
          obj.decisionPolicy = any_1.Any.fromJSON(object.decisionPolicy);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.admin !== void 0 && (obj.admin = message.admin);
        message.groupId !== void 0 && (obj.groupId = (message.groupId || BigInt(0)).toString());
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        message.decisionPolicy !== void 0 && (obj.decisionPolicy = message.decisionPolicy ? any_1.Any.toJSON(message.decisionPolicy) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgCreateGroupPolicy();
        message.admin = object.admin ?? "";
        if (object.groupId !== void 0 && object.groupId !== null) {
          message.groupId = BigInt(object.groupId.toString());
        }
        message.metadata = object.metadata ?? "";
        if (object.decisionPolicy !== void 0 && object.decisionPolicy !== null) {
          message.decisionPolicy = any_1.Any.fromPartial(object.decisionPolicy);
        }
        return message;
      }
    };
    function createBaseMsgCreateGroupPolicyResponse() {
      return {
        address: ""
      };
    }
    exports.MsgCreateGroupPolicyResponse = {
      typeUrl: "/cosmos.group.v1.MsgCreateGroupPolicyResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateGroupPolicyResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCreateGroupPolicyResponse();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgCreateGroupPolicyResponse();
        message.address = object.address ?? "";
        return message;
      }
    };
    function createBaseMsgUpdateGroupPolicyAdmin() {
      return {
        admin: "",
        groupPolicyAddress: "",
        newAdmin: ""
      };
    }
    exports.MsgUpdateGroupPolicyAdmin = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyAdmin",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.admin !== "") {
          writer.uint32(10).string(message.admin);
        }
        if (message.groupPolicyAddress !== "") {
          writer.uint32(18).string(message.groupPolicyAddress);
        }
        if (message.newAdmin !== "") {
          writer.uint32(26).string(message.newAdmin);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupPolicyAdmin();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.admin = reader.string();
              break;
            case 2:
              message.groupPolicyAddress = reader.string();
              break;
            case 3:
              message.newAdmin = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateGroupPolicyAdmin();
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.groupPolicyAddress))
          obj.groupPolicyAddress = String(object.groupPolicyAddress);
        if ((0, helpers_1.isSet)(object.newAdmin))
          obj.newAdmin = String(object.newAdmin);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.admin !== void 0 && (obj.admin = message.admin);
        message.groupPolicyAddress !== void 0 && (obj.groupPolicyAddress = message.groupPolicyAddress);
        message.newAdmin !== void 0 && (obj.newAdmin = message.newAdmin);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateGroupPolicyAdmin();
        message.admin = object.admin ?? "";
        message.groupPolicyAddress = object.groupPolicyAddress ?? "";
        message.newAdmin = object.newAdmin ?? "";
        return message;
      }
    };
    function createBaseMsgUpdateGroupPolicyAdminResponse() {
      return {};
    }
    exports.MsgUpdateGroupPolicyAdminResponse = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyAdminResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupPolicyAdminResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgUpdateGroupPolicyAdminResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgUpdateGroupPolicyAdminResponse();
        return message;
      }
    };
    function createBaseMsgCreateGroupWithPolicy() {
      return {
        admin: "",
        members: [],
        groupMetadata: "",
        groupPolicyMetadata: "",
        groupPolicyAsAdmin: false,
        decisionPolicy: void 0
      };
    }
    exports.MsgCreateGroupWithPolicy = {
      typeUrl: "/cosmos.group.v1.MsgCreateGroupWithPolicy",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.admin !== "") {
          writer.uint32(10).string(message.admin);
        }
        for (const v9 of message.members) {
          types_1.MemberRequest.encode(v9, writer.uint32(18).fork()).ldelim();
        }
        if (message.groupMetadata !== "") {
          writer.uint32(26).string(message.groupMetadata);
        }
        if (message.groupPolicyMetadata !== "") {
          writer.uint32(34).string(message.groupPolicyMetadata);
        }
        if (message.groupPolicyAsAdmin === true) {
          writer.uint32(40).bool(message.groupPolicyAsAdmin);
        }
        if (message.decisionPolicy !== void 0) {
          any_1.Any.encode(message.decisionPolicy, writer.uint32(50).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateGroupWithPolicy();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.admin = reader.string();
              break;
            case 2:
              message.members.push(types_1.MemberRequest.decode(reader, reader.uint32()));
              break;
            case 3:
              message.groupMetadata = reader.string();
              break;
            case 4:
              message.groupPolicyMetadata = reader.string();
              break;
            case 5:
              message.groupPolicyAsAdmin = reader.bool();
              break;
            case 6:
              message.decisionPolicy = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCreateGroupWithPolicy();
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if (Array.isArray(object?.members))
          obj.members = object.members.map((e) => types_1.MemberRequest.fromJSON(e));
        if ((0, helpers_1.isSet)(object.groupMetadata))
          obj.groupMetadata = String(object.groupMetadata);
        if ((0, helpers_1.isSet)(object.groupPolicyMetadata))
          obj.groupPolicyMetadata = String(object.groupPolicyMetadata);
        if ((0, helpers_1.isSet)(object.groupPolicyAsAdmin))
          obj.groupPolicyAsAdmin = Boolean(object.groupPolicyAsAdmin);
        if ((0, helpers_1.isSet)(object.decisionPolicy))
          obj.decisionPolicy = any_1.Any.fromJSON(object.decisionPolicy);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.admin !== void 0 && (obj.admin = message.admin);
        if (message.members) {
          obj.members = message.members.map((e) => e ? types_1.MemberRequest.toJSON(e) : void 0);
        } else {
          obj.members = [];
        }
        message.groupMetadata !== void 0 && (obj.groupMetadata = message.groupMetadata);
        message.groupPolicyMetadata !== void 0 && (obj.groupPolicyMetadata = message.groupPolicyMetadata);
        message.groupPolicyAsAdmin !== void 0 && (obj.groupPolicyAsAdmin = message.groupPolicyAsAdmin);
        message.decisionPolicy !== void 0 && (obj.decisionPolicy = message.decisionPolicy ? any_1.Any.toJSON(message.decisionPolicy) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgCreateGroupWithPolicy();
        message.admin = object.admin ?? "";
        message.members = object.members?.map((e) => types_1.MemberRequest.fromPartial(e)) || [];
        message.groupMetadata = object.groupMetadata ?? "";
        message.groupPolicyMetadata = object.groupPolicyMetadata ?? "";
        message.groupPolicyAsAdmin = object.groupPolicyAsAdmin ?? false;
        if (object.decisionPolicy !== void 0 && object.decisionPolicy !== null) {
          message.decisionPolicy = any_1.Any.fromPartial(object.decisionPolicy);
        }
        return message;
      }
    };
    function createBaseMsgCreateGroupWithPolicyResponse() {
      return {
        groupId: BigInt(0),
        groupPolicyAddress: ""
      };
    }
    exports.MsgCreateGroupWithPolicyResponse = {
      typeUrl: "/cosmos.group.v1.MsgCreateGroupWithPolicyResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.groupId !== BigInt(0)) {
          writer.uint32(8).uint64(message.groupId);
        }
        if (message.groupPolicyAddress !== "") {
          writer.uint32(18).string(message.groupPolicyAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateGroupWithPolicyResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.groupId = reader.uint64();
              break;
            case 2:
              message.groupPolicyAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCreateGroupWithPolicyResponse();
        if ((0, helpers_1.isSet)(object.groupId))
          obj.groupId = BigInt(object.groupId.toString());
        if ((0, helpers_1.isSet)(object.groupPolicyAddress))
          obj.groupPolicyAddress = String(object.groupPolicyAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.groupId !== void 0 && (obj.groupId = (message.groupId || BigInt(0)).toString());
        message.groupPolicyAddress !== void 0 && (obj.groupPolicyAddress = message.groupPolicyAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgCreateGroupWithPolicyResponse();
        if (object.groupId !== void 0 && object.groupId !== null) {
          message.groupId = BigInt(object.groupId.toString());
        }
        message.groupPolicyAddress = object.groupPolicyAddress ?? "";
        return message;
      }
    };
    function createBaseMsgUpdateGroupPolicyDecisionPolicy() {
      return {
        admin: "",
        groupPolicyAddress: "",
        decisionPolicy: void 0
      };
    }
    exports.MsgUpdateGroupPolicyDecisionPolicy = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicy",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.admin !== "") {
          writer.uint32(10).string(message.admin);
        }
        if (message.groupPolicyAddress !== "") {
          writer.uint32(18).string(message.groupPolicyAddress);
        }
        if (message.decisionPolicy !== void 0) {
          any_1.Any.encode(message.decisionPolicy, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupPolicyDecisionPolicy();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.admin = reader.string();
              break;
            case 2:
              message.groupPolicyAddress = reader.string();
              break;
            case 3:
              message.decisionPolicy = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateGroupPolicyDecisionPolicy();
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.groupPolicyAddress))
          obj.groupPolicyAddress = String(object.groupPolicyAddress);
        if ((0, helpers_1.isSet)(object.decisionPolicy))
          obj.decisionPolicy = any_1.Any.fromJSON(object.decisionPolicy);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.admin !== void 0 && (obj.admin = message.admin);
        message.groupPolicyAddress !== void 0 && (obj.groupPolicyAddress = message.groupPolicyAddress);
        message.decisionPolicy !== void 0 && (obj.decisionPolicy = message.decisionPolicy ? any_1.Any.toJSON(message.decisionPolicy) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateGroupPolicyDecisionPolicy();
        message.admin = object.admin ?? "";
        message.groupPolicyAddress = object.groupPolicyAddress ?? "";
        if (object.decisionPolicy !== void 0 && object.decisionPolicy !== null) {
          message.decisionPolicy = any_1.Any.fromPartial(object.decisionPolicy);
        }
        return message;
      }
    };
    function createBaseMsgUpdateGroupPolicyDecisionPolicyResponse() {
      return {};
    }
    exports.MsgUpdateGroupPolicyDecisionPolicyResponse = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicyResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupPolicyDecisionPolicyResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgUpdateGroupPolicyDecisionPolicyResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgUpdateGroupPolicyDecisionPolicyResponse();
        return message;
      }
    };
    function createBaseMsgUpdateGroupPolicyMetadata() {
      return {
        admin: "",
        groupPolicyAddress: "",
        metadata: ""
      };
    }
    exports.MsgUpdateGroupPolicyMetadata = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyMetadata",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.admin !== "") {
          writer.uint32(10).string(message.admin);
        }
        if (message.groupPolicyAddress !== "") {
          writer.uint32(18).string(message.groupPolicyAddress);
        }
        if (message.metadata !== "") {
          writer.uint32(26).string(message.metadata);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupPolicyMetadata();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.admin = reader.string();
              break;
            case 2:
              message.groupPolicyAddress = reader.string();
              break;
            case 3:
              message.metadata = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateGroupPolicyMetadata();
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.groupPolicyAddress))
          obj.groupPolicyAddress = String(object.groupPolicyAddress);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.admin !== void 0 && (obj.admin = message.admin);
        message.groupPolicyAddress !== void 0 && (obj.groupPolicyAddress = message.groupPolicyAddress);
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateGroupPolicyMetadata();
        message.admin = object.admin ?? "";
        message.groupPolicyAddress = object.groupPolicyAddress ?? "";
        message.metadata = object.metadata ?? "";
        return message;
      }
    };
    function createBaseMsgUpdateGroupPolicyMetadataResponse() {
      return {};
    }
    exports.MsgUpdateGroupPolicyMetadataResponse = {
      typeUrl: "/cosmos.group.v1.MsgUpdateGroupPolicyMetadataResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateGroupPolicyMetadataResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgUpdateGroupPolicyMetadataResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgUpdateGroupPolicyMetadataResponse();
        return message;
      }
    };
    function createBaseMsgSubmitProposal() {
      return {
        groupPolicyAddress: "",
        proposers: [],
        metadata: "",
        messages: [],
        exec: 0,
        title: "",
        summary: ""
      };
    }
    exports.MsgSubmitProposal = {
      typeUrl: "/cosmos.group.v1.MsgSubmitProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.groupPolicyAddress !== "") {
          writer.uint32(10).string(message.groupPolicyAddress);
        }
        for (const v9 of message.proposers) {
          writer.uint32(18).string(v9);
        }
        if (message.metadata !== "") {
          writer.uint32(26).string(message.metadata);
        }
        for (const v9 of message.messages) {
          any_1.Any.encode(v9, writer.uint32(34).fork()).ldelim();
        }
        if (message.exec !== 0) {
          writer.uint32(40).int32(message.exec);
        }
        if (message.title !== "") {
          writer.uint32(50).string(message.title);
        }
        if (message.summary !== "") {
          writer.uint32(58).string(message.summary);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.groupPolicyAddress = reader.string();
              break;
            case 2:
              message.proposers.push(reader.string());
              break;
            case 3:
              message.metadata = reader.string();
              break;
            case 4:
              message.messages.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            case 5:
              message.exec = reader.int32();
              break;
            case 6:
              message.title = reader.string();
              break;
            case 7:
              message.summary = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgSubmitProposal();
        if ((0, helpers_1.isSet)(object.groupPolicyAddress))
          obj.groupPolicyAddress = String(object.groupPolicyAddress);
        if (Array.isArray(object?.proposers))
          obj.proposers = object.proposers.map((e) => String(e));
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        if (Array.isArray(object?.messages))
          obj.messages = object.messages.map((e) => any_1.Any.fromJSON(e));
        if ((0, helpers_1.isSet)(object.exec))
          obj.exec = execFromJSON(object.exec);
        if ((0, helpers_1.isSet)(object.title))
          obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.summary))
          obj.summary = String(object.summary);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.groupPolicyAddress !== void 0 && (obj.groupPolicyAddress = message.groupPolicyAddress);
        if (message.proposers) {
          obj.proposers = message.proposers.map((e) => e);
        } else {
          obj.proposers = [];
        }
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        if (message.messages) {
          obj.messages = message.messages.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.messages = [];
        }
        message.exec !== void 0 && (obj.exec = execToJSON(message.exec));
        message.title !== void 0 && (obj.title = message.title);
        message.summary !== void 0 && (obj.summary = message.summary);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgSubmitProposal();
        message.groupPolicyAddress = object.groupPolicyAddress ?? "";
        message.proposers = object.proposers?.map((e) => e) || [];
        message.metadata = object.metadata ?? "";
        message.messages = object.messages?.map((e) => any_1.Any.fromPartial(e)) || [];
        message.exec = object.exec ?? 0;
        message.title = object.title ?? "";
        message.summary = object.summary ?? "";
        return message;
      }
    };
    function createBaseMsgSubmitProposalResponse() {
      return {
        proposalId: BigInt(0)
      };
    }
    exports.MsgSubmitProposalResponse = {
      typeUrl: "/cosmos.group.v1.MsgSubmitProposalResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitProposalResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgSubmitProposalResponse();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgSubmitProposalResponse();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        return message;
      }
    };
    function createBaseMsgWithdrawProposal() {
      return {
        proposalId: BigInt(0),
        address: ""
      };
    }
    exports.MsgWithdrawProposal = {
      typeUrl: "/cosmos.group.v1.MsgWithdrawProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.address !== "") {
          writer.uint32(18).string(message.address);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.address = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgWithdrawProposal();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.address !== void 0 && (obj.address = message.address);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgWithdrawProposal();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.address = object.address ?? "";
        return message;
      }
    };
    function createBaseMsgWithdrawProposalResponse() {
      return {};
    }
    exports.MsgWithdrawProposalResponse = {
      typeUrl: "/cosmos.group.v1.MsgWithdrawProposalResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawProposalResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgWithdrawProposalResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgWithdrawProposalResponse();
        return message;
      }
    };
    function createBaseMsgVote() {
      return {
        proposalId: BigInt(0),
        voter: "",
        option: 0,
        metadata: "",
        exec: 0
      };
    }
    exports.MsgVote = {
      typeUrl: "/cosmos.group.v1.MsgVote",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
          writer.uint32(18).string(message.voter);
        }
        if (message.option !== 0) {
          writer.uint32(24).int32(message.option);
        }
        if (message.metadata !== "") {
          writer.uint32(34).string(message.metadata);
        }
        if (message.exec !== 0) {
          writer.uint32(40).int32(message.exec);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVote();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.voter = reader.string();
              break;
            case 3:
              message.option = reader.int32();
              break;
            case 4:
              message.metadata = reader.string();
              break;
            case 5:
              message.exec = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgVote();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.voter))
          obj.voter = String(object.voter);
        if ((0, helpers_1.isSet)(object.option))
          obj.option = (0, types_1.voteOptionFromJSON)(object.option);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = String(object.metadata);
        if ((0, helpers_1.isSet)(object.exec))
          obj.exec = execFromJSON(object.exec);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.voter !== void 0 && (obj.voter = message.voter);
        message.option !== void 0 && (obj.option = (0, types_1.voteOptionToJSON)(message.option));
        message.metadata !== void 0 && (obj.metadata = message.metadata);
        message.exec !== void 0 && (obj.exec = execToJSON(message.exec));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgVote();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.voter = object.voter ?? "";
        message.option = object.option ?? 0;
        message.metadata = object.metadata ?? "";
        message.exec = object.exec ?? 0;
        return message;
      }
    };
    function createBaseMsgVoteResponse() {
      return {};
    }
    exports.MsgVoteResponse = {
      typeUrl: "/cosmos.group.v1.MsgVoteResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgVoteResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgVoteResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgVoteResponse();
        return message;
      }
    };
    function createBaseMsgExec() {
      return {
        proposalId: BigInt(0),
        executor: ""
      };
    }
    exports.MsgExec = {
      typeUrl: "/cosmos.group.v1.MsgExec",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.proposalId !== BigInt(0)) {
          writer.uint32(8).uint64(message.proposalId);
        }
        if (message.executor !== "") {
          writer.uint32(18).string(message.executor);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgExec();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proposalId = reader.uint64();
              break;
            case 2:
              message.executor = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgExec();
        if ((0, helpers_1.isSet)(object.proposalId))
          obj.proposalId = BigInt(object.proposalId.toString());
        if ((0, helpers_1.isSet)(object.executor))
          obj.executor = String(object.executor);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.proposalId !== void 0 && (obj.proposalId = (message.proposalId || BigInt(0)).toString());
        message.executor !== void 0 && (obj.executor = message.executor);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgExec();
        if (object.proposalId !== void 0 && object.proposalId !== null) {
          message.proposalId = BigInt(object.proposalId.toString());
        }
        message.executor = object.executor ?? "";
        return message;
      }
    };
    function createBaseMsgExecResponse() {
      return {
        result: 0
      };
    }
    exports.MsgExecResponse = {
      typeUrl: "/cosmos.group.v1.MsgExecResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== 0) {
          writer.uint32(16).int32(message.result);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgExecResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 2:
              message.result = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgExecResponse();
        if ((0, helpers_1.isSet)(object.result))
          obj.result = (0, types_1.proposalExecutorResultFromJSON)(object.result);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = (0, types_1.proposalExecutorResultToJSON)(message.result));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgExecResponse();
        message.result = object.result ?? 0;
        return message;
      }
    };
    function createBaseMsgLeaveGroup() {
      return {
        address: "",
        groupId: BigInt(0)
      };
    }
    exports.MsgLeaveGroup = {
      typeUrl: "/cosmos.group.v1.MsgLeaveGroup",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.groupId !== BigInt(0)) {
          writer.uint32(16).uint64(message.groupId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgLeaveGroup();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.groupId = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgLeaveGroup();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.groupId))
          obj.groupId = BigInt(object.groupId.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.groupId !== void 0 && (obj.groupId = (message.groupId || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgLeaveGroup();
        message.address = object.address ?? "";
        if (object.groupId !== void 0 && object.groupId !== null) {
          message.groupId = BigInt(object.groupId.toString());
        }
        return message;
      }
    };
    function createBaseMsgLeaveGroupResponse() {
      return {};
    }
    exports.MsgLeaveGroupResponse = {
      typeUrl: "/cosmos.group.v1.MsgLeaveGroupResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgLeaveGroupResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgLeaveGroupResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgLeaveGroupResponse();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.CreateGroup = this.CreateGroup.bind(this);
        this.UpdateGroupMembers = this.UpdateGroupMembers.bind(this);
        this.UpdateGroupAdmin = this.UpdateGroupAdmin.bind(this);
        this.UpdateGroupMetadata = this.UpdateGroupMetadata.bind(this);
        this.CreateGroupPolicy = this.CreateGroupPolicy.bind(this);
        this.CreateGroupWithPolicy = this.CreateGroupWithPolicy.bind(this);
        this.UpdateGroupPolicyAdmin = this.UpdateGroupPolicyAdmin.bind(this);
        this.UpdateGroupPolicyDecisionPolicy = this.UpdateGroupPolicyDecisionPolicy.bind(this);
        this.UpdateGroupPolicyMetadata = this.UpdateGroupPolicyMetadata.bind(this);
        this.SubmitProposal = this.SubmitProposal.bind(this);
        this.WithdrawProposal = this.WithdrawProposal.bind(this);
        this.Vote = this.Vote.bind(this);
        this.Exec = this.Exec.bind(this);
        this.LeaveGroup = this.LeaveGroup.bind(this);
      }
      CreateGroup(request) {
        const data2 = exports.MsgCreateGroup.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "CreateGroup", data2);
        return promise.then((data3) => exports.MsgCreateGroupResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateGroupMembers(request) {
        const data2 = exports.MsgUpdateGroupMembers.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupMembers", data2);
        return promise.then((data3) => exports.MsgUpdateGroupMembersResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateGroupAdmin(request) {
        const data2 = exports.MsgUpdateGroupAdmin.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupAdmin", data2);
        return promise.then((data3) => exports.MsgUpdateGroupAdminResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateGroupMetadata(request) {
        const data2 = exports.MsgUpdateGroupMetadata.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupMetadata", data2);
        return promise.then((data3) => exports.MsgUpdateGroupMetadataResponse.decode(new binary_1.BinaryReader(data3)));
      }
      CreateGroupPolicy(request) {
        const data2 = exports.MsgCreateGroupPolicy.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "CreateGroupPolicy", data2);
        return promise.then((data3) => exports.MsgCreateGroupPolicyResponse.decode(new binary_1.BinaryReader(data3)));
      }
      CreateGroupWithPolicy(request) {
        const data2 = exports.MsgCreateGroupWithPolicy.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "CreateGroupWithPolicy", data2);
        return promise.then((data3) => exports.MsgCreateGroupWithPolicyResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateGroupPolicyAdmin(request) {
        const data2 = exports.MsgUpdateGroupPolicyAdmin.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupPolicyAdmin", data2);
        return promise.then((data3) => exports.MsgUpdateGroupPolicyAdminResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateGroupPolicyDecisionPolicy(request) {
        const data2 = exports.MsgUpdateGroupPolicyDecisionPolicy.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupPolicyDecisionPolicy", data2);
        return promise.then((data3) => exports.MsgUpdateGroupPolicyDecisionPolicyResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateGroupPolicyMetadata(request) {
        const data2 = exports.MsgUpdateGroupPolicyMetadata.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "UpdateGroupPolicyMetadata", data2);
        return promise.then((data3) => exports.MsgUpdateGroupPolicyMetadataResponse.decode(new binary_1.BinaryReader(data3)));
      }
      SubmitProposal(request) {
        const data2 = exports.MsgSubmitProposal.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "SubmitProposal", data2);
        return promise.then((data3) => exports.MsgSubmitProposalResponse.decode(new binary_1.BinaryReader(data3)));
      }
      WithdrawProposal(request) {
        const data2 = exports.MsgWithdrawProposal.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "WithdrawProposal", data2);
        return promise.then((data3) => exports.MsgWithdrawProposalResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Vote(request) {
        const data2 = exports.MsgVote.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "Vote", data2);
        return promise.then((data3) => exports.MsgVoteResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Exec(request) {
        const data2 = exports.MsgExec.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "Exec", data2);
        return promise.then((data3) => exports.MsgExecResponse.decode(new binary_1.BinaryReader(data3)));
      }
      LeaveGroup(request) {
        const data2 = exports.MsgLeaveGroup.encode(request).finish();
        const promise = this.rpc.request("cosmos.group.v1.Msg", "LeaveGroup", data2);
        return promise.then((data3) => exports.MsgLeaveGroupResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.MsgClientImpl = MsgClientImpl;
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/group/messages.js
var require_messages6 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/group/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.groupTypes = void 0;
    var tx_1 = require_tx8();
    exports.groupTypes = [
      ["/cosmos.group.v1.MsgCreateGroup", tx_1.MsgCreateGroup],
      ["/cosmos.group.v1.MsgCreateGroupPolicy", tx_1.MsgCreateGroupPolicy],
      ["/cosmos.group.v1.MsgCreateGroupWithPolicy", tx_1.MsgCreateGroupWithPolicy],
      ["/cosmos.group.v1.MsgExec", tx_1.MsgExec],
      ["/cosmos.group.v1.MsgLeaveGroup", tx_1.MsgLeaveGroup],
      ["/cosmos.group.v1.MsgSubmitProposal", tx_1.MsgSubmitProposal],
      ["/cosmos.group.v1.MsgUpdateGroupAdmin", tx_1.MsgUpdateGroupAdmin],
      ["/cosmos.group.v1.MsgUpdateGroupMembers", tx_1.MsgUpdateGroupMembers],
      ["/cosmos.group.v1.MsgUpdateGroupMetadata", tx_1.MsgUpdateGroupMetadata],
      ["/cosmos.group.v1.MsgUpdateGroupPolicyAdmin", tx_1.MsgUpdateGroupPolicyAdmin],
      ["/cosmos.group.v1.MsgUpdateGroupPolicyDecisionPolicy", tx_1.MsgUpdateGroupPolicyDecisionPolicy],
      ["/cosmos.group.v1.MsgUpdateGroupPolicyMetadata", tx_1.MsgUpdateGroupPolicyMetadata],
      ["/cosmos.group.v1.MsgVote", tx_1.MsgVote],
      ["/cosmos.group.v1.MsgWithdrawProposal", tx_1.MsgWithdrawProposal]
    ];
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/upgrade/v1beta1/upgrade.js
var require_upgrade = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/upgrade/v1beta1/upgrade.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ModuleVersion = exports.CancelSoftwareUpgradeProposal = exports.SoftwareUpgradeProposal = exports.Plan = exports.protobufPackage = void 0;
    var timestamp_1 = require_timestamp();
    var any_1 = require_any();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.upgrade.v1beta1";
    function createBasePlan() {
      return {
        name: "",
        time: timestamp_1.Timestamp.fromPartial({}),
        height: BigInt(0),
        info: "",
        upgradedClientState: void 0
      };
    }
    exports.Plan = {
      typeUrl: "/cosmos.upgrade.v1beta1.Plan",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.name !== "") {
          writer.uint32(10).string(message.name);
        }
        if (message.time !== void 0) {
          timestamp_1.Timestamp.encode(message.time, writer.uint32(18).fork()).ldelim();
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(24).int64(message.height);
        }
        if (message.info !== "") {
          writer.uint32(34).string(message.info);
        }
        if (message.upgradedClientState !== void 0) {
          any_1.Any.encode(message.upgradedClientState, writer.uint32(42).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePlan();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.name = reader.string();
              break;
            case 2:
              message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 3:
              message.height = reader.int64();
              break;
            case 4:
              message.info = reader.string();
              break;
            case 5:
              message.upgradedClientState = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePlan();
        if ((0, helpers_1.isSet)(object.name))
          obj.name = String(object.name);
        if ((0, helpers_1.isSet)(object.time))
          obj.time = (0, helpers_1.fromJsonTimestamp)(object.time);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.info))
          obj.info = String(object.info);
        if ((0, helpers_1.isSet)(object.upgradedClientState))
          obj.upgradedClientState = any_1.Any.fromJSON(object.upgradedClientState);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.name !== void 0 && (obj.name = message.name);
        message.time !== void 0 && (obj.time = (0, helpers_1.fromTimestamp)(message.time).toISOString());
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.info !== void 0 && (obj.info = message.info);
        message.upgradedClientState !== void 0 && (obj.upgradedClientState = message.upgradedClientState ? any_1.Any.toJSON(message.upgradedClientState) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBasePlan();
        message.name = object.name ?? "";
        if (object.time !== void 0 && object.time !== null) {
          message.time = timestamp_1.Timestamp.fromPartial(object.time);
        }
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        message.info = object.info ?? "";
        if (object.upgradedClientState !== void 0 && object.upgradedClientState !== null) {
          message.upgradedClientState = any_1.Any.fromPartial(object.upgradedClientState);
        }
        return message;
      }
    };
    function createBaseSoftwareUpgradeProposal() {
      return {
        title: "",
        description: "",
        plan: exports.Plan.fromPartial({})
      };
    }
    exports.SoftwareUpgradeProposal = {
      typeUrl: "/cosmos.upgrade.v1beta1.SoftwareUpgradeProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        if (message.plan !== void 0) {
          exports.Plan.encode(message.plan, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSoftwareUpgradeProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            case 3:
              message.plan = exports.Plan.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSoftwareUpgradeProposal();
        if ((0, helpers_1.isSet)(object.title))
          obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.description))
          obj.description = String(object.description);
        if ((0, helpers_1.isSet)(object.plan))
          obj.plan = exports.Plan.fromJSON(object.plan);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        message.plan !== void 0 && (obj.plan = message.plan ? exports.Plan.toJSON(message.plan) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSoftwareUpgradeProposal();
        message.title = object.title ?? "";
        message.description = object.description ?? "";
        if (object.plan !== void 0 && object.plan !== null) {
          message.plan = exports.Plan.fromPartial(object.plan);
        }
        return message;
      }
    };
    function createBaseCancelSoftwareUpgradeProposal() {
      return {
        title: "",
        description: ""
      };
    }
    exports.CancelSoftwareUpgradeProposal = {
      typeUrl: "/cosmos.upgrade.v1beta1.CancelSoftwareUpgradeProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCancelSoftwareUpgradeProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCancelSoftwareUpgradeProposal();
        if ((0, helpers_1.isSet)(object.title))
          obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.description))
          obj.description = String(object.description);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCancelSoftwareUpgradeProposal();
        message.title = object.title ?? "";
        message.description = object.description ?? "";
        return message;
      }
    };
    function createBaseModuleVersion() {
      return {
        name: "",
        version: BigInt(0)
      };
    }
    exports.ModuleVersion = {
      typeUrl: "/cosmos.upgrade.v1beta1.ModuleVersion",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.name !== "") {
          writer.uint32(10).string(message.name);
        }
        if (message.version !== BigInt(0)) {
          writer.uint32(16).uint64(message.version);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseModuleVersion();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.name = reader.string();
              break;
            case 2:
              message.version = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseModuleVersion();
        if ((0, helpers_1.isSet)(object.name))
          obj.name = String(object.name);
        if ((0, helpers_1.isSet)(object.version))
          obj.version = BigInt(object.version.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.name !== void 0 && (obj.name = message.name);
        message.version !== void 0 && (obj.version = (message.version || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseModuleVersion();
        message.name = object.name ?? "";
        if (object.version !== void 0 && object.version !== null) {
          message.version = BigInt(object.version.toString());
        }
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/core/client/v1/client.js
var require_client = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/core/client/v1/client.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UpgradeProposal = exports.ClientUpdateProposal = exports.Params = exports.Height = exports.ClientConsensusStates = exports.ConsensusStateWithHeight = exports.IdentifiedClientState = exports.protobufPackage = void 0;
    var any_1 = require_any();
    var upgrade_1 = require_upgrade();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "ibc.core.client.v1";
    function createBaseIdentifiedClientState() {
      return {
        clientId: "",
        clientState: void 0
      };
    }
    exports.IdentifiedClientState = {
      typeUrl: "/ibc.core.client.v1.IdentifiedClientState",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.clientState !== void 0) {
          any_1.Any.encode(message.clientState, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseIdentifiedClientState();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.clientState = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseIdentifiedClientState();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.clientState))
          obj.clientState = any_1.Any.fromJSON(object.clientState);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.clientState !== void 0 && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseIdentifiedClientState();
        message.clientId = object.clientId ?? "";
        if (object.clientState !== void 0 && object.clientState !== null) {
          message.clientState = any_1.Any.fromPartial(object.clientState);
        }
        return message;
      }
    };
    function createBaseConsensusStateWithHeight() {
      return {
        height: exports.Height.fromPartial({}),
        consensusState: void 0
      };
    }
    exports.ConsensusStateWithHeight = {
      typeUrl: "/ibc.core.client.v1.ConsensusStateWithHeight",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== void 0) {
          exports.Height.encode(message.height, writer.uint32(10).fork()).ldelim();
        }
        if (message.consensusState !== void 0) {
          any_1.Any.encode(message.consensusState, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseConsensusStateWithHeight();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = exports.Height.decode(reader, reader.uint32());
              break;
            case 2:
              message.consensusState = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseConsensusStateWithHeight();
        if ((0, helpers_1.isSet)(object.height))
          obj.height = exports.Height.fromJSON(object.height);
        if ((0, helpers_1.isSet)(object.consensusState))
          obj.consensusState = any_1.Any.fromJSON(object.consensusState);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = message.height ? exports.Height.toJSON(message.height) : void 0);
        message.consensusState !== void 0 && (obj.consensusState = message.consensusState ? any_1.Any.toJSON(message.consensusState) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseConsensusStateWithHeight();
        if (object.height !== void 0 && object.height !== null) {
          message.height = exports.Height.fromPartial(object.height);
        }
        if (object.consensusState !== void 0 && object.consensusState !== null) {
          message.consensusState = any_1.Any.fromPartial(object.consensusState);
        }
        return message;
      }
    };
    function createBaseClientConsensusStates() {
      return {
        clientId: "",
        consensusStates: []
      };
    }
    exports.ClientConsensusStates = {
      typeUrl: "/ibc.core.client.v1.ClientConsensusStates",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        for (const v9 of message.consensusStates) {
          exports.ConsensusStateWithHeight.encode(v9, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseClientConsensusStates();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.consensusStates.push(exports.ConsensusStateWithHeight.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseClientConsensusStates();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if (Array.isArray(object?.consensusStates))
          obj.consensusStates = object.consensusStates.map((e) => exports.ConsensusStateWithHeight.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        if (message.consensusStates) {
          obj.consensusStates = message.consensusStates.map((e) => e ? exports.ConsensusStateWithHeight.toJSON(e) : void 0);
        } else {
          obj.consensusStates = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseClientConsensusStates();
        message.clientId = object.clientId ?? "";
        message.consensusStates = object.consensusStates?.map((e) => exports.ConsensusStateWithHeight.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseHeight() {
      return {
        revisionNumber: BigInt(0),
        revisionHeight: BigInt(0)
      };
    }
    exports.Height = {
      typeUrl: "/ibc.core.client.v1.Height",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.revisionNumber !== BigInt(0)) {
          writer.uint32(8).uint64(message.revisionNumber);
        }
        if (message.revisionHeight !== BigInt(0)) {
          writer.uint32(16).uint64(message.revisionHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseHeight();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.revisionNumber = reader.uint64();
              break;
            case 2:
              message.revisionHeight = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseHeight();
        if ((0, helpers_1.isSet)(object.revisionNumber))
          obj.revisionNumber = BigInt(object.revisionNumber.toString());
        if ((0, helpers_1.isSet)(object.revisionHeight))
          obj.revisionHeight = BigInt(object.revisionHeight.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.revisionNumber !== void 0 && (obj.revisionNumber = (message.revisionNumber || BigInt(0)).toString());
        message.revisionHeight !== void 0 && (obj.revisionHeight = (message.revisionHeight || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseHeight();
        if (object.revisionNumber !== void 0 && object.revisionNumber !== null) {
          message.revisionNumber = BigInt(object.revisionNumber.toString());
        }
        if (object.revisionHeight !== void 0 && object.revisionHeight !== null) {
          message.revisionHeight = BigInt(object.revisionHeight.toString());
        }
        return message;
      }
    };
    function createBaseParams() {
      return {
        allowedClients: []
      };
    }
    exports.Params = {
      typeUrl: "/ibc.core.client.v1.Params",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.allowedClients) {
          writer.uint32(10).string(v9);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.allowedClients.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseParams();
        if (Array.isArray(object?.allowedClients))
          obj.allowedClients = object.allowedClients.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.allowedClients) {
          obj.allowedClients = message.allowedClients.map((e) => e);
        } else {
          obj.allowedClients = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseParams();
        message.allowedClients = object.allowedClients?.map((e) => e) || [];
        return message;
      }
    };
    function createBaseClientUpdateProposal() {
      return {
        title: "",
        description: "",
        subjectClientId: "",
        substituteClientId: ""
      };
    }
    exports.ClientUpdateProposal = {
      typeUrl: "/ibc.core.client.v1.ClientUpdateProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        if (message.subjectClientId !== "") {
          writer.uint32(26).string(message.subjectClientId);
        }
        if (message.substituteClientId !== "") {
          writer.uint32(34).string(message.substituteClientId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseClientUpdateProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            case 3:
              message.subjectClientId = reader.string();
              break;
            case 4:
              message.substituteClientId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseClientUpdateProposal();
        if ((0, helpers_1.isSet)(object.title))
          obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.description))
          obj.description = String(object.description);
        if ((0, helpers_1.isSet)(object.subjectClientId))
          obj.subjectClientId = String(object.subjectClientId);
        if ((0, helpers_1.isSet)(object.substituteClientId))
          obj.substituteClientId = String(object.substituteClientId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        message.subjectClientId !== void 0 && (obj.subjectClientId = message.subjectClientId);
        message.substituteClientId !== void 0 && (obj.substituteClientId = message.substituteClientId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseClientUpdateProposal();
        message.title = object.title ?? "";
        message.description = object.description ?? "";
        message.subjectClientId = object.subjectClientId ?? "";
        message.substituteClientId = object.substituteClientId ?? "";
        return message;
      }
    };
    function createBaseUpgradeProposal() {
      return {
        title: "",
        description: "",
        plan: upgrade_1.Plan.fromPartial({}),
        upgradedClientState: void 0
      };
    }
    exports.UpgradeProposal = {
      typeUrl: "/ibc.core.client.v1.UpgradeProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        if (message.plan !== void 0) {
          upgrade_1.Plan.encode(message.plan, writer.uint32(26).fork()).ldelim();
        }
        if (message.upgradedClientState !== void 0) {
          any_1.Any.encode(message.upgradedClientState, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUpgradeProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.title = reader.string();
              break;
            case 2:
              message.description = reader.string();
              break;
            case 3:
              message.plan = upgrade_1.Plan.decode(reader, reader.uint32());
              break;
            case 4:
              message.upgradedClientState = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseUpgradeProposal();
        if ((0, helpers_1.isSet)(object.title))
          obj.title = String(object.title);
        if ((0, helpers_1.isSet)(object.description))
          obj.description = String(object.description);
        if ((0, helpers_1.isSet)(object.plan))
          obj.plan = upgrade_1.Plan.fromJSON(object.plan);
        if ((0, helpers_1.isSet)(object.upgradedClientState))
          obj.upgradedClientState = any_1.Any.fromJSON(object.upgradedClientState);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.title !== void 0 && (obj.title = message.title);
        message.description !== void 0 && (obj.description = message.description);
        message.plan !== void 0 && (obj.plan = message.plan ? upgrade_1.Plan.toJSON(message.plan) : void 0);
        message.upgradedClientState !== void 0 && (obj.upgradedClientState = message.upgradedClientState ? any_1.Any.toJSON(message.upgradedClientState) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseUpgradeProposal();
        message.title = object.title ?? "";
        message.description = object.description ?? "";
        if (object.plan !== void 0 && object.plan !== null) {
          message.plan = upgrade_1.Plan.fromPartial(object.plan);
        }
        if (object.upgradedClientState !== void 0 && object.upgradedClientState !== null) {
          message.upgradedClientState = any_1.Any.fromPartial(object.upgradedClientState);
        }
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/applications/transfer/v1/tx.js
var require_tx9 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/applications/transfer/v1/tx.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MsgClientImpl = exports.MsgUpdateParamsResponse = exports.MsgUpdateParams = exports.MsgTransferResponse = exports.MsgTransfer = exports.protobufPackage = void 0;
    var coin_1 = require_coin();
    var client_1 = require_client();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "ibc.applications.transfer.v1";
    function createBaseMsgTransfer() {
      return {
        sourcePort: "",
        sourceChannel: "",
        token: coin_1.Coin.fromPartial({}),
        sender: "",
        receiver: "",
        timeoutHeight: client_1.Height.fromPartial({}),
        timeoutTimestamp: BigInt(0),
        memo: ""
      };
    }
    exports.MsgTransfer = {
      typeUrl: "/ibc.applications.transfer.v1.MsgTransfer",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.sourcePort !== "") {
          writer.uint32(10).string(message.sourcePort);
        }
        if (message.sourceChannel !== "") {
          writer.uint32(18).string(message.sourceChannel);
        }
        if (message.token !== void 0) {
          coin_1.Coin.encode(message.token, writer.uint32(26).fork()).ldelim();
        }
        if (message.sender !== "") {
          writer.uint32(34).string(message.sender);
        }
        if (message.receiver !== "") {
          writer.uint32(42).string(message.receiver);
        }
        if (message.timeoutHeight !== void 0) {
          client_1.Height.encode(message.timeoutHeight, writer.uint32(50).fork()).ldelim();
        }
        if (message.timeoutTimestamp !== BigInt(0)) {
          writer.uint32(56).uint64(message.timeoutTimestamp);
        }
        if (message.memo !== "") {
          writer.uint32(66).string(message.memo);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgTransfer();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sourcePort = reader.string();
              break;
            case 2:
              message.sourceChannel = reader.string();
              break;
            case 3:
              message.token = coin_1.Coin.decode(reader, reader.uint32());
              break;
            case 4:
              message.sender = reader.string();
              break;
            case 5:
              message.receiver = reader.string();
              break;
            case 6:
              message.timeoutHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 7:
              message.timeoutTimestamp = reader.uint64();
              break;
            case 8:
              message.memo = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgTransfer();
        if ((0, helpers_1.isSet)(object.sourcePort))
          obj.sourcePort = String(object.sourcePort);
        if ((0, helpers_1.isSet)(object.sourceChannel))
          obj.sourceChannel = String(object.sourceChannel);
        if ((0, helpers_1.isSet)(object.token))
          obj.token = coin_1.Coin.fromJSON(object.token);
        if ((0, helpers_1.isSet)(object.sender))
          obj.sender = String(object.sender);
        if ((0, helpers_1.isSet)(object.receiver))
          obj.receiver = String(object.receiver);
        if ((0, helpers_1.isSet)(object.timeoutHeight))
          obj.timeoutHeight = client_1.Height.fromJSON(object.timeoutHeight);
        if ((0, helpers_1.isSet)(object.timeoutTimestamp))
          obj.timeoutTimestamp = BigInt(object.timeoutTimestamp.toString());
        if ((0, helpers_1.isSet)(object.memo))
          obj.memo = String(object.memo);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.sourcePort !== void 0 && (obj.sourcePort = message.sourcePort);
        message.sourceChannel !== void 0 && (obj.sourceChannel = message.sourceChannel);
        message.token !== void 0 && (obj.token = message.token ? coin_1.Coin.toJSON(message.token) : void 0);
        message.sender !== void 0 && (obj.sender = message.sender);
        message.receiver !== void 0 && (obj.receiver = message.receiver);
        message.timeoutHeight !== void 0 && (obj.timeoutHeight = message.timeoutHeight ? client_1.Height.toJSON(message.timeoutHeight) : void 0);
        message.timeoutTimestamp !== void 0 && (obj.timeoutTimestamp = (message.timeoutTimestamp || BigInt(0)).toString());
        message.memo !== void 0 && (obj.memo = message.memo);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgTransfer();
        message.sourcePort = object.sourcePort ?? "";
        message.sourceChannel = object.sourceChannel ?? "";
        if (object.token !== void 0 && object.token !== null) {
          message.token = coin_1.Coin.fromPartial(object.token);
        }
        message.sender = object.sender ?? "";
        message.receiver = object.receiver ?? "";
        if (object.timeoutHeight !== void 0 && object.timeoutHeight !== null) {
          message.timeoutHeight = client_1.Height.fromPartial(object.timeoutHeight);
        }
        if (object.timeoutTimestamp !== void 0 && object.timeoutTimestamp !== null) {
          message.timeoutTimestamp = BigInt(object.timeoutTimestamp.toString());
        }
        message.memo = object.memo ?? "";
        return message;
      }
    };
    function createBaseMsgTransferResponse() {
      return {
        sequence: BigInt(0)
      };
    }
    exports.MsgTransferResponse = {
      typeUrl: "/ibc.applications.transfer.v1.MsgTransferResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.sequence !== BigInt(0)) {
          writer.uint32(8).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgTransferResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgTransferResponse();
        if ((0, helpers_1.isSet)(object.sequence))
          obj.sequence = BigInt(object.sequence.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgTransferResponse();
        if (object.sequence !== void 0 && object.sequence !== null) {
          message.sequence = BigInt(object.sequence.toString());
        }
        return message;
      }
    };
    function createBaseMsgUpdateParams() {
      return {
        signer: "",
        params: client_1.Params.fromPartial({})
      };
    }
    exports.MsgUpdateParams = {
      typeUrl: "/ibc.applications.transfer.v1.MsgUpdateParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.signer !== "") {
          writer.uint32(10).string(message.signer);
        }
        if (message.params !== void 0) {
          client_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signer = reader.string();
              break;
            case 2:
              message.params = client_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateParams();
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        if ((0, helpers_1.isSet)(object.params))
          obj.params = client_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.signer !== void 0 && (obj.signer = message.signer);
        message.params !== void 0 && (obj.params = message.params ? client_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateParams();
        message.signer = object.signer ?? "";
        if (object.params !== void 0 && object.params !== null) {
          message.params = client_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseMsgUpdateParamsResponse() {
      return {};
    }
    exports.MsgUpdateParamsResponse = {
      typeUrl: "/ibc.applications.transfer.v1.MsgUpdateParamsResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgUpdateParamsResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgUpdateParamsResponse();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Transfer = this.Transfer.bind(this);
        this.UpdateParams = this.UpdateParams.bind(this);
      }
      Transfer(request) {
        const data2 = exports.MsgTransfer.encode(request).finish();
        const promise = this.rpc.request("ibc.applications.transfer.v1.Msg", "Transfer", data2);
        return promise.then((data3) => exports.MsgTransferResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateParams(request) {
        const data2 = exports.MsgUpdateParams.encode(request).finish();
        const promise = this.rpc.request("ibc.applications.transfer.v1.Msg", "UpdateParams", data2);
        return promise.then((data3) => exports.MsgUpdateParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.MsgClientImpl = MsgClientImpl;
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/ibc/aminomessages.js
var require_aminomessages9 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/ibc/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAminoMsgTransfer = isAminoMsgTransfer;
    exports.createIbcAminoConverters = createIbcAminoConverters;
    var amino_1 = require_build5();
    var tx_1 = require_tx9();
    function isAminoMsgTransfer(msg) {
      return msg.type === "cosmos-sdk/MsgTransfer";
    }
    function createIbcAminoConverters() {
      return {
        "/ibc.applications.transfer.v1.MsgTransfer": {
          aminoType: "cosmos-sdk/MsgTransfer",
          toAmino: ({ sourcePort, sourceChannel, token, sender, receiver, timeoutHeight, timeoutTimestamp, memo }) => ({
            source_port: sourcePort,
            source_channel: sourceChannel,
            token,
            sender,
            receiver,
            timeout_height: timeoutHeight ? {
              revision_height: (0, amino_1.omitDefault)(timeoutHeight.revisionHeight)?.toString(),
              revision_number: (0, amino_1.omitDefault)(timeoutHeight.revisionNumber)?.toString()
            } : {},
            timeout_timestamp: (0, amino_1.omitDefault)(timeoutTimestamp)?.toString(),
            memo: (0, amino_1.omitDefault)(memo)
          }),
          fromAmino: ({ source_port, source_channel, token, sender, receiver, timeout_height, timeout_timestamp, memo }) => tx_1.MsgTransfer.fromPartial({
            sourcePort: source_port,
            sourceChannel: source_channel,
            token,
            sender,
            receiver,
            timeoutHeight: timeout_height ? {
              revisionHeight: BigInt(timeout_height.revision_height || "0"),
              revisionNumber: BigInt(timeout_height.revision_number || "0")
            } : void 0,
            timeoutTimestamp: BigInt(timeout_timestamp || "0"),
            memo: memo ?? ""
          })
        }
      };
    }
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/core/channel/v1/channel.js
var require_channel = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/core/channel/v1/channel.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Params = exports.Timeout = exports.Acknowledgement = exports.PacketId = exports.PacketState = exports.Packet = exports.Counterparty = exports.IdentifiedChannel = exports.Channel = exports.orderToJSON = exports.orderFromJSON = exports.Order = exports.stateToJSON = exports.stateFromJSON = exports.State = exports.protobufPackage = void 0;
    var client_1 = require_client();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "ibc.core.channel.v1";
    var State;
    (function(State2) {
      State2[State2["STATE_UNINITIALIZED_UNSPECIFIED"] = 0] = "STATE_UNINITIALIZED_UNSPECIFIED";
      State2[State2["STATE_INIT"] = 1] = "STATE_INIT";
      State2[State2["STATE_TRYOPEN"] = 2] = "STATE_TRYOPEN";
      State2[State2["STATE_OPEN"] = 3] = "STATE_OPEN";
      State2[State2["STATE_CLOSED"] = 4] = "STATE_CLOSED";
      State2[State2["STATE_FLUSHING"] = 5] = "STATE_FLUSHING";
      State2[State2["STATE_FLUSHCOMPLETE"] = 6] = "STATE_FLUSHCOMPLETE";
      State2[State2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(State || (exports.State = State = {}));
    function stateFromJSON(object) {
      switch (object) {
        case 0:
        case "STATE_UNINITIALIZED_UNSPECIFIED":
          return State.STATE_UNINITIALIZED_UNSPECIFIED;
        case 1:
        case "STATE_INIT":
          return State.STATE_INIT;
        case 2:
        case "STATE_TRYOPEN":
          return State.STATE_TRYOPEN;
        case 3:
        case "STATE_OPEN":
          return State.STATE_OPEN;
        case 4:
        case "STATE_CLOSED":
          return State.STATE_CLOSED;
        case 5:
        case "STATE_FLUSHING":
          return State.STATE_FLUSHING;
        case 6:
        case "STATE_FLUSHCOMPLETE":
          return State.STATE_FLUSHCOMPLETE;
        case -1:
        case "UNRECOGNIZED":
        default:
          return State.UNRECOGNIZED;
      }
    }
    exports.stateFromJSON = stateFromJSON;
    function stateToJSON(object) {
      switch (object) {
        case State.STATE_UNINITIALIZED_UNSPECIFIED:
          return "STATE_UNINITIALIZED_UNSPECIFIED";
        case State.STATE_INIT:
          return "STATE_INIT";
        case State.STATE_TRYOPEN:
          return "STATE_TRYOPEN";
        case State.STATE_OPEN:
          return "STATE_OPEN";
        case State.STATE_CLOSED:
          return "STATE_CLOSED";
        case State.STATE_FLUSHING:
          return "STATE_FLUSHING";
        case State.STATE_FLUSHCOMPLETE:
          return "STATE_FLUSHCOMPLETE";
        case State.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.stateToJSON = stateToJSON;
    var Order;
    (function(Order2) {
      Order2[Order2["ORDER_NONE_UNSPECIFIED"] = 0] = "ORDER_NONE_UNSPECIFIED";
      Order2[Order2["ORDER_UNORDERED"] = 1] = "ORDER_UNORDERED";
      Order2[Order2["ORDER_ORDERED"] = 2] = "ORDER_ORDERED";
      Order2[Order2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(Order || (exports.Order = Order = {}));
    function orderFromJSON(object) {
      switch (object) {
        case 0:
        case "ORDER_NONE_UNSPECIFIED":
          return Order.ORDER_NONE_UNSPECIFIED;
        case 1:
        case "ORDER_UNORDERED":
          return Order.ORDER_UNORDERED;
        case 2:
        case "ORDER_ORDERED":
          return Order.ORDER_ORDERED;
        case -1:
        case "UNRECOGNIZED":
        default:
          return Order.UNRECOGNIZED;
      }
    }
    exports.orderFromJSON = orderFromJSON;
    function orderToJSON(object) {
      switch (object) {
        case Order.ORDER_NONE_UNSPECIFIED:
          return "ORDER_NONE_UNSPECIFIED";
        case Order.ORDER_UNORDERED:
          return "ORDER_UNORDERED";
        case Order.ORDER_ORDERED:
          return "ORDER_ORDERED";
        case Order.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.orderToJSON = orderToJSON;
    function createBaseChannel() {
      return {
        state: 0,
        ordering: 0,
        counterparty: exports.Counterparty.fromPartial({}),
        connectionHops: [],
        version: "",
        upgradeSequence: BigInt(0)
      };
    }
    exports.Channel = {
      typeUrl: "/ibc.core.channel.v1.Channel",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.state !== 0) {
          writer.uint32(8).int32(message.state);
        }
        if (message.ordering !== 0) {
          writer.uint32(16).int32(message.ordering);
        }
        if (message.counterparty !== void 0) {
          exports.Counterparty.encode(message.counterparty, writer.uint32(26).fork()).ldelim();
        }
        for (const v9 of message.connectionHops) {
          writer.uint32(34).string(v9);
        }
        if (message.version !== "") {
          writer.uint32(42).string(message.version);
        }
        if (message.upgradeSequence !== BigInt(0)) {
          writer.uint32(48).uint64(message.upgradeSequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseChannel();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.state = reader.int32();
              break;
            case 2:
              message.ordering = reader.int32();
              break;
            case 3:
              message.counterparty = exports.Counterparty.decode(reader, reader.uint32());
              break;
            case 4:
              message.connectionHops.push(reader.string());
              break;
            case 5:
              message.version = reader.string();
              break;
            case 6:
              message.upgradeSequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseChannel();
        if ((0, helpers_1.isSet)(object.state))
          obj.state = stateFromJSON(object.state);
        if ((0, helpers_1.isSet)(object.ordering))
          obj.ordering = orderFromJSON(object.ordering);
        if ((0, helpers_1.isSet)(object.counterparty))
          obj.counterparty = exports.Counterparty.fromJSON(object.counterparty);
        if (Array.isArray(object?.connectionHops))
          obj.connectionHops = object.connectionHops.map((e) => String(e));
        if ((0, helpers_1.isSet)(object.version))
          obj.version = String(object.version);
        if ((0, helpers_1.isSet)(object.upgradeSequence))
          obj.upgradeSequence = BigInt(object.upgradeSequence.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.state !== void 0 && (obj.state = stateToJSON(message.state));
        message.ordering !== void 0 && (obj.ordering = orderToJSON(message.ordering));
        message.counterparty !== void 0 && (obj.counterparty = message.counterparty ? exports.Counterparty.toJSON(message.counterparty) : void 0);
        if (message.connectionHops) {
          obj.connectionHops = message.connectionHops.map((e) => e);
        } else {
          obj.connectionHops = [];
        }
        message.version !== void 0 && (obj.version = message.version);
        message.upgradeSequence !== void 0 && (obj.upgradeSequence = (message.upgradeSequence || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseChannel();
        message.state = object.state ?? 0;
        message.ordering = object.ordering ?? 0;
        if (object.counterparty !== void 0 && object.counterparty !== null) {
          message.counterparty = exports.Counterparty.fromPartial(object.counterparty);
        }
        message.connectionHops = object.connectionHops?.map((e) => e) || [];
        message.version = object.version ?? "";
        if (object.upgradeSequence !== void 0 && object.upgradeSequence !== null) {
          message.upgradeSequence = BigInt(object.upgradeSequence.toString());
        }
        return message;
      }
    };
    function createBaseIdentifiedChannel() {
      return {
        state: 0,
        ordering: 0,
        counterparty: exports.Counterparty.fromPartial({}),
        connectionHops: [],
        version: "",
        portId: "",
        channelId: "",
        upgradeSequence: BigInt(0)
      };
    }
    exports.IdentifiedChannel = {
      typeUrl: "/ibc.core.channel.v1.IdentifiedChannel",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.state !== 0) {
          writer.uint32(8).int32(message.state);
        }
        if (message.ordering !== 0) {
          writer.uint32(16).int32(message.ordering);
        }
        if (message.counterparty !== void 0) {
          exports.Counterparty.encode(message.counterparty, writer.uint32(26).fork()).ldelim();
        }
        for (const v9 of message.connectionHops) {
          writer.uint32(34).string(v9);
        }
        if (message.version !== "") {
          writer.uint32(42).string(message.version);
        }
        if (message.portId !== "") {
          writer.uint32(50).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(58).string(message.channelId);
        }
        if (message.upgradeSequence !== BigInt(0)) {
          writer.uint32(64).uint64(message.upgradeSequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseIdentifiedChannel();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.state = reader.int32();
              break;
            case 2:
              message.ordering = reader.int32();
              break;
            case 3:
              message.counterparty = exports.Counterparty.decode(reader, reader.uint32());
              break;
            case 4:
              message.connectionHops.push(reader.string());
              break;
            case 5:
              message.version = reader.string();
              break;
            case 6:
              message.portId = reader.string();
              break;
            case 7:
              message.channelId = reader.string();
              break;
            case 8:
              message.upgradeSequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseIdentifiedChannel();
        if ((0, helpers_1.isSet)(object.state))
          obj.state = stateFromJSON(object.state);
        if ((0, helpers_1.isSet)(object.ordering))
          obj.ordering = orderFromJSON(object.ordering);
        if ((0, helpers_1.isSet)(object.counterparty))
          obj.counterparty = exports.Counterparty.fromJSON(object.counterparty);
        if (Array.isArray(object?.connectionHops))
          obj.connectionHops = object.connectionHops.map((e) => String(e));
        if ((0, helpers_1.isSet)(object.version))
          obj.version = String(object.version);
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.upgradeSequence))
          obj.upgradeSequence = BigInt(object.upgradeSequence.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.state !== void 0 && (obj.state = stateToJSON(message.state));
        message.ordering !== void 0 && (obj.ordering = orderToJSON(message.ordering));
        message.counterparty !== void 0 && (obj.counterparty = message.counterparty ? exports.Counterparty.toJSON(message.counterparty) : void 0);
        if (message.connectionHops) {
          obj.connectionHops = message.connectionHops.map((e) => e);
        } else {
          obj.connectionHops = [];
        }
        message.version !== void 0 && (obj.version = message.version);
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.upgradeSequence !== void 0 && (obj.upgradeSequence = (message.upgradeSequence || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseIdentifiedChannel();
        message.state = object.state ?? 0;
        message.ordering = object.ordering ?? 0;
        if (object.counterparty !== void 0 && object.counterparty !== null) {
          message.counterparty = exports.Counterparty.fromPartial(object.counterparty);
        }
        message.connectionHops = object.connectionHops?.map((e) => e) || [];
        message.version = object.version ?? "";
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.upgradeSequence !== void 0 && object.upgradeSequence !== null) {
          message.upgradeSequence = BigInt(object.upgradeSequence.toString());
        }
        return message;
      }
    };
    function createBaseCounterparty() {
      return {
        portId: "",
        channelId: ""
      };
    }
    exports.Counterparty = {
      typeUrl: "/ibc.core.channel.v1.Counterparty",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCounterparty();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCounterparty();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCounterparty();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        return message;
      }
    };
    function createBasePacket() {
      return {
        sequence: BigInt(0),
        sourcePort: "",
        sourceChannel: "",
        destinationPort: "",
        destinationChannel: "",
        data: new Uint8Array(),
        timeoutHeight: client_1.Height.fromPartial({}),
        timeoutTimestamp: BigInt(0)
      };
    }
    exports.Packet = {
      typeUrl: "/ibc.core.channel.v1.Packet",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.sequence !== BigInt(0)) {
          writer.uint32(8).uint64(message.sequence);
        }
        if (message.sourcePort !== "") {
          writer.uint32(18).string(message.sourcePort);
        }
        if (message.sourceChannel !== "") {
          writer.uint32(26).string(message.sourceChannel);
        }
        if (message.destinationPort !== "") {
          writer.uint32(34).string(message.destinationPort);
        }
        if (message.destinationChannel !== "") {
          writer.uint32(42).string(message.destinationChannel);
        }
        if (message.data.length !== 0) {
          writer.uint32(50).bytes(message.data);
        }
        if (message.timeoutHeight !== void 0) {
          client_1.Height.encode(message.timeoutHeight, writer.uint32(58).fork()).ldelim();
        }
        if (message.timeoutTimestamp !== BigInt(0)) {
          writer.uint32(64).uint64(message.timeoutTimestamp);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePacket();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sequence = reader.uint64();
              break;
            case 2:
              message.sourcePort = reader.string();
              break;
            case 3:
              message.sourceChannel = reader.string();
              break;
            case 4:
              message.destinationPort = reader.string();
              break;
            case 5:
              message.destinationChannel = reader.string();
              break;
            case 6:
              message.data = reader.bytes();
              break;
            case 7:
              message.timeoutHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 8:
              message.timeoutTimestamp = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePacket();
        if ((0, helpers_1.isSet)(object.sequence))
          obj.sequence = BigInt(object.sequence.toString());
        if ((0, helpers_1.isSet)(object.sourcePort))
          obj.sourcePort = String(object.sourcePort);
        if ((0, helpers_1.isSet)(object.sourceChannel))
          obj.sourceChannel = String(object.sourceChannel);
        if ((0, helpers_1.isSet)(object.destinationPort))
          obj.destinationPort = String(object.destinationPort);
        if ((0, helpers_1.isSet)(object.destinationChannel))
          obj.destinationChannel = String(object.destinationChannel);
        if ((0, helpers_1.isSet)(object.data))
          obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        if ((0, helpers_1.isSet)(object.timeoutHeight))
          obj.timeoutHeight = client_1.Height.fromJSON(object.timeoutHeight);
        if ((0, helpers_1.isSet)(object.timeoutTimestamp))
          obj.timeoutTimestamp = BigInt(object.timeoutTimestamp.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt(0)).toString());
        message.sourcePort !== void 0 && (obj.sourcePort = message.sourcePort);
        message.sourceChannel !== void 0 && (obj.sourceChannel = message.sourceChannel);
        message.destinationPort !== void 0 && (obj.destinationPort = message.destinationPort);
        message.destinationChannel !== void 0 && (obj.destinationChannel = message.destinationChannel);
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        message.timeoutHeight !== void 0 && (obj.timeoutHeight = message.timeoutHeight ? client_1.Height.toJSON(message.timeoutHeight) : void 0);
        message.timeoutTimestamp !== void 0 && (obj.timeoutTimestamp = (message.timeoutTimestamp || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBasePacket();
        if (object.sequence !== void 0 && object.sequence !== null) {
          message.sequence = BigInt(object.sequence.toString());
        }
        message.sourcePort = object.sourcePort ?? "";
        message.sourceChannel = object.sourceChannel ?? "";
        message.destinationPort = object.destinationPort ?? "";
        message.destinationChannel = object.destinationChannel ?? "";
        message.data = object.data ?? new Uint8Array();
        if (object.timeoutHeight !== void 0 && object.timeoutHeight !== null) {
          message.timeoutHeight = client_1.Height.fromPartial(object.timeoutHeight);
        }
        if (object.timeoutTimestamp !== void 0 && object.timeoutTimestamp !== null) {
          message.timeoutTimestamp = BigInt(object.timeoutTimestamp.toString());
        }
        return message;
      }
    };
    function createBasePacketState() {
      return {
        portId: "",
        channelId: "",
        sequence: BigInt(0),
        data: new Uint8Array()
      };
    }
    exports.PacketState = {
      typeUrl: "/ibc.core.channel.v1.PacketState",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.sequence !== BigInt(0)) {
          writer.uint32(24).uint64(message.sequence);
        }
        if (message.data.length !== 0) {
          writer.uint32(34).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePacketState();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.sequence = reader.uint64();
              break;
            case 4:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePacketState();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.sequence))
          obj.sequence = BigInt(object.sequence.toString());
        if ((0, helpers_1.isSet)(object.data))
          obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt(0)).toString());
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBasePacketState();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.sequence !== void 0 && object.sequence !== null) {
          message.sequence = BigInt(object.sequence.toString());
        }
        message.data = object.data ?? new Uint8Array();
        return message;
      }
    };
    function createBasePacketId() {
      return {
        portId: "",
        channelId: "",
        sequence: BigInt(0)
      };
    }
    exports.PacketId = {
      typeUrl: "/ibc.core.channel.v1.PacketId",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.sequence !== BigInt(0)) {
          writer.uint32(24).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePacketId();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.sequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePacketId();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.sequence))
          obj.sequence = BigInt(object.sequence.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBasePacketId();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.sequence !== void 0 && object.sequence !== null) {
          message.sequence = BigInt(object.sequence.toString());
        }
        return message;
      }
    };
    function createBaseAcknowledgement() {
      return {
        result: void 0,
        error: void 0
      };
    }
    exports.Acknowledgement = {
      typeUrl: "/ibc.core.channel.v1.Acknowledgement",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== void 0) {
          writer.uint32(170).bytes(message.result);
        }
        if (message.error !== void 0) {
          writer.uint32(178).string(message.error);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAcknowledgement();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 21:
              message.result = reader.bytes();
              break;
            case 22:
              message.error = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseAcknowledgement();
        if ((0, helpers_1.isSet)(object.result))
          obj.result = (0, helpers_1.bytesFromBase64)(object.result);
        if ((0, helpers_1.isSet)(object.error))
          obj.error = String(object.error);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = message.result !== void 0 ? (0, helpers_1.base64FromBytes)(message.result) : void 0);
        message.error !== void 0 && (obj.error = message.error);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseAcknowledgement();
        message.result = object.result ?? void 0;
        message.error = object.error ?? void 0;
        return message;
      }
    };
    function createBaseTimeout() {
      return {
        height: client_1.Height.fromPartial({}),
        timestamp: BigInt(0)
      };
    }
    exports.Timeout = {
      typeUrl: "/ibc.core.channel.v1.Timeout",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== void 0) {
          client_1.Height.encode(message.height, writer.uint32(10).fork()).ldelim();
        }
        if (message.timestamp !== BigInt(0)) {
          writer.uint32(16).uint64(message.timestamp);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTimeout();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = client_1.Height.decode(reader, reader.uint32());
              break;
            case 2:
              message.timestamp = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTimeout();
        if ((0, helpers_1.isSet)(object.height))
          obj.height = client_1.Height.fromJSON(object.height);
        if ((0, helpers_1.isSet)(object.timestamp))
          obj.timestamp = BigInt(object.timestamp.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = message.height ? client_1.Height.toJSON(message.height) : void 0);
        message.timestamp !== void 0 && (obj.timestamp = (message.timestamp || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTimeout();
        if (object.height !== void 0 && object.height !== null) {
          message.height = client_1.Height.fromPartial(object.height);
        }
        if (object.timestamp !== void 0 && object.timestamp !== null) {
          message.timestamp = BigInt(object.timestamp.toString());
        }
        return message;
      }
    };
    function createBaseParams() {
      return {
        upgradeTimeout: exports.Timeout.fromPartial({})
      };
    }
    exports.Params = {
      typeUrl: "/ibc.core.channel.v1.Params",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.upgradeTimeout !== void 0) {
          exports.Timeout.encode(message.upgradeTimeout, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.upgradeTimeout = exports.Timeout.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseParams();
        if ((0, helpers_1.isSet)(object.upgradeTimeout))
          obj.upgradeTimeout = exports.Timeout.fromJSON(object.upgradeTimeout);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.upgradeTimeout !== void 0 && (obj.upgradeTimeout = message.upgradeTimeout ? exports.Timeout.toJSON(message.upgradeTimeout) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseParams();
        if (object.upgradeTimeout !== void 0 && object.upgradeTimeout !== null) {
          message.upgradeTimeout = exports.Timeout.fromPartial(object.upgradeTimeout);
        }
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/core/channel/v1/upgrade.js
var require_upgrade2 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/core/channel/v1/upgrade.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ErrorReceipt = exports.UpgradeFields = exports.Upgrade = exports.protobufPackage = void 0;
    var channel_1 = require_channel();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "ibc.core.channel.v1";
    function createBaseUpgrade() {
      return {
        fields: exports.UpgradeFields.fromPartial({}),
        timeout: channel_1.Timeout.fromPartial({}),
        nextSequenceSend: BigInt(0)
      };
    }
    exports.Upgrade = {
      typeUrl: "/ibc.core.channel.v1.Upgrade",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.fields !== void 0) {
          exports.UpgradeFields.encode(message.fields, writer.uint32(10).fork()).ldelim();
        }
        if (message.timeout !== void 0) {
          channel_1.Timeout.encode(message.timeout, writer.uint32(18).fork()).ldelim();
        }
        if (message.nextSequenceSend !== BigInt(0)) {
          writer.uint32(24).uint64(message.nextSequenceSend);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUpgrade();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.fields = exports.UpgradeFields.decode(reader, reader.uint32());
              break;
            case 2:
              message.timeout = channel_1.Timeout.decode(reader, reader.uint32());
              break;
            case 3:
              message.nextSequenceSend = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseUpgrade();
        if ((0, helpers_1.isSet)(object.fields))
          obj.fields = exports.UpgradeFields.fromJSON(object.fields);
        if ((0, helpers_1.isSet)(object.timeout))
          obj.timeout = channel_1.Timeout.fromJSON(object.timeout);
        if ((0, helpers_1.isSet)(object.nextSequenceSend))
          obj.nextSequenceSend = BigInt(object.nextSequenceSend.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.fields !== void 0 && (obj.fields = message.fields ? exports.UpgradeFields.toJSON(message.fields) : void 0);
        message.timeout !== void 0 && (obj.timeout = message.timeout ? channel_1.Timeout.toJSON(message.timeout) : void 0);
        message.nextSequenceSend !== void 0 && (obj.nextSequenceSend = (message.nextSequenceSend || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseUpgrade();
        if (object.fields !== void 0 && object.fields !== null) {
          message.fields = exports.UpgradeFields.fromPartial(object.fields);
        }
        if (object.timeout !== void 0 && object.timeout !== null) {
          message.timeout = channel_1.Timeout.fromPartial(object.timeout);
        }
        if (object.nextSequenceSend !== void 0 && object.nextSequenceSend !== null) {
          message.nextSequenceSend = BigInt(object.nextSequenceSend.toString());
        }
        return message;
      }
    };
    function createBaseUpgradeFields() {
      return {
        ordering: 0,
        connectionHops: [],
        version: ""
      };
    }
    exports.UpgradeFields = {
      typeUrl: "/ibc.core.channel.v1.UpgradeFields",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.ordering !== 0) {
          writer.uint32(8).int32(message.ordering);
        }
        for (const v9 of message.connectionHops) {
          writer.uint32(18).string(v9);
        }
        if (message.version !== "") {
          writer.uint32(26).string(message.version);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUpgradeFields();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.ordering = reader.int32();
              break;
            case 2:
              message.connectionHops.push(reader.string());
              break;
            case 3:
              message.version = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseUpgradeFields();
        if ((0, helpers_1.isSet)(object.ordering))
          obj.ordering = (0, channel_1.orderFromJSON)(object.ordering);
        if (Array.isArray(object?.connectionHops))
          obj.connectionHops = object.connectionHops.map((e) => String(e));
        if ((0, helpers_1.isSet)(object.version))
          obj.version = String(object.version);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.ordering !== void 0 && (obj.ordering = (0, channel_1.orderToJSON)(message.ordering));
        if (message.connectionHops) {
          obj.connectionHops = message.connectionHops.map((e) => e);
        } else {
          obj.connectionHops = [];
        }
        message.version !== void 0 && (obj.version = message.version);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseUpgradeFields();
        message.ordering = object.ordering ?? 0;
        message.connectionHops = object.connectionHops?.map((e) => e) || [];
        message.version = object.version ?? "";
        return message;
      }
    };
    function createBaseErrorReceipt() {
      return {
        sequence: BigInt(0),
        message: ""
      };
    }
    exports.ErrorReceipt = {
      typeUrl: "/ibc.core.channel.v1.ErrorReceipt",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.sequence !== BigInt(0)) {
          writer.uint32(8).uint64(message.sequence);
        }
        if (message.message !== "") {
          writer.uint32(18).string(message.message);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseErrorReceipt();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sequence = reader.uint64();
              break;
            case 2:
              message.message = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseErrorReceipt();
        if ((0, helpers_1.isSet)(object.sequence))
          obj.sequence = BigInt(object.sequence.toString());
        if ((0, helpers_1.isSet)(object.message))
          obj.message = String(object.message);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt(0)).toString());
        message.message !== void 0 && (obj.message = message.message);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseErrorReceipt();
        if (object.sequence !== void 0 && object.sequence !== null) {
          message.sequence = BigInt(object.sequence.toString());
        }
        message.message = object.message ?? "";
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/core/channel/v1/tx.js
var require_tx10 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/core/channel/v1/tx.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MsgClientImpl = exports.MsgPruneAcknowledgementsResponse = exports.MsgPruneAcknowledgements = exports.MsgUpdateParamsResponse = exports.MsgUpdateParams = exports.MsgChannelUpgradeCancelResponse = exports.MsgChannelUpgradeCancel = exports.MsgChannelUpgradeTimeoutResponse = exports.MsgChannelUpgradeTimeout = exports.MsgChannelUpgradeOpenResponse = exports.MsgChannelUpgradeOpen = exports.MsgChannelUpgradeConfirmResponse = exports.MsgChannelUpgradeConfirm = exports.MsgChannelUpgradeAckResponse = exports.MsgChannelUpgradeAck = exports.MsgChannelUpgradeTryResponse = exports.MsgChannelUpgradeTry = exports.MsgChannelUpgradeInitResponse = exports.MsgChannelUpgradeInit = exports.MsgAcknowledgementResponse = exports.MsgAcknowledgement = exports.MsgTimeoutOnCloseResponse = exports.MsgTimeoutOnClose = exports.MsgTimeoutResponse = exports.MsgTimeout = exports.MsgRecvPacketResponse = exports.MsgRecvPacket = exports.MsgChannelCloseConfirmResponse = exports.MsgChannelCloseConfirm = exports.MsgChannelCloseInitResponse = exports.MsgChannelCloseInit = exports.MsgChannelOpenConfirmResponse = exports.MsgChannelOpenConfirm = exports.MsgChannelOpenAckResponse = exports.MsgChannelOpenAck = exports.MsgChannelOpenTryResponse = exports.MsgChannelOpenTry = exports.MsgChannelOpenInitResponse = exports.MsgChannelOpenInit = exports.responseResultTypeToJSON = exports.responseResultTypeFromJSON = exports.ResponseResultType = exports.protobufPackage = void 0;
    var channel_1 = require_channel();
    var client_1 = require_client();
    var upgrade_1 = require_upgrade2();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "ibc.core.channel.v1";
    var ResponseResultType;
    (function(ResponseResultType2) {
      ResponseResultType2[ResponseResultType2["RESPONSE_RESULT_TYPE_UNSPECIFIED"] = 0] = "RESPONSE_RESULT_TYPE_UNSPECIFIED";
      ResponseResultType2[ResponseResultType2["RESPONSE_RESULT_TYPE_NOOP"] = 1] = "RESPONSE_RESULT_TYPE_NOOP";
      ResponseResultType2[ResponseResultType2["RESPONSE_RESULT_TYPE_SUCCESS"] = 2] = "RESPONSE_RESULT_TYPE_SUCCESS";
      ResponseResultType2[ResponseResultType2["RESPONSE_RESULT_TYPE_FAILURE"] = 3] = "RESPONSE_RESULT_TYPE_FAILURE";
      ResponseResultType2[ResponseResultType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ResponseResultType || (exports.ResponseResultType = ResponseResultType = {}));
    function responseResultTypeFromJSON(object) {
      switch (object) {
        case 0:
        case "RESPONSE_RESULT_TYPE_UNSPECIFIED":
          return ResponseResultType.RESPONSE_RESULT_TYPE_UNSPECIFIED;
        case 1:
        case "RESPONSE_RESULT_TYPE_NOOP":
          return ResponseResultType.RESPONSE_RESULT_TYPE_NOOP;
        case 2:
        case "RESPONSE_RESULT_TYPE_SUCCESS":
          return ResponseResultType.RESPONSE_RESULT_TYPE_SUCCESS;
        case 3:
        case "RESPONSE_RESULT_TYPE_FAILURE":
          return ResponseResultType.RESPONSE_RESULT_TYPE_FAILURE;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ResponseResultType.UNRECOGNIZED;
      }
    }
    exports.responseResultTypeFromJSON = responseResultTypeFromJSON;
    function responseResultTypeToJSON(object) {
      switch (object) {
        case ResponseResultType.RESPONSE_RESULT_TYPE_UNSPECIFIED:
          return "RESPONSE_RESULT_TYPE_UNSPECIFIED";
        case ResponseResultType.RESPONSE_RESULT_TYPE_NOOP:
          return "RESPONSE_RESULT_TYPE_NOOP";
        case ResponseResultType.RESPONSE_RESULT_TYPE_SUCCESS:
          return "RESPONSE_RESULT_TYPE_SUCCESS";
        case ResponseResultType.RESPONSE_RESULT_TYPE_FAILURE:
          return "RESPONSE_RESULT_TYPE_FAILURE";
        case ResponseResultType.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.responseResultTypeToJSON = responseResultTypeToJSON;
    function createBaseMsgChannelOpenInit() {
      return {
        portId: "",
        channel: channel_1.Channel.fromPartial({}),
        signer: ""
      };
    }
    exports.MsgChannelOpenInit = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelOpenInit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channel !== void 0) {
          channel_1.Channel.encode(message.channel, writer.uint32(18).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(26).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenInit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channel = channel_1.Channel.decode(reader, reader.uint32());
              break;
            case 3:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelOpenInit();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channel))
          obj.channel = channel_1.Channel.fromJSON(object.channel);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channel !== void 0 && (obj.channel = message.channel ? channel_1.Channel.toJSON(message.channel) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelOpenInit();
        message.portId = object.portId ?? "";
        if (object.channel !== void 0 && object.channel !== null) {
          message.channel = channel_1.Channel.fromPartial(object.channel);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgChannelOpenInitResponse() {
      return {
        channelId: "",
        version: ""
      };
    }
    exports.MsgChannelOpenInitResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelOpenInitResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.channelId !== "") {
          writer.uint32(10).string(message.channelId);
        }
        if (message.version !== "") {
          writer.uint32(18).string(message.version);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenInitResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.channelId = reader.string();
              break;
            case 2:
              message.version = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelOpenInitResponse();
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.version))
          obj.version = String(object.version);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.version !== void 0 && (obj.version = message.version);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelOpenInitResponse();
        message.channelId = object.channelId ?? "";
        message.version = object.version ?? "";
        return message;
      }
    };
    function createBaseMsgChannelOpenTry() {
      return {
        portId: "",
        previousChannelId: "",
        channel: channel_1.Channel.fromPartial({}),
        counterpartyVersion: "",
        proofInit: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
      };
    }
    exports.MsgChannelOpenTry = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelOpenTry",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.previousChannelId !== "") {
          writer.uint32(18).string(message.previousChannelId);
        }
        if (message.channel !== void 0) {
          channel_1.Channel.encode(message.channel, writer.uint32(26).fork()).ldelim();
        }
        if (message.counterpartyVersion !== "") {
          writer.uint32(34).string(message.counterpartyVersion);
        }
        if (message.proofInit.length !== 0) {
          writer.uint32(42).bytes(message.proofInit);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(50).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(58).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenTry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.previousChannelId = reader.string();
              break;
            case 3:
              message.channel = channel_1.Channel.decode(reader, reader.uint32());
              break;
            case 4:
              message.counterpartyVersion = reader.string();
              break;
            case 5:
              message.proofInit = reader.bytes();
              break;
            case 6:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 7:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelOpenTry();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.previousChannelId))
          obj.previousChannelId = String(object.previousChannelId);
        if ((0, helpers_1.isSet)(object.channel))
          obj.channel = channel_1.Channel.fromJSON(object.channel);
        if ((0, helpers_1.isSet)(object.counterpartyVersion))
          obj.counterpartyVersion = String(object.counterpartyVersion);
        if ((0, helpers_1.isSet)(object.proofInit))
          obj.proofInit = (0, helpers_1.bytesFromBase64)(object.proofInit);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.previousChannelId !== void 0 && (obj.previousChannelId = message.previousChannelId);
        message.channel !== void 0 && (obj.channel = message.channel ? channel_1.Channel.toJSON(message.channel) : void 0);
        message.counterpartyVersion !== void 0 && (obj.counterpartyVersion = message.counterpartyVersion);
        message.proofInit !== void 0 && (obj.proofInit = (0, helpers_1.base64FromBytes)(message.proofInit !== void 0 ? message.proofInit : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelOpenTry();
        message.portId = object.portId ?? "";
        message.previousChannelId = object.previousChannelId ?? "";
        if (object.channel !== void 0 && object.channel !== null) {
          message.channel = channel_1.Channel.fromPartial(object.channel);
        }
        message.counterpartyVersion = object.counterpartyVersion ?? "";
        message.proofInit = object.proofInit ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgChannelOpenTryResponse() {
      return {
        version: "",
        channelId: ""
      };
    }
    exports.MsgChannelOpenTryResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelOpenTryResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.version !== "") {
          writer.uint32(10).string(message.version);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenTryResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.version = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelOpenTryResponse();
        if ((0, helpers_1.isSet)(object.version))
          obj.version = String(object.version);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.version !== void 0 && (obj.version = message.version);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelOpenTryResponse();
        message.version = object.version ?? "";
        message.channelId = object.channelId ?? "";
        return message;
      }
    };
    function createBaseMsgChannelOpenAck() {
      return {
        portId: "",
        channelId: "",
        counterpartyChannelId: "",
        counterpartyVersion: "",
        proofTry: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
      };
    }
    exports.MsgChannelOpenAck = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelOpenAck",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.counterpartyChannelId !== "") {
          writer.uint32(26).string(message.counterpartyChannelId);
        }
        if (message.counterpartyVersion !== "") {
          writer.uint32(34).string(message.counterpartyVersion);
        }
        if (message.proofTry.length !== 0) {
          writer.uint32(42).bytes(message.proofTry);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(50).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(58).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenAck();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.counterpartyChannelId = reader.string();
              break;
            case 4:
              message.counterpartyVersion = reader.string();
              break;
            case 5:
              message.proofTry = reader.bytes();
              break;
            case 6:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 7:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelOpenAck();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.counterpartyChannelId))
          obj.counterpartyChannelId = String(object.counterpartyChannelId);
        if ((0, helpers_1.isSet)(object.counterpartyVersion))
          obj.counterpartyVersion = String(object.counterpartyVersion);
        if ((0, helpers_1.isSet)(object.proofTry))
          obj.proofTry = (0, helpers_1.bytesFromBase64)(object.proofTry);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.counterpartyChannelId !== void 0 && (obj.counterpartyChannelId = message.counterpartyChannelId);
        message.counterpartyVersion !== void 0 && (obj.counterpartyVersion = message.counterpartyVersion);
        message.proofTry !== void 0 && (obj.proofTry = (0, helpers_1.base64FromBytes)(message.proofTry !== void 0 ? message.proofTry : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelOpenAck();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        message.counterpartyChannelId = object.counterpartyChannelId ?? "";
        message.counterpartyVersion = object.counterpartyVersion ?? "";
        message.proofTry = object.proofTry ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgChannelOpenAckResponse() {
      return {};
    }
    exports.MsgChannelOpenAckResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelOpenAckResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenAckResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgChannelOpenAckResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgChannelOpenAckResponse();
        return message;
      }
    };
    function createBaseMsgChannelOpenConfirm() {
      return {
        portId: "",
        channelId: "",
        proofAck: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
      };
    }
    exports.MsgChannelOpenConfirm = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelOpenConfirm",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.proofAck.length !== 0) {
          writer.uint32(26).bytes(message.proofAck);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(42).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenConfirm();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.proofAck = reader.bytes();
              break;
            case 4:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 5:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelOpenConfirm();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.proofAck))
          obj.proofAck = (0, helpers_1.bytesFromBase64)(object.proofAck);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.proofAck !== void 0 && (obj.proofAck = (0, helpers_1.base64FromBytes)(message.proofAck !== void 0 ? message.proofAck : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelOpenConfirm();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        message.proofAck = object.proofAck ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgChannelOpenConfirmResponse() {
      return {};
    }
    exports.MsgChannelOpenConfirmResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelOpenConfirmResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelOpenConfirmResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgChannelOpenConfirmResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgChannelOpenConfirmResponse();
        return message;
      }
    };
    function createBaseMsgChannelCloseInit() {
      return {
        portId: "",
        channelId: "",
        signer: ""
      };
    }
    exports.MsgChannelCloseInit = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelCloseInit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.signer !== "") {
          writer.uint32(26).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelCloseInit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelCloseInit();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelCloseInit();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgChannelCloseInitResponse() {
      return {};
    }
    exports.MsgChannelCloseInitResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelCloseInitResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelCloseInitResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgChannelCloseInitResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgChannelCloseInitResponse();
        return message;
      }
    };
    function createBaseMsgChannelCloseConfirm() {
      return {
        portId: "",
        channelId: "",
        proofInit: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: "",
        counterpartyUpgradeSequence: BigInt(0)
      };
    }
    exports.MsgChannelCloseConfirm = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelCloseConfirm",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.proofInit.length !== 0) {
          writer.uint32(26).bytes(message.proofInit);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(42).string(message.signer);
        }
        if (message.counterpartyUpgradeSequence !== BigInt(0)) {
          writer.uint32(48).uint64(message.counterpartyUpgradeSequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelCloseConfirm();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.proofInit = reader.bytes();
              break;
            case 4:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 5:
              message.signer = reader.string();
              break;
            case 6:
              message.counterpartyUpgradeSequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelCloseConfirm();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.proofInit))
          obj.proofInit = (0, helpers_1.bytesFromBase64)(object.proofInit);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        if ((0, helpers_1.isSet)(object.counterpartyUpgradeSequence))
          obj.counterpartyUpgradeSequence = BigInt(object.counterpartyUpgradeSequence.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.proofInit !== void 0 && (obj.proofInit = (0, helpers_1.base64FromBytes)(message.proofInit !== void 0 ? message.proofInit : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        message.counterpartyUpgradeSequence !== void 0 && (obj.counterpartyUpgradeSequence = (message.counterpartyUpgradeSequence || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelCloseConfirm();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        message.proofInit = object.proofInit ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.signer = object.signer ?? "";
        if (object.counterpartyUpgradeSequence !== void 0 && object.counterpartyUpgradeSequence !== null) {
          message.counterpartyUpgradeSequence = BigInt(object.counterpartyUpgradeSequence.toString());
        }
        return message;
      }
    };
    function createBaseMsgChannelCloseConfirmResponse() {
      return {};
    }
    exports.MsgChannelCloseConfirmResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelCloseConfirmResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelCloseConfirmResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgChannelCloseConfirmResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgChannelCloseConfirmResponse();
        return message;
      }
    };
    function createBaseMsgRecvPacket() {
      return {
        packet: channel_1.Packet.fromPartial({}),
        proofCommitment: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
      };
    }
    exports.MsgRecvPacket = {
      typeUrl: "/ibc.core.channel.v1.MsgRecvPacket",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.packet !== void 0) {
          channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();
        }
        if (message.proofCommitment.length !== 0) {
          writer.uint32(18).bytes(message.proofCommitment);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(34).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRecvPacket();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.packet = channel_1.Packet.decode(reader, reader.uint32());
              break;
            case 2:
              message.proofCommitment = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 4:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgRecvPacket();
        if ((0, helpers_1.isSet)(object.packet))
          obj.packet = channel_1.Packet.fromJSON(object.packet);
        if ((0, helpers_1.isSet)(object.proofCommitment))
          obj.proofCommitment = (0, helpers_1.bytesFromBase64)(object.proofCommitment);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.packet !== void 0 && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : void 0);
        message.proofCommitment !== void 0 && (obj.proofCommitment = (0, helpers_1.base64FromBytes)(message.proofCommitment !== void 0 ? message.proofCommitment : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgRecvPacket();
        if (object.packet !== void 0 && object.packet !== null) {
          message.packet = channel_1.Packet.fromPartial(object.packet);
        }
        message.proofCommitment = object.proofCommitment ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgRecvPacketResponse() {
      return {
        result: 0
      };
    }
    exports.MsgRecvPacketResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgRecvPacketResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== 0) {
          writer.uint32(8).int32(message.result);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRecvPacketResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.result = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgRecvPacketResponse();
        if ((0, helpers_1.isSet)(object.result))
          obj.result = responseResultTypeFromJSON(object.result);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = responseResultTypeToJSON(message.result));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgRecvPacketResponse();
        message.result = object.result ?? 0;
        return message;
      }
    };
    function createBaseMsgTimeout() {
      return {
        packet: channel_1.Packet.fromPartial({}),
        proofUnreceived: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        nextSequenceRecv: BigInt(0),
        signer: ""
      };
    }
    exports.MsgTimeout = {
      typeUrl: "/ibc.core.channel.v1.MsgTimeout",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.packet !== void 0) {
          channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();
        }
        if (message.proofUnreceived.length !== 0) {
          writer.uint32(18).bytes(message.proofUnreceived);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        if (message.nextSequenceRecv !== BigInt(0)) {
          writer.uint32(32).uint64(message.nextSequenceRecv);
        }
        if (message.signer !== "") {
          writer.uint32(42).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgTimeout();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.packet = channel_1.Packet.decode(reader, reader.uint32());
              break;
            case 2:
              message.proofUnreceived = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 4:
              message.nextSequenceRecv = reader.uint64();
              break;
            case 5:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgTimeout();
        if ((0, helpers_1.isSet)(object.packet))
          obj.packet = channel_1.Packet.fromJSON(object.packet);
        if ((0, helpers_1.isSet)(object.proofUnreceived))
          obj.proofUnreceived = (0, helpers_1.bytesFromBase64)(object.proofUnreceived);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.nextSequenceRecv))
          obj.nextSequenceRecv = BigInt(object.nextSequenceRecv.toString());
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.packet !== void 0 && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : void 0);
        message.proofUnreceived !== void 0 && (obj.proofUnreceived = (0, helpers_1.base64FromBytes)(message.proofUnreceived !== void 0 ? message.proofUnreceived : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.nextSequenceRecv !== void 0 && (obj.nextSequenceRecv = (message.nextSequenceRecv || BigInt(0)).toString());
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgTimeout();
        if (object.packet !== void 0 && object.packet !== null) {
          message.packet = channel_1.Packet.fromPartial(object.packet);
        }
        message.proofUnreceived = object.proofUnreceived ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        if (object.nextSequenceRecv !== void 0 && object.nextSequenceRecv !== null) {
          message.nextSequenceRecv = BigInt(object.nextSequenceRecv.toString());
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgTimeoutResponse() {
      return {
        result: 0
      };
    }
    exports.MsgTimeoutResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgTimeoutResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== 0) {
          writer.uint32(8).int32(message.result);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgTimeoutResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.result = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgTimeoutResponse();
        if ((0, helpers_1.isSet)(object.result))
          obj.result = responseResultTypeFromJSON(object.result);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = responseResultTypeToJSON(message.result));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgTimeoutResponse();
        message.result = object.result ?? 0;
        return message;
      }
    };
    function createBaseMsgTimeoutOnClose() {
      return {
        packet: channel_1.Packet.fromPartial({}),
        proofUnreceived: new Uint8Array(),
        proofClose: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        nextSequenceRecv: BigInt(0),
        signer: "",
        counterpartyUpgradeSequence: BigInt(0)
      };
    }
    exports.MsgTimeoutOnClose = {
      typeUrl: "/ibc.core.channel.v1.MsgTimeoutOnClose",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.packet !== void 0) {
          channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();
        }
        if (message.proofUnreceived.length !== 0) {
          writer.uint32(18).bytes(message.proofUnreceived);
        }
        if (message.proofClose.length !== 0) {
          writer.uint32(26).bytes(message.proofClose);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        }
        if (message.nextSequenceRecv !== BigInt(0)) {
          writer.uint32(40).uint64(message.nextSequenceRecv);
        }
        if (message.signer !== "") {
          writer.uint32(50).string(message.signer);
        }
        if (message.counterpartyUpgradeSequence !== BigInt(0)) {
          writer.uint32(56).uint64(message.counterpartyUpgradeSequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgTimeoutOnClose();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.packet = channel_1.Packet.decode(reader, reader.uint32());
              break;
            case 2:
              message.proofUnreceived = reader.bytes();
              break;
            case 3:
              message.proofClose = reader.bytes();
              break;
            case 4:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 5:
              message.nextSequenceRecv = reader.uint64();
              break;
            case 6:
              message.signer = reader.string();
              break;
            case 7:
              message.counterpartyUpgradeSequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgTimeoutOnClose();
        if ((0, helpers_1.isSet)(object.packet))
          obj.packet = channel_1.Packet.fromJSON(object.packet);
        if ((0, helpers_1.isSet)(object.proofUnreceived))
          obj.proofUnreceived = (0, helpers_1.bytesFromBase64)(object.proofUnreceived);
        if ((0, helpers_1.isSet)(object.proofClose))
          obj.proofClose = (0, helpers_1.bytesFromBase64)(object.proofClose);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.nextSequenceRecv))
          obj.nextSequenceRecv = BigInt(object.nextSequenceRecv.toString());
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        if ((0, helpers_1.isSet)(object.counterpartyUpgradeSequence))
          obj.counterpartyUpgradeSequence = BigInt(object.counterpartyUpgradeSequence.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.packet !== void 0 && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : void 0);
        message.proofUnreceived !== void 0 && (obj.proofUnreceived = (0, helpers_1.base64FromBytes)(message.proofUnreceived !== void 0 ? message.proofUnreceived : new Uint8Array()));
        message.proofClose !== void 0 && (obj.proofClose = (0, helpers_1.base64FromBytes)(message.proofClose !== void 0 ? message.proofClose : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.nextSequenceRecv !== void 0 && (obj.nextSequenceRecv = (message.nextSequenceRecv || BigInt(0)).toString());
        message.signer !== void 0 && (obj.signer = message.signer);
        message.counterpartyUpgradeSequence !== void 0 && (obj.counterpartyUpgradeSequence = (message.counterpartyUpgradeSequence || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgTimeoutOnClose();
        if (object.packet !== void 0 && object.packet !== null) {
          message.packet = channel_1.Packet.fromPartial(object.packet);
        }
        message.proofUnreceived = object.proofUnreceived ?? new Uint8Array();
        message.proofClose = object.proofClose ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        if (object.nextSequenceRecv !== void 0 && object.nextSequenceRecv !== null) {
          message.nextSequenceRecv = BigInt(object.nextSequenceRecv.toString());
        }
        message.signer = object.signer ?? "";
        if (object.counterpartyUpgradeSequence !== void 0 && object.counterpartyUpgradeSequence !== null) {
          message.counterpartyUpgradeSequence = BigInt(object.counterpartyUpgradeSequence.toString());
        }
        return message;
      }
    };
    function createBaseMsgTimeoutOnCloseResponse() {
      return {
        result: 0
      };
    }
    exports.MsgTimeoutOnCloseResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgTimeoutOnCloseResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== 0) {
          writer.uint32(8).int32(message.result);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgTimeoutOnCloseResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.result = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgTimeoutOnCloseResponse();
        if ((0, helpers_1.isSet)(object.result))
          obj.result = responseResultTypeFromJSON(object.result);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = responseResultTypeToJSON(message.result));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgTimeoutOnCloseResponse();
        message.result = object.result ?? 0;
        return message;
      }
    };
    function createBaseMsgAcknowledgement() {
      return {
        packet: channel_1.Packet.fromPartial({}),
        acknowledgement: new Uint8Array(),
        proofAcked: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
      };
    }
    exports.MsgAcknowledgement = {
      typeUrl: "/ibc.core.channel.v1.MsgAcknowledgement",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.packet !== void 0) {
          channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();
        }
        if (message.acknowledgement.length !== 0) {
          writer.uint32(18).bytes(message.acknowledgement);
        }
        if (message.proofAcked.length !== 0) {
          writer.uint32(26).bytes(message.proofAcked);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(42).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgAcknowledgement();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.packet = channel_1.Packet.decode(reader, reader.uint32());
              break;
            case 2:
              message.acknowledgement = reader.bytes();
              break;
            case 3:
              message.proofAcked = reader.bytes();
              break;
            case 4:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 5:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgAcknowledgement();
        if ((0, helpers_1.isSet)(object.packet))
          obj.packet = channel_1.Packet.fromJSON(object.packet);
        if ((0, helpers_1.isSet)(object.acknowledgement))
          obj.acknowledgement = (0, helpers_1.bytesFromBase64)(object.acknowledgement);
        if ((0, helpers_1.isSet)(object.proofAcked))
          obj.proofAcked = (0, helpers_1.bytesFromBase64)(object.proofAcked);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.packet !== void 0 && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : void 0);
        message.acknowledgement !== void 0 && (obj.acknowledgement = (0, helpers_1.base64FromBytes)(message.acknowledgement !== void 0 ? message.acknowledgement : new Uint8Array()));
        message.proofAcked !== void 0 && (obj.proofAcked = (0, helpers_1.base64FromBytes)(message.proofAcked !== void 0 ? message.proofAcked : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgAcknowledgement();
        if (object.packet !== void 0 && object.packet !== null) {
          message.packet = channel_1.Packet.fromPartial(object.packet);
        }
        message.acknowledgement = object.acknowledgement ?? new Uint8Array();
        message.proofAcked = object.proofAcked ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgAcknowledgementResponse() {
      return {
        result: 0
      };
    }
    exports.MsgAcknowledgementResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgAcknowledgementResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== 0) {
          writer.uint32(8).int32(message.result);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgAcknowledgementResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.result = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgAcknowledgementResponse();
        if ((0, helpers_1.isSet)(object.result))
          obj.result = responseResultTypeFromJSON(object.result);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = responseResultTypeToJSON(message.result));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgAcknowledgementResponse();
        message.result = object.result ?? 0;
        return message;
      }
    };
    function createBaseMsgChannelUpgradeInit() {
      return {
        portId: "",
        channelId: "",
        fields: upgrade_1.UpgradeFields.fromPartial({}),
        signer: ""
      };
    }
    exports.MsgChannelUpgradeInit = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeInit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.fields !== void 0) {
          upgrade_1.UpgradeFields.encode(message.fields, writer.uint32(26).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(34).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeInit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.fields = upgrade_1.UpgradeFields.decode(reader, reader.uint32());
              break;
            case 4:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelUpgradeInit();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.fields))
          obj.fields = upgrade_1.UpgradeFields.fromJSON(object.fields);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.fields !== void 0 && (obj.fields = message.fields ? upgrade_1.UpgradeFields.toJSON(message.fields) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelUpgradeInit();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.fields !== void 0 && object.fields !== null) {
          message.fields = upgrade_1.UpgradeFields.fromPartial(object.fields);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgChannelUpgradeInitResponse() {
      return {
        upgrade: upgrade_1.Upgrade.fromPartial({}),
        upgradeSequence: BigInt(0)
      };
    }
    exports.MsgChannelUpgradeInitResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeInitResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.upgrade !== void 0) {
          upgrade_1.Upgrade.encode(message.upgrade, writer.uint32(10).fork()).ldelim();
        }
        if (message.upgradeSequence !== BigInt(0)) {
          writer.uint32(16).uint64(message.upgradeSequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeInitResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.upgrade = upgrade_1.Upgrade.decode(reader, reader.uint32());
              break;
            case 2:
              message.upgradeSequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelUpgradeInitResponse();
        if ((0, helpers_1.isSet)(object.upgrade))
          obj.upgrade = upgrade_1.Upgrade.fromJSON(object.upgrade);
        if ((0, helpers_1.isSet)(object.upgradeSequence))
          obj.upgradeSequence = BigInt(object.upgradeSequence.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.upgrade !== void 0 && (obj.upgrade = message.upgrade ? upgrade_1.Upgrade.toJSON(message.upgrade) : void 0);
        message.upgradeSequence !== void 0 && (obj.upgradeSequence = (message.upgradeSequence || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelUpgradeInitResponse();
        if (object.upgrade !== void 0 && object.upgrade !== null) {
          message.upgrade = upgrade_1.Upgrade.fromPartial(object.upgrade);
        }
        if (object.upgradeSequence !== void 0 && object.upgradeSequence !== null) {
          message.upgradeSequence = BigInt(object.upgradeSequence.toString());
        }
        return message;
      }
    };
    function createBaseMsgChannelUpgradeTry() {
      return {
        portId: "",
        channelId: "",
        proposedUpgradeConnectionHops: [],
        counterpartyUpgradeFields: upgrade_1.UpgradeFields.fromPartial({}),
        counterpartyUpgradeSequence: BigInt(0),
        proofChannel: new Uint8Array(),
        proofUpgrade: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
      };
    }
    exports.MsgChannelUpgradeTry = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeTry",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        for (const v9 of message.proposedUpgradeConnectionHops) {
          writer.uint32(26).string(v9);
        }
        if (message.counterpartyUpgradeFields !== void 0) {
          upgrade_1.UpgradeFields.encode(message.counterpartyUpgradeFields, writer.uint32(34).fork()).ldelim();
        }
        if (message.counterpartyUpgradeSequence !== BigInt(0)) {
          writer.uint32(40).uint64(message.counterpartyUpgradeSequence);
        }
        if (message.proofChannel.length !== 0) {
          writer.uint32(50).bytes(message.proofChannel);
        }
        if (message.proofUpgrade.length !== 0) {
          writer.uint32(58).bytes(message.proofUpgrade);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(66).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(74).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeTry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.proposedUpgradeConnectionHops.push(reader.string());
              break;
            case 4:
              message.counterpartyUpgradeFields = upgrade_1.UpgradeFields.decode(reader, reader.uint32());
              break;
            case 5:
              message.counterpartyUpgradeSequence = reader.uint64();
              break;
            case 6:
              message.proofChannel = reader.bytes();
              break;
            case 7:
              message.proofUpgrade = reader.bytes();
              break;
            case 8:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 9:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelUpgradeTry();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if (Array.isArray(object?.proposedUpgradeConnectionHops))
          obj.proposedUpgradeConnectionHops = object.proposedUpgradeConnectionHops.map((e) => String(e));
        if ((0, helpers_1.isSet)(object.counterpartyUpgradeFields))
          obj.counterpartyUpgradeFields = upgrade_1.UpgradeFields.fromJSON(object.counterpartyUpgradeFields);
        if ((0, helpers_1.isSet)(object.counterpartyUpgradeSequence))
          obj.counterpartyUpgradeSequence = BigInt(object.counterpartyUpgradeSequence.toString());
        if ((0, helpers_1.isSet)(object.proofChannel))
          obj.proofChannel = (0, helpers_1.bytesFromBase64)(object.proofChannel);
        if ((0, helpers_1.isSet)(object.proofUpgrade))
          obj.proofUpgrade = (0, helpers_1.bytesFromBase64)(object.proofUpgrade);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        if (message.proposedUpgradeConnectionHops) {
          obj.proposedUpgradeConnectionHops = message.proposedUpgradeConnectionHops.map((e) => e);
        } else {
          obj.proposedUpgradeConnectionHops = [];
        }
        message.counterpartyUpgradeFields !== void 0 && (obj.counterpartyUpgradeFields = message.counterpartyUpgradeFields ? upgrade_1.UpgradeFields.toJSON(message.counterpartyUpgradeFields) : void 0);
        message.counterpartyUpgradeSequence !== void 0 && (obj.counterpartyUpgradeSequence = (message.counterpartyUpgradeSequence || BigInt(0)).toString());
        message.proofChannel !== void 0 && (obj.proofChannel = (0, helpers_1.base64FromBytes)(message.proofChannel !== void 0 ? message.proofChannel : new Uint8Array()));
        message.proofUpgrade !== void 0 && (obj.proofUpgrade = (0, helpers_1.base64FromBytes)(message.proofUpgrade !== void 0 ? message.proofUpgrade : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelUpgradeTry();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        message.proposedUpgradeConnectionHops = object.proposedUpgradeConnectionHops?.map((e) => e) || [];
        if (object.counterpartyUpgradeFields !== void 0 && object.counterpartyUpgradeFields !== null) {
          message.counterpartyUpgradeFields = upgrade_1.UpgradeFields.fromPartial(object.counterpartyUpgradeFields);
        }
        if (object.counterpartyUpgradeSequence !== void 0 && object.counterpartyUpgradeSequence !== null) {
          message.counterpartyUpgradeSequence = BigInt(object.counterpartyUpgradeSequence.toString());
        }
        message.proofChannel = object.proofChannel ?? new Uint8Array();
        message.proofUpgrade = object.proofUpgrade ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgChannelUpgradeTryResponse() {
      return {
        upgrade: upgrade_1.Upgrade.fromPartial({}),
        upgradeSequence: BigInt(0),
        result: 0
      };
    }
    exports.MsgChannelUpgradeTryResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeTryResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.upgrade !== void 0) {
          upgrade_1.Upgrade.encode(message.upgrade, writer.uint32(10).fork()).ldelim();
        }
        if (message.upgradeSequence !== BigInt(0)) {
          writer.uint32(16).uint64(message.upgradeSequence);
        }
        if (message.result !== 0) {
          writer.uint32(24).int32(message.result);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeTryResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.upgrade = upgrade_1.Upgrade.decode(reader, reader.uint32());
              break;
            case 2:
              message.upgradeSequence = reader.uint64();
              break;
            case 3:
              message.result = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelUpgradeTryResponse();
        if ((0, helpers_1.isSet)(object.upgrade))
          obj.upgrade = upgrade_1.Upgrade.fromJSON(object.upgrade);
        if ((0, helpers_1.isSet)(object.upgradeSequence))
          obj.upgradeSequence = BigInt(object.upgradeSequence.toString());
        if ((0, helpers_1.isSet)(object.result))
          obj.result = responseResultTypeFromJSON(object.result);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.upgrade !== void 0 && (obj.upgrade = message.upgrade ? upgrade_1.Upgrade.toJSON(message.upgrade) : void 0);
        message.upgradeSequence !== void 0 && (obj.upgradeSequence = (message.upgradeSequence || BigInt(0)).toString());
        message.result !== void 0 && (obj.result = responseResultTypeToJSON(message.result));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelUpgradeTryResponse();
        if (object.upgrade !== void 0 && object.upgrade !== null) {
          message.upgrade = upgrade_1.Upgrade.fromPartial(object.upgrade);
        }
        if (object.upgradeSequence !== void 0 && object.upgradeSequence !== null) {
          message.upgradeSequence = BigInt(object.upgradeSequence.toString());
        }
        message.result = object.result ?? 0;
        return message;
      }
    };
    function createBaseMsgChannelUpgradeAck() {
      return {
        portId: "",
        channelId: "",
        counterpartyUpgrade: upgrade_1.Upgrade.fromPartial({}),
        proofChannel: new Uint8Array(),
        proofUpgrade: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
      };
    }
    exports.MsgChannelUpgradeAck = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeAck",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.counterpartyUpgrade !== void 0) {
          upgrade_1.Upgrade.encode(message.counterpartyUpgrade, writer.uint32(26).fork()).ldelim();
        }
        if (message.proofChannel.length !== 0) {
          writer.uint32(34).bytes(message.proofChannel);
        }
        if (message.proofUpgrade.length !== 0) {
          writer.uint32(42).bytes(message.proofUpgrade);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(50).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(58).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeAck();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.counterpartyUpgrade = upgrade_1.Upgrade.decode(reader, reader.uint32());
              break;
            case 4:
              message.proofChannel = reader.bytes();
              break;
            case 5:
              message.proofUpgrade = reader.bytes();
              break;
            case 6:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 7:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelUpgradeAck();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.counterpartyUpgrade))
          obj.counterpartyUpgrade = upgrade_1.Upgrade.fromJSON(object.counterpartyUpgrade);
        if ((0, helpers_1.isSet)(object.proofChannel))
          obj.proofChannel = (0, helpers_1.bytesFromBase64)(object.proofChannel);
        if ((0, helpers_1.isSet)(object.proofUpgrade))
          obj.proofUpgrade = (0, helpers_1.bytesFromBase64)(object.proofUpgrade);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.counterpartyUpgrade !== void 0 && (obj.counterpartyUpgrade = message.counterpartyUpgrade ? upgrade_1.Upgrade.toJSON(message.counterpartyUpgrade) : void 0);
        message.proofChannel !== void 0 && (obj.proofChannel = (0, helpers_1.base64FromBytes)(message.proofChannel !== void 0 ? message.proofChannel : new Uint8Array()));
        message.proofUpgrade !== void 0 && (obj.proofUpgrade = (0, helpers_1.base64FromBytes)(message.proofUpgrade !== void 0 ? message.proofUpgrade : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelUpgradeAck();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.counterpartyUpgrade !== void 0 && object.counterpartyUpgrade !== null) {
          message.counterpartyUpgrade = upgrade_1.Upgrade.fromPartial(object.counterpartyUpgrade);
        }
        message.proofChannel = object.proofChannel ?? new Uint8Array();
        message.proofUpgrade = object.proofUpgrade ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgChannelUpgradeAckResponse() {
      return {
        result: 0
      };
    }
    exports.MsgChannelUpgradeAckResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeAckResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== 0) {
          writer.uint32(8).int32(message.result);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeAckResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.result = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelUpgradeAckResponse();
        if ((0, helpers_1.isSet)(object.result))
          obj.result = responseResultTypeFromJSON(object.result);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = responseResultTypeToJSON(message.result));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelUpgradeAckResponse();
        message.result = object.result ?? 0;
        return message;
      }
    };
    function createBaseMsgChannelUpgradeConfirm() {
      return {
        portId: "",
        channelId: "",
        counterpartyChannelState: 0,
        counterpartyUpgrade: upgrade_1.Upgrade.fromPartial({}),
        proofChannel: new Uint8Array(),
        proofUpgrade: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
      };
    }
    exports.MsgChannelUpgradeConfirm = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeConfirm",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.counterpartyChannelState !== 0) {
          writer.uint32(24).int32(message.counterpartyChannelState);
        }
        if (message.counterpartyUpgrade !== void 0) {
          upgrade_1.Upgrade.encode(message.counterpartyUpgrade, writer.uint32(34).fork()).ldelim();
        }
        if (message.proofChannel.length !== 0) {
          writer.uint32(42).bytes(message.proofChannel);
        }
        if (message.proofUpgrade.length !== 0) {
          writer.uint32(50).bytes(message.proofUpgrade);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(58).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(66).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeConfirm();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.counterpartyChannelState = reader.int32();
              break;
            case 4:
              message.counterpartyUpgrade = upgrade_1.Upgrade.decode(reader, reader.uint32());
              break;
            case 5:
              message.proofChannel = reader.bytes();
              break;
            case 6:
              message.proofUpgrade = reader.bytes();
              break;
            case 7:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 8:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelUpgradeConfirm();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.counterpartyChannelState))
          obj.counterpartyChannelState = (0, channel_1.stateFromJSON)(object.counterpartyChannelState);
        if ((0, helpers_1.isSet)(object.counterpartyUpgrade))
          obj.counterpartyUpgrade = upgrade_1.Upgrade.fromJSON(object.counterpartyUpgrade);
        if ((0, helpers_1.isSet)(object.proofChannel))
          obj.proofChannel = (0, helpers_1.bytesFromBase64)(object.proofChannel);
        if ((0, helpers_1.isSet)(object.proofUpgrade))
          obj.proofUpgrade = (0, helpers_1.bytesFromBase64)(object.proofUpgrade);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.counterpartyChannelState !== void 0 && (obj.counterpartyChannelState = (0, channel_1.stateToJSON)(message.counterpartyChannelState));
        message.counterpartyUpgrade !== void 0 && (obj.counterpartyUpgrade = message.counterpartyUpgrade ? upgrade_1.Upgrade.toJSON(message.counterpartyUpgrade) : void 0);
        message.proofChannel !== void 0 && (obj.proofChannel = (0, helpers_1.base64FromBytes)(message.proofChannel !== void 0 ? message.proofChannel : new Uint8Array()));
        message.proofUpgrade !== void 0 && (obj.proofUpgrade = (0, helpers_1.base64FromBytes)(message.proofUpgrade !== void 0 ? message.proofUpgrade : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelUpgradeConfirm();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        message.counterpartyChannelState = object.counterpartyChannelState ?? 0;
        if (object.counterpartyUpgrade !== void 0 && object.counterpartyUpgrade !== null) {
          message.counterpartyUpgrade = upgrade_1.Upgrade.fromPartial(object.counterpartyUpgrade);
        }
        message.proofChannel = object.proofChannel ?? new Uint8Array();
        message.proofUpgrade = object.proofUpgrade ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgChannelUpgradeConfirmResponse() {
      return {
        result: 0
      };
    }
    exports.MsgChannelUpgradeConfirmResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeConfirmResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== 0) {
          writer.uint32(8).int32(message.result);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeConfirmResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.result = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelUpgradeConfirmResponse();
        if ((0, helpers_1.isSet)(object.result))
          obj.result = responseResultTypeFromJSON(object.result);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = responseResultTypeToJSON(message.result));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelUpgradeConfirmResponse();
        message.result = object.result ?? 0;
        return message;
      }
    };
    function createBaseMsgChannelUpgradeOpen() {
      return {
        portId: "",
        channelId: "",
        counterpartyChannelState: 0,
        counterpartyUpgradeSequence: BigInt(0),
        proofChannel: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
      };
    }
    exports.MsgChannelUpgradeOpen = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeOpen",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.counterpartyChannelState !== 0) {
          writer.uint32(24).int32(message.counterpartyChannelState);
        }
        if (message.counterpartyUpgradeSequence !== BigInt(0)) {
          writer.uint32(32).uint64(message.counterpartyUpgradeSequence);
        }
        if (message.proofChannel.length !== 0) {
          writer.uint32(42).bytes(message.proofChannel);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(50).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(58).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeOpen();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.counterpartyChannelState = reader.int32();
              break;
            case 4:
              message.counterpartyUpgradeSequence = reader.uint64();
              break;
            case 5:
              message.proofChannel = reader.bytes();
              break;
            case 6:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 7:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelUpgradeOpen();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.counterpartyChannelState))
          obj.counterpartyChannelState = (0, channel_1.stateFromJSON)(object.counterpartyChannelState);
        if ((0, helpers_1.isSet)(object.counterpartyUpgradeSequence))
          obj.counterpartyUpgradeSequence = BigInt(object.counterpartyUpgradeSequence.toString());
        if ((0, helpers_1.isSet)(object.proofChannel))
          obj.proofChannel = (0, helpers_1.bytesFromBase64)(object.proofChannel);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.counterpartyChannelState !== void 0 && (obj.counterpartyChannelState = (0, channel_1.stateToJSON)(message.counterpartyChannelState));
        message.counterpartyUpgradeSequence !== void 0 && (obj.counterpartyUpgradeSequence = (message.counterpartyUpgradeSequence || BigInt(0)).toString());
        message.proofChannel !== void 0 && (obj.proofChannel = (0, helpers_1.base64FromBytes)(message.proofChannel !== void 0 ? message.proofChannel : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelUpgradeOpen();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        message.counterpartyChannelState = object.counterpartyChannelState ?? 0;
        if (object.counterpartyUpgradeSequence !== void 0 && object.counterpartyUpgradeSequence !== null) {
          message.counterpartyUpgradeSequence = BigInt(object.counterpartyUpgradeSequence.toString());
        }
        message.proofChannel = object.proofChannel ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgChannelUpgradeOpenResponse() {
      return {};
    }
    exports.MsgChannelUpgradeOpenResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeOpenResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeOpenResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgChannelUpgradeOpenResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgChannelUpgradeOpenResponse();
        return message;
      }
    };
    function createBaseMsgChannelUpgradeTimeout() {
      return {
        portId: "",
        channelId: "",
        counterpartyChannel: channel_1.Channel.fromPartial({}),
        proofChannel: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
      };
    }
    exports.MsgChannelUpgradeTimeout = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeTimeout",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.counterpartyChannel !== void 0) {
          channel_1.Channel.encode(message.counterpartyChannel, writer.uint32(26).fork()).ldelim();
        }
        if (message.proofChannel.length !== 0) {
          writer.uint32(34).bytes(message.proofChannel);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(42).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(50).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeTimeout();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.counterpartyChannel = channel_1.Channel.decode(reader, reader.uint32());
              break;
            case 4:
              message.proofChannel = reader.bytes();
              break;
            case 5:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 6:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelUpgradeTimeout();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.counterpartyChannel))
          obj.counterpartyChannel = channel_1.Channel.fromJSON(object.counterpartyChannel);
        if ((0, helpers_1.isSet)(object.proofChannel))
          obj.proofChannel = (0, helpers_1.bytesFromBase64)(object.proofChannel);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.counterpartyChannel !== void 0 && (obj.counterpartyChannel = message.counterpartyChannel ? channel_1.Channel.toJSON(message.counterpartyChannel) : void 0);
        message.proofChannel !== void 0 && (obj.proofChannel = (0, helpers_1.base64FromBytes)(message.proofChannel !== void 0 ? message.proofChannel : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelUpgradeTimeout();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.counterpartyChannel !== void 0 && object.counterpartyChannel !== null) {
          message.counterpartyChannel = channel_1.Channel.fromPartial(object.counterpartyChannel);
        }
        message.proofChannel = object.proofChannel ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgChannelUpgradeTimeoutResponse() {
      return {};
    }
    exports.MsgChannelUpgradeTimeoutResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeTimeoutResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeTimeoutResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgChannelUpgradeTimeoutResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgChannelUpgradeTimeoutResponse();
        return message;
      }
    };
    function createBaseMsgChannelUpgradeCancel() {
      return {
        portId: "",
        channelId: "",
        errorReceipt: upgrade_1.ErrorReceipt.fromPartial({}),
        proofErrorReceipt: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
      };
    }
    exports.MsgChannelUpgradeCancel = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeCancel",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.errorReceipt !== void 0) {
          upgrade_1.ErrorReceipt.encode(message.errorReceipt, writer.uint32(26).fork()).ldelim();
        }
        if (message.proofErrorReceipt.length !== 0) {
          writer.uint32(34).bytes(message.proofErrorReceipt);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(42).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(50).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeCancel();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.errorReceipt = upgrade_1.ErrorReceipt.decode(reader, reader.uint32());
              break;
            case 4:
              message.proofErrorReceipt = reader.bytes();
              break;
            case 5:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 6:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgChannelUpgradeCancel();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.errorReceipt))
          obj.errorReceipt = upgrade_1.ErrorReceipt.fromJSON(object.errorReceipt);
        if ((0, helpers_1.isSet)(object.proofErrorReceipt))
          obj.proofErrorReceipt = (0, helpers_1.bytesFromBase64)(object.proofErrorReceipt);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.errorReceipt !== void 0 && (obj.errorReceipt = message.errorReceipt ? upgrade_1.ErrorReceipt.toJSON(message.errorReceipt) : void 0);
        message.proofErrorReceipt !== void 0 && (obj.proofErrorReceipt = (0, helpers_1.base64FromBytes)(message.proofErrorReceipt !== void 0 ? message.proofErrorReceipt : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgChannelUpgradeCancel();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.errorReceipt !== void 0 && object.errorReceipt !== null) {
          message.errorReceipt = upgrade_1.ErrorReceipt.fromPartial(object.errorReceipt);
        }
        message.proofErrorReceipt = object.proofErrorReceipt ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgChannelUpgradeCancelResponse() {
      return {};
    }
    exports.MsgChannelUpgradeCancelResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgChannelUpgradeCancelResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgChannelUpgradeCancelResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgChannelUpgradeCancelResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgChannelUpgradeCancelResponse();
        return message;
      }
    };
    function createBaseMsgUpdateParams() {
      return {
        authority: "",
        params: client_1.Params.fromPartial({})
      };
    }
    exports.MsgUpdateParams = {
      typeUrl: "/ibc.core.channel.v1.MsgUpdateParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.authority !== "") {
          writer.uint32(10).string(message.authority);
        }
        if (message.params !== void 0) {
          client_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.authority = reader.string();
              break;
            case 2:
              message.params = client_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateParams();
        if ((0, helpers_1.isSet)(object.authority))
          obj.authority = String(object.authority);
        if ((0, helpers_1.isSet)(object.params))
          obj.params = client_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.authority !== void 0 && (obj.authority = message.authority);
        message.params !== void 0 && (obj.params = message.params ? client_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateParams();
        message.authority = object.authority ?? "";
        if (object.params !== void 0 && object.params !== null) {
          message.params = client_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseMsgUpdateParamsResponse() {
      return {};
    }
    exports.MsgUpdateParamsResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgUpdateParamsResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgUpdateParamsResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgUpdateParamsResponse();
        return message;
      }
    };
    function createBaseMsgPruneAcknowledgements() {
      return {
        portId: "",
        channelId: "",
        limit: BigInt(0),
        signer: ""
      };
    }
    exports.MsgPruneAcknowledgements = {
      typeUrl: "/ibc.core.channel.v1.MsgPruneAcknowledgements",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.limit !== BigInt(0)) {
          writer.uint32(24).uint64(message.limit);
        }
        if (message.signer !== "") {
          writer.uint32(34).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgPruneAcknowledgements();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.limit = reader.uint64();
              break;
            case 4:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgPruneAcknowledgements();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.limit))
          obj.limit = BigInt(object.limit.toString());
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.limit !== void 0 && (obj.limit = (message.limit || BigInt(0)).toString());
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgPruneAcknowledgements();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.limit !== void 0 && object.limit !== null) {
          message.limit = BigInt(object.limit.toString());
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgPruneAcknowledgementsResponse() {
      return {
        totalPrunedSequences: BigInt(0),
        totalRemainingSequences: BigInt(0)
      };
    }
    exports.MsgPruneAcknowledgementsResponse = {
      typeUrl: "/ibc.core.channel.v1.MsgPruneAcknowledgementsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.totalPrunedSequences !== BigInt(0)) {
          writer.uint32(8).uint64(message.totalPrunedSequences);
        }
        if (message.totalRemainingSequences !== BigInt(0)) {
          writer.uint32(16).uint64(message.totalRemainingSequences);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgPruneAcknowledgementsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.totalPrunedSequences = reader.uint64();
              break;
            case 2:
              message.totalRemainingSequences = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgPruneAcknowledgementsResponse();
        if ((0, helpers_1.isSet)(object.totalPrunedSequences))
          obj.totalPrunedSequences = BigInt(object.totalPrunedSequences.toString());
        if ((0, helpers_1.isSet)(object.totalRemainingSequences))
          obj.totalRemainingSequences = BigInt(object.totalRemainingSequences.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.totalPrunedSequences !== void 0 && (obj.totalPrunedSequences = (message.totalPrunedSequences || BigInt(0)).toString());
        message.totalRemainingSequences !== void 0 && (obj.totalRemainingSequences = (message.totalRemainingSequences || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgPruneAcknowledgementsResponse();
        if (object.totalPrunedSequences !== void 0 && object.totalPrunedSequences !== null) {
          message.totalPrunedSequences = BigInt(object.totalPrunedSequences.toString());
        }
        if (object.totalRemainingSequences !== void 0 && object.totalRemainingSequences !== null) {
          message.totalRemainingSequences = BigInt(object.totalRemainingSequences.toString());
        }
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.ChannelOpenInit = this.ChannelOpenInit.bind(this);
        this.ChannelOpenTry = this.ChannelOpenTry.bind(this);
        this.ChannelOpenAck = this.ChannelOpenAck.bind(this);
        this.ChannelOpenConfirm = this.ChannelOpenConfirm.bind(this);
        this.ChannelCloseInit = this.ChannelCloseInit.bind(this);
        this.ChannelCloseConfirm = this.ChannelCloseConfirm.bind(this);
        this.RecvPacket = this.RecvPacket.bind(this);
        this.Timeout = this.Timeout.bind(this);
        this.TimeoutOnClose = this.TimeoutOnClose.bind(this);
        this.Acknowledgement = this.Acknowledgement.bind(this);
        this.ChannelUpgradeInit = this.ChannelUpgradeInit.bind(this);
        this.ChannelUpgradeTry = this.ChannelUpgradeTry.bind(this);
        this.ChannelUpgradeAck = this.ChannelUpgradeAck.bind(this);
        this.ChannelUpgradeConfirm = this.ChannelUpgradeConfirm.bind(this);
        this.ChannelUpgradeOpen = this.ChannelUpgradeOpen.bind(this);
        this.ChannelUpgradeTimeout = this.ChannelUpgradeTimeout.bind(this);
        this.ChannelUpgradeCancel = this.ChannelUpgradeCancel.bind(this);
        this.UpdateChannelParams = this.UpdateChannelParams.bind(this);
        this.PruneAcknowledgements = this.PruneAcknowledgements.bind(this);
      }
      ChannelOpenInit(request) {
        const data2 = exports.MsgChannelOpenInit.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenInit", data2);
        return promise.then((data3) => exports.MsgChannelOpenInitResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ChannelOpenTry(request) {
        const data2 = exports.MsgChannelOpenTry.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenTry", data2);
        return promise.then((data3) => exports.MsgChannelOpenTryResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ChannelOpenAck(request) {
        const data2 = exports.MsgChannelOpenAck.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenAck", data2);
        return promise.then((data3) => exports.MsgChannelOpenAckResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ChannelOpenConfirm(request) {
        const data2 = exports.MsgChannelOpenConfirm.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelOpenConfirm", data2);
        return promise.then((data3) => exports.MsgChannelOpenConfirmResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ChannelCloseInit(request) {
        const data2 = exports.MsgChannelCloseInit.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelCloseInit", data2);
        return promise.then((data3) => exports.MsgChannelCloseInitResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ChannelCloseConfirm(request) {
        const data2 = exports.MsgChannelCloseConfirm.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelCloseConfirm", data2);
        return promise.then((data3) => exports.MsgChannelCloseConfirmResponse.decode(new binary_1.BinaryReader(data3)));
      }
      RecvPacket(request) {
        const data2 = exports.MsgRecvPacket.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "RecvPacket", data2);
        return promise.then((data3) => exports.MsgRecvPacketResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Timeout(request) {
        const data2 = exports.MsgTimeout.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "Timeout", data2);
        return promise.then((data3) => exports.MsgTimeoutResponse.decode(new binary_1.BinaryReader(data3)));
      }
      TimeoutOnClose(request) {
        const data2 = exports.MsgTimeoutOnClose.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "TimeoutOnClose", data2);
        return promise.then((data3) => exports.MsgTimeoutOnCloseResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Acknowledgement(request) {
        const data2 = exports.MsgAcknowledgement.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "Acknowledgement", data2);
        return promise.then((data3) => exports.MsgAcknowledgementResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ChannelUpgradeInit(request) {
        const data2 = exports.MsgChannelUpgradeInit.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelUpgradeInit", data2);
        return promise.then((data3) => exports.MsgChannelUpgradeInitResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ChannelUpgradeTry(request) {
        const data2 = exports.MsgChannelUpgradeTry.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelUpgradeTry", data2);
        return promise.then((data3) => exports.MsgChannelUpgradeTryResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ChannelUpgradeAck(request) {
        const data2 = exports.MsgChannelUpgradeAck.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelUpgradeAck", data2);
        return promise.then((data3) => exports.MsgChannelUpgradeAckResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ChannelUpgradeConfirm(request) {
        const data2 = exports.MsgChannelUpgradeConfirm.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelUpgradeConfirm", data2);
        return promise.then((data3) => exports.MsgChannelUpgradeConfirmResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ChannelUpgradeOpen(request) {
        const data2 = exports.MsgChannelUpgradeOpen.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelUpgradeOpen", data2);
        return promise.then((data3) => exports.MsgChannelUpgradeOpenResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ChannelUpgradeTimeout(request) {
        const data2 = exports.MsgChannelUpgradeTimeout.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelUpgradeTimeout", data2);
        return promise.then((data3) => exports.MsgChannelUpgradeTimeoutResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ChannelUpgradeCancel(request) {
        const data2 = exports.MsgChannelUpgradeCancel.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "ChannelUpgradeCancel", data2);
        return promise.then((data3) => exports.MsgChannelUpgradeCancelResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateChannelParams(request) {
        const data2 = exports.MsgUpdateParams.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "UpdateChannelParams", data2);
        return promise.then((data3) => exports.MsgUpdateParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      PruneAcknowledgements(request) {
        const data2 = exports.MsgPruneAcknowledgements.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Msg", "PruneAcknowledgements", data2);
        return promise.then((data3) => exports.MsgPruneAcknowledgementsResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.MsgClientImpl = MsgClientImpl;
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/core/client/v1/tx.js
var require_tx11 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/core/client/v1/tx.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MsgClientImpl = exports.MsgUpdateParamsResponse = exports.MsgUpdateParams = exports.MsgIBCSoftwareUpgradeResponse = exports.MsgIBCSoftwareUpgrade = exports.MsgRecoverClientResponse = exports.MsgRecoverClient = exports.MsgSubmitMisbehaviourResponse = exports.MsgSubmitMisbehaviour = exports.MsgUpgradeClientResponse = exports.MsgUpgradeClient = exports.MsgUpdateClientResponse = exports.MsgUpdateClient = exports.MsgCreateClientResponse = exports.MsgCreateClient = exports.protobufPackage = void 0;
    var any_1 = require_any();
    var upgrade_1 = require_upgrade();
    var client_1 = require_client();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "ibc.core.client.v1";
    function createBaseMsgCreateClient() {
      return {
        clientState: void 0,
        consensusState: void 0,
        signer: ""
      };
    }
    exports.MsgCreateClient = {
      typeUrl: "/ibc.core.client.v1.MsgCreateClient",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientState !== void 0) {
          any_1.Any.encode(message.clientState, writer.uint32(10).fork()).ldelim();
        }
        if (message.consensusState !== void 0) {
          any_1.Any.encode(message.consensusState, writer.uint32(18).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(26).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateClient();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.consensusState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCreateClient();
        if ((0, helpers_1.isSet)(object.clientState))
          obj.clientState = any_1.Any.fromJSON(object.clientState);
        if ((0, helpers_1.isSet)(object.consensusState))
          obj.consensusState = any_1.Any.fromJSON(object.consensusState);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientState !== void 0 && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : void 0);
        message.consensusState !== void 0 && (obj.consensusState = message.consensusState ? any_1.Any.toJSON(message.consensusState) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgCreateClient();
        if (object.clientState !== void 0 && object.clientState !== null) {
          message.clientState = any_1.Any.fromPartial(object.clientState);
        }
        if (object.consensusState !== void 0 && object.consensusState !== null) {
          message.consensusState = any_1.Any.fromPartial(object.consensusState);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgCreateClientResponse() {
      return {};
    }
    exports.MsgCreateClientResponse = {
      typeUrl: "/ibc.core.client.v1.MsgCreateClientResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateClientResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgCreateClientResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgCreateClientResponse();
        return message;
      }
    };
    function createBaseMsgUpdateClient() {
      return {
        clientId: "",
        clientMessage: void 0,
        signer: ""
      };
    }
    exports.MsgUpdateClient = {
      typeUrl: "/ibc.core.client.v1.MsgUpdateClient",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.clientMessage !== void 0) {
          any_1.Any.encode(message.clientMessage, writer.uint32(18).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(26).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateClient();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.clientMessage = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateClient();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.clientMessage))
          obj.clientMessage = any_1.Any.fromJSON(object.clientMessage);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.clientMessage !== void 0 && (obj.clientMessage = message.clientMessage ? any_1.Any.toJSON(message.clientMessage) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateClient();
        message.clientId = object.clientId ?? "";
        if (object.clientMessage !== void 0 && object.clientMessage !== null) {
          message.clientMessage = any_1.Any.fromPartial(object.clientMessage);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgUpdateClientResponse() {
      return {};
    }
    exports.MsgUpdateClientResponse = {
      typeUrl: "/ibc.core.client.v1.MsgUpdateClientResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateClientResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgUpdateClientResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgUpdateClientResponse();
        return message;
      }
    };
    function createBaseMsgUpgradeClient() {
      return {
        clientId: "",
        clientState: void 0,
        consensusState: void 0,
        proofUpgradeClient: new Uint8Array(),
        proofUpgradeConsensusState: new Uint8Array(),
        signer: ""
      };
    }
    exports.MsgUpgradeClient = {
      typeUrl: "/ibc.core.client.v1.MsgUpgradeClient",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.clientState !== void 0) {
          any_1.Any.encode(message.clientState, writer.uint32(18).fork()).ldelim();
        }
        if (message.consensusState !== void 0) {
          any_1.Any.encode(message.consensusState, writer.uint32(26).fork()).ldelim();
        }
        if (message.proofUpgradeClient.length !== 0) {
          writer.uint32(34).bytes(message.proofUpgradeClient);
        }
        if (message.proofUpgradeConsensusState.length !== 0) {
          writer.uint32(42).bytes(message.proofUpgradeConsensusState);
        }
        if (message.signer !== "") {
          writer.uint32(50).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpgradeClient();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.clientState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.consensusState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 4:
              message.proofUpgradeClient = reader.bytes();
              break;
            case 5:
              message.proofUpgradeConsensusState = reader.bytes();
              break;
            case 6:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpgradeClient();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.clientState))
          obj.clientState = any_1.Any.fromJSON(object.clientState);
        if ((0, helpers_1.isSet)(object.consensusState))
          obj.consensusState = any_1.Any.fromJSON(object.consensusState);
        if ((0, helpers_1.isSet)(object.proofUpgradeClient))
          obj.proofUpgradeClient = (0, helpers_1.bytesFromBase64)(object.proofUpgradeClient);
        if ((0, helpers_1.isSet)(object.proofUpgradeConsensusState))
          obj.proofUpgradeConsensusState = (0, helpers_1.bytesFromBase64)(object.proofUpgradeConsensusState);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.clientState !== void 0 && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : void 0);
        message.consensusState !== void 0 && (obj.consensusState = message.consensusState ? any_1.Any.toJSON(message.consensusState) : void 0);
        message.proofUpgradeClient !== void 0 && (obj.proofUpgradeClient = (0, helpers_1.base64FromBytes)(message.proofUpgradeClient !== void 0 ? message.proofUpgradeClient : new Uint8Array()));
        message.proofUpgradeConsensusState !== void 0 && (obj.proofUpgradeConsensusState = (0, helpers_1.base64FromBytes)(message.proofUpgradeConsensusState !== void 0 ? message.proofUpgradeConsensusState : new Uint8Array()));
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpgradeClient();
        message.clientId = object.clientId ?? "";
        if (object.clientState !== void 0 && object.clientState !== null) {
          message.clientState = any_1.Any.fromPartial(object.clientState);
        }
        if (object.consensusState !== void 0 && object.consensusState !== null) {
          message.consensusState = any_1.Any.fromPartial(object.consensusState);
        }
        message.proofUpgradeClient = object.proofUpgradeClient ?? new Uint8Array();
        message.proofUpgradeConsensusState = object.proofUpgradeConsensusState ?? new Uint8Array();
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgUpgradeClientResponse() {
      return {};
    }
    exports.MsgUpgradeClientResponse = {
      typeUrl: "/ibc.core.client.v1.MsgUpgradeClientResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpgradeClientResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgUpgradeClientResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgUpgradeClientResponse();
        return message;
      }
    };
    function createBaseMsgSubmitMisbehaviour() {
      return {
        clientId: "",
        misbehaviour: void 0,
        signer: ""
      };
    }
    exports.MsgSubmitMisbehaviour = {
      typeUrl: "/ibc.core.client.v1.MsgSubmitMisbehaviour",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.misbehaviour !== void 0) {
          any_1.Any.encode(message.misbehaviour, writer.uint32(18).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(26).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitMisbehaviour();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.misbehaviour = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgSubmitMisbehaviour();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.misbehaviour))
          obj.misbehaviour = any_1.Any.fromJSON(object.misbehaviour);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.misbehaviour !== void 0 && (obj.misbehaviour = message.misbehaviour ? any_1.Any.toJSON(message.misbehaviour) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgSubmitMisbehaviour();
        message.clientId = object.clientId ?? "";
        if (object.misbehaviour !== void 0 && object.misbehaviour !== null) {
          message.misbehaviour = any_1.Any.fromPartial(object.misbehaviour);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgSubmitMisbehaviourResponse() {
      return {};
    }
    exports.MsgSubmitMisbehaviourResponse = {
      typeUrl: "/ibc.core.client.v1.MsgSubmitMisbehaviourResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitMisbehaviourResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgSubmitMisbehaviourResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgSubmitMisbehaviourResponse();
        return message;
      }
    };
    function createBaseMsgRecoverClient() {
      return {
        subjectClientId: "",
        substituteClientId: "",
        signer: ""
      };
    }
    exports.MsgRecoverClient = {
      typeUrl: "/ibc.core.client.v1.MsgRecoverClient",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.subjectClientId !== "") {
          writer.uint32(10).string(message.subjectClientId);
        }
        if (message.substituteClientId !== "") {
          writer.uint32(18).string(message.substituteClientId);
        }
        if (message.signer !== "") {
          writer.uint32(26).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRecoverClient();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.subjectClientId = reader.string();
              break;
            case 2:
              message.substituteClientId = reader.string();
              break;
            case 3:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgRecoverClient();
        if ((0, helpers_1.isSet)(object.subjectClientId))
          obj.subjectClientId = String(object.subjectClientId);
        if ((0, helpers_1.isSet)(object.substituteClientId))
          obj.substituteClientId = String(object.substituteClientId);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.subjectClientId !== void 0 && (obj.subjectClientId = message.subjectClientId);
        message.substituteClientId !== void 0 && (obj.substituteClientId = message.substituteClientId);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgRecoverClient();
        message.subjectClientId = object.subjectClientId ?? "";
        message.substituteClientId = object.substituteClientId ?? "";
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgRecoverClientResponse() {
      return {};
    }
    exports.MsgRecoverClientResponse = {
      typeUrl: "/ibc.core.client.v1.MsgRecoverClientResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRecoverClientResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgRecoverClientResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgRecoverClientResponse();
        return message;
      }
    };
    function createBaseMsgIBCSoftwareUpgrade() {
      return {
        plan: upgrade_1.Plan.fromPartial({}),
        upgradedClientState: void 0,
        signer: ""
      };
    }
    exports.MsgIBCSoftwareUpgrade = {
      typeUrl: "/ibc.core.client.v1.MsgIBCSoftwareUpgrade",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.plan !== void 0) {
          upgrade_1.Plan.encode(message.plan, writer.uint32(10).fork()).ldelim();
        }
        if (message.upgradedClientState !== void 0) {
          any_1.Any.encode(message.upgradedClientState, writer.uint32(18).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(26).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgIBCSoftwareUpgrade();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.plan = upgrade_1.Plan.decode(reader, reader.uint32());
              break;
            case 2:
              message.upgradedClientState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgIBCSoftwareUpgrade();
        if ((0, helpers_1.isSet)(object.plan))
          obj.plan = upgrade_1.Plan.fromJSON(object.plan);
        if ((0, helpers_1.isSet)(object.upgradedClientState))
          obj.upgradedClientState = any_1.Any.fromJSON(object.upgradedClientState);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.plan !== void 0 && (obj.plan = message.plan ? upgrade_1.Plan.toJSON(message.plan) : void 0);
        message.upgradedClientState !== void 0 && (obj.upgradedClientState = message.upgradedClientState ? any_1.Any.toJSON(message.upgradedClientState) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgIBCSoftwareUpgrade();
        if (object.plan !== void 0 && object.plan !== null) {
          message.plan = upgrade_1.Plan.fromPartial(object.plan);
        }
        if (object.upgradedClientState !== void 0 && object.upgradedClientState !== null) {
          message.upgradedClientState = any_1.Any.fromPartial(object.upgradedClientState);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgIBCSoftwareUpgradeResponse() {
      return {};
    }
    exports.MsgIBCSoftwareUpgradeResponse = {
      typeUrl: "/ibc.core.client.v1.MsgIBCSoftwareUpgradeResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgIBCSoftwareUpgradeResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgIBCSoftwareUpgradeResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgIBCSoftwareUpgradeResponse();
        return message;
      }
    };
    function createBaseMsgUpdateParams() {
      return {
        signer: "",
        params: client_1.Params.fromPartial({})
      };
    }
    exports.MsgUpdateParams = {
      typeUrl: "/ibc.core.client.v1.MsgUpdateParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.signer !== "") {
          writer.uint32(10).string(message.signer);
        }
        if (message.params !== void 0) {
          client_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signer = reader.string();
              break;
            case 2:
              message.params = client_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateParams();
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        if ((0, helpers_1.isSet)(object.params))
          obj.params = client_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.signer !== void 0 && (obj.signer = message.signer);
        message.params !== void 0 && (obj.params = message.params ? client_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateParams();
        message.signer = object.signer ?? "";
        if (object.params !== void 0 && object.params !== null) {
          message.params = client_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseMsgUpdateParamsResponse() {
      return {};
    }
    exports.MsgUpdateParamsResponse = {
      typeUrl: "/ibc.core.client.v1.MsgUpdateParamsResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgUpdateParamsResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgUpdateParamsResponse();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.CreateClient = this.CreateClient.bind(this);
        this.UpdateClient = this.UpdateClient.bind(this);
        this.UpgradeClient = this.UpgradeClient.bind(this);
        this.SubmitMisbehaviour = this.SubmitMisbehaviour.bind(this);
        this.RecoverClient = this.RecoverClient.bind(this);
        this.IBCSoftwareUpgrade = this.IBCSoftwareUpgrade.bind(this);
        this.UpdateClientParams = this.UpdateClientParams.bind(this);
      }
      CreateClient(request) {
        const data2 = exports.MsgCreateClient.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Msg", "CreateClient", data2);
        return promise.then((data3) => exports.MsgCreateClientResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateClient(request) {
        const data2 = exports.MsgUpdateClient.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Msg", "UpdateClient", data2);
        return promise.then((data3) => exports.MsgUpdateClientResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpgradeClient(request) {
        const data2 = exports.MsgUpgradeClient.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Msg", "UpgradeClient", data2);
        return promise.then((data3) => exports.MsgUpgradeClientResponse.decode(new binary_1.BinaryReader(data3)));
      }
      SubmitMisbehaviour(request) {
        const data2 = exports.MsgSubmitMisbehaviour.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Msg", "SubmitMisbehaviour", data2);
        return promise.then((data3) => exports.MsgSubmitMisbehaviourResponse.decode(new binary_1.BinaryReader(data3)));
      }
      RecoverClient(request) {
        const data2 = exports.MsgRecoverClient.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Msg", "RecoverClient", data2);
        return promise.then((data3) => exports.MsgRecoverClientResponse.decode(new binary_1.BinaryReader(data3)));
      }
      IBCSoftwareUpgrade(request) {
        const data2 = exports.MsgIBCSoftwareUpgrade.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Msg", "IBCSoftwareUpgrade", data2);
        return promise.then((data3) => exports.MsgIBCSoftwareUpgradeResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateClientParams(request) {
        const data2 = exports.MsgUpdateParams.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Msg", "UpdateClientParams", data2);
        return promise.then((data3) => exports.MsgUpdateParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.MsgClientImpl = MsgClientImpl;
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/ics23/v1/proofs.js
var require_proofs = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/ics23/v1/proofs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CompressedNonExistenceProof = exports.CompressedExistenceProof = exports.CompressedBatchEntry = exports.CompressedBatchProof = exports.BatchEntry = exports.BatchProof = exports.InnerSpec = exports.ProofSpec = exports.InnerOp = exports.LeafOp = exports.CommitmentProof = exports.NonExistenceProof = exports.ExistenceProof = exports.lengthOpToJSON = exports.lengthOpFromJSON = exports.LengthOp = exports.hashOpToJSON = exports.hashOpFromJSON = exports.HashOp = exports.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.ics23.v1";
    var HashOp;
    (function(HashOp2) {
      HashOp2[HashOp2["NO_HASH"] = 0] = "NO_HASH";
      HashOp2[HashOp2["SHA256"] = 1] = "SHA256";
      HashOp2[HashOp2["SHA512"] = 2] = "SHA512";
      HashOp2[HashOp2["KECCAK"] = 3] = "KECCAK";
      HashOp2[HashOp2["RIPEMD160"] = 4] = "RIPEMD160";
      HashOp2[HashOp2["BITCOIN"] = 5] = "BITCOIN";
      HashOp2[HashOp2["SHA512_256"] = 6] = "SHA512_256";
      HashOp2[HashOp2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(HashOp || (exports.HashOp = HashOp = {}));
    function hashOpFromJSON(object) {
      switch (object) {
        case 0:
        case "NO_HASH":
          return HashOp.NO_HASH;
        case 1:
        case "SHA256":
          return HashOp.SHA256;
        case 2:
        case "SHA512":
          return HashOp.SHA512;
        case 3:
        case "KECCAK":
          return HashOp.KECCAK;
        case 4:
        case "RIPEMD160":
          return HashOp.RIPEMD160;
        case 5:
        case "BITCOIN":
          return HashOp.BITCOIN;
        case 6:
        case "SHA512_256":
          return HashOp.SHA512_256;
        case -1:
        case "UNRECOGNIZED":
        default:
          return HashOp.UNRECOGNIZED;
      }
    }
    exports.hashOpFromJSON = hashOpFromJSON;
    function hashOpToJSON(object) {
      switch (object) {
        case HashOp.NO_HASH:
          return "NO_HASH";
        case HashOp.SHA256:
          return "SHA256";
        case HashOp.SHA512:
          return "SHA512";
        case HashOp.KECCAK:
          return "KECCAK";
        case HashOp.RIPEMD160:
          return "RIPEMD160";
        case HashOp.BITCOIN:
          return "BITCOIN";
        case HashOp.SHA512_256:
          return "SHA512_256";
        case HashOp.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.hashOpToJSON = hashOpToJSON;
    var LengthOp;
    (function(LengthOp2) {
      LengthOp2[LengthOp2["NO_PREFIX"] = 0] = "NO_PREFIX";
      LengthOp2[LengthOp2["VAR_PROTO"] = 1] = "VAR_PROTO";
      LengthOp2[LengthOp2["VAR_RLP"] = 2] = "VAR_RLP";
      LengthOp2[LengthOp2["FIXED32_BIG"] = 3] = "FIXED32_BIG";
      LengthOp2[LengthOp2["FIXED32_LITTLE"] = 4] = "FIXED32_LITTLE";
      LengthOp2[LengthOp2["FIXED64_BIG"] = 5] = "FIXED64_BIG";
      LengthOp2[LengthOp2["FIXED64_LITTLE"] = 6] = "FIXED64_LITTLE";
      LengthOp2[LengthOp2["REQUIRE_32_BYTES"] = 7] = "REQUIRE_32_BYTES";
      LengthOp2[LengthOp2["REQUIRE_64_BYTES"] = 8] = "REQUIRE_64_BYTES";
      LengthOp2[LengthOp2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(LengthOp || (exports.LengthOp = LengthOp = {}));
    function lengthOpFromJSON(object) {
      switch (object) {
        case 0:
        case "NO_PREFIX":
          return LengthOp.NO_PREFIX;
        case 1:
        case "VAR_PROTO":
          return LengthOp.VAR_PROTO;
        case 2:
        case "VAR_RLP":
          return LengthOp.VAR_RLP;
        case 3:
        case "FIXED32_BIG":
          return LengthOp.FIXED32_BIG;
        case 4:
        case "FIXED32_LITTLE":
          return LengthOp.FIXED32_LITTLE;
        case 5:
        case "FIXED64_BIG":
          return LengthOp.FIXED64_BIG;
        case 6:
        case "FIXED64_LITTLE":
          return LengthOp.FIXED64_LITTLE;
        case 7:
        case "REQUIRE_32_BYTES":
          return LengthOp.REQUIRE_32_BYTES;
        case 8:
        case "REQUIRE_64_BYTES":
          return LengthOp.REQUIRE_64_BYTES;
        case -1:
        case "UNRECOGNIZED":
        default:
          return LengthOp.UNRECOGNIZED;
      }
    }
    exports.lengthOpFromJSON = lengthOpFromJSON;
    function lengthOpToJSON(object) {
      switch (object) {
        case LengthOp.NO_PREFIX:
          return "NO_PREFIX";
        case LengthOp.VAR_PROTO:
          return "VAR_PROTO";
        case LengthOp.VAR_RLP:
          return "VAR_RLP";
        case LengthOp.FIXED32_BIG:
          return "FIXED32_BIG";
        case LengthOp.FIXED32_LITTLE:
          return "FIXED32_LITTLE";
        case LengthOp.FIXED64_BIG:
          return "FIXED64_BIG";
        case LengthOp.FIXED64_LITTLE:
          return "FIXED64_LITTLE";
        case LengthOp.REQUIRE_32_BYTES:
          return "REQUIRE_32_BYTES";
        case LengthOp.REQUIRE_64_BYTES:
          return "REQUIRE_64_BYTES";
        case LengthOp.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.lengthOpToJSON = lengthOpToJSON;
    function createBaseExistenceProof() {
      return {
        key: new Uint8Array(),
        value: new Uint8Array(),
        leaf: void 0,
        path: []
      };
    }
    exports.ExistenceProof = {
      typeUrl: "/cosmos.ics23.v1.ExistenceProof",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        if (message.value.length !== 0) {
          writer.uint32(18).bytes(message.value);
        }
        if (message.leaf !== void 0) {
          exports.LeafOp.encode(message.leaf, writer.uint32(26).fork()).ldelim();
        }
        for (const v9 of message.path) {
          exports.InnerOp.encode(v9, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseExistenceProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            case 2:
              message.value = reader.bytes();
              break;
            case 3:
              message.leaf = exports.LeafOp.decode(reader, reader.uint32());
              break;
            case 4:
              message.path.push(exports.InnerOp.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseExistenceProof();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        if ((0, helpers_1.isSet)(object.value))
          obj.value = (0, helpers_1.bytesFromBase64)(object.value);
        if ((0, helpers_1.isSet)(object.leaf))
          obj.leaf = exports.LeafOp.fromJSON(object.leaf);
        if (Array.isArray(object?.path))
          obj.path = object.path.map((e) => exports.InnerOp.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        message.value !== void 0 && (obj.value = (0, helpers_1.base64FromBytes)(message.value !== void 0 ? message.value : new Uint8Array()));
        message.leaf !== void 0 && (obj.leaf = message.leaf ? exports.LeafOp.toJSON(message.leaf) : void 0);
        if (message.path) {
          obj.path = message.path.map((e) => e ? exports.InnerOp.toJSON(e) : void 0);
        } else {
          obj.path = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseExistenceProof();
        message.key = object.key ?? new Uint8Array();
        message.value = object.value ?? new Uint8Array();
        if (object.leaf !== void 0 && object.leaf !== null) {
          message.leaf = exports.LeafOp.fromPartial(object.leaf);
        }
        message.path = object.path?.map((e) => exports.InnerOp.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseNonExistenceProof() {
      return {
        key: new Uint8Array(),
        left: void 0,
        right: void 0
      };
    }
    exports.NonExistenceProof = {
      typeUrl: "/cosmos.ics23.v1.NonExistenceProof",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        if (message.left !== void 0) {
          exports.ExistenceProof.encode(message.left, writer.uint32(18).fork()).ldelim();
        }
        if (message.right !== void 0) {
          exports.ExistenceProof.encode(message.right, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseNonExistenceProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            case 2:
              message.left = exports.ExistenceProof.decode(reader, reader.uint32());
              break;
            case 3:
              message.right = exports.ExistenceProof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseNonExistenceProof();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        if ((0, helpers_1.isSet)(object.left))
          obj.left = exports.ExistenceProof.fromJSON(object.left);
        if ((0, helpers_1.isSet)(object.right))
          obj.right = exports.ExistenceProof.fromJSON(object.right);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        message.left !== void 0 && (obj.left = message.left ? exports.ExistenceProof.toJSON(message.left) : void 0);
        message.right !== void 0 && (obj.right = message.right ? exports.ExistenceProof.toJSON(message.right) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseNonExistenceProof();
        message.key = object.key ?? new Uint8Array();
        if (object.left !== void 0 && object.left !== null) {
          message.left = exports.ExistenceProof.fromPartial(object.left);
        }
        if (object.right !== void 0 && object.right !== null) {
          message.right = exports.ExistenceProof.fromPartial(object.right);
        }
        return message;
      }
    };
    function createBaseCommitmentProof() {
      return {
        exist: void 0,
        nonexist: void 0,
        batch: void 0,
        compressed: void 0
      };
    }
    exports.CommitmentProof = {
      typeUrl: "/cosmos.ics23.v1.CommitmentProof",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.exist !== void 0) {
          exports.ExistenceProof.encode(message.exist, writer.uint32(10).fork()).ldelim();
        }
        if (message.nonexist !== void 0) {
          exports.NonExistenceProof.encode(message.nonexist, writer.uint32(18).fork()).ldelim();
        }
        if (message.batch !== void 0) {
          exports.BatchProof.encode(message.batch, writer.uint32(26).fork()).ldelim();
        }
        if (message.compressed !== void 0) {
          exports.CompressedBatchProof.encode(message.compressed, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommitmentProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.exist = exports.ExistenceProof.decode(reader, reader.uint32());
              break;
            case 2:
              message.nonexist = exports.NonExistenceProof.decode(reader, reader.uint32());
              break;
            case 3:
              message.batch = exports.BatchProof.decode(reader, reader.uint32());
              break;
            case 4:
              message.compressed = exports.CompressedBatchProof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCommitmentProof();
        if ((0, helpers_1.isSet)(object.exist))
          obj.exist = exports.ExistenceProof.fromJSON(object.exist);
        if ((0, helpers_1.isSet)(object.nonexist))
          obj.nonexist = exports.NonExistenceProof.fromJSON(object.nonexist);
        if ((0, helpers_1.isSet)(object.batch))
          obj.batch = exports.BatchProof.fromJSON(object.batch);
        if ((0, helpers_1.isSet)(object.compressed))
          obj.compressed = exports.CompressedBatchProof.fromJSON(object.compressed);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.exist !== void 0 && (obj.exist = message.exist ? exports.ExistenceProof.toJSON(message.exist) : void 0);
        message.nonexist !== void 0 && (obj.nonexist = message.nonexist ? exports.NonExistenceProof.toJSON(message.nonexist) : void 0);
        message.batch !== void 0 && (obj.batch = message.batch ? exports.BatchProof.toJSON(message.batch) : void 0);
        message.compressed !== void 0 && (obj.compressed = message.compressed ? exports.CompressedBatchProof.toJSON(message.compressed) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCommitmentProof();
        if (object.exist !== void 0 && object.exist !== null) {
          message.exist = exports.ExistenceProof.fromPartial(object.exist);
        }
        if (object.nonexist !== void 0 && object.nonexist !== null) {
          message.nonexist = exports.NonExistenceProof.fromPartial(object.nonexist);
        }
        if (object.batch !== void 0 && object.batch !== null) {
          message.batch = exports.BatchProof.fromPartial(object.batch);
        }
        if (object.compressed !== void 0 && object.compressed !== null) {
          message.compressed = exports.CompressedBatchProof.fromPartial(object.compressed);
        }
        return message;
      }
    };
    function createBaseLeafOp() {
      return {
        hash: 0,
        prehashKey: 0,
        prehashValue: 0,
        length: 0,
        prefix: new Uint8Array()
      };
    }
    exports.LeafOp = {
      typeUrl: "/cosmos.ics23.v1.LeafOp",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.hash !== 0) {
          writer.uint32(8).int32(message.hash);
        }
        if (message.prehashKey !== 0) {
          writer.uint32(16).int32(message.prehashKey);
        }
        if (message.prehashValue !== 0) {
          writer.uint32(24).int32(message.prehashValue);
        }
        if (message.length !== 0) {
          writer.uint32(32).int32(message.length);
        }
        if (message.prefix.length !== 0) {
          writer.uint32(42).bytes(message.prefix);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLeafOp();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.int32();
              break;
            case 2:
              message.prehashKey = reader.int32();
              break;
            case 3:
              message.prehashValue = reader.int32();
              break;
            case 4:
              message.length = reader.int32();
              break;
            case 5:
              message.prefix = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseLeafOp();
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = hashOpFromJSON(object.hash);
        if ((0, helpers_1.isSet)(object.prehashKey))
          obj.prehashKey = hashOpFromJSON(object.prehashKey);
        if ((0, helpers_1.isSet)(object.prehashValue))
          obj.prehashValue = hashOpFromJSON(object.prehashValue);
        if ((0, helpers_1.isSet)(object.length))
          obj.length = lengthOpFromJSON(object.length);
        if ((0, helpers_1.isSet)(object.prefix))
          obj.prefix = (0, helpers_1.bytesFromBase64)(object.prefix);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = hashOpToJSON(message.hash));
        message.prehashKey !== void 0 && (obj.prehashKey = hashOpToJSON(message.prehashKey));
        message.prehashValue !== void 0 && (obj.prehashValue = hashOpToJSON(message.prehashValue));
        message.length !== void 0 && (obj.length = lengthOpToJSON(message.length));
        message.prefix !== void 0 && (obj.prefix = (0, helpers_1.base64FromBytes)(message.prefix !== void 0 ? message.prefix : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseLeafOp();
        message.hash = object.hash ?? 0;
        message.prehashKey = object.prehashKey ?? 0;
        message.prehashValue = object.prehashValue ?? 0;
        message.length = object.length ?? 0;
        message.prefix = object.prefix ?? new Uint8Array();
        return message;
      }
    };
    function createBaseInnerOp() {
      return {
        hash: 0,
        prefix: new Uint8Array(),
        suffix: new Uint8Array()
      };
    }
    exports.InnerOp = {
      typeUrl: "/cosmos.ics23.v1.InnerOp",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.hash !== 0) {
          writer.uint32(8).int32(message.hash);
        }
        if (message.prefix.length !== 0) {
          writer.uint32(18).bytes(message.prefix);
        }
        if (message.suffix.length !== 0) {
          writer.uint32(26).bytes(message.suffix);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseInnerOp();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.int32();
              break;
            case 2:
              message.prefix = reader.bytes();
              break;
            case 3:
              message.suffix = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseInnerOp();
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = hashOpFromJSON(object.hash);
        if ((0, helpers_1.isSet)(object.prefix))
          obj.prefix = (0, helpers_1.bytesFromBase64)(object.prefix);
        if ((0, helpers_1.isSet)(object.suffix))
          obj.suffix = (0, helpers_1.bytesFromBase64)(object.suffix);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = hashOpToJSON(message.hash));
        message.prefix !== void 0 && (obj.prefix = (0, helpers_1.base64FromBytes)(message.prefix !== void 0 ? message.prefix : new Uint8Array()));
        message.suffix !== void 0 && (obj.suffix = (0, helpers_1.base64FromBytes)(message.suffix !== void 0 ? message.suffix : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseInnerOp();
        message.hash = object.hash ?? 0;
        message.prefix = object.prefix ?? new Uint8Array();
        message.suffix = object.suffix ?? new Uint8Array();
        return message;
      }
    };
    function createBaseProofSpec() {
      return {
        leafSpec: void 0,
        innerSpec: void 0,
        maxDepth: 0,
        minDepth: 0
      };
    }
    exports.ProofSpec = {
      typeUrl: "/cosmos.ics23.v1.ProofSpec",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.leafSpec !== void 0) {
          exports.LeafOp.encode(message.leafSpec, writer.uint32(10).fork()).ldelim();
        }
        if (message.innerSpec !== void 0) {
          exports.InnerSpec.encode(message.innerSpec, writer.uint32(18).fork()).ldelim();
        }
        if (message.maxDepth !== 0) {
          writer.uint32(24).int32(message.maxDepth);
        }
        if (message.minDepth !== 0) {
          writer.uint32(32).int32(message.minDepth);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProofSpec();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.leafSpec = exports.LeafOp.decode(reader, reader.uint32());
              break;
            case 2:
              message.innerSpec = exports.InnerSpec.decode(reader, reader.uint32());
              break;
            case 3:
              message.maxDepth = reader.int32();
              break;
            case 4:
              message.minDepth = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseProofSpec();
        if ((0, helpers_1.isSet)(object.leafSpec))
          obj.leafSpec = exports.LeafOp.fromJSON(object.leafSpec);
        if ((0, helpers_1.isSet)(object.innerSpec))
          obj.innerSpec = exports.InnerSpec.fromJSON(object.innerSpec);
        if ((0, helpers_1.isSet)(object.maxDepth))
          obj.maxDepth = Number(object.maxDepth);
        if ((0, helpers_1.isSet)(object.minDepth))
          obj.minDepth = Number(object.minDepth);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.leafSpec !== void 0 && (obj.leafSpec = message.leafSpec ? exports.LeafOp.toJSON(message.leafSpec) : void 0);
        message.innerSpec !== void 0 && (obj.innerSpec = message.innerSpec ? exports.InnerSpec.toJSON(message.innerSpec) : void 0);
        message.maxDepth !== void 0 && (obj.maxDepth = Math.round(message.maxDepth));
        message.minDepth !== void 0 && (obj.minDepth = Math.round(message.minDepth));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseProofSpec();
        if (object.leafSpec !== void 0 && object.leafSpec !== null) {
          message.leafSpec = exports.LeafOp.fromPartial(object.leafSpec);
        }
        if (object.innerSpec !== void 0 && object.innerSpec !== null) {
          message.innerSpec = exports.InnerSpec.fromPartial(object.innerSpec);
        }
        message.maxDepth = object.maxDepth ?? 0;
        message.minDepth = object.minDepth ?? 0;
        return message;
      }
    };
    function createBaseInnerSpec() {
      return {
        childOrder: [],
        childSize: 0,
        minPrefixLength: 0,
        maxPrefixLength: 0,
        emptyChild: new Uint8Array(),
        hash: 0
      };
    }
    exports.InnerSpec = {
      typeUrl: "/cosmos.ics23.v1.InnerSpec",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        writer.uint32(10).fork();
        for (const v9 of message.childOrder) {
          writer.int32(v9);
        }
        writer.ldelim();
        if (message.childSize !== 0) {
          writer.uint32(16).int32(message.childSize);
        }
        if (message.minPrefixLength !== 0) {
          writer.uint32(24).int32(message.minPrefixLength);
        }
        if (message.maxPrefixLength !== 0) {
          writer.uint32(32).int32(message.maxPrefixLength);
        }
        if (message.emptyChild.length !== 0) {
          writer.uint32(42).bytes(message.emptyChild);
        }
        if (message.hash !== 0) {
          writer.uint32(48).int32(message.hash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseInnerSpec();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.childOrder.push(reader.int32());
                }
              } else {
                message.childOrder.push(reader.int32());
              }
              break;
            case 2:
              message.childSize = reader.int32();
              break;
            case 3:
              message.minPrefixLength = reader.int32();
              break;
            case 4:
              message.maxPrefixLength = reader.int32();
              break;
            case 5:
              message.emptyChild = reader.bytes();
              break;
            case 6:
              message.hash = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseInnerSpec();
        if (Array.isArray(object?.childOrder))
          obj.childOrder = object.childOrder.map((e) => Number(e));
        if ((0, helpers_1.isSet)(object.childSize))
          obj.childSize = Number(object.childSize);
        if ((0, helpers_1.isSet)(object.minPrefixLength))
          obj.minPrefixLength = Number(object.minPrefixLength);
        if ((0, helpers_1.isSet)(object.maxPrefixLength))
          obj.maxPrefixLength = Number(object.maxPrefixLength);
        if ((0, helpers_1.isSet)(object.emptyChild))
          obj.emptyChild = (0, helpers_1.bytesFromBase64)(object.emptyChild);
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = hashOpFromJSON(object.hash);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.childOrder) {
          obj.childOrder = message.childOrder.map((e) => Math.round(e));
        } else {
          obj.childOrder = [];
        }
        message.childSize !== void 0 && (obj.childSize = Math.round(message.childSize));
        message.minPrefixLength !== void 0 && (obj.minPrefixLength = Math.round(message.minPrefixLength));
        message.maxPrefixLength !== void 0 && (obj.maxPrefixLength = Math.round(message.maxPrefixLength));
        message.emptyChild !== void 0 && (obj.emptyChild = (0, helpers_1.base64FromBytes)(message.emptyChild !== void 0 ? message.emptyChild : new Uint8Array()));
        message.hash !== void 0 && (obj.hash = hashOpToJSON(message.hash));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseInnerSpec();
        message.childOrder = object.childOrder?.map((e) => e) || [];
        message.childSize = object.childSize ?? 0;
        message.minPrefixLength = object.minPrefixLength ?? 0;
        message.maxPrefixLength = object.maxPrefixLength ?? 0;
        message.emptyChild = object.emptyChild ?? new Uint8Array();
        message.hash = object.hash ?? 0;
        return message;
      }
    };
    function createBaseBatchProof() {
      return {
        entries: []
      };
    }
    exports.BatchProof = {
      typeUrl: "/cosmos.ics23.v1.BatchProof",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.entries) {
          exports.BatchEntry.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBatchProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.entries.push(exports.BatchEntry.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBatchProof();
        if (Array.isArray(object?.entries))
          obj.entries = object.entries.map((e) => exports.BatchEntry.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.entries) {
          obj.entries = message.entries.map((e) => e ? exports.BatchEntry.toJSON(e) : void 0);
        } else {
          obj.entries = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBatchProof();
        message.entries = object.entries?.map((e) => exports.BatchEntry.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseBatchEntry() {
      return {
        exist: void 0,
        nonexist: void 0
      };
    }
    exports.BatchEntry = {
      typeUrl: "/cosmos.ics23.v1.BatchEntry",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.exist !== void 0) {
          exports.ExistenceProof.encode(message.exist, writer.uint32(10).fork()).ldelim();
        }
        if (message.nonexist !== void 0) {
          exports.NonExistenceProof.encode(message.nonexist, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBatchEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.exist = exports.ExistenceProof.decode(reader, reader.uint32());
              break;
            case 2:
              message.nonexist = exports.NonExistenceProof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBatchEntry();
        if ((0, helpers_1.isSet)(object.exist))
          obj.exist = exports.ExistenceProof.fromJSON(object.exist);
        if ((0, helpers_1.isSet)(object.nonexist))
          obj.nonexist = exports.NonExistenceProof.fromJSON(object.nonexist);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.exist !== void 0 && (obj.exist = message.exist ? exports.ExistenceProof.toJSON(message.exist) : void 0);
        message.nonexist !== void 0 && (obj.nonexist = message.nonexist ? exports.NonExistenceProof.toJSON(message.nonexist) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBatchEntry();
        if (object.exist !== void 0 && object.exist !== null) {
          message.exist = exports.ExistenceProof.fromPartial(object.exist);
        }
        if (object.nonexist !== void 0 && object.nonexist !== null) {
          message.nonexist = exports.NonExistenceProof.fromPartial(object.nonexist);
        }
        return message;
      }
    };
    function createBaseCompressedBatchProof() {
      return {
        entries: [],
        lookupInners: []
      };
    }
    exports.CompressedBatchProof = {
      typeUrl: "/cosmos.ics23.v1.CompressedBatchProof",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.entries) {
          exports.CompressedBatchEntry.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        for (const v9 of message.lookupInners) {
          exports.InnerOp.encode(v9, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCompressedBatchProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.entries.push(exports.CompressedBatchEntry.decode(reader, reader.uint32()));
              break;
            case 2:
              message.lookupInners.push(exports.InnerOp.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCompressedBatchProof();
        if (Array.isArray(object?.entries))
          obj.entries = object.entries.map((e) => exports.CompressedBatchEntry.fromJSON(e));
        if (Array.isArray(object?.lookupInners))
          obj.lookupInners = object.lookupInners.map((e) => exports.InnerOp.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.entries) {
          obj.entries = message.entries.map((e) => e ? exports.CompressedBatchEntry.toJSON(e) : void 0);
        } else {
          obj.entries = [];
        }
        if (message.lookupInners) {
          obj.lookupInners = message.lookupInners.map((e) => e ? exports.InnerOp.toJSON(e) : void 0);
        } else {
          obj.lookupInners = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCompressedBatchProof();
        message.entries = object.entries?.map((e) => exports.CompressedBatchEntry.fromPartial(e)) || [];
        message.lookupInners = object.lookupInners?.map((e) => exports.InnerOp.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseCompressedBatchEntry() {
      return {
        exist: void 0,
        nonexist: void 0
      };
    }
    exports.CompressedBatchEntry = {
      typeUrl: "/cosmos.ics23.v1.CompressedBatchEntry",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.exist !== void 0) {
          exports.CompressedExistenceProof.encode(message.exist, writer.uint32(10).fork()).ldelim();
        }
        if (message.nonexist !== void 0) {
          exports.CompressedNonExistenceProof.encode(message.nonexist, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCompressedBatchEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.exist = exports.CompressedExistenceProof.decode(reader, reader.uint32());
              break;
            case 2:
              message.nonexist = exports.CompressedNonExistenceProof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCompressedBatchEntry();
        if ((0, helpers_1.isSet)(object.exist))
          obj.exist = exports.CompressedExistenceProof.fromJSON(object.exist);
        if ((0, helpers_1.isSet)(object.nonexist))
          obj.nonexist = exports.CompressedNonExistenceProof.fromJSON(object.nonexist);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.exist !== void 0 && (obj.exist = message.exist ? exports.CompressedExistenceProof.toJSON(message.exist) : void 0);
        message.nonexist !== void 0 && (obj.nonexist = message.nonexist ? exports.CompressedNonExistenceProof.toJSON(message.nonexist) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCompressedBatchEntry();
        if (object.exist !== void 0 && object.exist !== null) {
          message.exist = exports.CompressedExistenceProof.fromPartial(object.exist);
        }
        if (object.nonexist !== void 0 && object.nonexist !== null) {
          message.nonexist = exports.CompressedNonExistenceProof.fromPartial(object.nonexist);
        }
        return message;
      }
    };
    function createBaseCompressedExistenceProof() {
      return {
        key: new Uint8Array(),
        value: new Uint8Array(),
        leaf: void 0,
        path: []
      };
    }
    exports.CompressedExistenceProof = {
      typeUrl: "/cosmos.ics23.v1.CompressedExistenceProof",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        if (message.value.length !== 0) {
          writer.uint32(18).bytes(message.value);
        }
        if (message.leaf !== void 0) {
          exports.LeafOp.encode(message.leaf, writer.uint32(26).fork()).ldelim();
        }
        writer.uint32(34).fork();
        for (const v9 of message.path) {
          writer.int32(v9);
        }
        writer.ldelim();
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCompressedExistenceProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            case 2:
              message.value = reader.bytes();
              break;
            case 3:
              message.leaf = exports.LeafOp.decode(reader, reader.uint32());
              break;
            case 4:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.path.push(reader.int32());
                }
              } else {
                message.path.push(reader.int32());
              }
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCompressedExistenceProof();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        if ((0, helpers_1.isSet)(object.value))
          obj.value = (0, helpers_1.bytesFromBase64)(object.value);
        if ((0, helpers_1.isSet)(object.leaf))
          obj.leaf = exports.LeafOp.fromJSON(object.leaf);
        if (Array.isArray(object?.path))
          obj.path = object.path.map((e) => Number(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        message.value !== void 0 && (obj.value = (0, helpers_1.base64FromBytes)(message.value !== void 0 ? message.value : new Uint8Array()));
        message.leaf !== void 0 && (obj.leaf = message.leaf ? exports.LeafOp.toJSON(message.leaf) : void 0);
        if (message.path) {
          obj.path = message.path.map((e) => Math.round(e));
        } else {
          obj.path = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCompressedExistenceProof();
        message.key = object.key ?? new Uint8Array();
        message.value = object.value ?? new Uint8Array();
        if (object.leaf !== void 0 && object.leaf !== null) {
          message.leaf = exports.LeafOp.fromPartial(object.leaf);
        }
        message.path = object.path?.map((e) => e) || [];
        return message;
      }
    };
    function createBaseCompressedNonExistenceProof() {
      return {
        key: new Uint8Array(),
        left: void 0,
        right: void 0
      };
    }
    exports.CompressedNonExistenceProof = {
      typeUrl: "/cosmos.ics23.v1.CompressedNonExistenceProof",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        if (message.left !== void 0) {
          exports.CompressedExistenceProof.encode(message.left, writer.uint32(18).fork()).ldelim();
        }
        if (message.right !== void 0) {
          exports.CompressedExistenceProof.encode(message.right, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCompressedNonExistenceProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            case 2:
              message.left = exports.CompressedExistenceProof.decode(reader, reader.uint32());
              break;
            case 3:
              message.right = exports.CompressedExistenceProof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCompressedNonExistenceProof();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        if ((0, helpers_1.isSet)(object.left))
          obj.left = exports.CompressedExistenceProof.fromJSON(object.left);
        if ((0, helpers_1.isSet)(object.right))
          obj.right = exports.CompressedExistenceProof.fromJSON(object.right);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        message.left !== void 0 && (obj.left = message.left ? exports.CompressedExistenceProof.toJSON(message.left) : void 0);
        message.right !== void 0 && (obj.right = message.right ? exports.CompressedExistenceProof.toJSON(message.right) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCompressedNonExistenceProof();
        message.key = object.key ?? new Uint8Array();
        if (object.left !== void 0 && object.left !== null) {
          message.left = exports.CompressedExistenceProof.fromPartial(object.left);
        }
        if (object.right !== void 0 && object.right !== null) {
          message.right = exports.CompressedExistenceProof.fromPartial(object.right);
        }
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/core/commitment/v1/commitment.js
var require_commitment = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/core/commitment/v1/commitment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MerkleProof = exports.MerklePath = exports.MerklePrefix = exports.MerkleRoot = exports.protobufPackage = void 0;
    var proofs_1 = require_proofs();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "ibc.core.commitment.v1";
    function createBaseMerkleRoot() {
      return {
        hash: new Uint8Array()
      };
    }
    exports.MerkleRoot = {
      typeUrl: "/ibc.core.commitment.v1.MerkleRoot",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.hash.length !== 0) {
          writer.uint32(10).bytes(message.hash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMerkleRoot();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMerkleRoot();
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = (0, helpers_1.bytesFromBase64)(object.hash);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = (0, helpers_1.base64FromBytes)(message.hash !== void 0 ? message.hash : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMerkleRoot();
        message.hash = object.hash ?? new Uint8Array();
        return message;
      }
    };
    function createBaseMerklePrefix() {
      return {
        keyPrefix: new Uint8Array()
      };
    }
    exports.MerklePrefix = {
      typeUrl: "/ibc.core.commitment.v1.MerklePrefix",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.keyPrefix.length !== 0) {
          writer.uint32(10).bytes(message.keyPrefix);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMerklePrefix();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.keyPrefix = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMerklePrefix();
        if ((0, helpers_1.isSet)(object.keyPrefix))
          obj.keyPrefix = (0, helpers_1.bytesFromBase64)(object.keyPrefix);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.keyPrefix !== void 0 && (obj.keyPrefix = (0, helpers_1.base64FromBytes)(message.keyPrefix !== void 0 ? message.keyPrefix : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMerklePrefix();
        message.keyPrefix = object.keyPrefix ?? new Uint8Array();
        return message;
      }
    };
    function createBaseMerklePath() {
      return {
        keyPath: []
      };
    }
    exports.MerklePath = {
      typeUrl: "/ibc.core.commitment.v1.MerklePath",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.keyPath) {
          writer.uint32(10).string(v9);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMerklePath();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.keyPath.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMerklePath();
        if (Array.isArray(object?.keyPath))
          obj.keyPath = object.keyPath.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.keyPath) {
          obj.keyPath = message.keyPath.map((e) => e);
        } else {
          obj.keyPath = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMerklePath();
        message.keyPath = object.keyPath?.map((e) => e) || [];
        return message;
      }
    };
    function createBaseMerkleProof() {
      return {
        proofs: []
      };
    }
    exports.MerkleProof = {
      typeUrl: "/ibc.core.commitment.v1.MerkleProof",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.proofs) {
          proofs_1.CommitmentProof.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMerkleProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.proofs.push(proofs_1.CommitmentProof.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMerkleProof();
        if (Array.isArray(object?.proofs))
          obj.proofs = object.proofs.map((e) => proofs_1.CommitmentProof.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.proofs) {
          obj.proofs = message.proofs.map((e) => e ? proofs_1.CommitmentProof.toJSON(e) : void 0);
        } else {
          obj.proofs = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMerkleProof();
        message.proofs = object.proofs?.map((e) => proofs_1.CommitmentProof.fromPartial(e)) || [];
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/core/connection/v1/connection.js
var require_connection = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/core/connection/v1/connection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Params = exports.Version = exports.ConnectionPaths = exports.ClientPaths = exports.Counterparty = exports.IdentifiedConnection = exports.ConnectionEnd = exports.stateToJSON = exports.stateFromJSON = exports.State = exports.protobufPackage = void 0;
    var commitment_1 = require_commitment();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "ibc.core.connection.v1";
    var State;
    (function(State2) {
      State2[State2["STATE_UNINITIALIZED_UNSPECIFIED"] = 0] = "STATE_UNINITIALIZED_UNSPECIFIED";
      State2[State2["STATE_INIT"] = 1] = "STATE_INIT";
      State2[State2["STATE_TRYOPEN"] = 2] = "STATE_TRYOPEN";
      State2[State2["STATE_OPEN"] = 3] = "STATE_OPEN";
      State2[State2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(State || (exports.State = State = {}));
    function stateFromJSON(object) {
      switch (object) {
        case 0:
        case "STATE_UNINITIALIZED_UNSPECIFIED":
          return State.STATE_UNINITIALIZED_UNSPECIFIED;
        case 1:
        case "STATE_INIT":
          return State.STATE_INIT;
        case 2:
        case "STATE_TRYOPEN":
          return State.STATE_TRYOPEN;
        case 3:
        case "STATE_OPEN":
          return State.STATE_OPEN;
        case -1:
        case "UNRECOGNIZED":
        default:
          return State.UNRECOGNIZED;
      }
    }
    exports.stateFromJSON = stateFromJSON;
    function stateToJSON(object) {
      switch (object) {
        case State.STATE_UNINITIALIZED_UNSPECIFIED:
          return "STATE_UNINITIALIZED_UNSPECIFIED";
        case State.STATE_INIT:
          return "STATE_INIT";
        case State.STATE_TRYOPEN:
          return "STATE_TRYOPEN";
        case State.STATE_OPEN:
          return "STATE_OPEN";
        case State.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.stateToJSON = stateToJSON;
    function createBaseConnectionEnd() {
      return {
        clientId: "",
        versions: [],
        state: 0,
        counterparty: exports.Counterparty.fromPartial({}),
        delayPeriod: BigInt(0)
      };
    }
    exports.ConnectionEnd = {
      typeUrl: "/ibc.core.connection.v1.ConnectionEnd",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        for (const v9 of message.versions) {
          exports.Version.encode(v9, writer.uint32(18).fork()).ldelim();
        }
        if (message.state !== 0) {
          writer.uint32(24).int32(message.state);
        }
        if (message.counterparty !== void 0) {
          exports.Counterparty.encode(message.counterparty, writer.uint32(34).fork()).ldelim();
        }
        if (message.delayPeriod !== BigInt(0)) {
          writer.uint32(40).uint64(message.delayPeriod);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseConnectionEnd();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.versions.push(exports.Version.decode(reader, reader.uint32()));
              break;
            case 3:
              message.state = reader.int32();
              break;
            case 4:
              message.counterparty = exports.Counterparty.decode(reader, reader.uint32());
              break;
            case 5:
              message.delayPeriod = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseConnectionEnd();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if (Array.isArray(object?.versions))
          obj.versions = object.versions.map((e) => exports.Version.fromJSON(e));
        if ((0, helpers_1.isSet)(object.state))
          obj.state = stateFromJSON(object.state);
        if ((0, helpers_1.isSet)(object.counterparty))
          obj.counterparty = exports.Counterparty.fromJSON(object.counterparty);
        if ((0, helpers_1.isSet)(object.delayPeriod))
          obj.delayPeriod = BigInt(object.delayPeriod.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        if (message.versions) {
          obj.versions = message.versions.map((e) => e ? exports.Version.toJSON(e) : void 0);
        } else {
          obj.versions = [];
        }
        message.state !== void 0 && (obj.state = stateToJSON(message.state));
        message.counterparty !== void 0 && (obj.counterparty = message.counterparty ? exports.Counterparty.toJSON(message.counterparty) : void 0);
        message.delayPeriod !== void 0 && (obj.delayPeriod = (message.delayPeriod || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseConnectionEnd();
        message.clientId = object.clientId ?? "";
        message.versions = object.versions?.map((e) => exports.Version.fromPartial(e)) || [];
        message.state = object.state ?? 0;
        if (object.counterparty !== void 0 && object.counterparty !== null) {
          message.counterparty = exports.Counterparty.fromPartial(object.counterparty);
        }
        if (object.delayPeriod !== void 0 && object.delayPeriod !== null) {
          message.delayPeriod = BigInt(object.delayPeriod.toString());
        }
        return message;
      }
    };
    function createBaseIdentifiedConnection() {
      return {
        id: "",
        clientId: "",
        versions: [],
        state: 0,
        counterparty: exports.Counterparty.fromPartial({}),
        delayPeriod: BigInt(0)
      };
    }
    exports.IdentifiedConnection = {
      typeUrl: "/ibc.core.connection.v1.IdentifiedConnection",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.id !== "") {
          writer.uint32(10).string(message.id);
        }
        if (message.clientId !== "") {
          writer.uint32(18).string(message.clientId);
        }
        for (const v9 of message.versions) {
          exports.Version.encode(v9, writer.uint32(26).fork()).ldelim();
        }
        if (message.state !== 0) {
          writer.uint32(32).int32(message.state);
        }
        if (message.counterparty !== void 0) {
          exports.Counterparty.encode(message.counterparty, writer.uint32(42).fork()).ldelim();
        }
        if (message.delayPeriod !== BigInt(0)) {
          writer.uint32(48).uint64(message.delayPeriod);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseIdentifiedConnection();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.id = reader.string();
              break;
            case 2:
              message.clientId = reader.string();
              break;
            case 3:
              message.versions.push(exports.Version.decode(reader, reader.uint32()));
              break;
            case 4:
              message.state = reader.int32();
              break;
            case 5:
              message.counterparty = exports.Counterparty.decode(reader, reader.uint32());
              break;
            case 6:
              message.delayPeriod = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseIdentifiedConnection();
        if ((0, helpers_1.isSet)(object.id))
          obj.id = String(object.id);
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if (Array.isArray(object?.versions))
          obj.versions = object.versions.map((e) => exports.Version.fromJSON(e));
        if ((0, helpers_1.isSet)(object.state))
          obj.state = stateFromJSON(object.state);
        if ((0, helpers_1.isSet)(object.counterparty))
          obj.counterparty = exports.Counterparty.fromJSON(object.counterparty);
        if ((0, helpers_1.isSet)(object.delayPeriod))
          obj.delayPeriod = BigInt(object.delayPeriod.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.id !== void 0 && (obj.id = message.id);
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        if (message.versions) {
          obj.versions = message.versions.map((e) => e ? exports.Version.toJSON(e) : void 0);
        } else {
          obj.versions = [];
        }
        message.state !== void 0 && (obj.state = stateToJSON(message.state));
        message.counterparty !== void 0 && (obj.counterparty = message.counterparty ? exports.Counterparty.toJSON(message.counterparty) : void 0);
        message.delayPeriod !== void 0 && (obj.delayPeriod = (message.delayPeriod || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseIdentifiedConnection();
        message.id = object.id ?? "";
        message.clientId = object.clientId ?? "";
        message.versions = object.versions?.map((e) => exports.Version.fromPartial(e)) || [];
        message.state = object.state ?? 0;
        if (object.counterparty !== void 0 && object.counterparty !== null) {
          message.counterparty = exports.Counterparty.fromPartial(object.counterparty);
        }
        if (object.delayPeriod !== void 0 && object.delayPeriod !== null) {
          message.delayPeriod = BigInt(object.delayPeriod.toString());
        }
        return message;
      }
    };
    function createBaseCounterparty() {
      return {
        clientId: "",
        connectionId: "",
        prefix: commitment_1.MerklePrefix.fromPartial({})
      };
    }
    exports.Counterparty = {
      typeUrl: "/ibc.core.connection.v1.Counterparty",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.connectionId !== "") {
          writer.uint32(18).string(message.connectionId);
        }
        if (message.prefix !== void 0) {
          commitment_1.MerklePrefix.encode(message.prefix, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCounterparty();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.connectionId = reader.string();
              break;
            case 3:
              message.prefix = commitment_1.MerklePrefix.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCounterparty();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.connectionId))
          obj.connectionId = String(object.connectionId);
        if ((0, helpers_1.isSet)(object.prefix))
          obj.prefix = commitment_1.MerklePrefix.fromJSON(object.prefix);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.connectionId !== void 0 && (obj.connectionId = message.connectionId);
        message.prefix !== void 0 && (obj.prefix = message.prefix ? commitment_1.MerklePrefix.toJSON(message.prefix) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCounterparty();
        message.clientId = object.clientId ?? "";
        message.connectionId = object.connectionId ?? "";
        if (object.prefix !== void 0 && object.prefix !== null) {
          message.prefix = commitment_1.MerklePrefix.fromPartial(object.prefix);
        }
        return message;
      }
    };
    function createBaseClientPaths() {
      return {
        paths: []
      };
    }
    exports.ClientPaths = {
      typeUrl: "/ibc.core.connection.v1.ClientPaths",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.paths) {
          writer.uint32(10).string(v9);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseClientPaths();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.paths.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseClientPaths();
        if (Array.isArray(object?.paths))
          obj.paths = object.paths.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.paths) {
          obj.paths = message.paths.map((e) => e);
        } else {
          obj.paths = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseClientPaths();
        message.paths = object.paths?.map((e) => e) || [];
        return message;
      }
    };
    function createBaseConnectionPaths() {
      return {
        clientId: "",
        paths: []
      };
    }
    exports.ConnectionPaths = {
      typeUrl: "/ibc.core.connection.v1.ConnectionPaths",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        for (const v9 of message.paths) {
          writer.uint32(18).string(v9);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseConnectionPaths();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.paths.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseConnectionPaths();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if (Array.isArray(object?.paths))
          obj.paths = object.paths.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        if (message.paths) {
          obj.paths = message.paths.map((e) => e);
        } else {
          obj.paths = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseConnectionPaths();
        message.clientId = object.clientId ?? "";
        message.paths = object.paths?.map((e) => e) || [];
        return message;
      }
    };
    function createBaseVersion() {
      return {
        identifier: "",
        features: []
      };
    }
    exports.Version = {
      typeUrl: "/ibc.core.connection.v1.Version",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.identifier !== "") {
          writer.uint32(10).string(message.identifier);
        }
        for (const v9 of message.features) {
          writer.uint32(18).string(v9);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVersion();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.identifier = reader.string();
              break;
            case 2:
              message.features.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseVersion();
        if ((0, helpers_1.isSet)(object.identifier))
          obj.identifier = String(object.identifier);
        if (Array.isArray(object?.features))
          obj.features = object.features.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.identifier !== void 0 && (obj.identifier = message.identifier);
        if (message.features) {
          obj.features = message.features.map((e) => e);
        } else {
          obj.features = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseVersion();
        message.identifier = object.identifier ?? "";
        message.features = object.features?.map((e) => e) || [];
        return message;
      }
    };
    function createBaseParams() {
      return {
        maxExpectedTimePerBlock: BigInt(0)
      };
    }
    exports.Params = {
      typeUrl: "/ibc.core.connection.v1.Params",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.maxExpectedTimePerBlock !== BigInt(0)) {
          writer.uint32(8).uint64(message.maxExpectedTimePerBlock);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.maxExpectedTimePerBlock = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseParams();
        if ((0, helpers_1.isSet)(object.maxExpectedTimePerBlock))
          obj.maxExpectedTimePerBlock = BigInt(object.maxExpectedTimePerBlock.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.maxExpectedTimePerBlock !== void 0 && (obj.maxExpectedTimePerBlock = (message.maxExpectedTimePerBlock || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseParams();
        if (object.maxExpectedTimePerBlock !== void 0 && object.maxExpectedTimePerBlock !== null) {
          message.maxExpectedTimePerBlock = BigInt(object.maxExpectedTimePerBlock.toString());
        }
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/core/connection/v1/tx.js
var require_tx12 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/core/connection/v1/tx.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MsgClientImpl = exports.MsgUpdateParamsResponse = exports.MsgUpdateParams = exports.MsgConnectionOpenConfirmResponse = exports.MsgConnectionOpenConfirm = exports.MsgConnectionOpenAckResponse = exports.MsgConnectionOpenAck = exports.MsgConnectionOpenTryResponse = exports.MsgConnectionOpenTry = exports.MsgConnectionOpenInitResponse = exports.MsgConnectionOpenInit = exports.protobufPackage = void 0;
    var connection_1 = require_connection();
    var any_1 = require_any();
    var client_1 = require_client();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "ibc.core.connection.v1";
    function createBaseMsgConnectionOpenInit() {
      return {
        clientId: "",
        counterparty: connection_1.Counterparty.fromPartial({}),
        version: void 0,
        delayPeriod: BigInt(0),
        signer: ""
      };
    }
    exports.MsgConnectionOpenInit = {
      typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenInit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.counterparty !== void 0) {
          connection_1.Counterparty.encode(message.counterparty, writer.uint32(18).fork()).ldelim();
        }
        if (message.version !== void 0) {
          connection_1.Version.encode(message.version, writer.uint32(26).fork()).ldelim();
        }
        if (message.delayPeriod !== BigInt(0)) {
          writer.uint32(32).uint64(message.delayPeriod);
        }
        if (message.signer !== "") {
          writer.uint32(42).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenInit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.counterparty = connection_1.Counterparty.decode(reader, reader.uint32());
              break;
            case 3:
              message.version = connection_1.Version.decode(reader, reader.uint32());
              break;
            case 4:
              message.delayPeriod = reader.uint64();
              break;
            case 5:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgConnectionOpenInit();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.counterparty))
          obj.counterparty = connection_1.Counterparty.fromJSON(object.counterparty);
        if ((0, helpers_1.isSet)(object.version))
          obj.version = connection_1.Version.fromJSON(object.version);
        if ((0, helpers_1.isSet)(object.delayPeriod))
          obj.delayPeriod = BigInt(object.delayPeriod.toString());
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.counterparty !== void 0 && (obj.counterparty = message.counterparty ? connection_1.Counterparty.toJSON(message.counterparty) : void 0);
        message.version !== void 0 && (obj.version = message.version ? connection_1.Version.toJSON(message.version) : void 0);
        message.delayPeriod !== void 0 && (obj.delayPeriod = (message.delayPeriod || BigInt(0)).toString());
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgConnectionOpenInit();
        message.clientId = object.clientId ?? "";
        if (object.counterparty !== void 0 && object.counterparty !== null) {
          message.counterparty = connection_1.Counterparty.fromPartial(object.counterparty);
        }
        if (object.version !== void 0 && object.version !== null) {
          message.version = connection_1.Version.fromPartial(object.version);
        }
        if (object.delayPeriod !== void 0 && object.delayPeriod !== null) {
          message.delayPeriod = BigInt(object.delayPeriod.toString());
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgConnectionOpenInitResponse() {
      return {};
    }
    exports.MsgConnectionOpenInitResponse = {
      typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenInitResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenInitResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgConnectionOpenInitResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgConnectionOpenInitResponse();
        return message;
      }
    };
    function createBaseMsgConnectionOpenTry() {
      return {
        clientId: "",
        previousConnectionId: "",
        clientState: void 0,
        counterparty: connection_1.Counterparty.fromPartial({}),
        delayPeriod: BigInt(0),
        counterpartyVersions: [],
        proofHeight: client_1.Height.fromPartial({}),
        proofInit: new Uint8Array(),
        proofClient: new Uint8Array(),
        proofConsensus: new Uint8Array(),
        consensusHeight: client_1.Height.fromPartial({}),
        signer: "",
        hostConsensusStateProof: new Uint8Array()
      };
    }
    exports.MsgConnectionOpenTry = {
      typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenTry",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.previousConnectionId !== "") {
          writer.uint32(18).string(message.previousConnectionId);
        }
        if (message.clientState !== void 0) {
          any_1.Any.encode(message.clientState, writer.uint32(26).fork()).ldelim();
        }
        if (message.counterparty !== void 0) {
          connection_1.Counterparty.encode(message.counterparty, writer.uint32(34).fork()).ldelim();
        }
        if (message.delayPeriod !== BigInt(0)) {
          writer.uint32(40).uint64(message.delayPeriod);
        }
        for (const v9 of message.counterpartyVersions) {
          connection_1.Version.encode(v9, writer.uint32(50).fork()).ldelim();
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(58).fork()).ldelim();
        }
        if (message.proofInit.length !== 0) {
          writer.uint32(66).bytes(message.proofInit);
        }
        if (message.proofClient.length !== 0) {
          writer.uint32(74).bytes(message.proofClient);
        }
        if (message.proofConsensus.length !== 0) {
          writer.uint32(82).bytes(message.proofConsensus);
        }
        if (message.consensusHeight !== void 0) {
          client_1.Height.encode(message.consensusHeight, writer.uint32(90).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(98).string(message.signer);
        }
        if (message.hostConsensusStateProof.length !== 0) {
          writer.uint32(106).bytes(message.hostConsensusStateProof);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenTry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.previousConnectionId = reader.string();
              break;
            case 3:
              message.clientState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 4:
              message.counterparty = connection_1.Counterparty.decode(reader, reader.uint32());
              break;
            case 5:
              message.delayPeriod = reader.uint64();
              break;
            case 6:
              message.counterpartyVersions.push(connection_1.Version.decode(reader, reader.uint32()));
              break;
            case 7:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 8:
              message.proofInit = reader.bytes();
              break;
            case 9:
              message.proofClient = reader.bytes();
              break;
            case 10:
              message.proofConsensus = reader.bytes();
              break;
            case 11:
              message.consensusHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 12:
              message.signer = reader.string();
              break;
            case 13:
              message.hostConsensusStateProof = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgConnectionOpenTry();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.previousConnectionId))
          obj.previousConnectionId = String(object.previousConnectionId);
        if ((0, helpers_1.isSet)(object.clientState))
          obj.clientState = any_1.Any.fromJSON(object.clientState);
        if ((0, helpers_1.isSet)(object.counterparty))
          obj.counterparty = connection_1.Counterparty.fromJSON(object.counterparty);
        if ((0, helpers_1.isSet)(object.delayPeriod))
          obj.delayPeriod = BigInt(object.delayPeriod.toString());
        if (Array.isArray(object?.counterpartyVersions))
          obj.counterpartyVersions = object.counterpartyVersions.map((e) => connection_1.Version.fromJSON(e));
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.proofInit))
          obj.proofInit = (0, helpers_1.bytesFromBase64)(object.proofInit);
        if ((0, helpers_1.isSet)(object.proofClient))
          obj.proofClient = (0, helpers_1.bytesFromBase64)(object.proofClient);
        if ((0, helpers_1.isSet)(object.proofConsensus))
          obj.proofConsensus = (0, helpers_1.bytesFromBase64)(object.proofConsensus);
        if ((0, helpers_1.isSet)(object.consensusHeight))
          obj.consensusHeight = client_1.Height.fromJSON(object.consensusHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        if ((0, helpers_1.isSet)(object.hostConsensusStateProof))
          obj.hostConsensusStateProof = (0, helpers_1.bytesFromBase64)(object.hostConsensusStateProof);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.previousConnectionId !== void 0 && (obj.previousConnectionId = message.previousConnectionId);
        message.clientState !== void 0 && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : void 0);
        message.counterparty !== void 0 && (obj.counterparty = message.counterparty ? connection_1.Counterparty.toJSON(message.counterparty) : void 0);
        message.delayPeriod !== void 0 && (obj.delayPeriod = (message.delayPeriod || BigInt(0)).toString());
        if (message.counterpartyVersions) {
          obj.counterpartyVersions = message.counterpartyVersions.map((e) => e ? connection_1.Version.toJSON(e) : void 0);
        } else {
          obj.counterpartyVersions = [];
        }
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.proofInit !== void 0 && (obj.proofInit = (0, helpers_1.base64FromBytes)(message.proofInit !== void 0 ? message.proofInit : new Uint8Array()));
        message.proofClient !== void 0 && (obj.proofClient = (0, helpers_1.base64FromBytes)(message.proofClient !== void 0 ? message.proofClient : new Uint8Array()));
        message.proofConsensus !== void 0 && (obj.proofConsensus = (0, helpers_1.base64FromBytes)(message.proofConsensus !== void 0 ? message.proofConsensus : new Uint8Array()));
        message.consensusHeight !== void 0 && (obj.consensusHeight = message.consensusHeight ? client_1.Height.toJSON(message.consensusHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        message.hostConsensusStateProof !== void 0 && (obj.hostConsensusStateProof = (0, helpers_1.base64FromBytes)(message.hostConsensusStateProof !== void 0 ? message.hostConsensusStateProof : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgConnectionOpenTry();
        message.clientId = object.clientId ?? "";
        message.previousConnectionId = object.previousConnectionId ?? "";
        if (object.clientState !== void 0 && object.clientState !== null) {
          message.clientState = any_1.Any.fromPartial(object.clientState);
        }
        if (object.counterparty !== void 0 && object.counterparty !== null) {
          message.counterparty = connection_1.Counterparty.fromPartial(object.counterparty);
        }
        if (object.delayPeriod !== void 0 && object.delayPeriod !== null) {
          message.delayPeriod = BigInt(object.delayPeriod.toString());
        }
        message.counterpartyVersions = object.counterpartyVersions?.map((e) => connection_1.Version.fromPartial(e)) || [];
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.proofInit = object.proofInit ?? new Uint8Array();
        message.proofClient = object.proofClient ?? new Uint8Array();
        message.proofConsensus = object.proofConsensus ?? new Uint8Array();
        if (object.consensusHeight !== void 0 && object.consensusHeight !== null) {
          message.consensusHeight = client_1.Height.fromPartial(object.consensusHeight);
        }
        message.signer = object.signer ?? "";
        message.hostConsensusStateProof = object.hostConsensusStateProof ?? new Uint8Array();
        return message;
      }
    };
    function createBaseMsgConnectionOpenTryResponse() {
      return {};
    }
    exports.MsgConnectionOpenTryResponse = {
      typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenTryResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenTryResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgConnectionOpenTryResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgConnectionOpenTryResponse();
        return message;
      }
    };
    function createBaseMsgConnectionOpenAck() {
      return {
        connectionId: "",
        counterpartyConnectionId: "",
        version: void 0,
        clientState: void 0,
        proofHeight: client_1.Height.fromPartial({}),
        proofTry: new Uint8Array(),
        proofClient: new Uint8Array(),
        proofConsensus: new Uint8Array(),
        consensusHeight: client_1.Height.fromPartial({}),
        signer: "",
        hostConsensusStateProof: new Uint8Array()
      };
    }
    exports.MsgConnectionOpenAck = {
      typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenAck",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.connectionId !== "") {
          writer.uint32(10).string(message.connectionId);
        }
        if (message.counterpartyConnectionId !== "") {
          writer.uint32(18).string(message.counterpartyConnectionId);
        }
        if (message.version !== void 0) {
          connection_1.Version.encode(message.version, writer.uint32(26).fork()).ldelim();
        }
        if (message.clientState !== void 0) {
          any_1.Any.encode(message.clientState, writer.uint32(34).fork()).ldelim();
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(42).fork()).ldelim();
        }
        if (message.proofTry.length !== 0) {
          writer.uint32(50).bytes(message.proofTry);
        }
        if (message.proofClient.length !== 0) {
          writer.uint32(58).bytes(message.proofClient);
        }
        if (message.proofConsensus.length !== 0) {
          writer.uint32(66).bytes(message.proofConsensus);
        }
        if (message.consensusHeight !== void 0) {
          client_1.Height.encode(message.consensusHeight, writer.uint32(74).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(82).string(message.signer);
        }
        if (message.hostConsensusStateProof.length !== 0) {
          writer.uint32(90).bytes(message.hostConsensusStateProof);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenAck();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connectionId = reader.string();
              break;
            case 2:
              message.counterpartyConnectionId = reader.string();
              break;
            case 3:
              message.version = connection_1.Version.decode(reader, reader.uint32());
              break;
            case 4:
              message.clientState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 5:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 6:
              message.proofTry = reader.bytes();
              break;
            case 7:
              message.proofClient = reader.bytes();
              break;
            case 8:
              message.proofConsensus = reader.bytes();
              break;
            case 9:
              message.consensusHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 10:
              message.signer = reader.string();
              break;
            case 11:
              message.hostConsensusStateProof = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgConnectionOpenAck();
        if ((0, helpers_1.isSet)(object.connectionId))
          obj.connectionId = String(object.connectionId);
        if ((0, helpers_1.isSet)(object.counterpartyConnectionId))
          obj.counterpartyConnectionId = String(object.counterpartyConnectionId);
        if ((0, helpers_1.isSet)(object.version))
          obj.version = connection_1.Version.fromJSON(object.version);
        if ((0, helpers_1.isSet)(object.clientState))
          obj.clientState = any_1.Any.fromJSON(object.clientState);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.proofTry))
          obj.proofTry = (0, helpers_1.bytesFromBase64)(object.proofTry);
        if ((0, helpers_1.isSet)(object.proofClient))
          obj.proofClient = (0, helpers_1.bytesFromBase64)(object.proofClient);
        if ((0, helpers_1.isSet)(object.proofConsensus))
          obj.proofConsensus = (0, helpers_1.bytesFromBase64)(object.proofConsensus);
        if ((0, helpers_1.isSet)(object.consensusHeight))
          obj.consensusHeight = client_1.Height.fromJSON(object.consensusHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        if ((0, helpers_1.isSet)(object.hostConsensusStateProof))
          obj.hostConsensusStateProof = (0, helpers_1.bytesFromBase64)(object.hostConsensusStateProof);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.connectionId !== void 0 && (obj.connectionId = message.connectionId);
        message.counterpartyConnectionId !== void 0 && (obj.counterpartyConnectionId = message.counterpartyConnectionId);
        message.version !== void 0 && (obj.version = message.version ? connection_1.Version.toJSON(message.version) : void 0);
        message.clientState !== void 0 && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : void 0);
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.proofTry !== void 0 && (obj.proofTry = (0, helpers_1.base64FromBytes)(message.proofTry !== void 0 ? message.proofTry : new Uint8Array()));
        message.proofClient !== void 0 && (obj.proofClient = (0, helpers_1.base64FromBytes)(message.proofClient !== void 0 ? message.proofClient : new Uint8Array()));
        message.proofConsensus !== void 0 && (obj.proofConsensus = (0, helpers_1.base64FromBytes)(message.proofConsensus !== void 0 ? message.proofConsensus : new Uint8Array()));
        message.consensusHeight !== void 0 && (obj.consensusHeight = message.consensusHeight ? client_1.Height.toJSON(message.consensusHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        message.hostConsensusStateProof !== void 0 && (obj.hostConsensusStateProof = (0, helpers_1.base64FromBytes)(message.hostConsensusStateProof !== void 0 ? message.hostConsensusStateProof : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgConnectionOpenAck();
        message.connectionId = object.connectionId ?? "";
        message.counterpartyConnectionId = object.counterpartyConnectionId ?? "";
        if (object.version !== void 0 && object.version !== null) {
          message.version = connection_1.Version.fromPartial(object.version);
        }
        if (object.clientState !== void 0 && object.clientState !== null) {
          message.clientState = any_1.Any.fromPartial(object.clientState);
        }
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.proofTry = object.proofTry ?? new Uint8Array();
        message.proofClient = object.proofClient ?? new Uint8Array();
        message.proofConsensus = object.proofConsensus ?? new Uint8Array();
        if (object.consensusHeight !== void 0 && object.consensusHeight !== null) {
          message.consensusHeight = client_1.Height.fromPartial(object.consensusHeight);
        }
        message.signer = object.signer ?? "";
        message.hostConsensusStateProof = object.hostConsensusStateProof ?? new Uint8Array();
        return message;
      }
    };
    function createBaseMsgConnectionOpenAckResponse() {
      return {};
    }
    exports.MsgConnectionOpenAckResponse = {
      typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenAckResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenAckResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgConnectionOpenAckResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgConnectionOpenAckResponse();
        return message;
      }
    };
    function createBaseMsgConnectionOpenConfirm() {
      return {
        connectionId: "",
        proofAck: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        signer: ""
      };
    }
    exports.MsgConnectionOpenConfirm = {
      typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenConfirm",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.connectionId !== "") {
          writer.uint32(10).string(message.connectionId);
        }
        if (message.proofAck.length !== 0) {
          writer.uint32(18).bytes(message.proofAck);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        if (message.signer !== "") {
          writer.uint32(34).string(message.signer);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenConfirm();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connectionId = reader.string();
              break;
            case 2:
              message.proofAck = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 4:
              message.signer = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgConnectionOpenConfirm();
        if ((0, helpers_1.isSet)(object.connectionId))
          obj.connectionId = String(object.connectionId);
        if ((0, helpers_1.isSet)(object.proofAck))
          obj.proofAck = (0, helpers_1.bytesFromBase64)(object.proofAck);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.connectionId !== void 0 && (obj.connectionId = message.connectionId);
        message.proofAck !== void 0 && (obj.proofAck = (0, helpers_1.base64FromBytes)(message.proofAck !== void 0 ? message.proofAck : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.signer !== void 0 && (obj.signer = message.signer);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgConnectionOpenConfirm();
        message.connectionId = object.connectionId ?? "";
        message.proofAck = object.proofAck ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        message.signer = object.signer ?? "";
        return message;
      }
    };
    function createBaseMsgConnectionOpenConfirmResponse() {
      return {};
    }
    exports.MsgConnectionOpenConfirmResponse = {
      typeUrl: "/ibc.core.connection.v1.MsgConnectionOpenConfirmResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgConnectionOpenConfirmResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgConnectionOpenConfirmResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgConnectionOpenConfirmResponse();
        return message;
      }
    };
    function createBaseMsgUpdateParams() {
      return {
        signer: "",
        params: client_1.Params.fromPartial({})
      };
    }
    exports.MsgUpdateParams = {
      typeUrl: "/ibc.core.connection.v1.MsgUpdateParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.signer !== "") {
          writer.uint32(10).string(message.signer);
        }
        if (message.params !== void 0) {
          client_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signer = reader.string();
              break;
            case 2:
              message.params = client_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateParams();
        if ((0, helpers_1.isSet)(object.signer))
          obj.signer = String(object.signer);
        if ((0, helpers_1.isSet)(object.params))
          obj.params = client_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.signer !== void 0 && (obj.signer = message.signer);
        message.params !== void 0 && (obj.params = message.params ? client_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateParams();
        message.signer = object.signer ?? "";
        if (object.params !== void 0 && object.params !== null) {
          message.params = client_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseMsgUpdateParamsResponse() {
      return {};
    }
    exports.MsgUpdateParamsResponse = {
      typeUrl: "/ibc.core.connection.v1.MsgUpdateParamsResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgUpdateParamsResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgUpdateParamsResponse();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.ConnectionOpenInit = this.ConnectionOpenInit.bind(this);
        this.ConnectionOpenTry = this.ConnectionOpenTry.bind(this);
        this.ConnectionOpenAck = this.ConnectionOpenAck.bind(this);
        this.ConnectionOpenConfirm = this.ConnectionOpenConfirm.bind(this);
        this.UpdateConnectionParams = this.UpdateConnectionParams.bind(this);
      }
      ConnectionOpenInit(request) {
        const data2 = exports.MsgConnectionOpenInit.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenInit", data2);
        return promise.then((data3) => exports.MsgConnectionOpenInitResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ConnectionOpenTry(request) {
        const data2 = exports.MsgConnectionOpenTry.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenTry", data2);
        return promise.then((data3) => exports.MsgConnectionOpenTryResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ConnectionOpenAck(request) {
        const data2 = exports.MsgConnectionOpenAck.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenAck", data2);
        return promise.then((data3) => exports.MsgConnectionOpenAckResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ConnectionOpenConfirm(request) {
        const data2 = exports.MsgConnectionOpenConfirm.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Msg", "ConnectionOpenConfirm", data2);
        return promise.then((data3) => exports.MsgConnectionOpenConfirmResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateConnectionParams(request) {
        const data2 = exports.MsgUpdateParams.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Msg", "UpdateConnectionParams", data2);
        return promise.then((data3) => exports.MsgUpdateParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.MsgClientImpl = MsgClientImpl;
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/ibc/messages.js
var require_messages7 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/ibc/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ibcTypes = void 0;
    exports.isMsgTransferEncodeObject = isMsgTransferEncodeObject;
    var tx_1 = require_tx9();
    var tx_2 = require_tx10();
    var tx_3 = require_tx11();
    var tx_4 = require_tx12();
    exports.ibcTypes = [
      ["/ibc.applications.transfer.v1.MsgTransfer", tx_1.MsgTransfer],
      ["/ibc.core.channel.v1.MsgAcknowledgement", tx_2.MsgAcknowledgement],
      ["/ibc.core.channel.v1.MsgChannelCloseConfirm", tx_2.MsgChannelCloseConfirm],
      ["/ibc.core.channel.v1.MsgChannelCloseInit", tx_2.MsgChannelCloseInit],
      ["/ibc.core.channel.v1.MsgChannelOpenAck", tx_2.MsgChannelOpenAck],
      ["/ibc.core.channel.v1.MsgChannelOpenConfirm", tx_2.MsgChannelOpenConfirm],
      ["/ibc.core.channel.v1.MsgChannelOpenInit", tx_2.MsgChannelOpenInit],
      ["/ibc.core.channel.v1.MsgChannelOpenTry", tx_2.MsgChannelOpenTry],
      ["/ibc.core.channel.v1.MsgRecvPacket", tx_2.MsgRecvPacket],
      ["/ibc.core.channel.v1.MsgTimeout", tx_2.MsgTimeout],
      ["/ibc.core.channel.v1.MsgTimeoutOnClose", tx_2.MsgTimeoutOnClose],
      ["/ibc.core.client.v1.MsgCreateClient", tx_3.MsgCreateClient],
      ["/ibc.core.client.v1.MsgSubmitMisbehaviour", tx_3.MsgSubmitMisbehaviour],
      ["/ibc.core.client.v1.MsgUpdateClient", tx_3.MsgUpdateClient],
      ["/ibc.core.client.v1.MsgUpgradeClient", tx_3.MsgUpgradeClient],
      ["/ibc.core.connection.v1.MsgConnectionOpenAck", tx_4.MsgConnectionOpenAck],
      ["/ibc.core.connection.v1.MsgConnectionOpenConfirm", tx_4.MsgConnectionOpenConfirm],
      ["/ibc.core.connection.v1.MsgConnectionOpenInit", tx_4.MsgConnectionOpenInit],
      ["/ibc.core.connection.v1.MsgConnectionOpenTry", tx_4.MsgConnectionOpenTry]
    ];
    function isMsgTransferEncodeObject(object) {
      return object.typeUrl === "/ibc.applications.transfer.v1.MsgTransfer";
    }
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/applications/transfer/v1/transfer.js
var require_transfer = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/applications/transfer/v1/transfer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Params = exports.DenomTrace = exports.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "ibc.applications.transfer.v1";
    function createBaseDenomTrace() {
      return {
        path: "",
        baseDenom: ""
      };
    }
    exports.DenomTrace = {
      typeUrl: "/ibc.applications.transfer.v1.DenomTrace",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.path !== "") {
          writer.uint32(10).string(message.path);
        }
        if (message.baseDenom !== "") {
          writer.uint32(18).string(message.baseDenom);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDenomTrace();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.path = reader.string();
              break;
            case 2:
              message.baseDenom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDenomTrace();
        if ((0, helpers_1.isSet)(object.path))
          obj.path = String(object.path);
        if ((0, helpers_1.isSet)(object.baseDenom))
          obj.baseDenom = String(object.baseDenom);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.path !== void 0 && (obj.path = message.path);
        message.baseDenom !== void 0 && (obj.baseDenom = message.baseDenom);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDenomTrace();
        message.path = object.path ?? "";
        message.baseDenom = object.baseDenom ?? "";
        return message;
      }
    };
    function createBaseParams() {
      return {
        sendEnabled: false,
        receiveEnabled: false
      };
    }
    exports.Params = {
      typeUrl: "/ibc.applications.transfer.v1.Params",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.sendEnabled === true) {
          writer.uint32(8).bool(message.sendEnabled);
        }
        if (message.receiveEnabled === true) {
          writer.uint32(16).bool(message.receiveEnabled);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sendEnabled = reader.bool();
              break;
            case 2:
              message.receiveEnabled = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseParams();
        if ((0, helpers_1.isSet)(object.sendEnabled))
          obj.sendEnabled = Boolean(object.sendEnabled);
        if ((0, helpers_1.isSet)(object.receiveEnabled))
          obj.receiveEnabled = Boolean(object.receiveEnabled);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.sendEnabled !== void 0 && (obj.sendEnabled = message.sendEnabled);
        message.receiveEnabled !== void 0 && (obj.receiveEnabled = message.receiveEnabled);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseParams();
        message.sendEnabled = object.sendEnabled ?? false;
        message.receiveEnabled = object.receiveEnabled ?? false;
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/applications/transfer/v1/query.js
var require_query7 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/applications/transfer/v1/query.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryClientImpl = exports.QueryTotalEscrowForDenomResponse = exports.QueryTotalEscrowForDenomRequest = exports.QueryEscrowAddressResponse = exports.QueryEscrowAddressRequest = exports.QueryDenomHashResponse = exports.QueryDenomHashRequest = exports.QueryParamsResponse = exports.QueryParamsRequest = exports.QueryDenomTracesResponse = exports.QueryDenomTracesRequest = exports.QueryDenomTraceResponse = exports.QueryDenomTraceRequest = exports.protobufPackage = void 0;
    var pagination_1 = require_pagination();
    var transfer_1 = require_transfer();
    var coin_1 = require_coin();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "ibc.applications.transfer.v1";
    function createBaseQueryDenomTraceRequest() {
      return {
        hash: ""
      };
    }
    exports.QueryDenomTraceRequest = {
      typeUrl: "/ibc.applications.transfer.v1.QueryDenomTraceRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.hash !== "") {
          writer.uint32(10).string(message.hash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomTraceRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomTraceRequest();
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = String(object.hash);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = message.hash);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomTraceRequest();
        message.hash = object.hash ?? "";
        return message;
      }
    };
    function createBaseQueryDenomTraceResponse() {
      return {
        denomTrace: void 0
      };
    }
    exports.QueryDenomTraceResponse = {
      typeUrl: "/ibc.applications.transfer.v1.QueryDenomTraceResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.denomTrace !== void 0) {
          transfer_1.DenomTrace.encode(message.denomTrace, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomTraceResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denomTrace = transfer_1.DenomTrace.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomTraceResponse();
        if ((0, helpers_1.isSet)(object.denomTrace))
          obj.denomTrace = transfer_1.DenomTrace.fromJSON(object.denomTrace);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.denomTrace !== void 0 && (obj.denomTrace = message.denomTrace ? transfer_1.DenomTrace.toJSON(message.denomTrace) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomTraceResponse();
        if (object.denomTrace !== void 0 && object.denomTrace !== null) {
          message.denomTrace = transfer_1.DenomTrace.fromPartial(object.denomTrace);
        }
        return message;
      }
    };
    function createBaseQueryDenomTracesRequest() {
      return {
        pagination: void 0
      };
    }
    exports.QueryDenomTracesRequest = {
      typeUrl: "/ibc.applications.transfer.v1.QueryDenomTracesRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomTracesRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomTracesRequest();
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomTracesRequest();
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDenomTracesResponse() {
      return {
        denomTraces: [],
        pagination: void 0
      };
    }
    exports.QueryDenomTracesResponse = {
      typeUrl: "/ibc.applications.transfer.v1.QueryDenomTracesResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.denomTraces) {
          transfer_1.DenomTrace.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomTracesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denomTraces.push(transfer_1.DenomTrace.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomTracesResponse();
        if (Array.isArray(object?.denomTraces))
          obj.denomTraces = object.denomTraces.map((e) => transfer_1.DenomTrace.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.denomTraces) {
          obj.denomTraces = message.denomTraces.map((e) => e ? transfer_1.DenomTrace.toJSON(e) : void 0);
        } else {
          obj.denomTraces = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomTracesResponse();
        message.denomTraces = object.denomTraces?.map((e) => transfer_1.DenomTrace.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryParamsRequest() {
      return {};
    }
    exports.QueryParamsRequest = {
      typeUrl: "/ibc.applications.transfer.v1.QueryParamsRequest",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseQueryParamsRequest();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseQueryParamsRequest();
        return message;
      }
    };
    function createBaseQueryParamsResponse() {
      return {
        params: void 0
      };
    }
    exports.QueryParamsResponse = {
      typeUrl: "/ibc.applications.transfer.v1.QueryParamsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== void 0) {
          transfer_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = transfer_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryParamsResponse();
        if ((0, helpers_1.isSet)(object.params))
          obj.params = transfer_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? transfer_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryParamsResponse();
        if (object.params !== void 0 && object.params !== null) {
          message.params = transfer_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseQueryDenomHashRequest() {
      return {
        trace: ""
      };
    }
    exports.QueryDenomHashRequest = {
      typeUrl: "/ibc.applications.transfer.v1.QueryDenomHashRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.trace !== "") {
          writer.uint32(10).string(message.trace);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomHashRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.trace = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomHashRequest();
        if ((0, helpers_1.isSet)(object.trace))
          obj.trace = String(object.trace);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.trace !== void 0 && (obj.trace = message.trace);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomHashRequest();
        message.trace = object.trace ?? "";
        return message;
      }
    };
    function createBaseQueryDenomHashResponse() {
      return {
        hash: ""
      };
    }
    exports.QueryDenomHashResponse = {
      typeUrl: "/ibc.applications.transfer.v1.QueryDenomHashResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.hash !== "") {
          writer.uint32(10).string(message.hash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomHashResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDenomHashResponse();
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = String(object.hash);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = message.hash);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDenomHashResponse();
        message.hash = object.hash ?? "";
        return message;
      }
    };
    function createBaseQueryEscrowAddressRequest() {
      return {
        portId: "",
        channelId: ""
      };
    }
    exports.QueryEscrowAddressRequest = {
      typeUrl: "/ibc.applications.transfer.v1.QueryEscrowAddressRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryEscrowAddressRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryEscrowAddressRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryEscrowAddressRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        return message;
      }
    };
    function createBaseQueryEscrowAddressResponse() {
      return {
        escrowAddress: ""
      };
    }
    exports.QueryEscrowAddressResponse = {
      typeUrl: "/ibc.applications.transfer.v1.QueryEscrowAddressResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.escrowAddress !== "") {
          writer.uint32(10).string(message.escrowAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryEscrowAddressResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.escrowAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryEscrowAddressResponse();
        if ((0, helpers_1.isSet)(object.escrowAddress))
          obj.escrowAddress = String(object.escrowAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.escrowAddress !== void 0 && (obj.escrowAddress = message.escrowAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryEscrowAddressResponse();
        message.escrowAddress = object.escrowAddress ?? "";
        return message;
      }
    };
    function createBaseQueryTotalEscrowForDenomRequest() {
      return {
        denom: ""
      };
    }
    exports.QueryTotalEscrowForDenomRequest = {
      typeUrl: "/ibc.applications.transfer.v1.QueryTotalEscrowForDenomRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.denom !== "") {
          writer.uint32(10).string(message.denom);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryTotalEscrowForDenomRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.denom = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryTotalEscrowForDenomRequest();
        if ((0, helpers_1.isSet)(object.denom))
          obj.denom = String(object.denom);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.denom !== void 0 && (obj.denom = message.denom);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryTotalEscrowForDenomRequest();
        message.denom = object.denom ?? "";
        return message;
      }
    };
    function createBaseQueryTotalEscrowForDenomResponse() {
      return {
        amount: coin_1.Coin.fromPartial({})
      };
    }
    exports.QueryTotalEscrowForDenomResponse = {
      typeUrl: "/ibc.applications.transfer.v1.QueryTotalEscrowForDenomResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.amount !== void 0) {
          coin_1.Coin.encode(message.amount, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryTotalEscrowForDenomResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.amount = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryTotalEscrowForDenomResponse();
        if ((0, helpers_1.isSet)(object.amount))
          obj.amount = coin_1.Coin.fromJSON(object.amount);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.amount !== void 0 && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryTotalEscrowForDenomResponse();
        if (object.amount !== void 0 && object.amount !== null) {
          message.amount = coin_1.Coin.fromPartial(object.amount);
        }
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.DenomTraces = this.DenomTraces.bind(this);
        this.DenomTrace = this.DenomTrace.bind(this);
        this.Params = this.Params.bind(this);
        this.DenomHash = this.DenomHash.bind(this);
        this.EscrowAddress = this.EscrowAddress.bind(this);
        this.TotalEscrowForDenom = this.TotalEscrowForDenom.bind(this);
      }
      DenomTraces(request = {
        pagination: pagination_1.PageRequest.fromPartial({})
      }) {
        const data2 = exports.QueryDenomTracesRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.applications.transfer.v1.Query", "DenomTraces", data2);
        return promise.then((data3) => exports.QueryDenomTracesResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DenomTrace(request) {
        const data2 = exports.QueryDenomTraceRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.applications.transfer.v1.Query", "DenomTrace", data2);
        return promise.then((data3) => exports.QueryDenomTraceResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Params(request = {}) {
        const data2 = exports.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.applications.transfer.v1.Query", "Params", data2);
        return promise.then((data3) => exports.QueryParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DenomHash(request) {
        const data2 = exports.QueryDenomHashRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.applications.transfer.v1.Query", "DenomHash", data2);
        return promise.then((data3) => exports.QueryDenomHashResponse.decode(new binary_1.BinaryReader(data3)));
      }
      EscrowAddress(request) {
        const data2 = exports.QueryEscrowAddressRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.applications.transfer.v1.Query", "EscrowAddress", data2);
        return promise.then((data3) => exports.QueryEscrowAddressResponse.decode(new binary_1.BinaryReader(data3)));
      }
      TotalEscrowForDenom(request) {
        const data2 = exports.QueryTotalEscrowForDenomRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.applications.transfer.v1.Query", "TotalEscrowForDenom", data2);
        return promise.then((data3) => exports.QueryTotalEscrowForDenomResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.QueryClientImpl = QueryClientImpl;
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/core/channel/v1/query.js
var require_query8 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/core/channel/v1/query.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryClientImpl = exports.QueryChannelParamsResponse = exports.QueryChannelParamsRequest = exports.QueryUpgradeResponse = exports.QueryUpgradeRequest = exports.QueryUpgradeErrorResponse = exports.QueryUpgradeErrorRequest = exports.QueryNextSequenceSendResponse = exports.QueryNextSequenceSendRequest = exports.QueryNextSequenceReceiveResponse = exports.QueryNextSequenceReceiveRequest = exports.QueryUnreceivedAcksResponse = exports.QueryUnreceivedAcksRequest = exports.QueryUnreceivedPacketsResponse = exports.QueryUnreceivedPacketsRequest = exports.QueryPacketAcknowledgementsResponse = exports.QueryPacketAcknowledgementsRequest = exports.QueryPacketAcknowledgementResponse = exports.QueryPacketAcknowledgementRequest = exports.QueryPacketReceiptResponse = exports.QueryPacketReceiptRequest = exports.QueryPacketCommitmentsResponse = exports.QueryPacketCommitmentsRequest = exports.QueryPacketCommitmentResponse = exports.QueryPacketCommitmentRequest = exports.QueryChannelConsensusStateResponse = exports.QueryChannelConsensusStateRequest = exports.QueryChannelClientStateResponse = exports.QueryChannelClientStateRequest = exports.QueryConnectionChannelsResponse = exports.QueryConnectionChannelsRequest = exports.QueryChannelsResponse = exports.QueryChannelsRequest = exports.QueryChannelResponse = exports.QueryChannelRequest = exports.protobufPackage = void 0;
    var pagination_1 = require_pagination();
    var channel_1 = require_channel();
    var client_1 = require_client();
    var any_1 = require_any();
    var upgrade_1 = require_upgrade2();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "ibc.core.channel.v1";
    function createBaseQueryChannelRequest() {
      return {
        portId: "",
        channelId: ""
      };
    }
    exports.QueryChannelRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryChannelRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryChannelRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryChannelRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        return message;
      }
    };
    function createBaseQueryChannelResponse() {
      return {
        channel: void 0,
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports.QueryChannelResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryChannelResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.channel !== void 0) {
          channel_1.Channel.encode(message.channel, writer.uint32(10).fork()).ldelim();
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.channel = channel_1.Channel.decode(reader, reader.uint32());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryChannelResponse();
        if ((0, helpers_1.isSet)(object.channel))
          obj.channel = channel_1.Channel.fromJSON(object.channel);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.channel !== void 0 && (obj.channel = message.channel ? channel_1.Channel.toJSON(message.channel) : void 0);
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryChannelResponse();
        if (object.channel !== void 0 && object.channel !== null) {
          message.channel = channel_1.Channel.fromPartial(object.channel);
        }
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryChannelsRequest() {
      return {
        pagination: void 0
      };
    }
    exports.QueryChannelsRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryChannelsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryChannelsRequest();
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryChannelsRequest();
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryChannelsResponse() {
      return {
        channels: [],
        pagination: void 0,
        height: client_1.Height.fromPartial({})
      };
    }
    exports.QueryChannelsResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryChannelsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.channels) {
          channel_1.IdentifiedChannel.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        if (message.height !== void 0) {
          client_1.Height.encode(message.height, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.channels.push(channel_1.IdentifiedChannel.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            case 3:
              message.height = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryChannelsResponse();
        if (Array.isArray(object?.channels))
          obj.channels = object.channels.map((e) => channel_1.IdentifiedChannel.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = client_1.Height.fromJSON(object.height);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.channels) {
          obj.channels = message.channels.map((e) => e ? channel_1.IdentifiedChannel.toJSON(e) : void 0);
        } else {
          obj.channels = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        message.height !== void 0 && (obj.height = message.height ? client_1.Height.toJSON(message.height) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryChannelsResponse();
        message.channels = object.channels?.map((e) => channel_1.IdentifiedChannel.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        if (object.height !== void 0 && object.height !== null) {
          message.height = client_1.Height.fromPartial(object.height);
        }
        return message;
      }
    };
    function createBaseQueryConnectionChannelsRequest() {
      return {
        connection: "",
        pagination: void 0
      };
    }
    exports.QueryConnectionChannelsRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryConnectionChannelsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.connection !== "") {
          writer.uint32(10).string(message.connection);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionChannelsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connection = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConnectionChannelsRequest();
        if ((0, helpers_1.isSet)(object.connection))
          obj.connection = String(object.connection);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.connection !== void 0 && (obj.connection = message.connection);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConnectionChannelsRequest();
        message.connection = object.connection ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryConnectionChannelsResponse() {
      return {
        channels: [],
        pagination: void 0,
        height: client_1.Height.fromPartial({})
      };
    }
    exports.QueryConnectionChannelsResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryConnectionChannelsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.channels) {
          channel_1.IdentifiedChannel.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        if (message.height !== void 0) {
          client_1.Height.encode(message.height, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionChannelsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.channels.push(channel_1.IdentifiedChannel.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            case 3:
              message.height = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConnectionChannelsResponse();
        if (Array.isArray(object?.channels))
          obj.channels = object.channels.map((e) => channel_1.IdentifiedChannel.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = client_1.Height.fromJSON(object.height);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.channels) {
          obj.channels = message.channels.map((e) => e ? channel_1.IdentifiedChannel.toJSON(e) : void 0);
        } else {
          obj.channels = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        message.height !== void 0 && (obj.height = message.height ? client_1.Height.toJSON(message.height) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConnectionChannelsResponse();
        message.channels = object.channels?.map((e) => channel_1.IdentifiedChannel.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        if (object.height !== void 0 && object.height !== null) {
          message.height = client_1.Height.fromPartial(object.height);
        }
        return message;
      }
    };
    function createBaseQueryChannelClientStateRequest() {
      return {
        portId: "",
        channelId: ""
      };
    }
    exports.QueryChannelClientStateRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryChannelClientStateRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelClientStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryChannelClientStateRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryChannelClientStateRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        return message;
      }
    };
    function createBaseQueryChannelClientStateResponse() {
      return {
        identifiedClientState: void 0,
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports.QueryChannelClientStateResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryChannelClientStateResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.identifiedClientState !== void 0) {
          client_1.IdentifiedClientState.encode(message.identifiedClientState, writer.uint32(10).fork()).ldelim();
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelClientStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.identifiedClientState = client_1.IdentifiedClientState.decode(reader, reader.uint32());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryChannelClientStateResponse();
        if ((0, helpers_1.isSet)(object.identifiedClientState))
          obj.identifiedClientState = client_1.IdentifiedClientState.fromJSON(object.identifiedClientState);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.identifiedClientState !== void 0 && (obj.identifiedClientState = message.identifiedClientState ? client_1.IdentifiedClientState.toJSON(message.identifiedClientState) : void 0);
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryChannelClientStateResponse();
        if (object.identifiedClientState !== void 0 && object.identifiedClientState !== null) {
          message.identifiedClientState = client_1.IdentifiedClientState.fromPartial(object.identifiedClientState);
        }
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryChannelConsensusStateRequest() {
      return {
        portId: "",
        channelId: "",
        revisionNumber: BigInt(0),
        revisionHeight: BigInt(0)
      };
    }
    exports.QueryChannelConsensusStateRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryChannelConsensusStateRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.revisionNumber !== BigInt(0)) {
          writer.uint32(24).uint64(message.revisionNumber);
        }
        if (message.revisionHeight !== BigInt(0)) {
          writer.uint32(32).uint64(message.revisionHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelConsensusStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.revisionNumber = reader.uint64();
              break;
            case 4:
              message.revisionHeight = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryChannelConsensusStateRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.revisionNumber))
          obj.revisionNumber = BigInt(object.revisionNumber.toString());
        if ((0, helpers_1.isSet)(object.revisionHeight))
          obj.revisionHeight = BigInt(object.revisionHeight.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.revisionNumber !== void 0 && (obj.revisionNumber = (message.revisionNumber || BigInt(0)).toString());
        message.revisionHeight !== void 0 && (obj.revisionHeight = (message.revisionHeight || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryChannelConsensusStateRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.revisionNumber !== void 0 && object.revisionNumber !== null) {
          message.revisionNumber = BigInt(object.revisionNumber.toString());
        }
        if (object.revisionHeight !== void 0 && object.revisionHeight !== null) {
          message.revisionHeight = BigInt(object.revisionHeight.toString());
        }
        return message;
      }
    };
    function createBaseQueryChannelConsensusStateResponse() {
      return {
        consensusState: void 0,
        clientId: "",
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports.QueryChannelConsensusStateResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryChannelConsensusStateResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.consensusState !== void 0) {
          any_1.Any.encode(message.consensusState, writer.uint32(10).fork()).ldelim();
        }
        if (message.clientId !== "") {
          writer.uint32(18).string(message.clientId);
        }
        if (message.proof.length !== 0) {
          writer.uint32(26).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelConsensusStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.consensusState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.clientId = reader.string();
              break;
            case 3:
              message.proof = reader.bytes();
              break;
            case 4:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryChannelConsensusStateResponse();
        if ((0, helpers_1.isSet)(object.consensusState))
          obj.consensusState = any_1.Any.fromJSON(object.consensusState);
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.consensusState !== void 0 && (obj.consensusState = message.consensusState ? any_1.Any.toJSON(message.consensusState) : void 0);
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryChannelConsensusStateResponse();
        if (object.consensusState !== void 0 && object.consensusState !== null) {
          message.consensusState = any_1.Any.fromPartial(object.consensusState);
        }
        message.clientId = object.clientId ?? "";
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryPacketCommitmentRequest() {
      return {
        portId: "",
        channelId: "",
        sequence: BigInt(0)
      };
    }
    exports.QueryPacketCommitmentRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryPacketCommitmentRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.sequence !== BigInt(0)) {
          writer.uint32(24).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketCommitmentRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.sequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryPacketCommitmentRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.sequence))
          obj.sequence = BigInt(object.sequence.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryPacketCommitmentRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.sequence !== void 0 && object.sequence !== null) {
          message.sequence = BigInt(object.sequence.toString());
        }
        return message;
      }
    };
    function createBaseQueryPacketCommitmentResponse() {
      return {
        commitment: new Uint8Array(),
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports.QueryPacketCommitmentResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryPacketCommitmentResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.commitment.length !== 0) {
          writer.uint32(10).bytes(message.commitment);
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketCommitmentResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.commitment = reader.bytes();
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryPacketCommitmentResponse();
        if ((0, helpers_1.isSet)(object.commitment))
          obj.commitment = (0, helpers_1.bytesFromBase64)(object.commitment);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.commitment !== void 0 && (obj.commitment = (0, helpers_1.base64FromBytes)(message.commitment !== void 0 ? message.commitment : new Uint8Array()));
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryPacketCommitmentResponse();
        message.commitment = object.commitment ?? new Uint8Array();
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryPacketCommitmentsRequest() {
      return {
        portId: "",
        channelId: "",
        pagination: void 0
      };
    }
    exports.QueryPacketCommitmentsRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryPacketCommitmentsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketCommitmentsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryPacketCommitmentsRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryPacketCommitmentsRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryPacketCommitmentsResponse() {
      return {
        commitments: [],
        pagination: void 0,
        height: client_1.Height.fromPartial({})
      };
    }
    exports.QueryPacketCommitmentsResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryPacketCommitmentsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.commitments) {
          channel_1.PacketState.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        if (message.height !== void 0) {
          client_1.Height.encode(message.height, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketCommitmentsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.commitments.push(channel_1.PacketState.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            case 3:
              message.height = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryPacketCommitmentsResponse();
        if (Array.isArray(object?.commitments))
          obj.commitments = object.commitments.map((e) => channel_1.PacketState.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = client_1.Height.fromJSON(object.height);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.commitments) {
          obj.commitments = message.commitments.map((e) => e ? channel_1.PacketState.toJSON(e) : void 0);
        } else {
          obj.commitments = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        message.height !== void 0 && (obj.height = message.height ? client_1.Height.toJSON(message.height) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryPacketCommitmentsResponse();
        message.commitments = object.commitments?.map((e) => channel_1.PacketState.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        if (object.height !== void 0 && object.height !== null) {
          message.height = client_1.Height.fromPartial(object.height);
        }
        return message;
      }
    };
    function createBaseQueryPacketReceiptRequest() {
      return {
        portId: "",
        channelId: "",
        sequence: BigInt(0)
      };
    }
    exports.QueryPacketReceiptRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryPacketReceiptRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.sequence !== BigInt(0)) {
          writer.uint32(24).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketReceiptRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.sequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryPacketReceiptRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.sequence))
          obj.sequence = BigInt(object.sequence.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryPacketReceiptRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.sequence !== void 0 && object.sequence !== null) {
          message.sequence = BigInt(object.sequence.toString());
        }
        return message;
      }
    };
    function createBaseQueryPacketReceiptResponse() {
      return {
        received: false,
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports.QueryPacketReceiptResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryPacketReceiptResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.received === true) {
          writer.uint32(16).bool(message.received);
        }
        if (message.proof.length !== 0) {
          writer.uint32(26).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketReceiptResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 2:
              message.received = reader.bool();
              break;
            case 3:
              message.proof = reader.bytes();
              break;
            case 4:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryPacketReceiptResponse();
        if ((0, helpers_1.isSet)(object.received))
          obj.received = Boolean(object.received);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.received !== void 0 && (obj.received = message.received);
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryPacketReceiptResponse();
        message.received = object.received ?? false;
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryPacketAcknowledgementRequest() {
      return {
        portId: "",
        channelId: "",
        sequence: BigInt(0)
      };
    }
    exports.QueryPacketAcknowledgementRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryPacketAcknowledgementRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.sequence !== BigInt(0)) {
          writer.uint32(24).uint64(message.sequence);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketAcknowledgementRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.sequence = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryPacketAcknowledgementRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.sequence))
          obj.sequence = BigInt(object.sequence.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.sequence !== void 0 && (obj.sequence = (message.sequence || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryPacketAcknowledgementRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.sequence !== void 0 && object.sequence !== null) {
          message.sequence = BigInt(object.sequence.toString());
        }
        return message;
      }
    };
    function createBaseQueryPacketAcknowledgementResponse() {
      return {
        acknowledgement: new Uint8Array(),
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports.QueryPacketAcknowledgementResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryPacketAcknowledgementResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.acknowledgement.length !== 0) {
          writer.uint32(10).bytes(message.acknowledgement);
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketAcknowledgementResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.acknowledgement = reader.bytes();
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryPacketAcknowledgementResponse();
        if ((0, helpers_1.isSet)(object.acknowledgement))
          obj.acknowledgement = (0, helpers_1.bytesFromBase64)(object.acknowledgement);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.acknowledgement !== void 0 && (obj.acknowledgement = (0, helpers_1.base64FromBytes)(message.acknowledgement !== void 0 ? message.acknowledgement : new Uint8Array()));
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryPacketAcknowledgementResponse();
        message.acknowledgement = object.acknowledgement ?? new Uint8Array();
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryPacketAcknowledgementsRequest() {
      return {
        portId: "",
        channelId: "",
        pagination: void 0,
        packetCommitmentSequences: []
      };
    }
    exports.QueryPacketAcknowledgementsRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryPacketAcknowledgementsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(26).fork()).ldelim();
        }
        writer.uint32(34).fork();
        for (const v9 of message.packetCommitmentSequences) {
          writer.uint64(v9);
        }
        writer.ldelim();
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketAcknowledgementsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            case 4:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.packetCommitmentSequences.push(reader.uint64());
                }
              } else {
                message.packetCommitmentSequences.push(reader.uint64());
              }
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryPacketAcknowledgementsRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        if (Array.isArray(object?.packetCommitmentSequences))
          obj.packetCommitmentSequences = object.packetCommitmentSequences.map((e) => BigInt(e.toString()));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        if (message.packetCommitmentSequences) {
          obj.packetCommitmentSequences = message.packetCommitmentSequences.map((e) => (e || BigInt(0)).toString());
        } else {
          obj.packetCommitmentSequences = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryPacketAcknowledgementsRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        message.packetCommitmentSequences = object.packetCommitmentSequences?.map((e) => BigInt(e.toString())) || [];
        return message;
      }
    };
    function createBaseQueryPacketAcknowledgementsResponse() {
      return {
        acknowledgements: [],
        pagination: void 0,
        height: client_1.Height.fromPartial({})
      };
    }
    exports.QueryPacketAcknowledgementsResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryPacketAcknowledgementsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.acknowledgements) {
          channel_1.PacketState.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        if (message.height !== void 0) {
          client_1.Height.encode(message.height, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPacketAcknowledgementsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.acknowledgements.push(channel_1.PacketState.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            case 3:
              message.height = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryPacketAcknowledgementsResponse();
        if (Array.isArray(object?.acknowledgements))
          obj.acknowledgements = object.acknowledgements.map((e) => channel_1.PacketState.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = client_1.Height.fromJSON(object.height);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.acknowledgements) {
          obj.acknowledgements = message.acknowledgements.map((e) => e ? channel_1.PacketState.toJSON(e) : void 0);
        } else {
          obj.acknowledgements = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        message.height !== void 0 && (obj.height = message.height ? client_1.Height.toJSON(message.height) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryPacketAcknowledgementsResponse();
        message.acknowledgements = object.acknowledgements?.map((e) => channel_1.PacketState.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        if (object.height !== void 0 && object.height !== null) {
          message.height = client_1.Height.fromPartial(object.height);
        }
        return message;
      }
    };
    function createBaseQueryUnreceivedPacketsRequest() {
      return {
        portId: "",
        channelId: "",
        packetCommitmentSequences: []
      };
    }
    exports.QueryUnreceivedPacketsRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryUnreceivedPacketsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        writer.uint32(26).fork();
        for (const v9 of message.packetCommitmentSequences) {
          writer.uint64(v9);
        }
        writer.ldelim();
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUnreceivedPacketsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.packetCommitmentSequences.push(reader.uint64());
                }
              } else {
                message.packetCommitmentSequences.push(reader.uint64());
              }
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryUnreceivedPacketsRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if (Array.isArray(object?.packetCommitmentSequences))
          obj.packetCommitmentSequences = object.packetCommitmentSequences.map((e) => BigInt(e.toString()));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        if (message.packetCommitmentSequences) {
          obj.packetCommitmentSequences = message.packetCommitmentSequences.map((e) => (e || BigInt(0)).toString());
        } else {
          obj.packetCommitmentSequences = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryUnreceivedPacketsRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        message.packetCommitmentSequences = object.packetCommitmentSequences?.map((e) => BigInt(e.toString())) || [];
        return message;
      }
    };
    function createBaseQueryUnreceivedPacketsResponse() {
      return {
        sequences: [],
        height: client_1.Height.fromPartial({})
      };
    }
    exports.QueryUnreceivedPacketsResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryUnreceivedPacketsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        writer.uint32(10).fork();
        for (const v9 of message.sequences) {
          writer.uint64(v9);
        }
        writer.ldelim();
        if (message.height !== void 0) {
          client_1.Height.encode(message.height, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUnreceivedPacketsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.sequences.push(reader.uint64());
                }
              } else {
                message.sequences.push(reader.uint64());
              }
              break;
            case 2:
              message.height = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryUnreceivedPacketsResponse();
        if (Array.isArray(object?.sequences))
          obj.sequences = object.sequences.map((e) => BigInt(e.toString()));
        if ((0, helpers_1.isSet)(object.height))
          obj.height = client_1.Height.fromJSON(object.height);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.sequences) {
          obj.sequences = message.sequences.map((e) => (e || BigInt(0)).toString());
        } else {
          obj.sequences = [];
        }
        message.height !== void 0 && (obj.height = message.height ? client_1.Height.toJSON(message.height) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryUnreceivedPacketsResponse();
        message.sequences = object.sequences?.map((e) => BigInt(e.toString())) || [];
        if (object.height !== void 0 && object.height !== null) {
          message.height = client_1.Height.fromPartial(object.height);
        }
        return message;
      }
    };
    function createBaseQueryUnreceivedAcksRequest() {
      return {
        portId: "",
        channelId: "",
        packetAckSequences: []
      };
    }
    exports.QueryUnreceivedAcksRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryUnreceivedAcksRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        writer.uint32(26).fork();
        for (const v9 of message.packetAckSequences) {
          writer.uint64(v9);
        }
        writer.ldelim();
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUnreceivedAcksRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            case 3:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.packetAckSequences.push(reader.uint64());
                }
              } else {
                message.packetAckSequences.push(reader.uint64());
              }
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryUnreceivedAcksRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        if (Array.isArray(object?.packetAckSequences))
          obj.packetAckSequences = object.packetAckSequences.map((e) => BigInt(e.toString()));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        if (message.packetAckSequences) {
          obj.packetAckSequences = message.packetAckSequences.map((e) => (e || BigInt(0)).toString());
        } else {
          obj.packetAckSequences = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryUnreceivedAcksRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        message.packetAckSequences = object.packetAckSequences?.map((e) => BigInt(e.toString())) || [];
        return message;
      }
    };
    function createBaseQueryUnreceivedAcksResponse() {
      return {
        sequences: [],
        height: client_1.Height.fromPartial({})
      };
    }
    exports.QueryUnreceivedAcksResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryUnreceivedAcksResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        writer.uint32(10).fork();
        for (const v9 of message.sequences) {
          writer.uint64(v9);
        }
        writer.ldelim();
        if (message.height !== void 0) {
          client_1.Height.encode(message.height, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUnreceivedAcksResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.sequences.push(reader.uint64());
                }
              } else {
                message.sequences.push(reader.uint64());
              }
              break;
            case 2:
              message.height = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryUnreceivedAcksResponse();
        if (Array.isArray(object?.sequences))
          obj.sequences = object.sequences.map((e) => BigInt(e.toString()));
        if ((0, helpers_1.isSet)(object.height))
          obj.height = client_1.Height.fromJSON(object.height);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.sequences) {
          obj.sequences = message.sequences.map((e) => (e || BigInt(0)).toString());
        } else {
          obj.sequences = [];
        }
        message.height !== void 0 && (obj.height = message.height ? client_1.Height.toJSON(message.height) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryUnreceivedAcksResponse();
        message.sequences = object.sequences?.map((e) => BigInt(e.toString())) || [];
        if (object.height !== void 0 && object.height !== null) {
          message.height = client_1.Height.fromPartial(object.height);
        }
        return message;
      }
    };
    function createBaseQueryNextSequenceReceiveRequest() {
      return {
        portId: "",
        channelId: ""
      };
    }
    exports.QueryNextSequenceReceiveRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryNextSequenceReceiveRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryNextSequenceReceiveRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryNextSequenceReceiveRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryNextSequenceReceiveRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        return message;
      }
    };
    function createBaseQueryNextSequenceReceiveResponse() {
      return {
        nextSequenceReceive: BigInt(0),
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports.QueryNextSequenceReceiveResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryNextSequenceReceiveResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.nextSequenceReceive !== BigInt(0)) {
          writer.uint32(8).uint64(message.nextSequenceReceive);
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryNextSequenceReceiveResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.nextSequenceReceive = reader.uint64();
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryNextSequenceReceiveResponse();
        if ((0, helpers_1.isSet)(object.nextSequenceReceive))
          obj.nextSequenceReceive = BigInt(object.nextSequenceReceive.toString());
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.nextSequenceReceive !== void 0 && (obj.nextSequenceReceive = (message.nextSequenceReceive || BigInt(0)).toString());
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryNextSequenceReceiveResponse();
        if (object.nextSequenceReceive !== void 0 && object.nextSequenceReceive !== null) {
          message.nextSequenceReceive = BigInt(object.nextSequenceReceive.toString());
        }
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryNextSequenceSendRequest() {
      return {
        portId: "",
        channelId: ""
      };
    }
    exports.QueryNextSequenceSendRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryNextSequenceSendRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryNextSequenceSendRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryNextSequenceSendRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryNextSequenceSendRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        return message;
      }
    };
    function createBaseQueryNextSequenceSendResponse() {
      return {
        nextSequenceSend: BigInt(0),
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports.QueryNextSequenceSendResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryNextSequenceSendResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.nextSequenceSend !== BigInt(0)) {
          writer.uint32(8).uint64(message.nextSequenceSend);
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryNextSequenceSendResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.nextSequenceSend = reader.uint64();
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryNextSequenceSendResponse();
        if ((0, helpers_1.isSet)(object.nextSequenceSend))
          obj.nextSequenceSend = BigInt(object.nextSequenceSend.toString());
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.nextSequenceSend !== void 0 && (obj.nextSequenceSend = (message.nextSequenceSend || BigInt(0)).toString());
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryNextSequenceSendResponse();
        if (object.nextSequenceSend !== void 0 && object.nextSequenceSend !== null) {
          message.nextSequenceSend = BigInt(object.nextSequenceSend.toString());
        }
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryUpgradeErrorRequest() {
      return {
        portId: "",
        channelId: ""
      };
    }
    exports.QueryUpgradeErrorRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryUpgradeErrorRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUpgradeErrorRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryUpgradeErrorRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryUpgradeErrorRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        return message;
      }
    };
    function createBaseQueryUpgradeErrorResponse() {
      return {
        errorReceipt: upgrade_1.ErrorReceipt.fromPartial({}),
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports.QueryUpgradeErrorResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryUpgradeErrorResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.errorReceipt !== void 0) {
          upgrade_1.ErrorReceipt.encode(message.errorReceipt, writer.uint32(10).fork()).ldelim();
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUpgradeErrorResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.errorReceipt = upgrade_1.ErrorReceipt.decode(reader, reader.uint32());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryUpgradeErrorResponse();
        if ((0, helpers_1.isSet)(object.errorReceipt))
          obj.errorReceipt = upgrade_1.ErrorReceipt.fromJSON(object.errorReceipt);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.errorReceipt !== void 0 && (obj.errorReceipt = message.errorReceipt ? upgrade_1.ErrorReceipt.toJSON(message.errorReceipt) : void 0);
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryUpgradeErrorResponse();
        if (object.errorReceipt !== void 0 && object.errorReceipt !== null) {
          message.errorReceipt = upgrade_1.ErrorReceipt.fromPartial(object.errorReceipt);
        }
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryUpgradeRequest() {
      return {
        portId: "",
        channelId: ""
      };
    }
    exports.QueryUpgradeRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryUpgradeRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.portId !== "") {
          writer.uint32(10).string(message.portId);
        }
        if (message.channelId !== "") {
          writer.uint32(18).string(message.channelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUpgradeRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.portId = reader.string();
              break;
            case 2:
              message.channelId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryUpgradeRequest();
        if ((0, helpers_1.isSet)(object.portId))
          obj.portId = String(object.portId);
        if ((0, helpers_1.isSet)(object.channelId))
          obj.channelId = String(object.channelId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.portId !== void 0 && (obj.portId = message.portId);
        message.channelId !== void 0 && (obj.channelId = message.channelId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryUpgradeRequest();
        message.portId = object.portId ?? "";
        message.channelId = object.channelId ?? "";
        return message;
      }
    };
    function createBaseQueryUpgradeResponse() {
      return {
        upgrade: upgrade_1.Upgrade.fromPartial({}),
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports.QueryUpgradeResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryUpgradeResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.upgrade !== void 0) {
          upgrade_1.Upgrade.encode(message.upgrade, writer.uint32(10).fork()).ldelim();
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUpgradeResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.upgrade = upgrade_1.Upgrade.decode(reader, reader.uint32());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryUpgradeResponse();
        if ((0, helpers_1.isSet)(object.upgrade))
          obj.upgrade = upgrade_1.Upgrade.fromJSON(object.upgrade);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.upgrade !== void 0 && (obj.upgrade = message.upgrade ? upgrade_1.Upgrade.toJSON(message.upgrade) : void 0);
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryUpgradeResponse();
        if (object.upgrade !== void 0 && object.upgrade !== null) {
          message.upgrade = upgrade_1.Upgrade.fromPartial(object.upgrade);
        }
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryChannelParamsRequest() {
      return {};
    }
    exports.QueryChannelParamsRequest = {
      typeUrl: "/ibc.core.channel.v1.QueryChannelParamsRequest",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelParamsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseQueryChannelParamsRequest();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseQueryChannelParamsRequest();
        return message;
      }
    };
    function createBaseQueryChannelParamsResponse() {
      return {
        params: void 0
      };
    }
    exports.QueryChannelParamsResponse = {
      typeUrl: "/ibc.core.channel.v1.QueryChannelParamsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== void 0) {
          client_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryChannelParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = client_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryChannelParamsResponse();
        if ((0, helpers_1.isSet)(object.params))
          obj.params = client_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? client_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryChannelParamsResponse();
        if (object.params !== void 0 && object.params !== null) {
          message.params = client_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Channel = this.Channel.bind(this);
        this.Channels = this.Channels.bind(this);
        this.ConnectionChannels = this.ConnectionChannels.bind(this);
        this.ChannelClientState = this.ChannelClientState.bind(this);
        this.ChannelConsensusState = this.ChannelConsensusState.bind(this);
        this.PacketCommitment = this.PacketCommitment.bind(this);
        this.PacketCommitments = this.PacketCommitments.bind(this);
        this.PacketReceipt = this.PacketReceipt.bind(this);
        this.PacketAcknowledgement = this.PacketAcknowledgement.bind(this);
        this.PacketAcknowledgements = this.PacketAcknowledgements.bind(this);
        this.UnreceivedPackets = this.UnreceivedPackets.bind(this);
        this.UnreceivedAcks = this.UnreceivedAcks.bind(this);
        this.NextSequenceReceive = this.NextSequenceReceive.bind(this);
        this.NextSequenceSend = this.NextSequenceSend.bind(this);
        this.UpgradeError = this.UpgradeError.bind(this);
        this.Upgrade = this.Upgrade.bind(this);
        this.ChannelParams = this.ChannelParams.bind(this);
      }
      Channel(request) {
        const data2 = exports.QueryChannelRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "Channel", data2);
        return promise.then((data3) => exports.QueryChannelResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Channels(request = {
        pagination: pagination_1.PageRequest.fromPartial({})
      }) {
        const data2 = exports.QueryChannelsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "Channels", data2);
        return promise.then((data3) => exports.QueryChannelsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ConnectionChannels(request) {
        const data2 = exports.QueryConnectionChannelsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "ConnectionChannels", data2);
        return promise.then((data3) => exports.QueryConnectionChannelsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ChannelClientState(request) {
        const data2 = exports.QueryChannelClientStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "ChannelClientState", data2);
        return promise.then((data3) => exports.QueryChannelClientStateResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ChannelConsensusState(request) {
        const data2 = exports.QueryChannelConsensusStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "ChannelConsensusState", data2);
        return promise.then((data3) => exports.QueryChannelConsensusStateResponse.decode(new binary_1.BinaryReader(data3)));
      }
      PacketCommitment(request) {
        const data2 = exports.QueryPacketCommitmentRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "PacketCommitment", data2);
        return promise.then((data3) => exports.QueryPacketCommitmentResponse.decode(new binary_1.BinaryReader(data3)));
      }
      PacketCommitments(request) {
        const data2 = exports.QueryPacketCommitmentsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "PacketCommitments", data2);
        return promise.then((data3) => exports.QueryPacketCommitmentsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      PacketReceipt(request) {
        const data2 = exports.QueryPacketReceiptRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "PacketReceipt", data2);
        return promise.then((data3) => exports.QueryPacketReceiptResponse.decode(new binary_1.BinaryReader(data3)));
      }
      PacketAcknowledgement(request) {
        const data2 = exports.QueryPacketAcknowledgementRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "PacketAcknowledgement", data2);
        return promise.then((data3) => exports.QueryPacketAcknowledgementResponse.decode(new binary_1.BinaryReader(data3)));
      }
      PacketAcknowledgements(request) {
        const data2 = exports.QueryPacketAcknowledgementsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "PacketAcknowledgements", data2);
        return promise.then((data3) => exports.QueryPacketAcknowledgementsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UnreceivedPackets(request) {
        const data2 = exports.QueryUnreceivedPacketsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "UnreceivedPackets", data2);
        return promise.then((data3) => exports.QueryUnreceivedPacketsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UnreceivedAcks(request) {
        const data2 = exports.QueryUnreceivedAcksRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "UnreceivedAcks", data2);
        return promise.then((data3) => exports.QueryUnreceivedAcksResponse.decode(new binary_1.BinaryReader(data3)));
      }
      NextSequenceReceive(request) {
        const data2 = exports.QueryNextSequenceReceiveRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "NextSequenceReceive", data2);
        return promise.then((data3) => exports.QueryNextSequenceReceiveResponse.decode(new binary_1.BinaryReader(data3)));
      }
      NextSequenceSend(request) {
        const data2 = exports.QueryNextSequenceSendRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "NextSequenceSend", data2);
        return promise.then((data3) => exports.QueryNextSequenceSendResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpgradeError(request) {
        const data2 = exports.QueryUpgradeErrorRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "UpgradeError", data2);
        return promise.then((data3) => exports.QueryUpgradeErrorResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Upgrade(request) {
        const data2 = exports.QueryUpgradeRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "Upgrade", data2);
        return promise.then((data3) => exports.QueryUpgradeResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ChannelParams(request = {}) {
        const data2 = exports.QueryChannelParamsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.channel.v1.Query", "ChannelParams", data2);
        return promise.then((data3) => exports.QueryChannelParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.QueryClientImpl = QueryClientImpl;
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/core/client/v1/query.js
var require_query9 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/core/client/v1/query.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryClientImpl = exports.QueryVerifyMembershipResponse = exports.QueryVerifyMembershipRequest = exports.QueryUpgradedConsensusStateResponse = exports.QueryUpgradedConsensusStateRequest = exports.QueryUpgradedClientStateResponse = exports.QueryUpgradedClientStateRequest = exports.QueryClientParamsResponse = exports.QueryClientParamsRequest = exports.QueryClientStatusResponse = exports.QueryClientStatusRequest = exports.QueryConsensusStateHeightsResponse = exports.QueryConsensusStateHeightsRequest = exports.QueryConsensusStatesResponse = exports.QueryConsensusStatesRequest = exports.QueryConsensusStateResponse = exports.QueryConsensusStateRequest = exports.QueryClientStatesResponse = exports.QueryClientStatesRequest = exports.QueryClientStateResponse = exports.QueryClientStateRequest = exports.protobufPackage = void 0;
    var pagination_1 = require_pagination();
    var client_1 = require_client();
    var commitment_1 = require_commitment();
    var any_1 = require_any();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "ibc.core.client.v1";
    function createBaseQueryClientStateRequest() {
      return {
        clientId: ""
      };
    }
    exports.QueryClientStateRequest = {
      typeUrl: "/ibc.core.client.v1.QueryClientStateRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryClientStateRequest();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryClientStateRequest();
        message.clientId = object.clientId ?? "";
        return message;
      }
    };
    function createBaseQueryClientStateResponse() {
      return {
        clientState: void 0,
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports.QueryClientStateResponse = {
      typeUrl: "/ibc.core.client.v1.QueryClientStateResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientState !== void 0) {
          any_1.Any.encode(message.clientState, writer.uint32(10).fork()).ldelim();
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryClientStateResponse();
        if ((0, helpers_1.isSet)(object.clientState))
          obj.clientState = any_1.Any.fromJSON(object.clientState);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientState !== void 0 && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : void 0);
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryClientStateResponse();
        if (object.clientState !== void 0 && object.clientState !== null) {
          message.clientState = any_1.Any.fromPartial(object.clientState);
        }
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryClientStatesRequest() {
      return {
        pagination: void 0
      };
    }
    exports.QueryClientStatesRequest = {
      typeUrl: "/ibc.core.client.v1.QueryClientStatesRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientStatesRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryClientStatesRequest();
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryClientStatesRequest();
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryClientStatesResponse() {
      return {
        clientStates: [],
        pagination: void 0
      };
    }
    exports.QueryClientStatesResponse = {
      typeUrl: "/ibc.core.client.v1.QueryClientStatesResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.clientStates) {
          client_1.IdentifiedClientState.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientStatesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientStates.push(client_1.IdentifiedClientState.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryClientStatesResponse();
        if (Array.isArray(object?.clientStates))
          obj.clientStates = object.clientStates.map((e) => client_1.IdentifiedClientState.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.clientStates) {
          obj.clientStates = message.clientStates.map((e) => e ? client_1.IdentifiedClientState.toJSON(e) : void 0);
        } else {
          obj.clientStates = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryClientStatesResponse();
        message.clientStates = object.clientStates?.map((e) => client_1.IdentifiedClientState.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryConsensusStateRequest() {
      return {
        clientId: "",
        revisionNumber: BigInt(0),
        revisionHeight: BigInt(0),
        latestHeight: false
      };
    }
    exports.QueryConsensusStateRequest = {
      typeUrl: "/ibc.core.client.v1.QueryConsensusStateRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.revisionNumber !== BigInt(0)) {
          writer.uint32(16).uint64(message.revisionNumber);
        }
        if (message.revisionHeight !== BigInt(0)) {
          writer.uint32(24).uint64(message.revisionHeight);
        }
        if (message.latestHeight === true) {
          writer.uint32(32).bool(message.latestHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConsensusStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.revisionNumber = reader.uint64();
              break;
            case 3:
              message.revisionHeight = reader.uint64();
              break;
            case 4:
              message.latestHeight = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConsensusStateRequest();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.revisionNumber))
          obj.revisionNumber = BigInt(object.revisionNumber.toString());
        if ((0, helpers_1.isSet)(object.revisionHeight))
          obj.revisionHeight = BigInt(object.revisionHeight.toString());
        if ((0, helpers_1.isSet)(object.latestHeight))
          obj.latestHeight = Boolean(object.latestHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.revisionNumber !== void 0 && (obj.revisionNumber = (message.revisionNumber || BigInt(0)).toString());
        message.revisionHeight !== void 0 && (obj.revisionHeight = (message.revisionHeight || BigInt(0)).toString());
        message.latestHeight !== void 0 && (obj.latestHeight = message.latestHeight);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConsensusStateRequest();
        message.clientId = object.clientId ?? "";
        if (object.revisionNumber !== void 0 && object.revisionNumber !== null) {
          message.revisionNumber = BigInt(object.revisionNumber.toString());
        }
        if (object.revisionHeight !== void 0 && object.revisionHeight !== null) {
          message.revisionHeight = BigInt(object.revisionHeight.toString());
        }
        message.latestHeight = object.latestHeight ?? false;
        return message;
      }
    };
    function createBaseQueryConsensusStateResponse() {
      return {
        consensusState: void 0,
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports.QueryConsensusStateResponse = {
      typeUrl: "/ibc.core.client.v1.QueryConsensusStateResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.consensusState !== void 0) {
          any_1.Any.encode(message.consensusState, writer.uint32(10).fork()).ldelim();
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConsensusStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.consensusState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConsensusStateResponse();
        if ((0, helpers_1.isSet)(object.consensusState))
          obj.consensusState = any_1.Any.fromJSON(object.consensusState);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.consensusState !== void 0 && (obj.consensusState = message.consensusState ? any_1.Any.toJSON(message.consensusState) : void 0);
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConsensusStateResponse();
        if (object.consensusState !== void 0 && object.consensusState !== null) {
          message.consensusState = any_1.Any.fromPartial(object.consensusState);
        }
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryConsensusStatesRequest() {
      return {
        clientId: "",
        pagination: void 0
      };
    }
    exports.QueryConsensusStatesRequest = {
      typeUrl: "/ibc.core.client.v1.QueryConsensusStatesRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConsensusStatesRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConsensusStatesRequest();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConsensusStatesRequest();
        message.clientId = object.clientId ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryConsensusStatesResponse() {
      return {
        consensusStates: [],
        pagination: void 0
      };
    }
    exports.QueryConsensusStatesResponse = {
      typeUrl: "/ibc.core.client.v1.QueryConsensusStatesResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.consensusStates) {
          client_1.ConsensusStateWithHeight.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConsensusStatesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.consensusStates.push(client_1.ConsensusStateWithHeight.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConsensusStatesResponse();
        if (Array.isArray(object?.consensusStates))
          obj.consensusStates = object.consensusStates.map((e) => client_1.ConsensusStateWithHeight.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.consensusStates) {
          obj.consensusStates = message.consensusStates.map((e) => e ? client_1.ConsensusStateWithHeight.toJSON(e) : void 0);
        } else {
          obj.consensusStates = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConsensusStatesResponse();
        message.consensusStates = object.consensusStates?.map((e) => client_1.ConsensusStateWithHeight.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryConsensusStateHeightsRequest() {
      return {
        clientId: "",
        pagination: void 0
      };
    }
    exports.QueryConsensusStateHeightsRequest = {
      typeUrl: "/ibc.core.client.v1.QueryConsensusStateHeightsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConsensusStateHeightsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConsensusStateHeightsRequest();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConsensusStateHeightsRequest();
        message.clientId = object.clientId ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryConsensusStateHeightsResponse() {
      return {
        consensusStateHeights: [],
        pagination: void 0
      };
    }
    exports.QueryConsensusStateHeightsResponse = {
      typeUrl: "/ibc.core.client.v1.QueryConsensusStateHeightsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.consensusStateHeights) {
          client_1.Height.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConsensusStateHeightsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.consensusStateHeights.push(client_1.Height.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConsensusStateHeightsResponse();
        if (Array.isArray(object?.consensusStateHeights))
          obj.consensusStateHeights = object.consensusStateHeights.map((e) => client_1.Height.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.consensusStateHeights) {
          obj.consensusStateHeights = message.consensusStateHeights.map((e) => e ? client_1.Height.toJSON(e) : void 0);
        } else {
          obj.consensusStateHeights = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConsensusStateHeightsResponse();
        message.consensusStateHeights = object.consensusStateHeights?.map((e) => client_1.Height.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryClientStatusRequest() {
      return {
        clientId: ""
      };
    }
    exports.QueryClientStatusRequest = {
      typeUrl: "/ibc.core.client.v1.QueryClientStatusRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientStatusRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryClientStatusRequest();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryClientStatusRequest();
        message.clientId = object.clientId ?? "";
        return message;
      }
    };
    function createBaseQueryClientStatusResponse() {
      return {
        status: ""
      };
    }
    exports.QueryClientStatusResponse = {
      typeUrl: "/ibc.core.client.v1.QueryClientStatusResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.status !== "") {
          writer.uint32(10).string(message.status);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientStatusResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.status = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryClientStatusResponse();
        if ((0, helpers_1.isSet)(object.status))
          obj.status = String(object.status);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.status !== void 0 && (obj.status = message.status);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryClientStatusResponse();
        message.status = object.status ?? "";
        return message;
      }
    };
    function createBaseQueryClientParamsRequest() {
      return {};
    }
    exports.QueryClientParamsRequest = {
      typeUrl: "/ibc.core.client.v1.QueryClientParamsRequest",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientParamsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseQueryClientParamsRequest();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseQueryClientParamsRequest();
        return message;
      }
    };
    function createBaseQueryClientParamsResponse() {
      return {
        params: void 0
      };
    }
    exports.QueryClientParamsResponse = {
      typeUrl: "/ibc.core.client.v1.QueryClientParamsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== void 0) {
          client_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = client_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryClientParamsResponse();
        if ((0, helpers_1.isSet)(object.params))
          obj.params = client_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? client_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryClientParamsResponse();
        if (object.params !== void 0 && object.params !== null) {
          message.params = client_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseQueryUpgradedClientStateRequest() {
      return {};
    }
    exports.QueryUpgradedClientStateRequest = {
      typeUrl: "/ibc.core.client.v1.QueryUpgradedClientStateRequest",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUpgradedClientStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseQueryUpgradedClientStateRequest();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseQueryUpgradedClientStateRequest();
        return message;
      }
    };
    function createBaseQueryUpgradedClientStateResponse() {
      return {
        upgradedClientState: void 0
      };
    }
    exports.QueryUpgradedClientStateResponse = {
      typeUrl: "/ibc.core.client.v1.QueryUpgradedClientStateResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.upgradedClientState !== void 0) {
          any_1.Any.encode(message.upgradedClientState, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUpgradedClientStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.upgradedClientState = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryUpgradedClientStateResponse();
        if ((0, helpers_1.isSet)(object.upgradedClientState))
          obj.upgradedClientState = any_1.Any.fromJSON(object.upgradedClientState);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.upgradedClientState !== void 0 && (obj.upgradedClientState = message.upgradedClientState ? any_1.Any.toJSON(message.upgradedClientState) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryUpgradedClientStateResponse();
        if (object.upgradedClientState !== void 0 && object.upgradedClientState !== null) {
          message.upgradedClientState = any_1.Any.fromPartial(object.upgradedClientState);
        }
        return message;
      }
    };
    function createBaseQueryUpgradedConsensusStateRequest() {
      return {};
    }
    exports.QueryUpgradedConsensusStateRequest = {
      typeUrl: "/ibc.core.client.v1.QueryUpgradedConsensusStateRequest",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUpgradedConsensusStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseQueryUpgradedConsensusStateRequest();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseQueryUpgradedConsensusStateRequest();
        return message;
      }
    };
    function createBaseQueryUpgradedConsensusStateResponse() {
      return {
        upgradedConsensusState: void 0
      };
    }
    exports.QueryUpgradedConsensusStateResponse = {
      typeUrl: "/ibc.core.client.v1.QueryUpgradedConsensusStateResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.upgradedConsensusState !== void 0) {
          any_1.Any.encode(message.upgradedConsensusState, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUpgradedConsensusStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.upgradedConsensusState = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryUpgradedConsensusStateResponse();
        if ((0, helpers_1.isSet)(object.upgradedConsensusState))
          obj.upgradedConsensusState = any_1.Any.fromJSON(object.upgradedConsensusState);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.upgradedConsensusState !== void 0 && (obj.upgradedConsensusState = message.upgradedConsensusState ? any_1.Any.toJSON(message.upgradedConsensusState) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryUpgradedConsensusStateResponse();
        if (object.upgradedConsensusState !== void 0 && object.upgradedConsensusState !== null) {
          message.upgradedConsensusState = any_1.Any.fromPartial(object.upgradedConsensusState);
        }
        return message;
      }
    };
    function createBaseQueryVerifyMembershipRequest() {
      return {
        clientId: "",
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({}),
        merklePath: commitment_1.MerklePath.fromPartial({}),
        value: new Uint8Array(),
        timeDelay: BigInt(0),
        blockDelay: BigInt(0)
      };
    }
    exports.QueryVerifyMembershipRequest = {
      typeUrl: "/ibc.core.client.v1.QueryVerifyMembershipRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        if (message.merklePath !== void 0) {
          commitment_1.MerklePath.encode(message.merklePath, writer.uint32(34).fork()).ldelim();
        }
        if (message.value.length !== 0) {
          writer.uint32(42).bytes(message.value);
        }
        if (message.timeDelay !== BigInt(0)) {
          writer.uint32(48).uint64(message.timeDelay);
        }
        if (message.blockDelay !== BigInt(0)) {
          writer.uint32(56).uint64(message.blockDelay);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryVerifyMembershipRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 4:
              message.merklePath = commitment_1.MerklePath.decode(reader, reader.uint32());
              break;
            case 5:
              message.value = reader.bytes();
              break;
            case 6:
              message.timeDelay = reader.uint64();
              break;
            case 7:
              message.blockDelay = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryVerifyMembershipRequest();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        if ((0, helpers_1.isSet)(object.merklePath))
          obj.merklePath = commitment_1.MerklePath.fromJSON(object.merklePath);
        if ((0, helpers_1.isSet)(object.value))
          obj.value = (0, helpers_1.bytesFromBase64)(object.value);
        if ((0, helpers_1.isSet)(object.timeDelay))
          obj.timeDelay = BigInt(object.timeDelay.toString());
        if ((0, helpers_1.isSet)(object.blockDelay))
          obj.blockDelay = BigInt(object.blockDelay.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        message.merklePath !== void 0 && (obj.merklePath = message.merklePath ? commitment_1.MerklePath.toJSON(message.merklePath) : void 0);
        message.value !== void 0 && (obj.value = (0, helpers_1.base64FromBytes)(message.value !== void 0 ? message.value : new Uint8Array()));
        message.timeDelay !== void 0 && (obj.timeDelay = (message.timeDelay || BigInt(0)).toString());
        message.blockDelay !== void 0 && (obj.blockDelay = (message.blockDelay || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryVerifyMembershipRequest();
        message.clientId = object.clientId ?? "";
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        if (object.merklePath !== void 0 && object.merklePath !== null) {
          message.merklePath = commitment_1.MerklePath.fromPartial(object.merklePath);
        }
        message.value = object.value ?? new Uint8Array();
        if (object.timeDelay !== void 0 && object.timeDelay !== null) {
          message.timeDelay = BigInt(object.timeDelay.toString());
        }
        if (object.blockDelay !== void 0 && object.blockDelay !== null) {
          message.blockDelay = BigInt(object.blockDelay.toString());
        }
        return message;
      }
    };
    function createBaseQueryVerifyMembershipResponse() {
      return {
        success: false
      };
    }
    exports.QueryVerifyMembershipResponse = {
      typeUrl: "/ibc.core.client.v1.QueryVerifyMembershipResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.success === true) {
          writer.uint32(8).bool(message.success);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryVerifyMembershipResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.success = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryVerifyMembershipResponse();
        if ((0, helpers_1.isSet)(object.success))
          obj.success = Boolean(object.success);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.success !== void 0 && (obj.success = message.success);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryVerifyMembershipResponse();
        message.success = object.success ?? false;
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.ClientState = this.ClientState.bind(this);
        this.ClientStates = this.ClientStates.bind(this);
        this.ConsensusState = this.ConsensusState.bind(this);
        this.ConsensusStates = this.ConsensusStates.bind(this);
        this.ConsensusStateHeights = this.ConsensusStateHeights.bind(this);
        this.ClientStatus = this.ClientStatus.bind(this);
        this.ClientParams = this.ClientParams.bind(this);
        this.UpgradedClientState = this.UpgradedClientState.bind(this);
        this.UpgradedConsensusState = this.UpgradedConsensusState.bind(this);
        this.VerifyMembership = this.VerifyMembership.bind(this);
      }
      ClientState(request) {
        const data2 = exports.QueryClientStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "ClientState", data2);
        return promise.then((data3) => exports.QueryClientStateResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ClientStates(request = {
        pagination: pagination_1.PageRequest.fromPartial({})
      }) {
        const data2 = exports.QueryClientStatesRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "ClientStates", data2);
        return promise.then((data3) => exports.QueryClientStatesResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ConsensusState(request) {
        const data2 = exports.QueryConsensusStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "ConsensusState", data2);
        return promise.then((data3) => exports.QueryConsensusStateResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ConsensusStates(request) {
        const data2 = exports.QueryConsensusStatesRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "ConsensusStates", data2);
        return promise.then((data3) => exports.QueryConsensusStatesResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ConsensusStateHeights(request) {
        const data2 = exports.QueryConsensusStateHeightsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "ConsensusStateHeights", data2);
        return promise.then((data3) => exports.QueryConsensusStateHeightsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ClientStatus(request) {
        const data2 = exports.QueryClientStatusRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "ClientStatus", data2);
        return promise.then((data3) => exports.QueryClientStatusResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ClientParams(request = {}) {
        const data2 = exports.QueryClientParamsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "ClientParams", data2);
        return promise.then((data3) => exports.QueryClientParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpgradedClientState(request = {}) {
        const data2 = exports.QueryUpgradedClientStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "UpgradedClientState", data2);
        return promise.then((data3) => exports.QueryUpgradedClientStateResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpgradedConsensusState(request = {}) {
        const data2 = exports.QueryUpgradedConsensusStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "UpgradedConsensusState", data2);
        return promise.then((data3) => exports.QueryUpgradedConsensusStateResponse.decode(new binary_1.BinaryReader(data3)));
      }
      VerifyMembership(request) {
        const data2 = exports.QueryVerifyMembershipRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.client.v1.Query", "VerifyMembership", data2);
        return promise.then((data3) => exports.QueryVerifyMembershipResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.QueryClientImpl = QueryClientImpl;
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/core/connection/v1/query.js
var require_query10 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/core/connection/v1/query.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryClientImpl = exports.QueryConnectionParamsResponse = exports.QueryConnectionParamsRequest = exports.QueryConnectionConsensusStateResponse = exports.QueryConnectionConsensusStateRequest = exports.QueryConnectionClientStateResponse = exports.QueryConnectionClientStateRequest = exports.QueryClientConnectionsResponse = exports.QueryClientConnectionsRequest = exports.QueryConnectionsResponse = exports.QueryConnectionsRequest = exports.QueryConnectionResponse = exports.QueryConnectionRequest = exports.protobufPackage = void 0;
    var pagination_1 = require_pagination();
    var connection_1 = require_connection();
    var client_1 = require_client();
    var any_1 = require_any();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "ibc.core.connection.v1";
    function createBaseQueryConnectionRequest() {
      return {
        connectionId: ""
      };
    }
    exports.QueryConnectionRequest = {
      typeUrl: "/ibc.core.connection.v1.QueryConnectionRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.connectionId !== "") {
          writer.uint32(10).string(message.connectionId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connectionId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConnectionRequest();
        if ((0, helpers_1.isSet)(object.connectionId))
          obj.connectionId = String(object.connectionId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.connectionId !== void 0 && (obj.connectionId = message.connectionId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConnectionRequest();
        message.connectionId = object.connectionId ?? "";
        return message;
      }
    };
    function createBaseQueryConnectionResponse() {
      return {
        connection: void 0,
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports.QueryConnectionResponse = {
      typeUrl: "/ibc.core.connection.v1.QueryConnectionResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.connection !== void 0) {
          connection_1.ConnectionEnd.encode(message.connection, writer.uint32(10).fork()).ldelim();
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connection = connection_1.ConnectionEnd.decode(reader, reader.uint32());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConnectionResponse();
        if ((0, helpers_1.isSet)(object.connection))
          obj.connection = connection_1.ConnectionEnd.fromJSON(object.connection);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.connection !== void 0 && (obj.connection = message.connection ? connection_1.ConnectionEnd.toJSON(message.connection) : void 0);
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConnectionResponse();
        if (object.connection !== void 0 && object.connection !== null) {
          message.connection = connection_1.ConnectionEnd.fromPartial(object.connection);
        }
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryConnectionsRequest() {
      return {
        pagination: void 0
      };
    }
    exports.QueryConnectionsRequest = {
      typeUrl: "/ibc.core.connection.v1.QueryConnectionsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConnectionsRequest();
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConnectionsRequest();
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryConnectionsResponse() {
      return {
        connections: [],
        pagination: void 0,
        height: client_1.Height.fromPartial({})
      };
    }
    exports.QueryConnectionsResponse = {
      typeUrl: "/ibc.core.connection.v1.QueryConnectionsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.connections) {
          connection_1.IdentifiedConnection.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        if (message.height !== void 0) {
          client_1.Height.encode(message.height, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connections.push(connection_1.IdentifiedConnection.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            case 3:
              message.height = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConnectionsResponse();
        if (Array.isArray(object?.connections))
          obj.connections = object.connections.map((e) => connection_1.IdentifiedConnection.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = client_1.Height.fromJSON(object.height);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.connections) {
          obj.connections = message.connections.map((e) => e ? connection_1.IdentifiedConnection.toJSON(e) : void 0);
        } else {
          obj.connections = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        message.height !== void 0 && (obj.height = message.height ? client_1.Height.toJSON(message.height) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConnectionsResponse();
        message.connections = object.connections?.map((e) => connection_1.IdentifiedConnection.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        if (object.height !== void 0 && object.height !== null) {
          message.height = client_1.Height.fromPartial(object.height);
        }
        return message;
      }
    };
    function createBaseQueryClientConnectionsRequest() {
      return {
        clientId: ""
      };
    }
    exports.QueryClientConnectionsRequest = {
      typeUrl: "/ibc.core.connection.v1.QueryClientConnectionsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientConnectionsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryClientConnectionsRequest();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryClientConnectionsRequest();
        message.clientId = object.clientId ?? "";
        return message;
      }
    };
    function createBaseQueryClientConnectionsResponse() {
      return {
        connectionPaths: [],
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports.QueryClientConnectionsResponse = {
      typeUrl: "/ibc.core.connection.v1.QueryClientConnectionsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.connectionPaths) {
          writer.uint32(10).string(v9);
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryClientConnectionsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connectionPaths.push(reader.string());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryClientConnectionsResponse();
        if (Array.isArray(object?.connectionPaths))
          obj.connectionPaths = object.connectionPaths.map((e) => String(e));
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.connectionPaths) {
          obj.connectionPaths = message.connectionPaths.map((e) => e);
        } else {
          obj.connectionPaths = [];
        }
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryClientConnectionsResponse();
        message.connectionPaths = object.connectionPaths?.map((e) => e) || [];
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryConnectionClientStateRequest() {
      return {
        connectionId: ""
      };
    }
    exports.QueryConnectionClientStateRequest = {
      typeUrl: "/ibc.core.connection.v1.QueryConnectionClientStateRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.connectionId !== "") {
          writer.uint32(10).string(message.connectionId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionClientStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connectionId = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConnectionClientStateRequest();
        if ((0, helpers_1.isSet)(object.connectionId))
          obj.connectionId = String(object.connectionId);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.connectionId !== void 0 && (obj.connectionId = message.connectionId);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConnectionClientStateRequest();
        message.connectionId = object.connectionId ?? "";
        return message;
      }
    };
    function createBaseQueryConnectionClientStateResponse() {
      return {
        identifiedClientState: void 0,
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports.QueryConnectionClientStateResponse = {
      typeUrl: "/ibc.core.connection.v1.QueryConnectionClientStateResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.identifiedClientState !== void 0) {
          client_1.IdentifiedClientState.encode(message.identifiedClientState, writer.uint32(10).fork()).ldelim();
        }
        if (message.proof.length !== 0) {
          writer.uint32(18).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionClientStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.identifiedClientState = client_1.IdentifiedClientState.decode(reader, reader.uint32());
              break;
            case 2:
              message.proof = reader.bytes();
              break;
            case 3:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConnectionClientStateResponse();
        if ((0, helpers_1.isSet)(object.identifiedClientState))
          obj.identifiedClientState = client_1.IdentifiedClientState.fromJSON(object.identifiedClientState);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.identifiedClientState !== void 0 && (obj.identifiedClientState = message.identifiedClientState ? client_1.IdentifiedClientState.toJSON(message.identifiedClientState) : void 0);
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConnectionClientStateResponse();
        if (object.identifiedClientState !== void 0 && object.identifiedClientState !== null) {
          message.identifiedClientState = client_1.IdentifiedClientState.fromPartial(object.identifiedClientState);
        }
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryConnectionConsensusStateRequest() {
      return {
        connectionId: "",
        revisionNumber: BigInt(0),
        revisionHeight: BigInt(0)
      };
    }
    exports.QueryConnectionConsensusStateRequest = {
      typeUrl: "/ibc.core.connection.v1.QueryConnectionConsensusStateRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.connectionId !== "") {
          writer.uint32(10).string(message.connectionId);
        }
        if (message.revisionNumber !== BigInt(0)) {
          writer.uint32(16).uint64(message.revisionNumber);
        }
        if (message.revisionHeight !== BigInt(0)) {
          writer.uint32(24).uint64(message.revisionHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionConsensusStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.connectionId = reader.string();
              break;
            case 2:
              message.revisionNumber = reader.uint64();
              break;
            case 3:
              message.revisionHeight = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConnectionConsensusStateRequest();
        if ((0, helpers_1.isSet)(object.connectionId))
          obj.connectionId = String(object.connectionId);
        if ((0, helpers_1.isSet)(object.revisionNumber))
          obj.revisionNumber = BigInt(object.revisionNumber.toString());
        if ((0, helpers_1.isSet)(object.revisionHeight))
          obj.revisionHeight = BigInt(object.revisionHeight.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.connectionId !== void 0 && (obj.connectionId = message.connectionId);
        message.revisionNumber !== void 0 && (obj.revisionNumber = (message.revisionNumber || BigInt(0)).toString());
        message.revisionHeight !== void 0 && (obj.revisionHeight = (message.revisionHeight || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConnectionConsensusStateRequest();
        message.connectionId = object.connectionId ?? "";
        if (object.revisionNumber !== void 0 && object.revisionNumber !== null) {
          message.revisionNumber = BigInt(object.revisionNumber.toString());
        }
        if (object.revisionHeight !== void 0 && object.revisionHeight !== null) {
          message.revisionHeight = BigInt(object.revisionHeight.toString());
        }
        return message;
      }
    };
    function createBaseQueryConnectionConsensusStateResponse() {
      return {
        consensusState: void 0,
        clientId: "",
        proof: new Uint8Array(),
        proofHeight: client_1.Height.fromPartial({})
      };
    }
    exports.QueryConnectionConsensusStateResponse = {
      typeUrl: "/ibc.core.connection.v1.QueryConnectionConsensusStateResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.consensusState !== void 0) {
          any_1.Any.encode(message.consensusState, writer.uint32(10).fork()).ldelim();
        }
        if (message.clientId !== "") {
          writer.uint32(18).string(message.clientId);
        }
        if (message.proof.length !== 0) {
          writer.uint32(26).bytes(message.proof);
        }
        if (message.proofHeight !== void 0) {
          client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionConsensusStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.consensusState = any_1.Any.decode(reader, reader.uint32());
              break;
            case 2:
              message.clientId = reader.string();
              break;
            case 3:
              message.proof = reader.bytes();
              break;
            case 4:
              message.proofHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConnectionConsensusStateResponse();
        if ((0, helpers_1.isSet)(object.consensusState))
          obj.consensusState = any_1.Any.fromJSON(object.consensusState);
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = (0, helpers_1.bytesFromBase64)(object.proof);
        if ((0, helpers_1.isSet)(object.proofHeight))
          obj.proofHeight = client_1.Height.fromJSON(object.proofHeight);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.consensusState !== void 0 && (obj.consensusState = message.consensusState ? any_1.Any.toJSON(message.consensusState) : void 0);
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.proof !== void 0 && (obj.proof = (0, helpers_1.base64FromBytes)(message.proof !== void 0 ? message.proof : new Uint8Array()));
        message.proofHeight !== void 0 && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConnectionConsensusStateResponse();
        if (object.consensusState !== void 0 && object.consensusState !== null) {
          message.consensusState = any_1.Any.fromPartial(object.consensusState);
        }
        message.clientId = object.clientId ?? "";
        message.proof = object.proof ?? new Uint8Array();
        if (object.proofHeight !== void 0 && object.proofHeight !== null) {
          message.proofHeight = client_1.Height.fromPartial(object.proofHeight);
        }
        return message;
      }
    };
    function createBaseQueryConnectionParamsRequest() {
      return {};
    }
    exports.QueryConnectionParamsRequest = {
      typeUrl: "/ibc.core.connection.v1.QueryConnectionParamsRequest",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionParamsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseQueryConnectionParamsRequest();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseQueryConnectionParamsRequest();
        return message;
      }
    };
    function createBaseQueryConnectionParamsResponse() {
      return {
        params: void 0
      };
    }
    exports.QueryConnectionParamsResponse = {
      typeUrl: "/ibc.core.connection.v1.QueryConnectionParamsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== void 0) {
          client_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryConnectionParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = client_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryConnectionParamsResponse();
        if ((0, helpers_1.isSet)(object.params))
          obj.params = client_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? client_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryConnectionParamsResponse();
        if (object.params !== void 0 && object.params !== null) {
          message.params = client_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Connection = this.Connection.bind(this);
        this.Connections = this.Connections.bind(this);
        this.ClientConnections = this.ClientConnections.bind(this);
        this.ConnectionClientState = this.ConnectionClientState.bind(this);
        this.ConnectionConsensusState = this.ConnectionConsensusState.bind(this);
        this.ConnectionParams = this.ConnectionParams.bind(this);
      }
      Connection(request) {
        const data2 = exports.QueryConnectionRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Query", "Connection", data2);
        return promise.then((data3) => exports.QueryConnectionResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Connections(request = {
        pagination: pagination_1.PageRequest.fromPartial({})
      }) {
        const data2 = exports.QueryConnectionsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Query", "Connections", data2);
        return promise.then((data3) => exports.QueryConnectionsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ClientConnections(request) {
        const data2 = exports.QueryClientConnectionsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Query", "ClientConnections", data2);
        return promise.then((data3) => exports.QueryClientConnectionsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ConnectionClientState(request) {
        const data2 = exports.QueryConnectionClientStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Query", "ConnectionClientState", data2);
        return promise.then((data3) => exports.QueryConnectionClientStateResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ConnectionConsensusState(request) {
        const data2 = exports.QueryConnectionConsensusStateRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Query", "ConnectionConsensusState", data2);
        return promise.then((data3) => exports.QueryConnectionConsensusStateResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ConnectionParams(request = {}) {
        const data2 = exports.QueryConnectionParamsRequest.encode(request).finish();
        const promise = this.rpc.request("ibc.core.connection.v1.Query", "ConnectionParams", data2);
        return promise.then((data3) => exports.QueryConnectionParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.QueryClientImpl = QueryClientImpl;
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/tendermint/crypto/proof.js
var require_proof = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/tendermint/crypto/proof.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProofOps = exports.ProofOp = exports.DominoOp = exports.ValueOp = exports.Proof = exports.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "tendermint.crypto";
    function createBaseProof() {
      return {
        total: BigInt(0),
        index: BigInt(0),
        leafHash: new Uint8Array(),
        aunts: []
      };
    }
    exports.Proof = {
      typeUrl: "/tendermint.crypto.Proof",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.total !== BigInt(0)) {
          writer.uint32(8).int64(message.total);
        }
        if (message.index !== BigInt(0)) {
          writer.uint32(16).int64(message.index);
        }
        if (message.leafHash.length !== 0) {
          writer.uint32(26).bytes(message.leafHash);
        }
        for (const v9 of message.aunts) {
          writer.uint32(34).bytes(v9);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.total = reader.int64();
              break;
            case 2:
              message.index = reader.int64();
              break;
            case 3:
              message.leafHash = reader.bytes();
              break;
            case 4:
              message.aunts.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseProof();
        if ((0, helpers_1.isSet)(object.total))
          obj.total = BigInt(object.total.toString());
        if ((0, helpers_1.isSet)(object.index))
          obj.index = BigInt(object.index.toString());
        if ((0, helpers_1.isSet)(object.leafHash))
          obj.leafHash = (0, helpers_1.bytesFromBase64)(object.leafHash);
        if (Array.isArray(object?.aunts))
          obj.aunts = object.aunts.map((e) => (0, helpers_1.bytesFromBase64)(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.total !== void 0 && (obj.total = (message.total || BigInt(0)).toString());
        message.index !== void 0 && (obj.index = (message.index || BigInt(0)).toString());
        message.leafHash !== void 0 && (obj.leafHash = (0, helpers_1.base64FromBytes)(message.leafHash !== void 0 ? message.leafHash : new Uint8Array()));
        if (message.aunts) {
          obj.aunts = message.aunts.map((e) => (0, helpers_1.base64FromBytes)(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.aunts = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseProof();
        if (object.total !== void 0 && object.total !== null) {
          message.total = BigInt(object.total.toString());
        }
        if (object.index !== void 0 && object.index !== null) {
          message.index = BigInt(object.index.toString());
        }
        message.leafHash = object.leafHash ?? new Uint8Array();
        message.aunts = object.aunts?.map((e) => e) || [];
        return message;
      }
    };
    function createBaseValueOp() {
      return {
        key: new Uint8Array(),
        proof: void 0
      };
    }
    exports.ValueOp = {
      typeUrl: "/tendermint.crypto.ValueOp",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        if (message.proof !== void 0) {
          exports.Proof.encode(message.proof, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValueOp();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            case 2:
              message.proof = exports.Proof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValueOp();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = exports.Proof.fromJSON(object.proof);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        message.proof !== void 0 && (obj.proof = message.proof ? exports.Proof.toJSON(message.proof) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseValueOp();
        message.key = object.key ?? new Uint8Array();
        if (object.proof !== void 0 && object.proof !== null) {
          message.proof = exports.Proof.fromPartial(object.proof);
        }
        return message;
      }
    };
    function createBaseDominoOp() {
      return {
        key: "",
        input: "",
        output: ""
      };
    }
    exports.DominoOp = {
      typeUrl: "/tendermint.crypto.DominoOp",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key !== "") {
          writer.uint32(10).string(message.key);
        }
        if (message.input !== "") {
          writer.uint32(18).string(message.input);
        }
        if (message.output !== "") {
          writer.uint32(26).string(message.output);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDominoOp();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.string();
              break;
            case 2:
              message.input = reader.string();
              break;
            case 3:
              message.output = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDominoOp();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = String(object.key);
        if ((0, helpers_1.isSet)(object.input))
          obj.input = String(object.input);
        if ((0, helpers_1.isSet)(object.output))
          obj.output = String(object.output);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = message.key);
        message.input !== void 0 && (obj.input = message.input);
        message.output !== void 0 && (obj.output = message.output);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDominoOp();
        message.key = object.key ?? "";
        message.input = object.input ?? "";
        message.output = object.output ?? "";
        return message;
      }
    };
    function createBaseProofOp() {
      return {
        type: "",
        key: new Uint8Array(),
        data: new Uint8Array()
      };
    }
    exports.ProofOp = {
      typeUrl: "/tendermint.crypto.ProofOp",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.type !== "") {
          writer.uint32(10).string(message.type);
        }
        if (message.key.length !== 0) {
          writer.uint32(18).bytes(message.key);
        }
        if (message.data.length !== 0) {
          writer.uint32(26).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProofOp();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.type = reader.string();
              break;
            case 2:
              message.key = reader.bytes();
              break;
            case 3:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseProofOp();
        if ((0, helpers_1.isSet)(object.type))
          obj.type = String(object.type);
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        if ((0, helpers_1.isSet)(object.data))
          obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.type !== void 0 && (obj.type = message.type);
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseProofOp();
        message.type = object.type ?? "";
        message.key = object.key ?? new Uint8Array();
        message.data = object.data ?? new Uint8Array();
        return message;
      }
    };
    function createBaseProofOps() {
      return {
        ops: []
      };
    }
    exports.ProofOps = {
      typeUrl: "/tendermint.crypto.ProofOps",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.ops) {
          exports.ProofOp.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProofOps();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.ops.push(exports.ProofOp.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseProofOps();
        if (Array.isArray(object?.ops))
          obj.ops = object.ops.map((e) => exports.ProofOp.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.ops) {
          obj.ops = message.ops.map((e) => e ? exports.ProofOp.toJSON(e) : void 0);
        } else {
          obj.ops = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseProofOps();
        message.ops = object.ops?.map((e) => exports.ProofOp.fromPartial(e)) || [];
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/tendermint/version/types.js
var require_types2 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/tendermint/version/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Consensus = exports.App = exports.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "tendermint.version";
    function createBaseApp() {
      return {
        protocol: BigInt(0),
        software: ""
      };
    }
    exports.App = {
      typeUrl: "/tendermint.version.App",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.protocol !== BigInt(0)) {
          writer.uint32(8).uint64(message.protocol);
        }
        if (message.software !== "") {
          writer.uint32(18).string(message.software);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseApp();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.protocol = reader.uint64();
              break;
            case 2:
              message.software = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseApp();
        if ((0, helpers_1.isSet)(object.protocol))
          obj.protocol = BigInt(object.protocol.toString());
        if ((0, helpers_1.isSet)(object.software))
          obj.software = String(object.software);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.protocol !== void 0 && (obj.protocol = (message.protocol || BigInt(0)).toString());
        message.software !== void 0 && (obj.software = message.software);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseApp();
        if (object.protocol !== void 0 && object.protocol !== null) {
          message.protocol = BigInt(object.protocol.toString());
        }
        message.software = object.software ?? "";
        return message;
      }
    };
    function createBaseConsensus() {
      return {
        block: BigInt(0),
        app: BigInt(0)
      };
    }
    exports.Consensus = {
      typeUrl: "/tendermint.version.Consensus",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.block !== BigInt(0)) {
          writer.uint32(8).uint64(message.block);
        }
        if (message.app !== BigInt(0)) {
          writer.uint32(16).uint64(message.app);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseConsensus();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.block = reader.uint64();
              break;
            case 2:
              message.app = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseConsensus();
        if ((0, helpers_1.isSet)(object.block))
          obj.block = BigInt(object.block.toString());
        if ((0, helpers_1.isSet)(object.app))
          obj.app = BigInt(object.app.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.block !== void 0 && (obj.block = (message.block || BigInt(0)).toString());
        message.app !== void 0 && (obj.app = (message.app || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseConsensus();
        if (object.block !== void 0 && object.block !== null) {
          message.block = BigInt(object.block.toString());
        }
        if (object.app !== void 0 && object.app !== null) {
          message.app = BigInt(object.app.toString());
        }
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/tendermint/crypto/keys.js
var require_keys4 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/tendermint/crypto/keys.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PublicKey = exports.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "tendermint.crypto";
    function createBasePublicKey() {
      return {
        ed25519: void 0,
        secp256k1: void 0
      };
    }
    exports.PublicKey = {
      typeUrl: "/tendermint.crypto.PublicKey",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.ed25519 !== void 0) {
          writer.uint32(10).bytes(message.ed25519);
        }
        if (message.secp256k1 !== void 0) {
          writer.uint32(18).bytes(message.secp256k1);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePublicKey();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.ed25519 = reader.bytes();
              break;
            case 2:
              message.secp256k1 = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePublicKey();
        if ((0, helpers_1.isSet)(object.ed25519))
          obj.ed25519 = (0, helpers_1.bytesFromBase64)(object.ed25519);
        if ((0, helpers_1.isSet)(object.secp256k1))
          obj.secp256k1 = (0, helpers_1.bytesFromBase64)(object.secp256k1);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.ed25519 !== void 0 && (obj.ed25519 = message.ed25519 !== void 0 ? (0, helpers_1.base64FromBytes)(message.ed25519) : void 0);
        message.secp256k1 !== void 0 && (obj.secp256k1 = message.secp256k1 !== void 0 ? (0, helpers_1.base64FromBytes)(message.secp256k1) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBasePublicKey();
        message.ed25519 = object.ed25519 ?? void 0;
        message.secp256k1 = object.secp256k1 ?? void 0;
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/tendermint/types/validator.js
var require_validator = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/tendermint/types/validator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SimpleValidator = exports.Validator = exports.ValidatorSet = exports.blockIDFlagToJSON = exports.blockIDFlagFromJSON = exports.BlockIDFlag = exports.protobufPackage = void 0;
    var keys_1 = require_keys4();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "tendermint.types";
    var BlockIDFlag;
    (function(BlockIDFlag2) {
      BlockIDFlag2[BlockIDFlag2["BLOCK_ID_FLAG_UNKNOWN"] = 0] = "BLOCK_ID_FLAG_UNKNOWN";
      BlockIDFlag2[BlockIDFlag2["BLOCK_ID_FLAG_ABSENT"] = 1] = "BLOCK_ID_FLAG_ABSENT";
      BlockIDFlag2[BlockIDFlag2["BLOCK_ID_FLAG_COMMIT"] = 2] = "BLOCK_ID_FLAG_COMMIT";
      BlockIDFlag2[BlockIDFlag2["BLOCK_ID_FLAG_NIL"] = 3] = "BLOCK_ID_FLAG_NIL";
      BlockIDFlag2[BlockIDFlag2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(BlockIDFlag || (exports.BlockIDFlag = BlockIDFlag = {}));
    function blockIDFlagFromJSON(object) {
      switch (object) {
        case 0:
        case "BLOCK_ID_FLAG_UNKNOWN":
          return BlockIDFlag.BLOCK_ID_FLAG_UNKNOWN;
        case 1:
        case "BLOCK_ID_FLAG_ABSENT":
          return BlockIDFlag.BLOCK_ID_FLAG_ABSENT;
        case 2:
        case "BLOCK_ID_FLAG_COMMIT":
          return BlockIDFlag.BLOCK_ID_FLAG_COMMIT;
        case 3:
        case "BLOCK_ID_FLAG_NIL":
          return BlockIDFlag.BLOCK_ID_FLAG_NIL;
        case -1:
        case "UNRECOGNIZED":
        default:
          return BlockIDFlag.UNRECOGNIZED;
      }
    }
    exports.blockIDFlagFromJSON = blockIDFlagFromJSON;
    function blockIDFlagToJSON(object) {
      switch (object) {
        case BlockIDFlag.BLOCK_ID_FLAG_UNKNOWN:
          return "BLOCK_ID_FLAG_UNKNOWN";
        case BlockIDFlag.BLOCK_ID_FLAG_ABSENT:
          return "BLOCK_ID_FLAG_ABSENT";
        case BlockIDFlag.BLOCK_ID_FLAG_COMMIT:
          return "BLOCK_ID_FLAG_COMMIT";
        case BlockIDFlag.BLOCK_ID_FLAG_NIL:
          return "BLOCK_ID_FLAG_NIL";
        case BlockIDFlag.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.blockIDFlagToJSON = blockIDFlagToJSON;
    function createBaseValidatorSet() {
      return {
        validators: [],
        proposer: void 0,
        totalVotingPower: BigInt(0)
      };
    }
    exports.ValidatorSet = {
      typeUrl: "/tendermint.types.ValidatorSet",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.validators) {
          exports.Validator.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.proposer !== void 0) {
          exports.Validator.encode(message.proposer, writer.uint32(18).fork()).ldelim();
        }
        if (message.totalVotingPower !== BigInt(0)) {
          writer.uint32(24).int64(message.totalVotingPower);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorSet();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validators.push(exports.Validator.decode(reader, reader.uint32()));
              break;
            case 2:
              message.proposer = exports.Validator.decode(reader, reader.uint32());
              break;
            case 3:
              message.totalVotingPower = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidatorSet();
        if (Array.isArray(object?.validators))
          obj.validators = object.validators.map((e) => exports.Validator.fromJSON(e));
        if ((0, helpers_1.isSet)(object.proposer))
          obj.proposer = exports.Validator.fromJSON(object.proposer);
        if ((0, helpers_1.isSet)(object.totalVotingPower))
          obj.totalVotingPower = BigInt(object.totalVotingPower.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.validators) {
          obj.validators = message.validators.map((e) => e ? exports.Validator.toJSON(e) : void 0);
        } else {
          obj.validators = [];
        }
        message.proposer !== void 0 && (obj.proposer = message.proposer ? exports.Validator.toJSON(message.proposer) : void 0);
        message.totalVotingPower !== void 0 && (obj.totalVotingPower = (message.totalVotingPower || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseValidatorSet();
        message.validators = object.validators?.map((e) => exports.Validator.fromPartial(e)) || [];
        if (object.proposer !== void 0 && object.proposer !== null) {
          message.proposer = exports.Validator.fromPartial(object.proposer);
        }
        if (object.totalVotingPower !== void 0 && object.totalVotingPower !== null) {
          message.totalVotingPower = BigInt(object.totalVotingPower.toString());
        }
        return message;
      }
    };
    function createBaseValidator() {
      return {
        address: new Uint8Array(),
        pubKey: keys_1.PublicKey.fromPartial({}),
        votingPower: BigInt(0),
        proposerPriority: BigInt(0)
      };
    }
    exports.Validator = {
      typeUrl: "/tendermint.types.Validator",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address.length !== 0) {
          writer.uint32(10).bytes(message.address);
        }
        if (message.pubKey !== void 0) {
          keys_1.PublicKey.encode(message.pubKey, writer.uint32(18).fork()).ldelim();
        }
        if (message.votingPower !== BigInt(0)) {
          writer.uint32(24).int64(message.votingPower);
        }
        if (message.proposerPriority !== BigInt(0)) {
          writer.uint32(32).int64(message.proposerPriority);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidator();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.bytes();
              break;
            case 2:
              message.pubKey = keys_1.PublicKey.decode(reader, reader.uint32());
              break;
            case 3:
              message.votingPower = reader.int64();
              break;
            case 4:
              message.proposerPriority = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidator();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = (0, helpers_1.bytesFromBase64)(object.address);
        if ((0, helpers_1.isSet)(object.pubKey))
          obj.pubKey = keys_1.PublicKey.fromJSON(object.pubKey);
        if ((0, helpers_1.isSet)(object.votingPower))
          obj.votingPower = BigInt(object.votingPower.toString());
        if ((0, helpers_1.isSet)(object.proposerPriority))
          obj.proposerPriority = BigInt(object.proposerPriority.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = (0, helpers_1.base64FromBytes)(message.address !== void 0 ? message.address : new Uint8Array()));
        message.pubKey !== void 0 && (obj.pubKey = message.pubKey ? keys_1.PublicKey.toJSON(message.pubKey) : void 0);
        message.votingPower !== void 0 && (obj.votingPower = (message.votingPower || BigInt(0)).toString());
        message.proposerPriority !== void 0 && (obj.proposerPriority = (message.proposerPriority || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseValidator();
        message.address = object.address ?? new Uint8Array();
        if (object.pubKey !== void 0 && object.pubKey !== null) {
          message.pubKey = keys_1.PublicKey.fromPartial(object.pubKey);
        }
        if (object.votingPower !== void 0 && object.votingPower !== null) {
          message.votingPower = BigInt(object.votingPower.toString());
        }
        if (object.proposerPriority !== void 0 && object.proposerPriority !== null) {
          message.proposerPriority = BigInt(object.proposerPriority.toString());
        }
        return message;
      }
    };
    function createBaseSimpleValidator() {
      return {
        pubKey: void 0,
        votingPower: BigInt(0)
      };
    }
    exports.SimpleValidator = {
      typeUrl: "/tendermint.types.SimpleValidator",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pubKey !== void 0) {
          keys_1.PublicKey.encode(message.pubKey, writer.uint32(10).fork()).ldelim();
        }
        if (message.votingPower !== BigInt(0)) {
          writer.uint32(16).int64(message.votingPower);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSimpleValidator();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pubKey = keys_1.PublicKey.decode(reader, reader.uint32());
              break;
            case 2:
              message.votingPower = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSimpleValidator();
        if ((0, helpers_1.isSet)(object.pubKey))
          obj.pubKey = keys_1.PublicKey.fromJSON(object.pubKey);
        if ((0, helpers_1.isSet)(object.votingPower))
          obj.votingPower = BigInt(object.votingPower.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.pubKey !== void 0 && (obj.pubKey = message.pubKey ? keys_1.PublicKey.toJSON(message.pubKey) : void 0);
        message.votingPower !== void 0 && (obj.votingPower = (message.votingPower || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSimpleValidator();
        if (object.pubKey !== void 0 && object.pubKey !== null) {
          message.pubKey = keys_1.PublicKey.fromPartial(object.pubKey);
        }
        if (object.votingPower !== void 0 && object.votingPower !== null) {
          message.votingPower = BigInt(object.votingPower.toString());
        }
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/tendermint/types/types.js
var require_types3 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/tendermint/types/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TxProof = exports.BlockMeta = exports.LightBlock = exports.SignedHeader = exports.Proposal = exports.ExtendedCommitSig = exports.ExtendedCommit = exports.CommitSig = exports.Commit = exports.Vote = exports.Data = exports.Header = exports.BlockID = exports.Part = exports.PartSetHeader = exports.signedMsgTypeToJSON = exports.signedMsgTypeFromJSON = exports.SignedMsgType = exports.protobufPackage = void 0;
    var proof_1 = require_proof();
    var types_1 = require_types2();
    var timestamp_1 = require_timestamp();
    var validator_1 = require_validator();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "tendermint.types";
    var SignedMsgType;
    (function(SignedMsgType2) {
      SignedMsgType2[SignedMsgType2["SIGNED_MSG_TYPE_UNKNOWN"] = 0] = "SIGNED_MSG_TYPE_UNKNOWN";
      SignedMsgType2[SignedMsgType2["SIGNED_MSG_TYPE_PREVOTE"] = 1] = "SIGNED_MSG_TYPE_PREVOTE";
      SignedMsgType2[SignedMsgType2["SIGNED_MSG_TYPE_PRECOMMIT"] = 2] = "SIGNED_MSG_TYPE_PRECOMMIT";
      SignedMsgType2[SignedMsgType2["SIGNED_MSG_TYPE_PROPOSAL"] = 32] = "SIGNED_MSG_TYPE_PROPOSAL";
      SignedMsgType2[SignedMsgType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(SignedMsgType || (exports.SignedMsgType = SignedMsgType = {}));
    function signedMsgTypeFromJSON(object) {
      switch (object) {
        case 0:
        case "SIGNED_MSG_TYPE_UNKNOWN":
          return SignedMsgType.SIGNED_MSG_TYPE_UNKNOWN;
        case 1:
        case "SIGNED_MSG_TYPE_PREVOTE":
          return SignedMsgType.SIGNED_MSG_TYPE_PREVOTE;
        case 2:
        case "SIGNED_MSG_TYPE_PRECOMMIT":
          return SignedMsgType.SIGNED_MSG_TYPE_PRECOMMIT;
        case 32:
        case "SIGNED_MSG_TYPE_PROPOSAL":
          return SignedMsgType.SIGNED_MSG_TYPE_PROPOSAL;
        case -1:
        case "UNRECOGNIZED":
        default:
          return SignedMsgType.UNRECOGNIZED;
      }
    }
    exports.signedMsgTypeFromJSON = signedMsgTypeFromJSON;
    function signedMsgTypeToJSON(object) {
      switch (object) {
        case SignedMsgType.SIGNED_MSG_TYPE_UNKNOWN:
          return "SIGNED_MSG_TYPE_UNKNOWN";
        case SignedMsgType.SIGNED_MSG_TYPE_PREVOTE:
          return "SIGNED_MSG_TYPE_PREVOTE";
        case SignedMsgType.SIGNED_MSG_TYPE_PRECOMMIT:
          return "SIGNED_MSG_TYPE_PRECOMMIT";
        case SignedMsgType.SIGNED_MSG_TYPE_PROPOSAL:
          return "SIGNED_MSG_TYPE_PROPOSAL";
        case SignedMsgType.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.signedMsgTypeToJSON = signedMsgTypeToJSON;
    function createBasePartSetHeader() {
      return {
        total: 0,
        hash: new Uint8Array()
      };
    }
    exports.PartSetHeader = {
      typeUrl: "/tendermint.types.PartSetHeader",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.total !== 0) {
          writer.uint32(8).uint32(message.total);
        }
        if (message.hash.length !== 0) {
          writer.uint32(18).bytes(message.hash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePartSetHeader();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.total = reader.uint32();
              break;
            case 2:
              message.hash = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePartSetHeader();
        if ((0, helpers_1.isSet)(object.total))
          obj.total = Number(object.total);
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = (0, helpers_1.bytesFromBase64)(object.hash);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.total !== void 0 && (obj.total = Math.round(message.total));
        message.hash !== void 0 && (obj.hash = (0, helpers_1.base64FromBytes)(message.hash !== void 0 ? message.hash : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBasePartSetHeader();
        message.total = object.total ?? 0;
        message.hash = object.hash ?? new Uint8Array();
        return message;
      }
    };
    function createBasePart() {
      return {
        index: 0,
        bytes: new Uint8Array(),
        proof: proof_1.Proof.fromPartial({})
      };
    }
    exports.Part = {
      typeUrl: "/tendermint.types.Part",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.index !== 0) {
          writer.uint32(8).uint32(message.index);
        }
        if (message.bytes.length !== 0) {
          writer.uint32(18).bytes(message.bytes);
        }
        if (message.proof !== void 0) {
          proof_1.Proof.encode(message.proof, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePart();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.index = reader.uint32();
              break;
            case 2:
              message.bytes = reader.bytes();
              break;
            case 3:
              message.proof = proof_1.Proof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePart();
        if ((0, helpers_1.isSet)(object.index))
          obj.index = Number(object.index);
        if ((0, helpers_1.isSet)(object.bytes))
          obj.bytes = (0, helpers_1.bytesFromBase64)(object.bytes);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = proof_1.Proof.fromJSON(object.proof);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.index !== void 0 && (obj.index = Math.round(message.index));
        message.bytes !== void 0 && (obj.bytes = (0, helpers_1.base64FromBytes)(message.bytes !== void 0 ? message.bytes : new Uint8Array()));
        message.proof !== void 0 && (obj.proof = message.proof ? proof_1.Proof.toJSON(message.proof) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBasePart();
        message.index = object.index ?? 0;
        message.bytes = object.bytes ?? new Uint8Array();
        if (object.proof !== void 0 && object.proof !== null) {
          message.proof = proof_1.Proof.fromPartial(object.proof);
        }
        return message;
      }
    };
    function createBaseBlockID() {
      return {
        hash: new Uint8Array(),
        partSetHeader: exports.PartSetHeader.fromPartial({})
      };
    }
    exports.BlockID = {
      typeUrl: "/tendermint.types.BlockID",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.hash.length !== 0) {
          writer.uint32(10).bytes(message.hash);
        }
        if (message.partSetHeader !== void 0) {
          exports.PartSetHeader.encode(message.partSetHeader, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBlockID();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.bytes();
              break;
            case 2:
              message.partSetHeader = exports.PartSetHeader.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBlockID();
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = (0, helpers_1.bytesFromBase64)(object.hash);
        if ((0, helpers_1.isSet)(object.partSetHeader))
          obj.partSetHeader = exports.PartSetHeader.fromJSON(object.partSetHeader);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = (0, helpers_1.base64FromBytes)(message.hash !== void 0 ? message.hash : new Uint8Array()));
        message.partSetHeader !== void 0 && (obj.partSetHeader = message.partSetHeader ? exports.PartSetHeader.toJSON(message.partSetHeader) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBlockID();
        message.hash = object.hash ?? new Uint8Array();
        if (object.partSetHeader !== void 0 && object.partSetHeader !== null) {
          message.partSetHeader = exports.PartSetHeader.fromPartial(object.partSetHeader);
        }
        return message;
      }
    };
    function createBaseHeader() {
      return {
        version: types_1.Consensus.fromPartial({}),
        chainId: "",
        height: BigInt(0),
        time: timestamp_1.Timestamp.fromPartial({}),
        lastBlockId: exports.BlockID.fromPartial({}),
        lastCommitHash: new Uint8Array(),
        dataHash: new Uint8Array(),
        validatorsHash: new Uint8Array(),
        nextValidatorsHash: new Uint8Array(),
        consensusHash: new Uint8Array(),
        appHash: new Uint8Array(),
        lastResultsHash: new Uint8Array(),
        evidenceHash: new Uint8Array(),
        proposerAddress: new Uint8Array()
      };
    }
    exports.Header = {
      typeUrl: "/tendermint.types.Header",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.version !== void 0) {
          types_1.Consensus.encode(message.version, writer.uint32(10).fork()).ldelim();
        }
        if (message.chainId !== "") {
          writer.uint32(18).string(message.chainId);
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(24).int64(message.height);
        }
        if (message.time !== void 0) {
          timestamp_1.Timestamp.encode(message.time, writer.uint32(34).fork()).ldelim();
        }
        if (message.lastBlockId !== void 0) {
          exports.BlockID.encode(message.lastBlockId, writer.uint32(42).fork()).ldelim();
        }
        if (message.lastCommitHash.length !== 0) {
          writer.uint32(50).bytes(message.lastCommitHash);
        }
        if (message.dataHash.length !== 0) {
          writer.uint32(58).bytes(message.dataHash);
        }
        if (message.validatorsHash.length !== 0) {
          writer.uint32(66).bytes(message.validatorsHash);
        }
        if (message.nextValidatorsHash.length !== 0) {
          writer.uint32(74).bytes(message.nextValidatorsHash);
        }
        if (message.consensusHash.length !== 0) {
          writer.uint32(82).bytes(message.consensusHash);
        }
        if (message.appHash.length !== 0) {
          writer.uint32(90).bytes(message.appHash);
        }
        if (message.lastResultsHash.length !== 0) {
          writer.uint32(98).bytes(message.lastResultsHash);
        }
        if (message.evidenceHash.length !== 0) {
          writer.uint32(106).bytes(message.evidenceHash);
        }
        if (message.proposerAddress.length !== 0) {
          writer.uint32(114).bytes(message.proposerAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseHeader();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.version = types_1.Consensus.decode(reader, reader.uint32());
              break;
            case 2:
              message.chainId = reader.string();
              break;
            case 3:
              message.height = reader.int64();
              break;
            case 4:
              message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 5:
              message.lastBlockId = exports.BlockID.decode(reader, reader.uint32());
              break;
            case 6:
              message.lastCommitHash = reader.bytes();
              break;
            case 7:
              message.dataHash = reader.bytes();
              break;
            case 8:
              message.validatorsHash = reader.bytes();
              break;
            case 9:
              message.nextValidatorsHash = reader.bytes();
              break;
            case 10:
              message.consensusHash = reader.bytes();
              break;
            case 11:
              message.appHash = reader.bytes();
              break;
            case 12:
              message.lastResultsHash = reader.bytes();
              break;
            case 13:
              message.evidenceHash = reader.bytes();
              break;
            case 14:
              message.proposerAddress = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseHeader();
        if ((0, helpers_1.isSet)(object.version))
          obj.version = types_1.Consensus.fromJSON(object.version);
        if ((0, helpers_1.isSet)(object.chainId))
          obj.chainId = String(object.chainId);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.time))
          obj.time = (0, helpers_1.fromJsonTimestamp)(object.time);
        if ((0, helpers_1.isSet)(object.lastBlockId))
          obj.lastBlockId = exports.BlockID.fromJSON(object.lastBlockId);
        if ((0, helpers_1.isSet)(object.lastCommitHash))
          obj.lastCommitHash = (0, helpers_1.bytesFromBase64)(object.lastCommitHash);
        if ((0, helpers_1.isSet)(object.dataHash))
          obj.dataHash = (0, helpers_1.bytesFromBase64)(object.dataHash);
        if ((0, helpers_1.isSet)(object.validatorsHash))
          obj.validatorsHash = (0, helpers_1.bytesFromBase64)(object.validatorsHash);
        if ((0, helpers_1.isSet)(object.nextValidatorsHash))
          obj.nextValidatorsHash = (0, helpers_1.bytesFromBase64)(object.nextValidatorsHash);
        if ((0, helpers_1.isSet)(object.consensusHash))
          obj.consensusHash = (0, helpers_1.bytesFromBase64)(object.consensusHash);
        if ((0, helpers_1.isSet)(object.appHash))
          obj.appHash = (0, helpers_1.bytesFromBase64)(object.appHash);
        if ((0, helpers_1.isSet)(object.lastResultsHash))
          obj.lastResultsHash = (0, helpers_1.bytesFromBase64)(object.lastResultsHash);
        if ((0, helpers_1.isSet)(object.evidenceHash))
          obj.evidenceHash = (0, helpers_1.bytesFromBase64)(object.evidenceHash);
        if ((0, helpers_1.isSet)(object.proposerAddress))
          obj.proposerAddress = (0, helpers_1.bytesFromBase64)(object.proposerAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.version !== void 0 && (obj.version = message.version ? types_1.Consensus.toJSON(message.version) : void 0);
        message.chainId !== void 0 && (obj.chainId = message.chainId);
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.time !== void 0 && (obj.time = (0, helpers_1.fromTimestamp)(message.time).toISOString());
        message.lastBlockId !== void 0 && (obj.lastBlockId = message.lastBlockId ? exports.BlockID.toJSON(message.lastBlockId) : void 0);
        message.lastCommitHash !== void 0 && (obj.lastCommitHash = (0, helpers_1.base64FromBytes)(message.lastCommitHash !== void 0 ? message.lastCommitHash : new Uint8Array()));
        message.dataHash !== void 0 && (obj.dataHash = (0, helpers_1.base64FromBytes)(message.dataHash !== void 0 ? message.dataHash : new Uint8Array()));
        message.validatorsHash !== void 0 && (obj.validatorsHash = (0, helpers_1.base64FromBytes)(message.validatorsHash !== void 0 ? message.validatorsHash : new Uint8Array()));
        message.nextValidatorsHash !== void 0 && (obj.nextValidatorsHash = (0, helpers_1.base64FromBytes)(message.nextValidatorsHash !== void 0 ? message.nextValidatorsHash : new Uint8Array()));
        message.consensusHash !== void 0 && (obj.consensusHash = (0, helpers_1.base64FromBytes)(message.consensusHash !== void 0 ? message.consensusHash : new Uint8Array()));
        message.appHash !== void 0 && (obj.appHash = (0, helpers_1.base64FromBytes)(message.appHash !== void 0 ? message.appHash : new Uint8Array()));
        message.lastResultsHash !== void 0 && (obj.lastResultsHash = (0, helpers_1.base64FromBytes)(message.lastResultsHash !== void 0 ? message.lastResultsHash : new Uint8Array()));
        message.evidenceHash !== void 0 && (obj.evidenceHash = (0, helpers_1.base64FromBytes)(message.evidenceHash !== void 0 ? message.evidenceHash : new Uint8Array()));
        message.proposerAddress !== void 0 && (obj.proposerAddress = (0, helpers_1.base64FromBytes)(message.proposerAddress !== void 0 ? message.proposerAddress : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseHeader();
        if (object.version !== void 0 && object.version !== null) {
          message.version = types_1.Consensus.fromPartial(object.version);
        }
        message.chainId = object.chainId ?? "";
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        if (object.time !== void 0 && object.time !== null) {
          message.time = timestamp_1.Timestamp.fromPartial(object.time);
        }
        if (object.lastBlockId !== void 0 && object.lastBlockId !== null) {
          message.lastBlockId = exports.BlockID.fromPartial(object.lastBlockId);
        }
        message.lastCommitHash = object.lastCommitHash ?? new Uint8Array();
        message.dataHash = object.dataHash ?? new Uint8Array();
        message.validatorsHash = object.validatorsHash ?? new Uint8Array();
        message.nextValidatorsHash = object.nextValidatorsHash ?? new Uint8Array();
        message.consensusHash = object.consensusHash ?? new Uint8Array();
        message.appHash = object.appHash ?? new Uint8Array();
        message.lastResultsHash = object.lastResultsHash ?? new Uint8Array();
        message.evidenceHash = object.evidenceHash ?? new Uint8Array();
        message.proposerAddress = object.proposerAddress ?? new Uint8Array();
        return message;
      }
    };
    function createBaseData() {
      return {
        txs: []
      };
    }
    exports.Data = {
      typeUrl: "/tendermint.types.Data",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.txs) {
          writer.uint32(10).bytes(v9);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseData();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txs.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseData();
        if (Array.isArray(object?.txs))
          obj.txs = object.txs.map((e) => (0, helpers_1.bytesFromBase64)(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.txs) {
          obj.txs = message.txs.map((e) => (0, helpers_1.base64FromBytes)(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.txs = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseData();
        message.txs = object.txs?.map((e) => e) || [];
        return message;
      }
    };
    function createBaseVote() {
      return {
        type: 0,
        height: BigInt(0),
        round: 0,
        blockId: exports.BlockID.fromPartial({}),
        timestamp: timestamp_1.Timestamp.fromPartial({}),
        validatorAddress: new Uint8Array(),
        validatorIndex: 0,
        signature: new Uint8Array(),
        extension: new Uint8Array(),
        extensionSignature: new Uint8Array()
      };
    }
    exports.Vote = {
      typeUrl: "/tendermint.types.Vote",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.type !== 0) {
          writer.uint32(8).int32(message.type);
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(16).int64(message.height);
        }
        if (message.round !== 0) {
          writer.uint32(24).int32(message.round);
        }
        if (message.blockId !== void 0) {
          exports.BlockID.encode(message.blockId, writer.uint32(34).fork()).ldelim();
        }
        if (message.timestamp !== void 0) {
          timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(42).fork()).ldelim();
        }
        if (message.validatorAddress.length !== 0) {
          writer.uint32(50).bytes(message.validatorAddress);
        }
        if (message.validatorIndex !== 0) {
          writer.uint32(56).int32(message.validatorIndex);
        }
        if (message.signature.length !== 0) {
          writer.uint32(66).bytes(message.signature);
        }
        if (message.extension.length !== 0) {
          writer.uint32(74).bytes(message.extension);
        }
        if (message.extensionSignature.length !== 0) {
          writer.uint32(82).bytes(message.extensionSignature);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVote();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.type = reader.int32();
              break;
            case 2:
              message.height = reader.int64();
              break;
            case 3:
              message.round = reader.int32();
              break;
            case 4:
              message.blockId = exports.BlockID.decode(reader, reader.uint32());
              break;
            case 5:
              message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 6:
              message.validatorAddress = reader.bytes();
              break;
            case 7:
              message.validatorIndex = reader.int32();
              break;
            case 8:
              message.signature = reader.bytes();
              break;
            case 9:
              message.extension = reader.bytes();
              break;
            case 10:
              message.extensionSignature = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseVote();
        if ((0, helpers_1.isSet)(object.type))
          obj.type = signedMsgTypeFromJSON(object.type);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.round))
          obj.round = Number(object.round);
        if ((0, helpers_1.isSet)(object.blockId))
          obj.blockId = exports.BlockID.fromJSON(object.blockId);
        if ((0, helpers_1.isSet)(object.timestamp))
          obj.timestamp = (0, helpers_1.fromJsonTimestamp)(object.timestamp);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = (0, helpers_1.bytesFromBase64)(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.validatorIndex))
          obj.validatorIndex = Number(object.validatorIndex);
        if ((0, helpers_1.isSet)(object.signature))
          obj.signature = (0, helpers_1.bytesFromBase64)(object.signature);
        if ((0, helpers_1.isSet)(object.extension))
          obj.extension = (0, helpers_1.bytesFromBase64)(object.extension);
        if ((0, helpers_1.isSet)(object.extensionSignature))
          obj.extensionSignature = (0, helpers_1.bytesFromBase64)(object.extensionSignature);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.type !== void 0 && (obj.type = signedMsgTypeToJSON(message.type));
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.round !== void 0 && (obj.round = Math.round(message.round));
        message.blockId !== void 0 && (obj.blockId = message.blockId ? exports.BlockID.toJSON(message.blockId) : void 0);
        message.timestamp !== void 0 && (obj.timestamp = (0, helpers_1.fromTimestamp)(message.timestamp).toISOString());
        message.validatorAddress !== void 0 && (obj.validatorAddress = (0, helpers_1.base64FromBytes)(message.validatorAddress !== void 0 ? message.validatorAddress : new Uint8Array()));
        message.validatorIndex !== void 0 && (obj.validatorIndex = Math.round(message.validatorIndex));
        message.signature !== void 0 && (obj.signature = (0, helpers_1.base64FromBytes)(message.signature !== void 0 ? message.signature : new Uint8Array()));
        message.extension !== void 0 && (obj.extension = (0, helpers_1.base64FromBytes)(message.extension !== void 0 ? message.extension : new Uint8Array()));
        message.extensionSignature !== void 0 && (obj.extensionSignature = (0, helpers_1.base64FromBytes)(message.extensionSignature !== void 0 ? message.extensionSignature : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseVote();
        message.type = object.type ?? 0;
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        message.round = object.round ?? 0;
        if (object.blockId !== void 0 && object.blockId !== null) {
          message.blockId = exports.BlockID.fromPartial(object.blockId);
        }
        if (object.timestamp !== void 0 && object.timestamp !== null) {
          message.timestamp = timestamp_1.Timestamp.fromPartial(object.timestamp);
        }
        message.validatorAddress = object.validatorAddress ?? new Uint8Array();
        message.validatorIndex = object.validatorIndex ?? 0;
        message.signature = object.signature ?? new Uint8Array();
        message.extension = object.extension ?? new Uint8Array();
        message.extensionSignature = object.extensionSignature ?? new Uint8Array();
        return message;
      }
    };
    function createBaseCommit() {
      return {
        height: BigInt(0),
        round: 0,
        blockId: exports.BlockID.fromPartial({}),
        signatures: []
      };
    }
    exports.Commit = {
      typeUrl: "/tendermint.types.Commit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== BigInt(0)) {
          writer.uint32(8).int64(message.height);
        }
        if (message.round !== 0) {
          writer.uint32(16).int32(message.round);
        }
        if (message.blockId !== void 0) {
          exports.BlockID.encode(message.blockId, writer.uint32(26).fork()).ldelim();
        }
        for (const v9 of message.signatures) {
          exports.CommitSig.encode(v9, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = reader.int64();
              break;
            case 2:
              message.round = reader.int32();
              break;
            case 3:
              message.blockId = exports.BlockID.decode(reader, reader.uint32());
              break;
            case 4:
              message.signatures.push(exports.CommitSig.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCommit();
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.round))
          obj.round = Number(object.round);
        if ((0, helpers_1.isSet)(object.blockId))
          obj.blockId = exports.BlockID.fromJSON(object.blockId);
        if (Array.isArray(object?.signatures))
          obj.signatures = object.signatures.map((e) => exports.CommitSig.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.round !== void 0 && (obj.round = Math.round(message.round));
        message.blockId !== void 0 && (obj.blockId = message.blockId ? exports.BlockID.toJSON(message.blockId) : void 0);
        if (message.signatures) {
          obj.signatures = message.signatures.map((e) => e ? exports.CommitSig.toJSON(e) : void 0);
        } else {
          obj.signatures = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCommit();
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        message.round = object.round ?? 0;
        if (object.blockId !== void 0 && object.blockId !== null) {
          message.blockId = exports.BlockID.fromPartial(object.blockId);
        }
        message.signatures = object.signatures?.map((e) => exports.CommitSig.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseCommitSig() {
      return {
        blockIdFlag: 0,
        validatorAddress: new Uint8Array(),
        timestamp: timestamp_1.Timestamp.fromPartial({}),
        signature: new Uint8Array()
      };
    }
    exports.CommitSig = {
      typeUrl: "/tendermint.types.CommitSig",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.blockIdFlag !== 0) {
          writer.uint32(8).int32(message.blockIdFlag);
        }
        if (message.validatorAddress.length !== 0) {
          writer.uint32(18).bytes(message.validatorAddress);
        }
        if (message.timestamp !== void 0) {
          timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(26).fork()).ldelim();
        }
        if (message.signature.length !== 0) {
          writer.uint32(34).bytes(message.signature);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommitSig();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.blockIdFlag = reader.int32();
              break;
            case 2:
              message.validatorAddress = reader.bytes();
              break;
            case 3:
              message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 4:
              message.signature = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCommitSig();
        if ((0, helpers_1.isSet)(object.blockIdFlag))
          obj.blockIdFlag = (0, validator_1.blockIDFlagFromJSON)(object.blockIdFlag);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = (0, helpers_1.bytesFromBase64)(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.timestamp))
          obj.timestamp = (0, helpers_1.fromJsonTimestamp)(object.timestamp);
        if ((0, helpers_1.isSet)(object.signature))
          obj.signature = (0, helpers_1.bytesFromBase64)(object.signature);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.blockIdFlag !== void 0 && (obj.blockIdFlag = (0, validator_1.blockIDFlagToJSON)(message.blockIdFlag));
        message.validatorAddress !== void 0 && (obj.validatorAddress = (0, helpers_1.base64FromBytes)(message.validatorAddress !== void 0 ? message.validatorAddress : new Uint8Array()));
        message.timestamp !== void 0 && (obj.timestamp = (0, helpers_1.fromTimestamp)(message.timestamp).toISOString());
        message.signature !== void 0 && (obj.signature = (0, helpers_1.base64FromBytes)(message.signature !== void 0 ? message.signature : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCommitSig();
        message.blockIdFlag = object.blockIdFlag ?? 0;
        message.validatorAddress = object.validatorAddress ?? new Uint8Array();
        if (object.timestamp !== void 0 && object.timestamp !== null) {
          message.timestamp = timestamp_1.Timestamp.fromPartial(object.timestamp);
        }
        message.signature = object.signature ?? new Uint8Array();
        return message;
      }
    };
    function createBaseExtendedCommit() {
      return {
        height: BigInt(0),
        round: 0,
        blockId: exports.BlockID.fromPartial({}),
        extendedSignatures: []
      };
    }
    exports.ExtendedCommit = {
      typeUrl: "/tendermint.types.ExtendedCommit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== BigInt(0)) {
          writer.uint32(8).int64(message.height);
        }
        if (message.round !== 0) {
          writer.uint32(16).int32(message.round);
        }
        if (message.blockId !== void 0) {
          exports.BlockID.encode(message.blockId, writer.uint32(26).fork()).ldelim();
        }
        for (const v9 of message.extendedSignatures) {
          exports.ExtendedCommitSig.encode(v9, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseExtendedCommit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = reader.int64();
              break;
            case 2:
              message.round = reader.int32();
              break;
            case 3:
              message.blockId = exports.BlockID.decode(reader, reader.uint32());
              break;
            case 4:
              message.extendedSignatures.push(exports.ExtendedCommitSig.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseExtendedCommit();
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.round))
          obj.round = Number(object.round);
        if ((0, helpers_1.isSet)(object.blockId))
          obj.blockId = exports.BlockID.fromJSON(object.blockId);
        if (Array.isArray(object?.extendedSignatures))
          obj.extendedSignatures = object.extendedSignatures.map((e) => exports.ExtendedCommitSig.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.round !== void 0 && (obj.round = Math.round(message.round));
        message.blockId !== void 0 && (obj.blockId = message.blockId ? exports.BlockID.toJSON(message.blockId) : void 0);
        if (message.extendedSignatures) {
          obj.extendedSignatures = message.extendedSignatures.map((e) => e ? exports.ExtendedCommitSig.toJSON(e) : void 0);
        } else {
          obj.extendedSignatures = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseExtendedCommit();
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        message.round = object.round ?? 0;
        if (object.blockId !== void 0 && object.blockId !== null) {
          message.blockId = exports.BlockID.fromPartial(object.blockId);
        }
        message.extendedSignatures = object.extendedSignatures?.map((e) => exports.ExtendedCommitSig.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseExtendedCommitSig() {
      return {
        blockIdFlag: 0,
        validatorAddress: new Uint8Array(),
        timestamp: timestamp_1.Timestamp.fromPartial({}),
        signature: new Uint8Array(),
        extension: new Uint8Array(),
        extensionSignature: new Uint8Array()
      };
    }
    exports.ExtendedCommitSig = {
      typeUrl: "/tendermint.types.ExtendedCommitSig",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.blockIdFlag !== 0) {
          writer.uint32(8).int32(message.blockIdFlag);
        }
        if (message.validatorAddress.length !== 0) {
          writer.uint32(18).bytes(message.validatorAddress);
        }
        if (message.timestamp !== void 0) {
          timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(26).fork()).ldelim();
        }
        if (message.signature.length !== 0) {
          writer.uint32(34).bytes(message.signature);
        }
        if (message.extension.length !== 0) {
          writer.uint32(42).bytes(message.extension);
        }
        if (message.extensionSignature.length !== 0) {
          writer.uint32(50).bytes(message.extensionSignature);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseExtendedCommitSig();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.blockIdFlag = reader.int32();
              break;
            case 2:
              message.validatorAddress = reader.bytes();
              break;
            case 3:
              message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 4:
              message.signature = reader.bytes();
              break;
            case 5:
              message.extension = reader.bytes();
              break;
            case 6:
              message.extensionSignature = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseExtendedCommitSig();
        if ((0, helpers_1.isSet)(object.blockIdFlag))
          obj.blockIdFlag = (0, validator_1.blockIDFlagFromJSON)(object.blockIdFlag);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = (0, helpers_1.bytesFromBase64)(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.timestamp))
          obj.timestamp = (0, helpers_1.fromJsonTimestamp)(object.timestamp);
        if ((0, helpers_1.isSet)(object.signature))
          obj.signature = (0, helpers_1.bytesFromBase64)(object.signature);
        if ((0, helpers_1.isSet)(object.extension))
          obj.extension = (0, helpers_1.bytesFromBase64)(object.extension);
        if ((0, helpers_1.isSet)(object.extensionSignature))
          obj.extensionSignature = (0, helpers_1.bytesFromBase64)(object.extensionSignature);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.blockIdFlag !== void 0 && (obj.blockIdFlag = (0, validator_1.blockIDFlagToJSON)(message.blockIdFlag));
        message.validatorAddress !== void 0 && (obj.validatorAddress = (0, helpers_1.base64FromBytes)(message.validatorAddress !== void 0 ? message.validatorAddress : new Uint8Array()));
        message.timestamp !== void 0 && (obj.timestamp = (0, helpers_1.fromTimestamp)(message.timestamp).toISOString());
        message.signature !== void 0 && (obj.signature = (0, helpers_1.base64FromBytes)(message.signature !== void 0 ? message.signature : new Uint8Array()));
        message.extension !== void 0 && (obj.extension = (0, helpers_1.base64FromBytes)(message.extension !== void 0 ? message.extension : new Uint8Array()));
        message.extensionSignature !== void 0 && (obj.extensionSignature = (0, helpers_1.base64FromBytes)(message.extensionSignature !== void 0 ? message.extensionSignature : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseExtendedCommitSig();
        message.blockIdFlag = object.blockIdFlag ?? 0;
        message.validatorAddress = object.validatorAddress ?? new Uint8Array();
        if (object.timestamp !== void 0 && object.timestamp !== null) {
          message.timestamp = timestamp_1.Timestamp.fromPartial(object.timestamp);
        }
        message.signature = object.signature ?? new Uint8Array();
        message.extension = object.extension ?? new Uint8Array();
        message.extensionSignature = object.extensionSignature ?? new Uint8Array();
        return message;
      }
    };
    function createBaseProposal() {
      return {
        type: 0,
        height: BigInt(0),
        round: 0,
        polRound: 0,
        blockId: exports.BlockID.fromPartial({}),
        timestamp: timestamp_1.Timestamp.fromPartial({}),
        signature: new Uint8Array()
      };
    }
    exports.Proposal = {
      typeUrl: "/tendermint.types.Proposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.type !== 0) {
          writer.uint32(8).int32(message.type);
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(16).int64(message.height);
        }
        if (message.round !== 0) {
          writer.uint32(24).int32(message.round);
        }
        if (message.polRound !== 0) {
          writer.uint32(32).int32(message.polRound);
        }
        if (message.blockId !== void 0) {
          exports.BlockID.encode(message.blockId, writer.uint32(42).fork()).ldelim();
        }
        if (message.timestamp !== void 0) {
          timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(50).fork()).ldelim();
        }
        if (message.signature.length !== 0) {
          writer.uint32(58).bytes(message.signature);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.type = reader.int32();
              break;
            case 2:
              message.height = reader.int64();
              break;
            case 3:
              message.round = reader.int32();
              break;
            case 4:
              message.polRound = reader.int32();
              break;
            case 5:
              message.blockId = exports.BlockID.decode(reader, reader.uint32());
              break;
            case 6:
              message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 7:
              message.signature = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseProposal();
        if ((0, helpers_1.isSet)(object.type))
          obj.type = signedMsgTypeFromJSON(object.type);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.round))
          obj.round = Number(object.round);
        if ((0, helpers_1.isSet)(object.polRound))
          obj.polRound = Number(object.polRound);
        if ((0, helpers_1.isSet)(object.blockId))
          obj.blockId = exports.BlockID.fromJSON(object.blockId);
        if ((0, helpers_1.isSet)(object.timestamp))
          obj.timestamp = (0, helpers_1.fromJsonTimestamp)(object.timestamp);
        if ((0, helpers_1.isSet)(object.signature))
          obj.signature = (0, helpers_1.bytesFromBase64)(object.signature);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.type !== void 0 && (obj.type = signedMsgTypeToJSON(message.type));
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.round !== void 0 && (obj.round = Math.round(message.round));
        message.polRound !== void 0 && (obj.polRound = Math.round(message.polRound));
        message.blockId !== void 0 && (obj.blockId = message.blockId ? exports.BlockID.toJSON(message.blockId) : void 0);
        message.timestamp !== void 0 && (obj.timestamp = (0, helpers_1.fromTimestamp)(message.timestamp).toISOString());
        message.signature !== void 0 && (obj.signature = (0, helpers_1.base64FromBytes)(message.signature !== void 0 ? message.signature : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseProposal();
        message.type = object.type ?? 0;
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        message.round = object.round ?? 0;
        message.polRound = object.polRound ?? 0;
        if (object.blockId !== void 0 && object.blockId !== null) {
          message.blockId = exports.BlockID.fromPartial(object.blockId);
        }
        if (object.timestamp !== void 0 && object.timestamp !== null) {
          message.timestamp = timestamp_1.Timestamp.fromPartial(object.timestamp);
        }
        message.signature = object.signature ?? new Uint8Array();
        return message;
      }
    };
    function createBaseSignedHeader() {
      return {
        header: void 0,
        commit: void 0
      };
    }
    exports.SignedHeader = {
      typeUrl: "/tendermint.types.SignedHeader",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.header !== void 0) {
          exports.Header.encode(message.header, writer.uint32(10).fork()).ldelim();
        }
        if (message.commit !== void 0) {
          exports.Commit.encode(message.commit, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSignedHeader();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.header = exports.Header.decode(reader, reader.uint32());
              break;
            case 2:
              message.commit = exports.Commit.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSignedHeader();
        if ((0, helpers_1.isSet)(object.header))
          obj.header = exports.Header.fromJSON(object.header);
        if ((0, helpers_1.isSet)(object.commit))
          obj.commit = exports.Commit.fromJSON(object.commit);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.header !== void 0 && (obj.header = message.header ? exports.Header.toJSON(message.header) : void 0);
        message.commit !== void 0 && (obj.commit = message.commit ? exports.Commit.toJSON(message.commit) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSignedHeader();
        if (object.header !== void 0 && object.header !== null) {
          message.header = exports.Header.fromPartial(object.header);
        }
        if (object.commit !== void 0 && object.commit !== null) {
          message.commit = exports.Commit.fromPartial(object.commit);
        }
        return message;
      }
    };
    function createBaseLightBlock() {
      return {
        signedHeader: void 0,
        validatorSet: void 0
      };
    }
    exports.LightBlock = {
      typeUrl: "/tendermint.types.LightBlock",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.signedHeader !== void 0) {
          exports.SignedHeader.encode(message.signedHeader, writer.uint32(10).fork()).ldelim();
        }
        if (message.validatorSet !== void 0) {
          validator_1.ValidatorSet.encode(message.validatorSet, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLightBlock();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signedHeader = exports.SignedHeader.decode(reader, reader.uint32());
              break;
            case 2:
              message.validatorSet = validator_1.ValidatorSet.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseLightBlock();
        if ((0, helpers_1.isSet)(object.signedHeader))
          obj.signedHeader = exports.SignedHeader.fromJSON(object.signedHeader);
        if ((0, helpers_1.isSet)(object.validatorSet))
          obj.validatorSet = validator_1.ValidatorSet.fromJSON(object.validatorSet);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.signedHeader !== void 0 && (obj.signedHeader = message.signedHeader ? exports.SignedHeader.toJSON(message.signedHeader) : void 0);
        message.validatorSet !== void 0 && (obj.validatorSet = message.validatorSet ? validator_1.ValidatorSet.toJSON(message.validatorSet) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseLightBlock();
        if (object.signedHeader !== void 0 && object.signedHeader !== null) {
          message.signedHeader = exports.SignedHeader.fromPartial(object.signedHeader);
        }
        if (object.validatorSet !== void 0 && object.validatorSet !== null) {
          message.validatorSet = validator_1.ValidatorSet.fromPartial(object.validatorSet);
        }
        return message;
      }
    };
    function createBaseBlockMeta() {
      return {
        blockId: exports.BlockID.fromPartial({}),
        blockSize: BigInt(0),
        header: exports.Header.fromPartial({}),
        numTxs: BigInt(0)
      };
    }
    exports.BlockMeta = {
      typeUrl: "/tendermint.types.BlockMeta",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.blockId !== void 0) {
          exports.BlockID.encode(message.blockId, writer.uint32(10).fork()).ldelim();
        }
        if (message.blockSize !== BigInt(0)) {
          writer.uint32(16).int64(message.blockSize);
        }
        if (message.header !== void 0) {
          exports.Header.encode(message.header, writer.uint32(26).fork()).ldelim();
        }
        if (message.numTxs !== BigInt(0)) {
          writer.uint32(32).int64(message.numTxs);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBlockMeta();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.blockId = exports.BlockID.decode(reader, reader.uint32());
              break;
            case 2:
              message.blockSize = reader.int64();
              break;
            case 3:
              message.header = exports.Header.decode(reader, reader.uint32());
              break;
            case 4:
              message.numTxs = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBlockMeta();
        if ((0, helpers_1.isSet)(object.blockId))
          obj.blockId = exports.BlockID.fromJSON(object.blockId);
        if ((0, helpers_1.isSet)(object.blockSize))
          obj.blockSize = BigInt(object.blockSize.toString());
        if ((0, helpers_1.isSet)(object.header))
          obj.header = exports.Header.fromJSON(object.header);
        if ((0, helpers_1.isSet)(object.numTxs))
          obj.numTxs = BigInt(object.numTxs.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.blockId !== void 0 && (obj.blockId = message.blockId ? exports.BlockID.toJSON(message.blockId) : void 0);
        message.blockSize !== void 0 && (obj.blockSize = (message.blockSize || BigInt(0)).toString());
        message.header !== void 0 && (obj.header = message.header ? exports.Header.toJSON(message.header) : void 0);
        message.numTxs !== void 0 && (obj.numTxs = (message.numTxs || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBlockMeta();
        if (object.blockId !== void 0 && object.blockId !== null) {
          message.blockId = exports.BlockID.fromPartial(object.blockId);
        }
        if (object.blockSize !== void 0 && object.blockSize !== null) {
          message.blockSize = BigInt(object.blockSize.toString());
        }
        if (object.header !== void 0 && object.header !== null) {
          message.header = exports.Header.fromPartial(object.header);
        }
        if (object.numTxs !== void 0 && object.numTxs !== null) {
          message.numTxs = BigInt(object.numTxs.toString());
        }
        return message;
      }
    };
    function createBaseTxProof() {
      return {
        rootHash: new Uint8Array(),
        data: new Uint8Array(),
        proof: void 0
      };
    }
    exports.TxProof = {
      typeUrl: "/tendermint.types.TxProof",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.rootHash.length !== 0) {
          writer.uint32(10).bytes(message.rootHash);
        }
        if (message.data.length !== 0) {
          writer.uint32(18).bytes(message.data);
        }
        if (message.proof !== void 0) {
          proof_1.Proof.encode(message.proof, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxProof();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rootHash = reader.bytes();
              break;
            case 2:
              message.data = reader.bytes();
              break;
            case 3:
              message.proof = proof_1.Proof.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxProof();
        if ((0, helpers_1.isSet)(object.rootHash))
          obj.rootHash = (0, helpers_1.bytesFromBase64)(object.rootHash);
        if ((0, helpers_1.isSet)(object.data))
          obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        if ((0, helpers_1.isSet)(object.proof))
          obj.proof = proof_1.Proof.fromJSON(object.proof);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.rootHash !== void 0 && (obj.rootHash = (0, helpers_1.base64FromBytes)(message.rootHash !== void 0 ? message.rootHash : new Uint8Array()));
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        message.proof !== void 0 && (obj.proof = message.proof ? proof_1.Proof.toJSON(message.proof) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxProof();
        message.rootHash = object.rootHash ?? new Uint8Array();
        message.data = object.data ?? new Uint8Array();
        if (object.proof !== void 0 && object.proof !== null) {
          message.proof = proof_1.Proof.fromPartial(object.proof);
        }
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/lightclients/tendermint/v1/tendermint.js
var require_tendermint = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/ibc/lightclients/tendermint/v1/tendermint.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Fraction = exports.Header = exports.Misbehaviour = exports.ConsensusState = exports.ClientState = exports.protobufPackage = void 0;
    var duration_1 = require_duration();
    var client_1 = require_client();
    var proofs_1 = require_proofs();
    var timestamp_1 = require_timestamp();
    var commitment_1 = require_commitment();
    var types_1 = require_types3();
    var validator_1 = require_validator();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "ibc.lightclients.tendermint.v1";
    function createBaseClientState() {
      return {
        chainId: "",
        trustLevel: exports.Fraction.fromPartial({}),
        trustingPeriod: duration_1.Duration.fromPartial({}),
        unbondingPeriod: duration_1.Duration.fromPartial({}),
        maxClockDrift: duration_1.Duration.fromPartial({}),
        frozenHeight: client_1.Height.fromPartial({}),
        latestHeight: client_1.Height.fromPartial({}),
        proofSpecs: [],
        upgradePath: [],
        allowUpdateAfterExpiry: false,
        allowUpdateAfterMisbehaviour: false
      };
    }
    exports.ClientState = {
      typeUrl: "/ibc.lightclients.tendermint.v1.ClientState",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.chainId !== "") {
          writer.uint32(10).string(message.chainId);
        }
        if (message.trustLevel !== void 0) {
          exports.Fraction.encode(message.trustLevel, writer.uint32(18).fork()).ldelim();
        }
        if (message.trustingPeriod !== void 0) {
          duration_1.Duration.encode(message.trustingPeriod, writer.uint32(26).fork()).ldelim();
        }
        if (message.unbondingPeriod !== void 0) {
          duration_1.Duration.encode(message.unbondingPeriod, writer.uint32(34).fork()).ldelim();
        }
        if (message.maxClockDrift !== void 0) {
          duration_1.Duration.encode(message.maxClockDrift, writer.uint32(42).fork()).ldelim();
        }
        if (message.frozenHeight !== void 0) {
          client_1.Height.encode(message.frozenHeight, writer.uint32(50).fork()).ldelim();
        }
        if (message.latestHeight !== void 0) {
          client_1.Height.encode(message.latestHeight, writer.uint32(58).fork()).ldelim();
        }
        for (const v9 of message.proofSpecs) {
          proofs_1.ProofSpec.encode(v9, writer.uint32(66).fork()).ldelim();
        }
        for (const v9 of message.upgradePath) {
          writer.uint32(74).string(v9);
        }
        if (message.allowUpdateAfterExpiry === true) {
          writer.uint32(80).bool(message.allowUpdateAfterExpiry);
        }
        if (message.allowUpdateAfterMisbehaviour === true) {
          writer.uint32(88).bool(message.allowUpdateAfterMisbehaviour);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseClientState();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.chainId = reader.string();
              break;
            case 2:
              message.trustLevel = exports.Fraction.decode(reader, reader.uint32());
              break;
            case 3:
              message.trustingPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 4:
              message.unbondingPeriod = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 5:
              message.maxClockDrift = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 6:
              message.frozenHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 7:
              message.latestHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 8:
              message.proofSpecs.push(proofs_1.ProofSpec.decode(reader, reader.uint32()));
              break;
            case 9:
              message.upgradePath.push(reader.string());
              break;
            case 10:
              message.allowUpdateAfterExpiry = reader.bool();
              break;
            case 11:
              message.allowUpdateAfterMisbehaviour = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseClientState();
        if ((0, helpers_1.isSet)(object.chainId))
          obj.chainId = String(object.chainId);
        if ((0, helpers_1.isSet)(object.trustLevel))
          obj.trustLevel = exports.Fraction.fromJSON(object.trustLevel);
        if ((0, helpers_1.isSet)(object.trustingPeriod))
          obj.trustingPeriod = duration_1.Duration.fromJSON(object.trustingPeriod);
        if ((0, helpers_1.isSet)(object.unbondingPeriod))
          obj.unbondingPeriod = duration_1.Duration.fromJSON(object.unbondingPeriod);
        if ((0, helpers_1.isSet)(object.maxClockDrift))
          obj.maxClockDrift = duration_1.Duration.fromJSON(object.maxClockDrift);
        if ((0, helpers_1.isSet)(object.frozenHeight))
          obj.frozenHeight = client_1.Height.fromJSON(object.frozenHeight);
        if ((0, helpers_1.isSet)(object.latestHeight))
          obj.latestHeight = client_1.Height.fromJSON(object.latestHeight);
        if (Array.isArray(object?.proofSpecs))
          obj.proofSpecs = object.proofSpecs.map((e) => proofs_1.ProofSpec.fromJSON(e));
        if (Array.isArray(object?.upgradePath))
          obj.upgradePath = object.upgradePath.map((e) => String(e));
        if ((0, helpers_1.isSet)(object.allowUpdateAfterExpiry))
          obj.allowUpdateAfterExpiry = Boolean(object.allowUpdateAfterExpiry);
        if ((0, helpers_1.isSet)(object.allowUpdateAfterMisbehaviour))
          obj.allowUpdateAfterMisbehaviour = Boolean(object.allowUpdateAfterMisbehaviour);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.chainId !== void 0 && (obj.chainId = message.chainId);
        message.trustLevel !== void 0 && (obj.trustLevel = message.trustLevel ? exports.Fraction.toJSON(message.trustLevel) : void 0);
        message.trustingPeriod !== void 0 && (obj.trustingPeriod = message.trustingPeriod ? duration_1.Duration.toJSON(message.trustingPeriod) : void 0);
        message.unbondingPeriod !== void 0 && (obj.unbondingPeriod = message.unbondingPeriod ? duration_1.Duration.toJSON(message.unbondingPeriod) : void 0);
        message.maxClockDrift !== void 0 && (obj.maxClockDrift = message.maxClockDrift ? duration_1.Duration.toJSON(message.maxClockDrift) : void 0);
        message.frozenHeight !== void 0 && (obj.frozenHeight = message.frozenHeight ? client_1.Height.toJSON(message.frozenHeight) : void 0);
        message.latestHeight !== void 0 && (obj.latestHeight = message.latestHeight ? client_1.Height.toJSON(message.latestHeight) : void 0);
        if (message.proofSpecs) {
          obj.proofSpecs = message.proofSpecs.map((e) => e ? proofs_1.ProofSpec.toJSON(e) : void 0);
        } else {
          obj.proofSpecs = [];
        }
        if (message.upgradePath) {
          obj.upgradePath = message.upgradePath.map((e) => e);
        } else {
          obj.upgradePath = [];
        }
        message.allowUpdateAfterExpiry !== void 0 && (obj.allowUpdateAfterExpiry = message.allowUpdateAfterExpiry);
        message.allowUpdateAfterMisbehaviour !== void 0 && (obj.allowUpdateAfterMisbehaviour = message.allowUpdateAfterMisbehaviour);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseClientState();
        message.chainId = object.chainId ?? "";
        if (object.trustLevel !== void 0 && object.trustLevel !== null) {
          message.trustLevel = exports.Fraction.fromPartial(object.trustLevel);
        }
        if (object.trustingPeriod !== void 0 && object.trustingPeriod !== null) {
          message.trustingPeriod = duration_1.Duration.fromPartial(object.trustingPeriod);
        }
        if (object.unbondingPeriod !== void 0 && object.unbondingPeriod !== null) {
          message.unbondingPeriod = duration_1.Duration.fromPartial(object.unbondingPeriod);
        }
        if (object.maxClockDrift !== void 0 && object.maxClockDrift !== null) {
          message.maxClockDrift = duration_1.Duration.fromPartial(object.maxClockDrift);
        }
        if (object.frozenHeight !== void 0 && object.frozenHeight !== null) {
          message.frozenHeight = client_1.Height.fromPartial(object.frozenHeight);
        }
        if (object.latestHeight !== void 0 && object.latestHeight !== null) {
          message.latestHeight = client_1.Height.fromPartial(object.latestHeight);
        }
        message.proofSpecs = object.proofSpecs?.map((e) => proofs_1.ProofSpec.fromPartial(e)) || [];
        message.upgradePath = object.upgradePath?.map((e) => e) || [];
        message.allowUpdateAfterExpiry = object.allowUpdateAfterExpiry ?? false;
        message.allowUpdateAfterMisbehaviour = object.allowUpdateAfterMisbehaviour ?? false;
        return message;
      }
    };
    function createBaseConsensusState() {
      return {
        timestamp: timestamp_1.Timestamp.fromPartial({}),
        root: commitment_1.MerkleRoot.fromPartial({}),
        nextValidatorsHash: new Uint8Array()
      };
    }
    exports.ConsensusState = {
      typeUrl: "/ibc.lightclients.tendermint.v1.ConsensusState",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.timestamp !== void 0) {
          timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(10).fork()).ldelim();
        }
        if (message.root !== void 0) {
          commitment_1.MerkleRoot.encode(message.root, writer.uint32(18).fork()).ldelim();
        }
        if (message.nextValidatorsHash.length !== 0) {
          writer.uint32(26).bytes(message.nextValidatorsHash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseConsensusState();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 2:
              message.root = commitment_1.MerkleRoot.decode(reader, reader.uint32());
              break;
            case 3:
              message.nextValidatorsHash = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseConsensusState();
        if ((0, helpers_1.isSet)(object.timestamp))
          obj.timestamp = (0, helpers_1.fromJsonTimestamp)(object.timestamp);
        if ((0, helpers_1.isSet)(object.root))
          obj.root = commitment_1.MerkleRoot.fromJSON(object.root);
        if ((0, helpers_1.isSet)(object.nextValidatorsHash))
          obj.nextValidatorsHash = (0, helpers_1.bytesFromBase64)(object.nextValidatorsHash);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.timestamp !== void 0 && (obj.timestamp = (0, helpers_1.fromTimestamp)(message.timestamp).toISOString());
        message.root !== void 0 && (obj.root = message.root ? commitment_1.MerkleRoot.toJSON(message.root) : void 0);
        message.nextValidatorsHash !== void 0 && (obj.nextValidatorsHash = (0, helpers_1.base64FromBytes)(message.nextValidatorsHash !== void 0 ? message.nextValidatorsHash : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseConsensusState();
        if (object.timestamp !== void 0 && object.timestamp !== null) {
          message.timestamp = timestamp_1.Timestamp.fromPartial(object.timestamp);
        }
        if (object.root !== void 0 && object.root !== null) {
          message.root = commitment_1.MerkleRoot.fromPartial(object.root);
        }
        message.nextValidatorsHash = object.nextValidatorsHash ?? new Uint8Array();
        return message;
      }
    };
    function createBaseMisbehaviour() {
      return {
        clientId: "",
        header1: void 0,
        header2: void 0
      };
    }
    exports.Misbehaviour = {
      typeUrl: "/ibc.lightclients.tendermint.v1.Misbehaviour",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.clientId !== "") {
          writer.uint32(10).string(message.clientId);
        }
        if (message.header1 !== void 0) {
          exports.Header.encode(message.header1, writer.uint32(18).fork()).ldelim();
        }
        if (message.header2 !== void 0) {
          exports.Header.encode(message.header2, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMisbehaviour();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.clientId = reader.string();
              break;
            case 2:
              message.header1 = exports.Header.decode(reader, reader.uint32());
              break;
            case 3:
              message.header2 = exports.Header.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMisbehaviour();
        if ((0, helpers_1.isSet)(object.clientId))
          obj.clientId = String(object.clientId);
        if ((0, helpers_1.isSet)(object.header1))
          obj.header1 = exports.Header.fromJSON(object.header1);
        if ((0, helpers_1.isSet)(object.header2))
          obj.header2 = exports.Header.fromJSON(object.header2);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.clientId !== void 0 && (obj.clientId = message.clientId);
        message.header1 !== void 0 && (obj.header1 = message.header1 ? exports.Header.toJSON(message.header1) : void 0);
        message.header2 !== void 0 && (obj.header2 = message.header2 ? exports.Header.toJSON(message.header2) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMisbehaviour();
        message.clientId = object.clientId ?? "";
        if (object.header1 !== void 0 && object.header1 !== null) {
          message.header1 = exports.Header.fromPartial(object.header1);
        }
        if (object.header2 !== void 0 && object.header2 !== null) {
          message.header2 = exports.Header.fromPartial(object.header2);
        }
        return message;
      }
    };
    function createBaseHeader() {
      return {
        signedHeader: void 0,
        validatorSet: void 0,
        trustedHeight: client_1.Height.fromPartial({}),
        trustedValidators: void 0
      };
    }
    exports.Header = {
      typeUrl: "/ibc.lightclients.tendermint.v1.Header",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.signedHeader !== void 0) {
          types_1.SignedHeader.encode(message.signedHeader, writer.uint32(10).fork()).ldelim();
        }
        if (message.validatorSet !== void 0) {
          validator_1.ValidatorSet.encode(message.validatorSet, writer.uint32(18).fork()).ldelim();
        }
        if (message.trustedHeight !== void 0) {
          client_1.Height.encode(message.trustedHeight, writer.uint32(26).fork()).ldelim();
        }
        if (message.trustedValidators !== void 0) {
          validator_1.ValidatorSet.encode(message.trustedValidators, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseHeader();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signedHeader = types_1.SignedHeader.decode(reader, reader.uint32());
              break;
            case 2:
              message.validatorSet = validator_1.ValidatorSet.decode(reader, reader.uint32());
              break;
            case 3:
              message.trustedHeight = client_1.Height.decode(reader, reader.uint32());
              break;
            case 4:
              message.trustedValidators = validator_1.ValidatorSet.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseHeader();
        if ((0, helpers_1.isSet)(object.signedHeader))
          obj.signedHeader = types_1.SignedHeader.fromJSON(object.signedHeader);
        if ((0, helpers_1.isSet)(object.validatorSet))
          obj.validatorSet = validator_1.ValidatorSet.fromJSON(object.validatorSet);
        if ((0, helpers_1.isSet)(object.trustedHeight))
          obj.trustedHeight = client_1.Height.fromJSON(object.trustedHeight);
        if ((0, helpers_1.isSet)(object.trustedValidators))
          obj.trustedValidators = validator_1.ValidatorSet.fromJSON(object.trustedValidators);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.signedHeader !== void 0 && (obj.signedHeader = message.signedHeader ? types_1.SignedHeader.toJSON(message.signedHeader) : void 0);
        message.validatorSet !== void 0 && (obj.validatorSet = message.validatorSet ? validator_1.ValidatorSet.toJSON(message.validatorSet) : void 0);
        message.trustedHeight !== void 0 && (obj.trustedHeight = message.trustedHeight ? client_1.Height.toJSON(message.trustedHeight) : void 0);
        message.trustedValidators !== void 0 && (obj.trustedValidators = message.trustedValidators ? validator_1.ValidatorSet.toJSON(message.trustedValidators) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseHeader();
        if (object.signedHeader !== void 0 && object.signedHeader !== null) {
          message.signedHeader = types_1.SignedHeader.fromPartial(object.signedHeader);
        }
        if (object.validatorSet !== void 0 && object.validatorSet !== null) {
          message.validatorSet = validator_1.ValidatorSet.fromPartial(object.validatorSet);
        }
        if (object.trustedHeight !== void 0 && object.trustedHeight !== null) {
          message.trustedHeight = client_1.Height.fromPartial(object.trustedHeight);
        }
        if (object.trustedValidators !== void 0 && object.trustedValidators !== null) {
          message.trustedValidators = validator_1.ValidatorSet.fromPartial(object.trustedValidators);
        }
        return message;
      }
    };
    function createBaseFraction() {
      return {
        numerator: BigInt(0),
        denominator: BigInt(0)
      };
    }
    exports.Fraction = {
      typeUrl: "/ibc.lightclients.tendermint.v1.Fraction",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.numerator !== BigInt(0)) {
          writer.uint32(8).uint64(message.numerator);
        }
        if (message.denominator !== BigInt(0)) {
          writer.uint32(16).uint64(message.denominator);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseFraction();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.numerator = reader.uint64();
              break;
            case 2:
              message.denominator = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseFraction();
        if ((0, helpers_1.isSet)(object.numerator))
          obj.numerator = BigInt(object.numerator.toString());
        if ((0, helpers_1.isSet)(object.denominator))
          obj.denominator = BigInt(object.denominator.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.numerator !== void 0 && (obj.numerator = (message.numerator || BigInt(0)).toString());
        message.denominator !== void 0 && (obj.denominator = (message.denominator || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseFraction();
        if (object.numerator !== void 0 && object.numerator !== null) {
          message.numerator = BigInt(object.numerator.toString());
        }
        if (object.denominator !== void 0 && object.denominator !== null) {
          message.denominator = BigInt(object.denominator.toString());
        }
        return message;
      }
    };
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/ibc/queries.js
var require_queries7 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/ibc/queries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupIbcExtension = setupIbcExtension;
    var query_1 = require_query7();
    var query_2 = require_query8();
    var query_3 = require_query9();
    var query_4 = require_query10();
    var tendermint_1 = require_tendermint();
    var queryclient_1 = require_queryclient2();
    function decodeTendermintClientStateAny(clientState) {
      if (clientState?.typeUrl !== "/ibc.lightclients.tendermint.v1.ClientState") {
        throw new Error(`Unexpected client state type: ${clientState?.typeUrl}`);
      }
      return tendermint_1.ClientState.decode(clientState.value);
    }
    function decodeTendermintConsensusStateAny(clientState) {
      if (clientState?.typeUrl !== "/ibc.lightclients.tendermint.v1.ConsensusState") {
        throw new Error(`Unexpected client state type: ${clientState?.typeUrl}`);
      }
      return tendermint_1.ConsensusState.decode(clientState.value);
    }
    function setupIbcExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const channelQueryService = new query_2.QueryClientImpl(rpc);
      const clientQueryService = new query_3.QueryClientImpl(rpc);
      const connectionQueryService = new query_4.QueryClientImpl(rpc);
      const transferQueryService = new query_1.QueryClientImpl(rpc);
      return {
        ibc: {
          channel: {
            channel: async (portId, channelId) => channelQueryService.Channel({
              portId,
              channelId
            }),
            channels: async (paginationKey) => channelQueryService.Channels({
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allChannels: async () => {
              const channels = [];
              let response;
              let key;
              do {
                response = await channelQueryService.Channels({
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                channels.push(...response.channels);
                key = response.pagination?.nextKey;
              } while (key && key.length);
              return query_2.QueryChannelsResponse.fromPartial({
                channels,
                height: response.height
              });
            },
            connectionChannels: async (connection, paginationKey) => channelQueryService.ConnectionChannels({
              connection,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allConnectionChannels: async (connection) => {
              const channels = [];
              let response;
              let key;
              do {
                response = await channelQueryService.ConnectionChannels({
                  connection,
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                channels.push(...response.channels);
                key = response.pagination?.nextKey;
              } while (key && key.length);
              return query_2.QueryConnectionChannelsResponse.fromPartial({
                channels,
                height: response.height
              });
            },
            clientState: async (portId, channelId) => channelQueryService.ChannelClientState({
              portId,
              channelId
            }),
            consensusState: async (portId, channelId, revisionNumber, revisionHeight) => channelQueryService.ChannelConsensusState({
              portId,
              channelId,
              revisionNumber: BigInt(revisionNumber),
              revisionHeight: BigInt(revisionHeight)
            }),
            packetCommitment: async (portId, channelId, sequence) => channelQueryService.PacketCommitment({
              portId,
              channelId,
              sequence: (0, queryclient_1.longify)(sequence)
            }),
            packetCommitments: async (portId, channelId, paginationKey) => channelQueryService.PacketCommitments({
              channelId,
              portId,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allPacketCommitments: async (portId, channelId) => {
              const commitments = [];
              let response;
              let key;
              do {
                response = await channelQueryService.PacketCommitments({
                  channelId,
                  portId,
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                commitments.push(...response.commitments);
                key = response.pagination?.nextKey;
              } while (key && key.length);
              return query_2.QueryPacketCommitmentsResponse.fromPartial({
                commitments,
                height: response.height
              });
            },
            packetReceipt: async (portId, channelId, sequence) => channelQueryService.PacketReceipt({
              portId,
              channelId,
              sequence: (0, queryclient_1.longify)(sequence)
            }),
            packetAcknowledgement: async (portId, channelId, sequence) => channelQueryService.PacketAcknowledgement({
              portId,
              channelId,
              sequence: (0, queryclient_1.longify)(sequence)
            }),
            packetAcknowledgements: async (portId, channelId, paginationKey) => {
              const request = query_2.QueryPacketAcknowledgementsRequest.fromPartial({
                portId,
                channelId,
                pagination: (0, queryclient_1.createPagination)(paginationKey)
              });
              return channelQueryService.PacketAcknowledgements(request);
            },
            allPacketAcknowledgements: async (portId, channelId) => {
              const acknowledgements = [];
              let response;
              let key;
              do {
                const request = query_2.QueryPacketAcknowledgementsRequest.fromPartial({
                  channelId,
                  portId,
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                response = await channelQueryService.PacketAcknowledgements(request);
                acknowledgements.push(...response.acknowledgements);
                key = response.pagination?.nextKey;
              } while (key && key.length);
              return query_2.QueryPacketAcknowledgementsResponse.fromPartial({
                acknowledgements,
                height: response.height
              });
            },
            unreceivedPackets: async (portId, channelId, packetCommitmentSequences) => channelQueryService.UnreceivedPackets({
              portId,
              channelId,
              packetCommitmentSequences: packetCommitmentSequences.map((s2) => BigInt(s2))
            }),
            unreceivedAcks: async (portId, channelId, packetAckSequences) => channelQueryService.UnreceivedAcks({
              portId,
              channelId,
              packetAckSequences: packetAckSequences.map((s2) => BigInt(s2))
            }),
            nextSequenceReceive: async (portId, channelId) => channelQueryService.NextSequenceReceive({
              portId,
              channelId
            })
          },
          client: {
            state: async (clientId) => clientQueryService.ClientState({ clientId }),
            states: async (paginationKey) => clientQueryService.ClientStates({
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allStates: async () => {
              const clientStates = [];
              let response;
              let key;
              do {
                response = await clientQueryService.ClientStates({
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                clientStates.push(...response.clientStates);
                key = response.pagination?.nextKey;
              } while (key && key.length);
              return query_3.QueryClientStatesResponse.fromPartial({
                clientStates
              });
            },
            consensusState: async (clientId, consensusHeight) => clientQueryService.ConsensusState(query_3.QueryConsensusStateRequest.fromPartial({
              clientId,
              revisionHeight: consensusHeight !== void 0 ? BigInt(consensusHeight) : void 0,
              latestHeight: consensusHeight === void 0
            })),
            consensusStates: async (clientId, paginationKey) => clientQueryService.ConsensusStates({
              clientId,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allConsensusStates: async (clientId) => {
              const consensusStates = [];
              let response;
              let key;
              do {
                response = await clientQueryService.ConsensusStates({
                  clientId,
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                consensusStates.push(...response.consensusStates);
                key = response.pagination?.nextKey;
              } while (key && key.length);
              return query_3.QueryConsensusStatesResponse.fromPartial({
                consensusStates
              });
            },
            params: async () => clientQueryService.ClientParams({}),
            stateTm: async (clientId) => {
              const response = await clientQueryService.ClientState({ clientId });
              return decodeTendermintClientStateAny(response.clientState);
            },
            statesTm: async (paginationKey) => {
              const { clientStates } = await clientQueryService.ClientStates({
                pagination: (0, queryclient_1.createPagination)(paginationKey)
              });
              return clientStates.map(({ clientState }) => decodeTendermintClientStateAny(clientState));
            },
            allStatesTm: async () => {
              const clientStates = [];
              let response;
              let key;
              do {
                response = await clientQueryService.ClientStates({
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                clientStates.push(...response.clientStates);
                key = response.pagination?.nextKey;
              } while (key && key.length);
              return clientStates.map(({ clientState }) => decodeTendermintClientStateAny(clientState));
            },
            consensusStateTm: async (clientId, consensusHeight) => {
              const response = await clientQueryService.ConsensusState(query_3.QueryConsensusStateRequest.fromPartial({
                clientId,
                revisionHeight: consensusHeight?.revisionHeight,
                revisionNumber: consensusHeight?.revisionNumber,
                latestHeight: consensusHeight === void 0
              }));
              return decodeTendermintConsensusStateAny(response.consensusState);
            }
          },
          connection: {
            connection: async (connectionId) => connectionQueryService.Connection({
              connectionId
            }),
            connections: async (paginationKey) => connectionQueryService.Connections({
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allConnections: async () => {
              const connections = [];
              let response;
              let key;
              do {
                response = await connectionQueryService.Connections({
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                connections.push(...response.connections);
                key = response.pagination?.nextKey;
              } while (key && key.length);
              return query_4.QueryConnectionsResponse.fromPartial({
                connections,
                height: response.height
              });
            },
            clientConnections: async (clientId) => connectionQueryService.ClientConnections({
              clientId
            }),
            clientState: async (connectionId) => connectionQueryService.ConnectionClientState({
              connectionId
            }),
            consensusState: async (connectionId, revisionHeight) => connectionQueryService.ConnectionConsensusState(query_4.QueryConnectionConsensusStateRequest.fromPartial({
              connectionId,
              revisionHeight: BigInt(revisionHeight)
            }))
          },
          transfer: {
            denomTrace: async (hash2) => transferQueryService.DenomTrace({ hash: hash2 }),
            denomTraces: async (paginationKey) => transferQueryService.DenomTraces({
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            }),
            allDenomTraces: async () => {
              const denomTraces = [];
              let response;
              let key;
              do {
                response = await transferQueryService.DenomTraces({
                  pagination: (0, queryclient_1.createPagination)(key)
                });
                denomTraces.push(...response.denomTraces);
                key = response.pagination?.nextKey;
              } while (key && key.length);
              return query_1.QueryDenomTracesResponse.fromPartial({
                denomTraces
              });
            },
            params: async () => transferQueryService.Params({})
          }
        }
      };
    }
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/mint/v1beta1/mint.js
var require_mint = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/mint/v1beta1/mint.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Params = exports.Minter = exports.protobufPackage = void 0;
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.mint.v1beta1";
    function createBaseMinter() {
      return {
        inflation: "",
        annualProvisions: ""
      };
    }
    exports.Minter = {
      typeUrl: "/cosmos.mint.v1beta1.Minter",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.inflation !== "") {
          writer.uint32(10).string(message.inflation);
        }
        if (message.annualProvisions !== "") {
          writer.uint32(18).string(message.annualProvisions);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMinter();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.inflation = reader.string();
              break;
            case 2:
              message.annualProvisions = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMinter();
        if ((0, helpers_1.isSet)(object.inflation))
          obj.inflation = String(object.inflation);
        if ((0, helpers_1.isSet)(object.annualProvisions))
          obj.annualProvisions = String(object.annualProvisions);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.inflation !== void 0 && (obj.inflation = message.inflation);
        message.annualProvisions !== void 0 && (obj.annualProvisions = message.annualProvisions);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMinter();
        message.inflation = object.inflation ?? "";
        message.annualProvisions = object.annualProvisions ?? "";
        return message;
      }
    };
    function createBaseParams() {
      return {
        mintDenom: "",
        inflationRateChange: "",
        inflationMax: "",
        inflationMin: "",
        goalBonded: "",
        blocksPerYear: BigInt(0)
      };
    }
    exports.Params = {
      typeUrl: "/cosmos.mint.v1beta1.Params",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.mintDenom !== "") {
          writer.uint32(10).string(message.mintDenom);
        }
        if (message.inflationRateChange !== "") {
          writer.uint32(18).string(message.inflationRateChange);
        }
        if (message.inflationMax !== "") {
          writer.uint32(26).string(message.inflationMax);
        }
        if (message.inflationMin !== "") {
          writer.uint32(34).string(message.inflationMin);
        }
        if (message.goalBonded !== "") {
          writer.uint32(42).string(message.goalBonded);
        }
        if (message.blocksPerYear !== BigInt(0)) {
          writer.uint32(48).uint64(message.blocksPerYear);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.mintDenom = reader.string();
              break;
            case 2:
              message.inflationRateChange = reader.string();
              break;
            case 3:
              message.inflationMax = reader.string();
              break;
            case 4:
              message.inflationMin = reader.string();
              break;
            case 5:
              message.goalBonded = reader.string();
              break;
            case 6:
              message.blocksPerYear = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseParams();
        if ((0, helpers_1.isSet)(object.mintDenom))
          obj.mintDenom = String(object.mintDenom);
        if ((0, helpers_1.isSet)(object.inflationRateChange))
          obj.inflationRateChange = String(object.inflationRateChange);
        if ((0, helpers_1.isSet)(object.inflationMax))
          obj.inflationMax = String(object.inflationMax);
        if ((0, helpers_1.isSet)(object.inflationMin))
          obj.inflationMin = String(object.inflationMin);
        if ((0, helpers_1.isSet)(object.goalBonded))
          obj.goalBonded = String(object.goalBonded);
        if ((0, helpers_1.isSet)(object.blocksPerYear))
          obj.blocksPerYear = BigInt(object.blocksPerYear.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.mintDenom !== void 0 && (obj.mintDenom = message.mintDenom);
        message.inflationRateChange !== void 0 && (obj.inflationRateChange = message.inflationRateChange);
        message.inflationMax !== void 0 && (obj.inflationMax = message.inflationMax);
        message.inflationMin !== void 0 && (obj.inflationMin = message.inflationMin);
        message.goalBonded !== void 0 && (obj.goalBonded = message.goalBonded);
        message.blocksPerYear !== void 0 && (obj.blocksPerYear = (message.blocksPerYear || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseParams();
        message.mintDenom = object.mintDenom ?? "";
        message.inflationRateChange = object.inflationRateChange ?? "";
        message.inflationMax = object.inflationMax ?? "";
        message.inflationMin = object.inflationMin ?? "";
        message.goalBonded = object.goalBonded ?? "";
        if (object.blocksPerYear !== void 0 && object.blocksPerYear !== null) {
          message.blocksPerYear = BigInt(object.blocksPerYear.toString());
        }
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/mint/v1beta1/query.js
var require_query11 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/mint/v1beta1/query.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryClientImpl = exports.QueryAnnualProvisionsResponse = exports.QueryAnnualProvisionsRequest = exports.QueryInflationResponse = exports.QueryInflationRequest = exports.QueryParamsResponse = exports.QueryParamsRequest = exports.protobufPackage = void 0;
    var mint_1 = require_mint();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.mint.v1beta1";
    function createBaseQueryParamsRequest() {
      return {};
    }
    exports.QueryParamsRequest = {
      typeUrl: "/cosmos.mint.v1beta1.QueryParamsRequest",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseQueryParamsRequest();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseQueryParamsRequest();
        return message;
      }
    };
    function createBaseQueryParamsResponse() {
      return {
        params: mint_1.Params.fromPartial({})
      };
    }
    exports.QueryParamsResponse = {
      typeUrl: "/cosmos.mint.v1beta1.QueryParamsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== void 0) {
          mint_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = mint_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryParamsResponse();
        if ((0, helpers_1.isSet)(object.params))
          obj.params = mint_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? mint_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryParamsResponse();
        if (object.params !== void 0 && object.params !== null) {
          message.params = mint_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseQueryInflationRequest() {
      return {};
    }
    exports.QueryInflationRequest = {
      typeUrl: "/cosmos.mint.v1beta1.QueryInflationRequest",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryInflationRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseQueryInflationRequest();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseQueryInflationRequest();
        return message;
      }
    };
    function createBaseQueryInflationResponse() {
      return {
        inflation: new Uint8Array()
      };
    }
    exports.QueryInflationResponse = {
      typeUrl: "/cosmos.mint.v1beta1.QueryInflationResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.inflation.length !== 0) {
          writer.uint32(10).bytes(message.inflation);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryInflationResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.inflation = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryInflationResponse();
        if ((0, helpers_1.isSet)(object.inflation))
          obj.inflation = (0, helpers_1.bytesFromBase64)(object.inflation);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.inflation !== void 0 && (obj.inflation = (0, helpers_1.base64FromBytes)(message.inflation !== void 0 ? message.inflation : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryInflationResponse();
        message.inflation = object.inflation ?? new Uint8Array();
        return message;
      }
    };
    function createBaseQueryAnnualProvisionsRequest() {
      return {};
    }
    exports.QueryAnnualProvisionsRequest = {
      typeUrl: "/cosmos.mint.v1beta1.QueryAnnualProvisionsRequest",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAnnualProvisionsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseQueryAnnualProvisionsRequest();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseQueryAnnualProvisionsRequest();
        return message;
      }
    };
    function createBaseQueryAnnualProvisionsResponse() {
      return {
        annualProvisions: new Uint8Array()
      };
    }
    exports.QueryAnnualProvisionsResponse = {
      typeUrl: "/cosmos.mint.v1beta1.QueryAnnualProvisionsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.annualProvisions.length !== 0) {
          writer.uint32(10).bytes(message.annualProvisions);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAnnualProvisionsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.annualProvisions = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAnnualProvisionsResponse();
        if ((0, helpers_1.isSet)(object.annualProvisions))
          obj.annualProvisions = (0, helpers_1.bytesFromBase64)(object.annualProvisions);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.annualProvisions !== void 0 && (obj.annualProvisions = (0, helpers_1.base64FromBytes)(message.annualProvisions !== void 0 ? message.annualProvisions : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAnnualProvisionsResponse();
        message.annualProvisions = object.annualProvisions ?? new Uint8Array();
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Params = this.Params.bind(this);
        this.Inflation = this.Inflation.bind(this);
        this.AnnualProvisions = this.AnnualProvisions.bind(this);
      }
      Params(request = {}) {
        const data2 = exports.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.mint.v1beta1.Query", "Params", data2);
        return promise.then((data3) => exports.QueryParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Inflation(request = {}) {
        const data2 = exports.QueryInflationRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.mint.v1beta1.Query", "Inflation", data2);
        return promise.then((data3) => exports.QueryInflationResponse.decode(new binary_1.BinaryReader(data3)));
      }
      AnnualProvisions(request = {}) {
        const data2 = exports.QueryAnnualProvisionsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.mint.v1beta1.Query", "AnnualProvisions", data2);
        return promise.then((data3) => exports.QueryAnnualProvisionsResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.QueryClientImpl = QueryClientImpl;
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/mint/queries.js
var require_queries8 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/mint/queries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupMintExtension = setupMintExtension;
    var utils_1 = require_build();
    var query_1 = require_query11();
    var queryclient_1 = require_queryclient2();
    function setupMintExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        mint: {
          params: async () => {
            const { params } = await queryService.Params({});
            (0, utils_1.assert)(params);
            return {
              blocksPerYear: params.blocksPerYear,
              goalBonded: (0, queryclient_1.decodeCosmosSdkDecFromProto)(params.goalBonded),
              inflationMin: (0, queryclient_1.decodeCosmosSdkDecFromProto)(params.inflationMin),
              inflationMax: (0, queryclient_1.decodeCosmosSdkDecFromProto)(params.inflationMax),
              inflationRateChange: (0, queryclient_1.decodeCosmosSdkDecFromProto)(params.inflationRateChange),
              mintDenom: params.mintDenom
            };
          },
          inflation: async () => {
            const { inflation } = await queryService.Inflation({});
            return (0, queryclient_1.decodeCosmosSdkDecFromProto)(inflation);
          },
          annualProvisions: async () => {
            const { annualProvisions } = await queryService.AnnualProvisions({});
            return (0, queryclient_1.decodeCosmosSdkDecFromProto)(annualProvisions);
          }
        }
      };
    }
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/slashing/aminomessages.js
var require_aminomessages10 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/slashing/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAminoMsgUnjail = isAminoMsgUnjail;
    exports.createSlashingAminoConverters = createSlashingAminoConverters;
    function isAminoMsgUnjail(msg) {
      return msg.type === "cosmos-sdk/MsgUnjail";
    }
    function createSlashingAminoConverters() {
      throw new Error("Not implemented");
    }
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/slashing/v1beta1/slashing.js
var require_slashing = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/slashing/v1beta1/slashing.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Params = exports.ValidatorSigningInfo = exports.protobufPackage = void 0;
    var timestamp_1 = require_timestamp();
    var duration_1 = require_duration();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.slashing.v1beta1";
    function createBaseValidatorSigningInfo() {
      return {
        address: "",
        startHeight: BigInt(0),
        indexOffset: BigInt(0),
        jailedUntil: timestamp_1.Timestamp.fromPartial({}),
        tombstoned: false,
        missedBlocksCounter: BigInt(0)
      };
    }
    exports.ValidatorSigningInfo = {
      typeUrl: "/cosmos.slashing.v1beta1.ValidatorSigningInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.startHeight !== BigInt(0)) {
          writer.uint32(16).int64(message.startHeight);
        }
        if (message.indexOffset !== BigInt(0)) {
          writer.uint32(24).int64(message.indexOffset);
        }
        if (message.jailedUntil !== void 0) {
          timestamp_1.Timestamp.encode(message.jailedUntil, writer.uint32(34).fork()).ldelim();
        }
        if (message.tombstoned === true) {
          writer.uint32(40).bool(message.tombstoned);
        }
        if (message.missedBlocksCounter !== BigInt(0)) {
          writer.uint32(48).int64(message.missedBlocksCounter);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorSigningInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.startHeight = reader.int64();
              break;
            case 3:
              message.indexOffset = reader.int64();
              break;
            case 4:
              message.jailedUntil = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 5:
              message.tombstoned = reader.bool();
              break;
            case 6:
              message.missedBlocksCounter = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidatorSigningInfo();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.startHeight))
          obj.startHeight = BigInt(object.startHeight.toString());
        if ((0, helpers_1.isSet)(object.indexOffset))
          obj.indexOffset = BigInt(object.indexOffset.toString());
        if ((0, helpers_1.isSet)(object.jailedUntil))
          obj.jailedUntil = (0, helpers_1.fromJsonTimestamp)(object.jailedUntil);
        if ((0, helpers_1.isSet)(object.tombstoned))
          obj.tombstoned = Boolean(object.tombstoned);
        if ((0, helpers_1.isSet)(object.missedBlocksCounter))
          obj.missedBlocksCounter = BigInt(object.missedBlocksCounter.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.startHeight !== void 0 && (obj.startHeight = (message.startHeight || BigInt(0)).toString());
        message.indexOffset !== void 0 && (obj.indexOffset = (message.indexOffset || BigInt(0)).toString());
        message.jailedUntil !== void 0 && (obj.jailedUntil = (0, helpers_1.fromTimestamp)(message.jailedUntil).toISOString());
        message.tombstoned !== void 0 && (obj.tombstoned = message.tombstoned);
        message.missedBlocksCounter !== void 0 && (obj.missedBlocksCounter = (message.missedBlocksCounter || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseValidatorSigningInfo();
        message.address = object.address ?? "";
        if (object.startHeight !== void 0 && object.startHeight !== null) {
          message.startHeight = BigInt(object.startHeight.toString());
        }
        if (object.indexOffset !== void 0 && object.indexOffset !== null) {
          message.indexOffset = BigInt(object.indexOffset.toString());
        }
        if (object.jailedUntil !== void 0 && object.jailedUntil !== null) {
          message.jailedUntil = timestamp_1.Timestamp.fromPartial(object.jailedUntil);
        }
        message.tombstoned = object.tombstoned ?? false;
        if (object.missedBlocksCounter !== void 0 && object.missedBlocksCounter !== null) {
          message.missedBlocksCounter = BigInt(object.missedBlocksCounter.toString());
        }
        return message;
      }
    };
    function createBaseParams() {
      return {
        signedBlocksWindow: BigInt(0),
        minSignedPerWindow: new Uint8Array(),
        downtimeJailDuration: duration_1.Duration.fromPartial({}),
        slashFractionDoubleSign: new Uint8Array(),
        slashFractionDowntime: new Uint8Array()
      };
    }
    exports.Params = {
      typeUrl: "/cosmos.slashing.v1beta1.Params",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.signedBlocksWindow !== BigInt(0)) {
          writer.uint32(8).int64(message.signedBlocksWindow);
        }
        if (message.minSignedPerWindow.length !== 0) {
          writer.uint32(18).bytes(message.minSignedPerWindow);
        }
        if (message.downtimeJailDuration !== void 0) {
          duration_1.Duration.encode(message.downtimeJailDuration, writer.uint32(26).fork()).ldelim();
        }
        if (message.slashFractionDoubleSign.length !== 0) {
          writer.uint32(34).bytes(message.slashFractionDoubleSign);
        }
        if (message.slashFractionDowntime.length !== 0) {
          writer.uint32(42).bytes(message.slashFractionDowntime);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.signedBlocksWindow = reader.int64();
              break;
            case 2:
              message.minSignedPerWindow = reader.bytes();
              break;
            case 3:
              message.downtimeJailDuration = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 4:
              message.slashFractionDoubleSign = reader.bytes();
              break;
            case 5:
              message.slashFractionDowntime = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseParams();
        if ((0, helpers_1.isSet)(object.signedBlocksWindow))
          obj.signedBlocksWindow = BigInt(object.signedBlocksWindow.toString());
        if ((0, helpers_1.isSet)(object.minSignedPerWindow))
          obj.minSignedPerWindow = (0, helpers_1.bytesFromBase64)(object.minSignedPerWindow);
        if ((0, helpers_1.isSet)(object.downtimeJailDuration))
          obj.downtimeJailDuration = duration_1.Duration.fromJSON(object.downtimeJailDuration);
        if ((0, helpers_1.isSet)(object.slashFractionDoubleSign))
          obj.slashFractionDoubleSign = (0, helpers_1.bytesFromBase64)(object.slashFractionDoubleSign);
        if ((0, helpers_1.isSet)(object.slashFractionDowntime))
          obj.slashFractionDowntime = (0, helpers_1.bytesFromBase64)(object.slashFractionDowntime);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.signedBlocksWindow !== void 0 && (obj.signedBlocksWindow = (message.signedBlocksWindow || BigInt(0)).toString());
        message.minSignedPerWindow !== void 0 && (obj.minSignedPerWindow = (0, helpers_1.base64FromBytes)(message.minSignedPerWindow !== void 0 ? message.minSignedPerWindow : new Uint8Array()));
        message.downtimeJailDuration !== void 0 && (obj.downtimeJailDuration = message.downtimeJailDuration ? duration_1.Duration.toJSON(message.downtimeJailDuration) : void 0);
        message.slashFractionDoubleSign !== void 0 && (obj.slashFractionDoubleSign = (0, helpers_1.base64FromBytes)(message.slashFractionDoubleSign !== void 0 ? message.slashFractionDoubleSign : new Uint8Array()));
        message.slashFractionDowntime !== void 0 && (obj.slashFractionDowntime = (0, helpers_1.base64FromBytes)(message.slashFractionDowntime !== void 0 ? message.slashFractionDowntime : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseParams();
        if (object.signedBlocksWindow !== void 0 && object.signedBlocksWindow !== null) {
          message.signedBlocksWindow = BigInt(object.signedBlocksWindow.toString());
        }
        message.minSignedPerWindow = object.minSignedPerWindow ?? new Uint8Array();
        if (object.downtimeJailDuration !== void 0 && object.downtimeJailDuration !== null) {
          message.downtimeJailDuration = duration_1.Duration.fromPartial(object.downtimeJailDuration);
        }
        message.slashFractionDoubleSign = object.slashFractionDoubleSign ?? new Uint8Array();
        message.slashFractionDowntime = object.slashFractionDowntime ?? new Uint8Array();
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/slashing/v1beta1/query.js
var require_query12 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/slashing/v1beta1/query.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryClientImpl = exports.QuerySigningInfosResponse = exports.QuerySigningInfosRequest = exports.QuerySigningInfoResponse = exports.QuerySigningInfoRequest = exports.QueryParamsResponse = exports.QueryParamsRequest = exports.protobufPackage = void 0;
    var pagination_1 = require_pagination();
    var slashing_1 = require_slashing();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.slashing.v1beta1";
    function createBaseQueryParamsRequest() {
      return {};
    }
    exports.QueryParamsRequest = {
      typeUrl: "/cosmos.slashing.v1beta1.QueryParamsRequest",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseQueryParamsRequest();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseQueryParamsRequest();
        return message;
      }
    };
    function createBaseQueryParamsResponse() {
      return {
        params: slashing_1.Params.fromPartial({})
      };
    }
    exports.QueryParamsResponse = {
      typeUrl: "/cosmos.slashing.v1beta1.QueryParamsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== void 0) {
          slashing_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = slashing_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryParamsResponse();
        if ((0, helpers_1.isSet)(object.params))
          obj.params = slashing_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? slashing_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryParamsResponse();
        if (object.params !== void 0 && object.params !== null) {
          message.params = slashing_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseQuerySigningInfoRequest() {
      return {
        consAddress: ""
      };
    }
    exports.QuerySigningInfoRequest = {
      typeUrl: "/cosmos.slashing.v1beta1.QuerySigningInfoRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.consAddress !== "") {
          writer.uint32(10).string(message.consAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySigningInfoRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.consAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQuerySigningInfoRequest();
        if ((0, helpers_1.isSet)(object.consAddress))
          obj.consAddress = String(object.consAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.consAddress !== void 0 && (obj.consAddress = message.consAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQuerySigningInfoRequest();
        message.consAddress = object.consAddress ?? "";
        return message;
      }
    };
    function createBaseQuerySigningInfoResponse() {
      return {
        valSigningInfo: slashing_1.ValidatorSigningInfo.fromPartial({})
      };
    }
    exports.QuerySigningInfoResponse = {
      typeUrl: "/cosmos.slashing.v1beta1.QuerySigningInfoResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.valSigningInfo !== void 0) {
          slashing_1.ValidatorSigningInfo.encode(message.valSigningInfo, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySigningInfoResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.valSigningInfo = slashing_1.ValidatorSigningInfo.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQuerySigningInfoResponse();
        if ((0, helpers_1.isSet)(object.valSigningInfo))
          obj.valSigningInfo = slashing_1.ValidatorSigningInfo.fromJSON(object.valSigningInfo);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.valSigningInfo !== void 0 && (obj.valSigningInfo = message.valSigningInfo ? slashing_1.ValidatorSigningInfo.toJSON(message.valSigningInfo) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQuerySigningInfoResponse();
        if (object.valSigningInfo !== void 0 && object.valSigningInfo !== null) {
          message.valSigningInfo = slashing_1.ValidatorSigningInfo.fromPartial(object.valSigningInfo);
        }
        return message;
      }
    };
    function createBaseQuerySigningInfosRequest() {
      return {
        pagination: void 0
      };
    }
    exports.QuerySigningInfosRequest = {
      typeUrl: "/cosmos.slashing.v1beta1.QuerySigningInfosRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySigningInfosRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQuerySigningInfosRequest();
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQuerySigningInfosRequest();
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQuerySigningInfosResponse() {
      return {
        info: [],
        pagination: void 0
      };
    }
    exports.QuerySigningInfosResponse = {
      typeUrl: "/cosmos.slashing.v1beta1.QuerySigningInfosResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.info) {
          slashing_1.ValidatorSigningInfo.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySigningInfosResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.info.push(slashing_1.ValidatorSigningInfo.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQuerySigningInfosResponse();
        if (Array.isArray(object?.info))
          obj.info = object.info.map((e) => slashing_1.ValidatorSigningInfo.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.info) {
          obj.info = message.info.map((e) => e ? slashing_1.ValidatorSigningInfo.toJSON(e) : void 0);
        } else {
          obj.info = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQuerySigningInfosResponse();
        message.info = object.info?.map((e) => slashing_1.ValidatorSigningInfo.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Params = this.Params.bind(this);
        this.SigningInfo = this.SigningInfo.bind(this);
        this.SigningInfos = this.SigningInfos.bind(this);
      }
      Params(request = {}) {
        const data2 = exports.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.slashing.v1beta1.Query", "Params", data2);
        return promise.then((data3) => exports.QueryParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      SigningInfo(request) {
        const data2 = exports.QuerySigningInfoRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.slashing.v1beta1.Query", "SigningInfo", data2);
        return promise.then((data3) => exports.QuerySigningInfoResponse.decode(new binary_1.BinaryReader(data3)));
      }
      SigningInfos(request = {
        pagination: pagination_1.PageRequest.fromPartial({})
      }) {
        const data2 = exports.QuerySigningInfosRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.slashing.v1beta1.Query", "SigningInfos", data2);
        return promise.then((data3) => exports.QuerySigningInfosResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.QueryClientImpl = QueryClientImpl;
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/slashing/queries.js
var require_queries9 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/slashing/queries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupSlashingExtension = setupSlashingExtension;
    var query_1 = require_query12();
    var queryclient_1 = require_queryclient2();
    function setupSlashingExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        slashing: {
          signingInfo: async (consAddress) => {
            const response = await queryService.SigningInfo({
              consAddress
            });
            return response;
          },
          signingInfos: async (paginationKey) => {
            const response = await queryService.SigningInfos({
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          params: async () => {
            const response = await queryService.Params({});
            return response;
          }
        }
      };
    }
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/staking/aminomessages.js
var require_aminomessages11 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/staking/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.protoDecimalToJson = protoDecimalToJson;
    exports.isAminoMsgCreateValidator = isAminoMsgCreateValidator;
    exports.isAminoMsgEditValidator = isAminoMsgEditValidator;
    exports.isAminoMsgDelegate = isAminoMsgDelegate;
    exports.isAminoMsgBeginRedelegate = isAminoMsgBeginRedelegate;
    exports.isAminoMsgUndelegate = isAminoMsgUndelegate;
    exports.isAminoMsgCancelUnbondingDelegation = isAminoMsgCancelUnbondingDelegation;
    exports.createStakingAminoConverters = createStakingAminoConverters;
    var math_1 = require_build3();
    var proto_signing_1 = require_build6();
    var utils_1 = require_build();
    function protoDecimalToJson(decimal) {
      const parsed = math_1.Decimal.fromAtomics(decimal, 18);
      const [whole, fractional] = parsed.toString().split(".");
      return `${whole}.${(fractional ?? "").padEnd(18, "0")}`;
    }
    function jsonDecimalToProto(decimal) {
      const parsed = math_1.Decimal.fromUserInput(decimal, 18);
      return parsed.atomics;
    }
    function isAminoMsgCreateValidator(msg) {
      return msg.type === "cosmos-sdk/MsgCreateValidator";
    }
    function isAminoMsgEditValidator(msg) {
      return msg.type === "cosmos-sdk/MsgEditValidator";
    }
    function isAminoMsgDelegate(msg) {
      return msg.type === "cosmos-sdk/MsgDelegate";
    }
    function isAminoMsgBeginRedelegate(msg) {
      return msg.type === "cosmos-sdk/MsgBeginRedelegate";
    }
    function isAminoMsgUndelegate(msg) {
      return msg.type === "cosmos-sdk/MsgUndelegate";
    }
    function isAminoMsgCancelUnbondingDelegation(msg) {
      return msg.type === "cosmos-sdk/MsgCancelUnbondingDelegation";
    }
    function createStakingAminoConverters() {
      return {
        "/cosmos.staking.v1beta1.MsgBeginRedelegate": {
          aminoType: "cosmos-sdk/MsgBeginRedelegate",
          toAmino: ({ delegatorAddress, validatorSrcAddress, validatorDstAddress, amount }) => {
            (0, utils_1.assertDefinedAndNotNull)(amount, "missing amount");
            return {
              delegator_address: delegatorAddress,
              validator_src_address: validatorSrcAddress,
              validator_dst_address: validatorDstAddress,
              amount
            };
          },
          fromAmino: ({ delegator_address, validator_src_address, validator_dst_address, amount }) => ({
            delegatorAddress: delegator_address,
            validatorSrcAddress: validator_src_address,
            validatorDstAddress: validator_dst_address,
            amount
          })
        },
        "/cosmos.staking.v1beta1.MsgCreateValidator": {
          aminoType: "cosmos-sdk/MsgCreateValidator",
          toAmino: ({ description, commission, minSelfDelegation, delegatorAddress, validatorAddress, pubkey, value }) => {
            (0, utils_1.assertDefinedAndNotNull)(description, "missing description");
            (0, utils_1.assertDefinedAndNotNull)(commission, "missing commission");
            (0, utils_1.assertDefinedAndNotNull)(pubkey, "missing pubkey");
            (0, utils_1.assertDefinedAndNotNull)(value, "missing value");
            return {
              description: {
                moniker: description.moniker,
                identity: description.identity,
                website: description.website,
                security_contact: description.securityContact,
                details: description.details
              },
              commission: {
                rate: protoDecimalToJson(commission.rate),
                max_rate: protoDecimalToJson(commission.maxRate),
                max_change_rate: protoDecimalToJson(commission.maxChangeRate)
              },
              min_self_delegation: minSelfDelegation,
              delegator_address: delegatorAddress,
              validator_address: validatorAddress,
              pubkey: (0, proto_signing_1.decodePubkey)(pubkey),
              value
            };
          },
          fromAmino: ({ description, commission, min_self_delegation, delegator_address, validator_address, pubkey, value }) => {
            return {
              description: {
                moniker: description.moniker,
                identity: description.identity,
                website: description.website,
                securityContact: description.security_contact,
                details: description.details
              },
              commission: {
                rate: jsonDecimalToProto(commission.rate),
                maxRate: jsonDecimalToProto(commission.max_rate),
                maxChangeRate: jsonDecimalToProto(commission.max_change_rate)
              },
              minSelfDelegation: min_self_delegation,
              delegatorAddress: delegator_address,
              validatorAddress: validator_address,
              pubkey: (0, proto_signing_1.encodePubkey)(pubkey),
              value
            };
          }
        },
        "/cosmos.staking.v1beta1.MsgDelegate": {
          aminoType: "cosmos-sdk/MsgDelegate",
          toAmino: ({ delegatorAddress, validatorAddress, amount }) => {
            (0, utils_1.assertDefinedAndNotNull)(amount, "missing amount");
            return {
              delegator_address: delegatorAddress,
              validator_address: validatorAddress,
              amount
            };
          },
          fromAmino: ({ delegator_address, validator_address, amount }) => ({
            delegatorAddress: delegator_address,
            validatorAddress: validator_address,
            amount
          })
        },
        "/cosmos.staking.v1beta1.MsgEditValidator": {
          aminoType: "cosmos-sdk/MsgEditValidator",
          toAmino: ({ description, commissionRate, minSelfDelegation, validatorAddress }) => {
            (0, utils_1.assertDefinedAndNotNull)(description, "missing description");
            return {
              description: {
                moniker: description.moniker,
                identity: description.identity,
                website: description.website,
                security_contact: description.securityContact,
                details: description.details
              },
              // empty string in the protobuf document means "do not change"
              commission_rate: commissionRate ? protoDecimalToJson(commissionRate) : void 0,
              // empty string in the protobuf document means "do not change"
              min_self_delegation: minSelfDelegation ? minSelfDelegation : void 0,
              validator_address: validatorAddress
            };
          },
          fromAmino: ({ description, commission_rate, min_self_delegation, validator_address }) => ({
            description: {
              moniker: description.moniker,
              identity: description.identity,
              website: description.website,
              securityContact: description.security_contact,
              details: description.details
            },
            // empty string in the protobuf document means "do not change"
            commissionRate: commission_rate ? jsonDecimalToProto(commission_rate) : "",
            // empty string in the protobuf document means "do not change"
            minSelfDelegation: min_self_delegation ?? "",
            validatorAddress: validator_address
          })
        },
        "/cosmos.staking.v1beta1.MsgUndelegate": {
          aminoType: "cosmos-sdk/MsgUndelegate",
          toAmino: ({ delegatorAddress, validatorAddress, amount }) => {
            (0, utils_1.assertDefinedAndNotNull)(amount, "missing amount");
            return {
              delegator_address: delegatorAddress,
              validator_address: validatorAddress,
              amount
            };
          },
          fromAmino: ({ delegator_address, validator_address, amount }) => ({
            delegatorAddress: delegator_address,
            validatorAddress: validator_address,
            amount
          })
        },
        "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation": {
          aminoType: "cosmos-sdk/MsgCancelUnbondingDelegation",
          toAmino: ({ delegatorAddress, validatorAddress, amount, creationHeight }) => {
            (0, utils_1.assertDefinedAndNotNull)(amount, "missing amount");
            return {
              delegator_address: delegatorAddress,
              validator_address: validatorAddress,
              amount,
              creation_height: creationHeight.toString()
            };
          },
          fromAmino: ({ delegator_address, validator_address, amount, creation_height }) => ({
            delegatorAddress: delegator_address,
            validatorAddress: validator_address,
            amount,
            creationHeight: BigInt(creation_height)
          })
        }
      };
    }
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/tendermint/types/params.js
var require_params = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/tendermint/types/params.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ABCIParams = exports.HashedParams = exports.VersionParams = exports.ValidatorParams = exports.EvidenceParams = exports.BlockParams = exports.ConsensusParams = exports.protobufPackage = void 0;
    var duration_1 = require_duration();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "tendermint.types";
    function createBaseConsensusParams() {
      return {
        block: void 0,
        evidence: void 0,
        validator: void 0,
        version: void 0,
        abci: void 0
      };
    }
    exports.ConsensusParams = {
      typeUrl: "/tendermint.types.ConsensusParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.block !== void 0) {
          exports.BlockParams.encode(message.block, writer.uint32(10).fork()).ldelim();
        }
        if (message.evidence !== void 0) {
          exports.EvidenceParams.encode(message.evidence, writer.uint32(18).fork()).ldelim();
        }
        if (message.validator !== void 0) {
          exports.ValidatorParams.encode(message.validator, writer.uint32(26).fork()).ldelim();
        }
        if (message.version !== void 0) {
          exports.VersionParams.encode(message.version, writer.uint32(34).fork()).ldelim();
        }
        if (message.abci !== void 0) {
          exports.ABCIParams.encode(message.abci, writer.uint32(42).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseConsensusParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.block = exports.BlockParams.decode(reader, reader.uint32());
              break;
            case 2:
              message.evidence = exports.EvidenceParams.decode(reader, reader.uint32());
              break;
            case 3:
              message.validator = exports.ValidatorParams.decode(reader, reader.uint32());
              break;
            case 4:
              message.version = exports.VersionParams.decode(reader, reader.uint32());
              break;
            case 5:
              message.abci = exports.ABCIParams.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseConsensusParams();
        if ((0, helpers_1.isSet)(object.block))
          obj.block = exports.BlockParams.fromJSON(object.block);
        if ((0, helpers_1.isSet)(object.evidence))
          obj.evidence = exports.EvidenceParams.fromJSON(object.evidence);
        if ((0, helpers_1.isSet)(object.validator))
          obj.validator = exports.ValidatorParams.fromJSON(object.validator);
        if ((0, helpers_1.isSet)(object.version))
          obj.version = exports.VersionParams.fromJSON(object.version);
        if ((0, helpers_1.isSet)(object.abci))
          obj.abci = exports.ABCIParams.fromJSON(object.abci);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.block !== void 0 && (obj.block = message.block ? exports.BlockParams.toJSON(message.block) : void 0);
        message.evidence !== void 0 && (obj.evidence = message.evidence ? exports.EvidenceParams.toJSON(message.evidence) : void 0);
        message.validator !== void 0 && (obj.validator = message.validator ? exports.ValidatorParams.toJSON(message.validator) : void 0);
        message.version !== void 0 && (obj.version = message.version ? exports.VersionParams.toJSON(message.version) : void 0);
        message.abci !== void 0 && (obj.abci = message.abci ? exports.ABCIParams.toJSON(message.abci) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseConsensusParams();
        if (object.block !== void 0 && object.block !== null) {
          message.block = exports.BlockParams.fromPartial(object.block);
        }
        if (object.evidence !== void 0 && object.evidence !== null) {
          message.evidence = exports.EvidenceParams.fromPartial(object.evidence);
        }
        if (object.validator !== void 0 && object.validator !== null) {
          message.validator = exports.ValidatorParams.fromPartial(object.validator);
        }
        if (object.version !== void 0 && object.version !== null) {
          message.version = exports.VersionParams.fromPartial(object.version);
        }
        if (object.abci !== void 0 && object.abci !== null) {
          message.abci = exports.ABCIParams.fromPartial(object.abci);
        }
        return message;
      }
    };
    function createBaseBlockParams() {
      return {
        maxBytes: BigInt(0),
        maxGas: BigInt(0)
      };
    }
    exports.BlockParams = {
      typeUrl: "/tendermint.types.BlockParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.maxBytes !== BigInt(0)) {
          writer.uint32(8).int64(message.maxBytes);
        }
        if (message.maxGas !== BigInt(0)) {
          writer.uint32(16).int64(message.maxGas);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBlockParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.maxBytes = reader.int64();
              break;
            case 2:
              message.maxGas = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBlockParams();
        if ((0, helpers_1.isSet)(object.maxBytes))
          obj.maxBytes = BigInt(object.maxBytes.toString());
        if ((0, helpers_1.isSet)(object.maxGas))
          obj.maxGas = BigInt(object.maxGas.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.maxBytes !== void 0 && (obj.maxBytes = (message.maxBytes || BigInt(0)).toString());
        message.maxGas !== void 0 && (obj.maxGas = (message.maxGas || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBlockParams();
        if (object.maxBytes !== void 0 && object.maxBytes !== null) {
          message.maxBytes = BigInt(object.maxBytes.toString());
        }
        if (object.maxGas !== void 0 && object.maxGas !== null) {
          message.maxGas = BigInt(object.maxGas.toString());
        }
        return message;
      }
    };
    function createBaseEvidenceParams() {
      return {
        maxAgeNumBlocks: BigInt(0),
        maxAgeDuration: duration_1.Duration.fromPartial({}),
        maxBytes: BigInt(0)
      };
    }
    exports.EvidenceParams = {
      typeUrl: "/tendermint.types.EvidenceParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.maxAgeNumBlocks !== BigInt(0)) {
          writer.uint32(8).int64(message.maxAgeNumBlocks);
        }
        if (message.maxAgeDuration !== void 0) {
          duration_1.Duration.encode(message.maxAgeDuration, writer.uint32(18).fork()).ldelim();
        }
        if (message.maxBytes !== BigInt(0)) {
          writer.uint32(24).int64(message.maxBytes);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseEvidenceParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.maxAgeNumBlocks = reader.int64();
              break;
            case 2:
              message.maxAgeDuration = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 3:
              message.maxBytes = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseEvidenceParams();
        if ((0, helpers_1.isSet)(object.maxAgeNumBlocks))
          obj.maxAgeNumBlocks = BigInt(object.maxAgeNumBlocks.toString());
        if ((0, helpers_1.isSet)(object.maxAgeDuration))
          obj.maxAgeDuration = duration_1.Duration.fromJSON(object.maxAgeDuration);
        if ((0, helpers_1.isSet)(object.maxBytes))
          obj.maxBytes = BigInt(object.maxBytes.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.maxAgeNumBlocks !== void 0 && (obj.maxAgeNumBlocks = (message.maxAgeNumBlocks || BigInt(0)).toString());
        message.maxAgeDuration !== void 0 && (obj.maxAgeDuration = message.maxAgeDuration ? duration_1.Duration.toJSON(message.maxAgeDuration) : void 0);
        message.maxBytes !== void 0 && (obj.maxBytes = (message.maxBytes || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseEvidenceParams();
        if (object.maxAgeNumBlocks !== void 0 && object.maxAgeNumBlocks !== null) {
          message.maxAgeNumBlocks = BigInt(object.maxAgeNumBlocks.toString());
        }
        if (object.maxAgeDuration !== void 0 && object.maxAgeDuration !== null) {
          message.maxAgeDuration = duration_1.Duration.fromPartial(object.maxAgeDuration);
        }
        if (object.maxBytes !== void 0 && object.maxBytes !== null) {
          message.maxBytes = BigInt(object.maxBytes.toString());
        }
        return message;
      }
    };
    function createBaseValidatorParams() {
      return {
        pubKeyTypes: []
      };
    }
    exports.ValidatorParams = {
      typeUrl: "/tendermint.types.ValidatorParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.pubKeyTypes) {
          writer.uint32(10).string(v9);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pubKeyTypes.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidatorParams();
        if (Array.isArray(object?.pubKeyTypes))
          obj.pubKeyTypes = object.pubKeyTypes.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.pubKeyTypes) {
          obj.pubKeyTypes = message.pubKeyTypes.map((e) => e);
        } else {
          obj.pubKeyTypes = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseValidatorParams();
        message.pubKeyTypes = object.pubKeyTypes?.map((e) => e) || [];
        return message;
      }
    };
    function createBaseVersionParams() {
      return {
        app: BigInt(0)
      };
    }
    exports.VersionParams = {
      typeUrl: "/tendermint.types.VersionParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.app !== BigInt(0)) {
          writer.uint32(8).uint64(message.app);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVersionParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.app = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseVersionParams();
        if ((0, helpers_1.isSet)(object.app))
          obj.app = BigInt(object.app.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.app !== void 0 && (obj.app = (message.app || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseVersionParams();
        if (object.app !== void 0 && object.app !== null) {
          message.app = BigInt(object.app.toString());
        }
        return message;
      }
    };
    function createBaseHashedParams() {
      return {
        blockMaxBytes: BigInt(0),
        blockMaxGas: BigInt(0)
      };
    }
    exports.HashedParams = {
      typeUrl: "/tendermint.types.HashedParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.blockMaxBytes !== BigInt(0)) {
          writer.uint32(8).int64(message.blockMaxBytes);
        }
        if (message.blockMaxGas !== BigInt(0)) {
          writer.uint32(16).int64(message.blockMaxGas);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseHashedParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.blockMaxBytes = reader.int64();
              break;
            case 2:
              message.blockMaxGas = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseHashedParams();
        if ((0, helpers_1.isSet)(object.blockMaxBytes))
          obj.blockMaxBytes = BigInt(object.blockMaxBytes.toString());
        if ((0, helpers_1.isSet)(object.blockMaxGas))
          obj.blockMaxGas = BigInt(object.blockMaxGas.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.blockMaxBytes !== void 0 && (obj.blockMaxBytes = (message.blockMaxBytes || BigInt(0)).toString());
        message.blockMaxGas !== void 0 && (obj.blockMaxGas = (message.blockMaxGas || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseHashedParams();
        if (object.blockMaxBytes !== void 0 && object.blockMaxBytes !== null) {
          message.blockMaxBytes = BigInt(object.blockMaxBytes.toString());
        }
        if (object.blockMaxGas !== void 0 && object.blockMaxGas !== null) {
          message.blockMaxGas = BigInt(object.blockMaxGas.toString());
        }
        return message;
      }
    };
    function createBaseABCIParams() {
      return {
        voteExtensionsEnableHeight: BigInt(0)
      };
    }
    exports.ABCIParams = {
      typeUrl: "/tendermint.types.ABCIParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.voteExtensionsEnableHeight !== BigInt(0)) {
          writer.uint32(8).int64(message.voteExtensionsEnableHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseABCIParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.voteExtensionsEnableHeight = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseABCIParams();
        if ((0, helpers_1.isSet)(object.voteExtensionsEnableHeight))
          obj.voteExtensionsEnableHeight = BigInt(object.voteExtensionsEnableHeight.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.voteExtensionsEnableHeight !== void 0 && (obj.voteExtensionsEnableHeight = (message.voteExtensionsEnableHeight || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseABCIParams();
        if (object.voteExtensionsEnableHeight !== void 0 && object.voteExtensionsEnableHeight !== null) {
          message.voteExtensionsEnableHeight = BigInt(object.voteExtensionsEnableHeight.toString());
        }
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/tendermint/abci/types.js
var require_types4 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/tendermint/abci/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ResponsePrepareProposal = exports.ResponseApplySnapshotChunk = exports.ResponseLoadSnapshotChunk = exports.ResponseOfferSnapshot = exports.ResponseListSnapshots = exports.ResponseCommit = exports.ResponseCheckTx = exports.ResponseQuery = exports.ResponseInitChain = exports.ResponseInfo = exports.ResponseFlush = exports.ResponseEcho = exports.ResponseException = exports.Response = exports.RequestFinalizeBlock = exports.RequestVerifyVoteExtension = exports.RequestExtendVote = exports.RequestProcessProposal = exports.RequestPrepareProposal = exports.RequestApplySnapshotChunk = exports.RequestLoadSnapshotChunk = exports.RequestOfferSnapshot = exports.RequestListSnapshots = exports.RequestCommit = exports.RequestCheckTx = exports.RequestQuery = exports.RequestInitChain = exports.RequestInfo = exports.RequestFlush = exports.RequestEcho = exports.Request = exports.misbehaviorTypeToJSON = exports.misbehaviorTypeFromJSON = exports.MisbehaviorType = exports.responseVerifyVoteExtension_VerifyStatusToJSON = exports.responseVerifyVoteExtension_VerifyStatusFromJSON = exports.ResponseVerifyVoteExtension_VerifyStatus = exports.responseProcessProposal_ProposalStatusToJSON = exports.responseProcessProposal_ProposalStatusFromJSON = exports.ResponseProcessProposal_ProposalStatus = exports.responseApplySnapshotChunk_ResultToJSON = exports.responseApplySnapshotChunk_ResultFromJSON = exports.ResponseApplySnapshotChunk_Result = exports.responseOfferSnapshot_ResultToJSON = exports.responseOfferSnapshot_ResultFromJSON = exports.ResponseOfferSnapshot_Result = exports.checkTxTypeToJSON = exports.checkTxTypeFromJSON = exports.CheckTxType = exports.protobufPackage = void 0;
    exports.Snapshot = exports.Misbehavior = exports.ExtendedVoteInfo = exports.VoteInfo = exports.ValidatorUpdate = exports.Validator = exports.TxResult = exports.ExecTxResult = exports.EventAttribute = exports.Event = exports.ExtendedCommitInfo = exports.CommitInfo = exports.ResponseFinalizeBlock = exports.ResponseVerifyVoteExtension = exports.ResponseExtendVote = exports.ResponseProcessProposal = void 0;
    var timestamp_1 = require_timestamp();
    var params_1 = require_params();
    var proof_1 = require_proof();
    var keys_1 = require_keys4();
    var validator_1 = require_validator();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "tendermint.abci";
    var CheckTxType;
    (function(CheckTxType2) {
      CheckTxType2[CheckTxType2["NEW"] = 0] = "NEW";
      CheckTxType2[CheckTxType2["RECHECK"] = 1] = "RECHECK";
      CheckTxType2[CheckTxType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(CheckTxType || (exports.CheckTxType = CheckTxType = {}));
    function checkTxTypeFromJSON(object) {
      switch (object) {
        case 0:
        case "NEW":
          return CheckTxType.NEW;
        case 1:
        case "RECHECK":
          return CheckTxType.RECHECK;
        case -1:
        case "UNRECOGNIZED":
        default:
          return CheckTxType.UNRECOGNIZED;
      }
    }
    exports.checkTxTypeFromJSON = checkTxTypeFromJSON;
    function checkTxTypeToJSON(object) {
      switch (object) {
        case CheckTxType.NEW:
          return "NEW";
        case CheckTxType.RECHECK:
          return "RECHECK";
        case CheckTxType.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.checkTxTypeToJSON = checkTxTypeToJSON;
    var ResponseOfferSnapshot_Result;
    (function(ResponseOfferSnapshot_Result2) {
      ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["UNKNOWN"] = 0] = "UNKNOWN";
      ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["ACCEPT"] = 1] = "ACCEPT";
      ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["ABORT"] = 2] = "ABORT";
      ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["REJECT"] = 3] = "REJECT";
      ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["REJECT_FORMAT"] = 4] = "REJECT_FORMAT";
      ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["REJECT_SENDER"] = 5] = "REJECT_SENDER";
      ResponseOfferSnapshot_Result2[ResponseOfferSnapshot_Result2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ResponseOfferSnapshot_Result || (exports.ResponseOfferSnapshot_Result = ResponseOfferSnapshot_Result = {}));
    function responseOfferSnapshot_ResultFromJSON(object) {
      switch (object) {
        case 0:
        case "UNKNOWN":
          return ResponseOfferSnapshot_Result.UNKNOWN;
        case 1:
        case "ACCEPT":
          return ResponseOfferSnapshot_Result.ACCEPT;
        case 2:
        case "ABORT":
          return ResponseOfferSnapshot_Result.ABORT;
        case 3:
        case "REJECT":
          return ResponseOfferSnapshot_Result.REJECT;
        case 4:
        case "REJECT_FORMAT":
          return ResponseOfferSnapshot_Result.REJECT_FORMAT;
        case 5:
        case "REJECT_SENDER":
          return ResponseOfferSnapshot_Result.REJECT_SENDER;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ResponseOfferSnapshot_Result.UNRECOGNIZED;
      }
    }
    exports.responseOfferSnapshot_ResultFromJSON = responseOfferSnapshot_ResultFromJSON;
    function responseOfferSnapshot_ResultToJSON(object) {
      switch (object) {
        case ResponseOfferSnapshot_Result.UNKNOWN:
          return "UNKNOWN";
        case ResponseOfferSnapshot_Result.ACCEPT:
          return "ACCEPT";
        case ResponseOfferSnapshot_Result.ABORT:
          return "ABORT";
        case ResponseOfferSnapshot_Result.REJECT:
          return "REJECT";
        case ResponseOfferSnapshot_Result.REJECT_FORMAT:
          return "REJECT_FORMAT";
        case ResponseOfferSnapshot_Result.REJECT_SENDER:
          return "REJECT_SENDER";
        case ResponseOfferSnapshot_Result.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.responseOfferSnapshot_ResultToJSON = responseOfferSnapshot_ResultToJSON;
    var ResponseApplySnapshotChunk_Result;
    (function(ResponseApplySnapshotChunk_Result2) {
      ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["UNKNOWN"] = 0] = "UNKNOWN";
      ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["ACCEPT"] = 1] = "ACCEPT";
      ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["ABORT"] = 2] = "ABORT";
      ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["RETRY"] = 3] = "RETRY";
      ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["RETRY_SNAPSHOT"] = 4] = "RETRY_SNAPSHOT";
      ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["REJECT_SNAPSHOT"] = 5] = "REJECT_SNAPSHOT";
      ResponseApplySnapshotChunk_Result2[ResponseApplySnapshotChunk_Result2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ResponseApplySnapshotChunk_Result || (exports.ResponseApplySnapshotChunk_Result = ResponseApplySnapshotChunk_Result = {}));
    function responseApplySnapshotChunk_ResultFromJSON(object) {
      switch (object) {
        case 0:
        case "UNKNOWN":
          return ResponseApplySnapshotChunk_Result.UNKNOWN;
        case 1:
        case "ACCEPT":
          return ResponseApplySnapshotChunk_Result.ACCEPT;
        case 2:
        case "ABORT":
          return ResponseApplySnapshotChunk_Result.ABORT;
        case 3:
        case "RETRY":
          return ResponseApplySnapshotChunk_Result.RETRY;
        case 4:
        case "RETRY_SNAPSHOT":
          return ResponseApplySnapshotChunk_Result.RETRY_SNAPSHOT;
        case 5:
        case "REJECT_SNAPSHOT":
          return ResponseApplySnapshotChunk_Result.REJECT_SNAPSHOT;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ResponseApplySnapshotChunk_Result.UNRECOGNIZED;
      }
    }
    exports.responseApplySnapshotChunk_ResultFromJSON = responseApplySnapshotChunk_ResultFromJSON;
    function responseApplySnapshotChunk_ResultToJSON(object) {
      switch (object) {
        case ResponseApplySnapshotChunk_Result.UNKNOWN:
          return "UNKNOWN";
        case ResponseApplySnapshotChunk_Result.ACCEPT:
          return "ACCEPT";
        case ResponseApplySnapshotChunk_Result.ABORT:
          return "ABORT";
        case ResponseApplySnapshotChunk_Result.RETRY:
          return "RETRY";
        case ResponseApplySnapshotChunk_Result.RETRY_SNAPSHOT:
          return "RETRY_SNAPSHOT";
        case ResponseApplySnapshotChunk_Result.REJECT_SNAPSHOT:
          return "REJECT_SNAPSHOT";
        case ResponseApplySnapshotChunk_Result.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.responseApplySnapshotChunk_ResultToJSON = responseApplySnapshotChunk_ResultToJSON;
    var ResponseProcessProposal_ProposalStatus;
    (function(ResponseProcessProposal_ProposalStatus2) {
      ResponseProcessProposal_ProposalStatus2[ResponseProcessProposal_ProposalStatus2["UNKNOWN"] = 0] = "UNKNOWN";
      ResponseProcessProposal_ProposalStatus2[ResponseProcessProposal_ProposalStatus2["ACCEPT"] = 1] = "ACCEPT";
      ResponseProcessProposal_ProposalStatus2[ResponseProcessProposal_ProposalStatus2["REJECT"] = 2] = "REJECT";
      ResponseProcessProposal_ProposalStatus2[ResponseProcessProposal_ProposalStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ResponseProcessProposal_ProposalStatus || (exports.ResponseProcessProposal_ProposalStatus = ResponseProcessProposal_ProposalStatus = {}));
    function responseProcessProposal_ProposalStatusFromJSON(object) {
      switch (object) {
        case 0:
        case "UNKNOWN":
          return ResponseProcessProposal_ProposalStatus.UNKNOWN;
        case 1:
        case "ACCEPT":
          return ResponseProcessProposal_ProposalStatus.ACCEPT;
        case 2:
        case "REJECT":
          return ResponseProcessProposal_ProposalStatus.REJECT;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ResponseProcessProposal_ProposalStatus.UNRECOGNIZED;
      }
    }
    exports.responseProcessProposal_ProposalStatusFromJSON = responseProcessProposal_ProposalStatusFromJSON;
    function responseProcessProposal_ProposalStatusToJSON(object) {
      switch (object) {
        case ResponseProcessProposal_ProposalStatus.UNKNOWN:
          return "UNKNOWN";
        case ResponseProcessProposal_ProposalStatus.ACCEPT:
          return "ACCEPT";
        case ResponseProcessProposal_ProposalStatus.REJECT:
          return "REJECT";
        case ResponseProcessProposal_ProposalStatus.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.responseProcessProposal_ProposalStatusToJSON = responseProcessProposal_ProposalStatusToJSON;
    var ResponseVerifyVoteExtension_VerifyStatus;
    (function(ResponseVerifyVoteExtension_VerifyStatus2) {
      ResponseVerifyVoteExtension_VerifyStatus2[ResponseVerifyVoteExtension_VerifyStatus2["UNKNOWN"] = 0] = "UNKNOWN";
      ResponseVerifyVoteExtension_VerifyStatus2[ResponseVerifyVoteExtension_VerifyStatus2["ACCEPT"] = 1] = "ACCEPT";
      ResponseVerifyVoteExtension_VerifyStatus2[ResponseVerifyVoteExtension_VerifyStatus2["REJECT"] = 2] = "REJECT";
      ResponseVerifyVoteExtension_VerifyStatus2[ResponseVerifyVoteExtension_VerifyStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ResponseVerifyVoteExtension_VerifyStatus || (exports.ResponseVerifyVoteExtension_VerifyStatus = ResponseVerifyVoteExtension_VerifyStatus = {}));
    function responseVerifyVoteExtension_VerifyStatusFromJSON(object) {
      switch (object) {
        case 0:
        case "UNKNOWN":
          return ResponseVerifyVoteExtension_VerifyStatus.UNKNOWN;
        case 1:
        case "ACCEPT":
          return ResponseVerifyVoteExtension_VerifyStatus.ACCEPT;
        case 2:
        case "REJECT":
          return ResponseVerifyVoteExtension_VerifyStatus.REJECT;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ResponseVerifyVoteExtension_VerifyStatus.UNRECOGNIZED;
      }
    }
    exports.responseVerifyVoteExtension_VerifyStatusFromJSON = responseVerifyVoteExtension_VerifyStatusFromJSON;
    function responseVerifyVoteExtension_VerifyStatusToJSON(object) {
      switch (object) {
        case ResponseVerifyVoteExtension_VerifyStatus.UNKNOWN:
          return "UNKNOWN";
        case ResponseVerifyVoteExtension_VerifyStatus.ACCEPT:
          return "ACCEPT";
        case ResponseVerifyVoteExtension_VerifyStatus.REJECT:
          return "REJECT";
        case ResponseVerifyVoteExtension_VerifyStatus.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.responseVerifyVoteExtension_VerifyStatusToJSON = responseVerifyVoteExtension_VerifyStatusToJSON;
    var MisbehaviorType;
    (function(MisbehaviorType2) {
      MisbehaviorType2[MisbehaviorType2["UNKNOWN"] = 0] = "UNKNOWN";
      MisbehaviorType2[MisbehaviorType2["DUPLICATE_VOTE"] = 1] = "DUPLICATE_VOTE";
      MisbehaviorType2[MisbehaviorType2["LIGHT_CLIENT_ATTACK"] = 2] = "LIGHT_CLIENT_ATTACK";
      MisbehaviorType2[MisbehaviorType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(MisbehaviorType || (exports.MisbehaviorType = MisbehaviorType = {}));
    function misbehaviorTypeFromJSON(object) {
      switch (object) {
        case 0:
        case "UNKNOWN":
          return MisbehaviorType.UNKNOWN;
        case 1:
        case "DUPLICATE_VOTE":
          return MisbehaviorType.DUPLICATE_VOTE;
        case 2:
        case "LIGHT_CLIENT_ATTACK":
          return MisbehaviorType.LIGHT_CLIENT_ATTACK;
        case -1:
        case "UNRECOGNIZED":
        default:
          return MisbehaviorType.UNRECOGNIZED;
      }
    }
    exports.misbehaviorTypeFromJSON = misbehaviorTypeFromJSON;
    function misbehaviorTypeToJSON(object) {
      switch (object) {
        case MisbehaviorType.UNKNOWN:
          return "UNKNOWN";
        case MisbehaviorType.DUPLICATE_VOTE:
          return "DUPLICATE_VOTE";
        case MisbehaviorType.LIGHT_CLIENT_ATTACK:
          return "LIGHT_CLIENT_ATTACK";
        case MisbehaviorType.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.misbehaviorTypeToJSON = misbehaviorTypeToJSON;
    function createBaseRequest() {
      return {
        echo: void 0,
        flush: void 0,
        info: void 0,
        initChain: void 0,
        query: void 0,
        checkTx: void 0,
        commit: void 0,
        listSnapshots: void 0,
        offerSnapshot: void 0,
        loadSnapshotChunk: void 0,
        applySnapshotChunk: void 0,
        prepareProposal: void 0,
        processProposal: void 0,
        extendVote: void 0,
        verifyVoteExtension: void 0,
        finalizeBlock: void 0
      };
    }
    exports.Request = {
      typeUrl: "/tendermint.abci.Request",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.echo !== void 0) {
          exports.RequestEcho.encode(message.echo, writer.uint32(10).fork()).ldelim();
        }
        if (message.flush !== void 0) {
          exports.RequestFlush.encode(message.flush, writer.uint32(18).fork()).ldelim();
        }
        if (message.info !== void 0) {
          exports.RequestInfo.encode(message.info, writer.uint32(26).fork()).ldelim();
        }
        if (message.initChain !== void 0) {
          exports.RequestInitChain.encode(message.initChain, writer.uint32(42).fork()).ldelim();
        }
        if (message.query !== void 0) {
          exports.RequestQuery.encode(message.query, writer.uint32(50).fork()).ldelim();
        }
        if (message.checkTx !== void 0) {
          exports.RequestCheckTx.encode(message.checkTx, writer.uint32(66).fork()).ldelim();
        }
        if (message.commit !== void 0) {
          exports.RequestCommit.encode(message.commit, writer.uint32(90).fork()).ldelim();
        }
        if (message.listSnapshots !== void 0) {
          exports.RequestListSnapshots.encode(message.listSnapshots, writer.uint32(98).fork()).ldelim();
        }
        if (message.offerSnapshot !== void 0) {
          exports.RequestOfferSnapshot.encode(message.offerSnapshot, writer.uint32(106).fork()).ldelim();
        }
        if (message.loadSnapshotChunk !== void 0) {
          exports.RequestLoadSnapshotChunk.encode(message.loadSnapshotChunk, writer.uint32(114).fork()).ldelim();
        }
        if (message.applySnapshotChunk !== void 0) {
          exports.RequestApplySnapshotChunk.encode(message.applySnapshotChunk, writer.uint32(122).fork()).ldelim();
        }
        if (message.prepareProposal !== void 0) {
          exports.RequestPrepareProposal.encode(message.prepareProposal, writer.uint32(130).fork()).ldelim();
        }
        if (message.processProposal !== void 0) {
          exports.RequestProcessProposal.encode(message.processProposal, writer.uint32(138).fork()).ldelim();
        }
        if (message.extendVote !== void 0) {
          exports.RequestExtendVote.encode(message.extendVote, writer.uint32(146).fork()).ldelim();
        }
        if (message.verifyVoteExtension !== void 0) {
          exports.RequestVerifyVoteExtension.encode(message.verifyVoteExtension, writer.uint32(154).fork()).ldelim();
        }
        if (message.finalizeBlock !== void 0) {
          exports.RequestFinalizeBlock.encode(message.finalizeBlock, writer.uint32(162).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.echo = exports.RequestEcho.decode(reader, reader.uint32());
              break;
            case 2:
              message.flush = exports.RequestFlush.decode(reader, reader.uint32());
              break;
            case 3:
              message.info = exports.RequestInfo.decode(reader, reader.uint32());
              break;
            case 5:
              message.initChain = exports.RequestInitChain.decode(reader, reader.uint32());
              break;
            case 6:
              message.query = exports.RequestQuery.decode(reader, reader.uint32());
              break;
            case 8:
              message.checkTx = exports.RequestCheckTx.decode(reader, reader.uint32());
              break;
            case 11:
              message.commit = exports.RequestCommit.decode(reader, reader.uint32());
              break;
            case 12:
              message.listSnapshots = exports.RequestListSnapshots.decode(reader, reader.uint32());
              break;
            case 13:
              message.offerSnapshot = exports.RequestOfferSnapshot.decode(reader, reader.uint32());
              break;
            case 14:
              message.loadSnapshotChunk = exports.RequestLoadSnapshotChunk.decode(reader, reader.uint32());
              break;
            case 15:
              message.applySnapshotChunk = exports.RequestApplySnapshotChunk.decode(reader, reader.uint32());
              break;
            case 16:
              message.prepareProposal = exports.RequestPrepareProposal.decode(reader, reader.uint32());
              break;
            case 17:
              message.processProposal = exports.RequestProcessProposal.decode(reader, reader.uint32());
              break;
            case 18:
              message.extendVote = exports.RequestExtendVote.decode(reader, reader.uint32());
              break;
            case 19:
              message.verifyVoteExtension = exports.RequestVerifyVoteExtension.decode(reader, reader.uint32());
              break;
            case 20:
              message.finalizeBlock = exports.RequestFinalizeBlock.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequest();
        if ((0, helpers_1.isSet)(object.echo))
          obj.echo = exports.RequestEcho.fromJSON(object.echo);
        if ((0, helpers_1.isSet)(object.flush))
          obj.flush = exports.RequestFlush.fromJSON(object.flush);
        if ((0, helpers_1.isSet)(object.info))
          obj.info = exports.RequestInfo.fromJSON(object.info);
        if ((0, helpers_1.isSet)(object.initChain))
          obj.initChain = exports.RequestInitChain.fromJSON(object.initChain);
        if ((0, helpers_1.isSet)(object.query))
          obj.query = exports.RequestQuery.fromJSON(object.query);
        if ((0, helpers_1.isSet)(object.checkTx))
          obj.checkTx = exports.RequestCheckTx.fromJSON(object.checkTx);
        if ((0, helpers_1.isSet)(object.commit))
          obj.commit = exports.RequestCommit.fromJSON(object.commit);
        if ((0, helpers_1.isSet)(object.listSnapshots))
          obj.listSnapshots = exports.RequestListSnapshots.fromJSON(object.listSnapshots);
        if ((0, helpers_1.isSet)(object.offerSnapshot))
          obj.offerSnapshot = exports.RequestOfferSnapshot.fromJSON(object.offerSnapshot);
        if ((0, helpers_1.isSet)(object.loadSnapshotChunk))
          obj.loadSnapshotChunk = exports.RequestLoadSnapshotChunk.fromJSON(object.loadSnapshotChunk);
        if ((0, helpers_1.isSet)(object.applySnapshotChunk))
          obj.applySnapshotChunk = exports.RequestApplySnapshotChunk.fromJSON(object.applySnapshotChunk);
        if ((0, helpers_1.isSet)(object.prepareProposal))
          obj.prepareProposal = exports.RequestPrepareProposal.fromJSON(object.prepareProposal);
        if ((0, helpers_1.isSet)(object.processProposal))
          obj.processProposal = exports.RequestProcessProposal.fromJSON(object.processProposal);
        if ((0, helpers_1.isSet)(object.extendVote))
          obj.extendVote = exports.RequestExtendVote.fromJSON(object.extendVote);
        if ((0, helpers_1.isSet)(object.verifyVoteExtension))
          obj.verifyVoteExtension = exports.RequestVerifyVoteExtension.fromJSON(object.verifyVoteExtension);
        if ((0, helpers_1.isSet)(object.finalizeBlock))
          obj.finalizeBlock = exports.RequestFinalizeBlock.fromJSON(object.finalizeBlock);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.echo !== void 0 && (obj.echo = message.echo ? exports.RequestEcho.toJSON(message.echo) : void 0);
        message.flush !== void 0 && (obj.flush = message.flush ? exports.RequestFlush.toJSON(message.flush) : void 0);
        message.info !== void 0 && (obj.info = message.info ? exports.RequestInfo.toJSON(message.info) : void 0);
        message.initChain !== void 0 && (obj.initChain = message.initChain ? exports.RequestInitChain.toJSON(message.initChain) : void 0);
        message.query !== void 0 && (obj.query = message.query ? exports.RequestQuery.toJSON(message.query) : void 0);
        message.checkTx !== void 0 && (obj.checkTx = message.checkTx ? exports.RequestCheckTx.toJSON(message.checkTx) : void 0);
        message.commit !== void 0 && (obj.commit = message.commit ? exports.RequestCommit.toJSON(message.commit) : void 0);
        message.listSnapshots !== void 0 && (obj.listSnapshots = message.listSnapshots ? exports.RequestListSnapshots.toJSON(message.listSnapshots) : void 0);
        message.offerSnapshot !== void 0 && (obj.offerSnapshot = message.offerSnapshot ? exports.RequestOfferSnapshot.toJSON(message.offerSnapshot) : void 0);
        message.loadSnapshotChunk !== void 0 && (obj.loadSnapshotChunk = message.loadSnapshotChunk ? exports.RequestLoadSnapshotChunk.toJSON(message.loadSnapshotChunk) : void 0);
        message.applySnapshotChunk !== void 0 && (obj.applySnapshotChunk = message.applySnapshotChunk ? exports.RequestApplySnapshotChunk.toJSON(message.applySnapshotChunk) : void 0);
        message.prepareProposal !== void 0 && (obj.prepareProposal = message.prepareProposal ? exports.RequestPrepareProposal.toJSON(message.prepareProposal) : void 0);
        message.processProposal !== void 0 && (obj.processProposal = message.processProposal ? exports.RequestProcessProposal.toJSON(message.processProposal) : void 0);
        message.extendVote !== void 0 && (obj.extendVote = message.extendVote ? exports.RequestExtendVote.toJSON(message.extendVote) : void 0);
        message.verifyVoteExtension !== void 0 && (obj.verifyVoteExtension = message.verifyVoteExtension ? exports.RequestVerifyVoteExtension.toJSON(message.verifyVoteExtension) : void 0);
        message.finalizeBlock !== void 0 && (obj.finalizeBlock = message.finalizeBlock ? exports.RequestFinalizeBlock.toJSON(message.finalizeBlock) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequest();
        if (object.echo !== void 0 && object.echo !== null) {
          message.echo = exports.RequestEcho.fromPartial(object.echo);
        }
        if (object.flush !== void 0 && object.flush !== null) {
          message.flush = exports.RequestFlush.fromPartial(object.flush);
        }
        if (object.info !== void 0 && object.info !== null) {
          message.info = exports.RequestInfo.fromPartial(object.info);
        }
        if (object.initChain !== void 0 && object.initChain !== null) {
          message.initChain = exports.RequestInitChain.fromPartial(object.initChain);
        }
        if (object.query !== void 0 && object.query !== null) {
          message.query = exports.RequestQuery.fromPartial(object.query);
        }
        if (object.checkTx !== void 0 && object.checkTx !== null) {
          message.checkTx = exports.RequestCheckTx.fromPartial(object.checkTx);
        }
        if (object.commit !== void 0 && object.commit !== null) {
          message.commit = exports.RequestCommit.fromPartial(object.commit);
        }
        if (object.listSnapshots !== void 0 && object.listSnapshots !== null) {
          message.listSnapshots = exports.RequestListSnapshots.fromPartial(object.listSnapshots);
        }
        if (object.offerSnapshot !== void 0 && object.offerSnapshot !== null) {
          message.offerSnapshot = exports.RequestOfferSnapshot.fromPartial(object.offerSnapshot);
        }
        if (object.loadSnapshotChunk !== void 0 && object.loadSnapshotChunk !== null) {
          message.loadSnapshotChunk = exports.RequestLoadSnapshotChunk.fromPartial(object.loadSnapshotChunk);
        }
        if (object.applySnapshotChunk !== void 0 && object.applySnapshotChunk !== null) {
          message.applySnapshotChunk = exports.RequestApplySnapshotChunk.fromPartial(object.applySnapshotChunk);
        }
        if (object.prepareProposal !== void 0 && object.prepareProposal !== null) {
          message.prepareProposal = exports.RequestPrepareProposal.fromPartial(object.prepareProposal);
        }
        if (object.processProposal !== void 0 && object.processProposal !== null) {
          message.processProposal = exports.RequestProcessProposal.fromPartial(object.processProposal);
        }
        if (object.extendVote !== void 0 && object.extendVote !== null) {
          message.extendVote = exports.RequestExtendVote.fromPartial(object.extendVote);
        }
        if (object.verifyVoteExtension !== void 0 && object.verifyVoteExtension !== null) {
          message.verifyVoteExtension = exports.RequestVerifyVoteExtension.fromPartial(object.verifyVoteExtension);
        }
        if (object.finalizeBlock !== void 0 && object.finalizeBlock !== null) {
          message.finalizeBlock = exports.RequestFinalizeBlock.fromPartial(object.finalizeBlock);
        }
        return message;
      }
    };
    function createBaseRequestEcho() {
      return {
        message: ""
      };
    }
    exports.RequestEcho = {
      typeUrl: "/tendermint.abci.RequestEcho",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.message !== "") {
          writer.uint32(10).string(message.message);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestEcho();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.message = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestEcho();
        if ((0, helpers_1.isSet)(object.message))
          obj.message = String(object.message);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.message !== void 0 && (obj.message = message.message);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequestEcho();
        message.message = object.message ?? "";
        return message;
      }
    };
    function createBaseRequestFlush() {
      return {};
    }
    exports.RequestFlush = {
      typeUrl: "/tendermint.abci.RequestFlush",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestFlush();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseRequestFlush();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseRequestFlush();
        return message;
      }
    };
    function createBaseRequestInfo() {
      return {
        version: "",
        blockVersion: BigInt(0),
        p2pVersion: BigInt(0),
        abciVersion: ""
      };
    }
    exports.RequestInfo = {
      typeUrl: "/tendermint.abci.RequestInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.version !== "") {
          writer.uint32(10).string(message.version);
        }
        if (message.blockVersion !== BigInt(0)) {
          writer.uint32(16).uint64(message.blockVersion);
        }
        if (message.p2pVersion !== BigInt(0)) {
          writer.uint32(24).uint64(message.p2pVersion);
        }
        if (message.abciVersion !== "") {
          writer.uint32(34).string(message.abciVersion);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.version = reader.string();
              break;
            case 2:
              message.blockVersion = reader.uint64();
              break;
            case 3:
              message.p2pVersion = reader.uint64();
              break;
            case 4:
              message.abciVersion = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestInfo();
        if ((0, helpers_1.isSet)(object.version))
          obj.version = String(object.version);
        if ((0, helpers_1.isSet)(object.blockVersion))
          obj.blockVersion = BigInt(object.blockVersion.toString());
        if ((0, helpers_1.isSet)(object.p2pVersion))
          obj.p2pVersion = BigInt(object.p2pVersion.toString());
        if ((0, helpers_1.isSet)(object.abciVersion))
          obj.abciVersion = String(object.abciVersion);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.version !== void 0 && (obj.version = message.version);
        message.blockVersion !== void 0 && (obj.blockVersion = (message.blockVersion || BigInt(0)).toString());
        message.p2pVersion !== void 0 && (obj.p2pVersion = (message.p2pVersion || BigInt(0)).toString());
        message.abciVersion !== void 0 && (obj.abciVersion = message.abciVersion);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequestInfo();
        message.version = object.version ?? "";
        if (object.blockVersion !== void 0 && object.blockVersion !== null) {
          message.blockVersion = BigInt(object.blockVersion.toString());
        }
        if (object.p2pVersion !== void 0 && object.p2pVersion !== null) {
          message.p2pVersion = BigInt(object.p2pVersion.toString());
        }
        message.abciVersion = object.abciVersion ?? "";
        return message;
      }
    };
    function createBaseRequestInitChain() {
      return {
        time: timestamp_1.Timestamp.fromPartial({}),
        chainId: "",
        consensusParams: void 0,
        validators: [],
        appStateBytes: new Uint8Array(),
        initialHeight: BigInt(0)
      };
    }
    exports.RequestInitChain = {
      typeUrl: "/tendermint.abci.RequestInitChain",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.time !== void 0) {
          timestamp_1.Timestamp.encode(message.time, writer.uint32(10).fork()).ldelim();
        }
        if (message.chainId !== "") {
          writer.uint32(18).string(message.chainId);
        }
        if (message.consensusParams !== void 0) {
          params_1.ConsensusParams.encode(message.consensusParams, writer.uint32(26).fork()).ldelim();
        }
        for (const v9 of message.validators) {
          exports.ValidatorUpdate.encode(v9, writer.uint32(34).fork()).ldelim();
        }
        if (message.appStateBytes.length !== 0) {
          writer.uint32(42).bytes(message.appStateBytes);
        }
        if (message.initialHeight !== BigInt(0)) {
          writer.uint32(48).int64(message.initialHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestInitChain();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 2:
              message.chainId = reader.string();
              break;
            case 3:
              message.consensusParams = params_1.ConsensusParams.decode(reader, reader.uint32());
              break;
            case 4:
              message.validators.push(exports.ValidatorUpdate.decode(reader, reader.uint32()));
              break;
            case 5:
              message.appStateBytes = reader.bytes();
              break;
            case 6:
              message.initialHeight = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestInitChain();
        if ((0, helpers_1.isSet)(object.time))
          obj.time = (0, helpers_1.fromJsonTimestamp)(object.time);
        if ((0, helpers_1.isSet)(object.chainId))
          obj.chainId = String(object.chainId);
        if ((0, helpers_1.isSet)(object.consensusParams))
          obj.consensusParams = params_1.ConsensusParams.fromJSON(object.consensusParams);
        if (Array.isArray(object?.validators))
          obj.validators = object.validators.map((e) => exports.ValidatorUpdate.fromJSON(e));
        if ((0, helpers_1.isSet)(object.appStateBytes))
          obj.appStateBytes = (0, helpers_1.bytesFromBase64)(object.appStateBytes);
        if ((0, helpers_1.isSet)(object.initialHeight))
          obj.initialHeight = BigInt(object.initialHeight.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.time !== void 0 && (obj.time = (0, helpers_1.fromTimestamp)(message.time).toISOString());
        message.chainId !== void 0 && (obj.chainId = message.chainId);
        message.consensusParams !== void 0 && (obj.consensusParams = message.consensusParams ? params_1.ConsensusParams.toJSON(message.consensusParams) : void 0);
        if (message.validators) {
          obj.validators = message.validators.map((e) => e ? exports.ValidatorUpdate.toJSON(e) : void 0);
        } else {
          obj.validators = [];
        }
        message.appStateBytes !== void 0 && (obj.appStateBytes = (0, helpers_1.base64FromBytes)(message.appStateBytes !== void 0 ? message.appStateBytes : new Uint8Array()));
        message.initialHeight !== void 0 && (obj.initialHeight = (message.initialHeight || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequestInitChain();
        if (object.time !== void 0 && object.time !== null) {
          message.time = timestamp_1.Timestamp.fromPartial(object.time);
        }
        message.chainId = object.chainId ?? "";
        if (object.consensusParams !== void 0 && object.consensusParams !== null) {
          message.consensusParams = params_1.ConsensusParams.fromPartial(object.consensusParams);
        }
        message.validators = object.validators?.map((e) => exports.ValidatorUpdate.fromPartial(e)) || [];
        message.appStateBytes = object.appStateBytes ?? new Uint8Array();
        if (object.initialHeight !== void 0 && object.initialHeight !== null) {
          message.initialHeight = BigInt(object.initialHeight.toString());
        }
        return message;
      }
    };
    function createBaseRequestQuery() {
      return {
        data: new Uint8Array(),
        path: "",
        height: BigInt(0),
        prove: false
      };
    }
    exports.RequestQuery = {
      typeUrl: "/tendermint.abci.RequestQuery",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.data.length !== 0) {
          writer.uint32(10).bytes(message.data);
        }
        if (message.path !== "") {
          writer.uint32(18).string(message.path);
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(24).int64(message.height);
        }
        if (message.prove === true) {
          writer.uint32(32).bool(message.prove);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestQuery();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.data = reader.bytes();
              break;
            case 2:
              message.path = reader.string();
              break;
            case 3:
              message.height = reader.int64();
              break;
            case 4:
              message.prove = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestQuery();
        if ((0, helpers_1.isSet)(object.data))
          obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        if ((0, helpers_1.isSet)(object.path))
          obj.path = String(object.path);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.prove))
          obj.prove = Boolean(object.prove);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        message.path !== void 0 && (obj.path = message.path);
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.prove !== void 0 && (obj.prove = message.prove);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequestQuery();
        message.data = object.data ?? new Uint8Array();
        message.path = object.path ?? "";
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        message.prove = object.prove ?? false;
        return message;
      }
    };
    function createBaseRequestCheckTx() {
      return {
        tx: new Uint8Array(),
        type: 0
      };
    }
    exports.RequestCheckTx = {
      typeUrl: "/tendermint.abci.RequestCheckTx",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.tx.length !== 0) {
          writer.uint32(10).bytes(message.tx);
        }
        if (message.type !== 0) {
          writer.uint32(16).int32(message.type);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestCheckTx();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.tx = reader.bytes();
              break;
            case 2:
              message.type = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestCheckTx();
        if ((0, helpers_1.isSet)(object.tx))
          obj.tx = (0, helpers_1.bytesFromBase64)(object.tx);
        if ((0, helpers_1.isSet)(object.type))
          obj.type = checkTxTypeFromJSON(object.type);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.tx !== void 0 && (obj.tx = (0, helpers_1.base64FromBytes)(message.tx !== void 0 ? message.tx : new Uint8Array()));
        message.type !== void 0 && (obj.type = checkTxTypeToJSON(message.type));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequestCheckTx();
        message.tx = object.tx ?? new Uint8Array();
        message.type = object.type ?? 0;
        return message;
      }
    };
    function createBaseRequestCommit() {
      return {};
    }
    exports.RequestCommit = {
      typeUrl: "/tendermint.abci.RequestCommit",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestCommit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseRequestCommit();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseRequestCommit();
        return message;
      }
    };
    function createBaseRequestListSnapshots() {
      return {};
    }
    exports.RequestListSnapshots = {
      typeUrl: "/tendermint.abci.RequestListSnapshots",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestListSnapshots();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseRequestListSnapshots();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseRequestListSnapshots();
        return message;
      }
    };
    function createBaseRequestOfferSnapshot() {
      return {
        snapshot: void 0,
        appHash: new Uint8Array()
      };
    }
    exports.RequestOfferSnapshot = {
      typeUrl: "/tendermint.abci.RequestOfferSnapshot",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.snapshot !== void 0) {
          exports.Snapshot.encode(message.snapshot, writer.uint32(10).fork()).ldelim();
        }
        if (message.appHash.length !== 0) {
          writer.uint32(18).bytes(message.appHash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestOfferSnapshot();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.snapshot = exports.Snapshot.decode(reader, reader.uint32());
              break;
            case 2:
              message.appHash = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestOfferSnapshot();
        if ((0, helpers_1.isSet)(object.snapshot))
          obj.snapshot = exports.Snapshot.fromJSON(object.snapshot);
        if ((0, helpers_1.isSet)(object.appHash))
          obj.appHash = (0, helpers_1.bytesFromBase64)(object.appHash);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.snapshot !== void 0 && (obj.snapshot = message.snapshot ? exports.Snapshot.toJSON(message.snapshot) : void 0);
        message.appHash !== void 0 && (obj.appHash = (0, helpers_1.base64FromBytes)(message.appHash !== void 0 ? message.appHash : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequestOfferSnapshot();
        if (object.snapshot !== void 0 && object.snapshot !== null) {
          message.snapshot = exports.Snapshot.fromPartial(object.snapshot);
        }
        message.appHash = object.appHash ?? new Uint8Array();
        return message;
      }
    };
    function createBaseRequestLoadSnapshotChunk() {
      return {
        height: BigInt(0),
        format: 0,
        chunk: 0
      };
    }
    exports.RequestLoadSnapshotChunk = {
      typeUrl: "/tendermint.abci.RequestLoadSnapshotChunk",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== BigInt(0)) {
          writer.uint32(8).uint64(message.height);
        }
        if (message.format !== 0) {
          writer.uint32(16).uint32(message.format);
        }
        if (message.chunk !== 0) {
          writer.uint32(24).uint32(message.chunk);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestLoadSnapshotChunk();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = reader.uint64();
              break;
            case 2:
              message.format = reader.uint32();
              break;
            case 3:
              message.chunk = reader.uint32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestLoadSnapshotChunk();
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.format))
          obj.format = Number(object.format);
        if ((0, helpers_1.isSet)(object.chunk))
          obj.chunk = Number(object.chunk);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.format !== void 0 && (obj.format = Math.round(message.format));
        message.chunk !== void 0 && (obj.chunk = Math.round(message.chunk));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequestLoadSnapshotChunk();
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        message.format = object.format ?? 0;
        message.chunk = object.chunk ?? 0;
        return message;
      }
    };
    function createBaseRequestApplySnapshotChunk() {
      return {
        index: 0,
        chunk: new Uint8Array(),
        sender: ""
      };
    }
    exports.RequestApplySnapshotChunk = {
      typeUrl: "/tendermint.abci.RequestApplySnapshotChunk",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.index !== 0) {
          writer.uint32(8).uint32(message.index);
        }
        if (message.chunk.length !== 0) {
          writer.uint32(18).bytes(message.chunk);
        }
        if (message.sender !== "") {
          writer.uint32(26).string(message.sender);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestApplySnapshotChunk();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.index = reader.uint32();
              break;
            case 2:
              message.chunk = reader.bytes();
              break;
            case 3:
              message.sender = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestApplySnapshotChunk();
        if ((0, helpers_1.isSet)(object.index))
          obj.index = Number(object.index);
        if ((0, helpers_1.isSet)(object.chunk))
          obj.chunk = (0, helpers_1.bytesFromBase64)(object.chunk);
        if ((0, helpers_1.isSet)(object.sender))
          obj.sender = String(object.sender);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.index !== void 0 && (obj.index = Math.round(message.index));
        message.chunk !== void 0 && (obj.chunk = (0, helpers_1.base64FromBytes)(message.chunk !== void 0 ? message.chunk : new Uint8Array()));
        message.sender !== void 0 && (obj.sender = message.sender);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequestApplySnapshotChunk();
        message.index = object.index ?? 0;
        message.chunk = object.chunk ?? new Uint8Array();
        message.sender = object.sender ?? "";
        return message;
      }
    };
    function createBaseRequestPrepareProposal() {
      return {
        maxTxBytes: BigInt(0),
        txs: [],
        localLastCommit: exports.ExtendedCommitInfo.fromPartial({}),
        misbehavior: [],
        height: BigInt(0),
        time: timestamp_1.Timestamp.fromPartial({}),
        nextValidatorsHash: new Uint8Array(),
        proposerAddress: new Uint8Array()
      };
    }
    exports.RequestPrepareProposal = {
      typeUrl: "/tendermint.abci.RequestPrepareProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.maxTxBytes !== BigInt(0)) {
          writer.uint32(8).int64(message.maxTxBytes);
        }
        for (const v9 of message.txs) {
          writer.uint32(18).bytes(v9);
        }
        if (message.localLastCommit !== void 0) {
          exports.ExtendedCommitInfo.encode(message.localLastCommit, writer.uint32(26).fork()).ldelim();
        }
        for (const v9 of message.misbehavior) {
          exports.Misbehavior.encode(v9, writer.uint32(34).fork()).ldelim();
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(40).int64(message.height);
        }
        if (message.time !== void 0) {
          timestamp_1.Timestamp.encode(message.time, writer.uint32(50).fork()).ldelim();
        }
        if (message.nextValidatorsHash.length !== 0) {
          writer.uint32(58).bytes(message.nextValidatorsHash);
        }
        if (message.proposerAddress.length !== 0) {
          writer.uint32(66).bytes(message.proposerAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestPrepareProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.maxTxBytes = reader.int64();
              break;
            case 2:
              message.txs.push(reader.bytes());
              break;
            case 3:
              message.localLastCommit = exports.ExtendedCommitInfo.decode(reader, reader.uint32());
              break;
            case 4:
              message.misbehavior.push(exports.Misbehavior.decode(reader, reader.uint32()));
              break;
            case 5:
              message.height = reader.int64();
              break;
            case 6:
              message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 7:
              message.nextValidatorsHash = reader.bytes();
              break;
            case 8:
              message.proposerAddress = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestPrepareProposal();
        if ((0, helpers_1.isSet)(object.maxTxBytes))
          obj.maxTxBytes = BigInt(object.maxTxBytes.toString());
        if (Array.isArray(object?.txs))
          obj.txs = object.txs.map((e) => (0, helpers_1.bytesFromBase64)(e));
        if ((0, helpers_1.isSet)(object.localLastCommit))
          obj.localLastCommit = exports.ExtendedCommitInfo.fromJSON(object.localLastCommit);
        if (Array.isArray(object?.misbehavior))
          obj.misbehavior = object.misbehavior.map((e) => exports.Misbehavior.fromJSON(e));
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.time))
          obj.time = (0, helpers_1.fromJsonTimestamp)(object.time);
        if ((0, helpers_1.isSet)(object.nextValidatorsHash))
          obj.nextValidatorsHash = (0, helpers_1.bytesFromBase64)(object.nextValidatorsHash);
        if ((0, helpers_1.isSet)(object.proposerAddress))
          obj.proposerAddress = (0, helpers_1.bytesFromBase64)(object.proposerAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.maxTxBytes !== void 0 && (obj.maxTxBytes = (message.maxTxBytes || BigInt(0)).toString());
        if (message.txs) {
          obj.txs = message.txs.map((e) => (0, helpers_1.base64FromBytes)(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.txs = [];
        }
        message.localLastCommit !== void 0 && (obj.localLastCommit = message.localLastCommit ? exports.ExtendedCommitInfo.toJSON(message.localLastCommit) : void 0);
        if (message.misbehavior) {
          obj.misbehavior = message.misbehavior.map((e) => e ? exports.Misbehavior.toJSON(e) : void 0);
        } else {
          obj.misbehavior = [];
        }
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.time !== void 0 && (obj.time = (0, helpers_1.fromTimestamp)(message.time).toISOString());
        message.nextValidatorsHash !== void 0 && (obj.nextValidatorsHash = (0, helpers_1.base64FromBytes)(message.nextValidatorsHash !== void 0 ? message.nextValidatorsHash : new Uint8Array()));
        message.proposerAddress !== void 0 && (obj.proposerAddress = (0, helpers_1.base64FromBytes)(message.proposerAddress !== void 0 ? message.proposerAddress : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequestPrepareProposal();
        if (object.maxTxBytes !== void 0 && object.maxTxBytes !== null) {
          message.maxTxBytes = BigInt(object.maxTxBytes.toString());
        }
        message.txs = object.txs?.map((e) => e) || [];
        if (object.localLastCommit !== void 0 && object.localLastCommit !== null) {
          message.localLastCommit = exports.ExtendedCommitInfo.fromPartial(object.localLastCommit);
        }
        message.misbehavior = object.misbehavior?.map((e) => exports.Misbehavior.fromPartial(e)) || [];
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        if (object.time !== void 0 && object.time !== null) {
          message.time = timestamp_1.Timestamp.fromPartial(object.time);
        }
        message.nextValidatorsHash = object.nextValidatorsHash ?? new Uint8Array();
        message.proposerAddress = object.proposerAddress ?? new Uint8Array();
        return message;
      }
    };
    function createBaseRequestProcessProposal() {
      return {
        txs: [],
        proposedLastCommit: exports.CommitInfo.fromPartial({}),
        misbehavior: [],
        hash: new Uint8Array(),
        height: BigInt(0),
        time: timestamp_1.Timestamp.fromPartial({}),
        nextValidatorsHash: new Uint8Array(),
        proposerAddress: new Uint8Array()
      };
    }
    exports.RequestProcessProposal = {
      typeUrl: "/tendermint.abci.RequestProcessProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.txs) {
          writer.uint32(10).bytes(v9);
        }
        if (message.proposedLastCommit !== void 0) {
          exports.CommitInfo.encode(message.proposedLastCommit, writer.uint32(18).fork()).ldelim();
        }
        for (const v9 of message.misbehavior) {
          exports.Misbehavior.encode(v9, writer.uint32(26).fork()).ldelim();
        }
        if (message.hash.length !== 0) {
          writer.uint32(34).bytes(message.hash);
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(40).int64(message.height);
        }
        if (message.time !== void 0) {
          timestamp_1.Timestamp.encode(message.time, writer.uint32(50).fork()).ldelim();
        }
        if (message.nextValidatorsHash.length !== 0) {
          writer.uint32(58).bytes(message.nextValidatorsHash);
        }
        if (message.proposerAddress.length !== 0) {
          writer.uint32(66).bytes(message.proposerAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestProcessProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txs.push(reader.bytes());
              break;
            case 2:
              message.proposedLastCommit = exports.CommitInfo.decode(reader, reader.uint32());
              break;
            case 3:
              message.misbehavior.push(exports.Misbehavior.decode(reader, reader.uint32()));
              break;
            case 4:
              message.hash = reader.bytes();
              break;
            case 5:
              message.height = reader.int64();
              break;
            case 6:
              message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 7:
              message.nextValidatorsHash = reader.bytes();
              break;
            case 8:
              message.proposerAddress = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestProcessProposal();
        if (Array.isArray(object?.txs))
          obj.txs = object.txs.map((e) => (0, helpers_1.bytesFromBase64)(e));
        if ((0, helpers_1.isSet)(object.proposedLastCommit))
          obj.proposedLastCommit = exports.CommitInfo.fromJSON(object.proposedLastCommit);
        if (Array.isArray(object?.misbehavior))
          obj.misbehavior = object.misbehavior.map((e) => exports.Misbehavior.fromJSON(e));
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = (0, helpers_1.bytesFromBase64)(object.hash);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.time))
          obj.time = (0, helpers_1.fromJsonTimestamp)(object.time);
        if ((0, helpers_1.isSet)(object.nextValidatorsHash))
          obj.nextValidatorsHash = (0, helpers_1.bytesFromBase64)(object.nextValidatorsHash);
        if ((0, helpers_1.isSet)(object.proposerAddress))
          obj.proposerAddress = (0, helpers_1.bytesFromBase64)(object.proposerAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.txs) {
          obj.txs = message.txs.map((e) => (0, helpers_1.base64FromBytes)(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.txs = [];
        }
        message.proposedLastCommit !== void 0 && (obj.proposedLastCommit = message.proposedLastCommit ? exports.CommitInfo.toJSON(message.proposedLastCommit) : void 0);
        if (message.misbehavior) {
          obj.misbehavior = message.misbehavior.map((e) => e ? exports.Misbehavior.toJSON(e) : void 0);
        } else {
          obj.misbehavior = [];
        }
        message.hash !== void 0 && (obj.hash = (0, helpers_1.base64FromBytes)(message.hash !== void 0 ? message.hash : new Uint8Array()));
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.time !== void 0 && (obj.time = (0, helpers_1.fromTimestamp)(message.time).toISOString());
        message.nextValidatorsHash !== void 0 && (obj.nextValidatorsHash = (0, helpers_1.base64FromBytes)(message.nextValidatorsHash !== void 0 ? message.nextValidatorsHash : new Uint8Array()));
        message.proposerAddress !== void 0 && (obj.proposerAddress = (0, helpers_1.base64FromBytes)(message.proposerAddress !== void 0 ? message.proposerAddress : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequestProcessProposal();
        message.txs = object.txs?.map((e) => e) || [];
        if (object.proposedLastCommit !== void 0 && object.proposedLastCommit !== null) {
          message.proposedLastCommit = exports.CommitInfo.fromPartial(object.proposedLastCommit);
        }
        message.misbehavior = object.misbehavior?.map((e) => exports.Misbehavior.fromPartial(e)) || [];
        message.hash = object.hash ?? new Uint8Array();
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        if (object.time !== void 0 && object.time !== null) {
          message.time = timestamp_1.Timestamp.fromPartial(object.time);
        }
        message.nextValidatorsHash = object.nextValidatorsHash ?? new Uint8Array();
        message.proposerAddress = object.proposerAddress ?? new Uint8Array();
        return message;
      }
    };
    function createBaseRequestExtendVote() {
      return {
        hash: new Uint8Array(),
        height: BigInt(0),
        time: timestamp_1.Timestamp.fromPartial({}),
        txs: [],
        proposedLastCommit: exports.CommitInfo.fromPartial({}),
        misbehavior: [],
        nextValidatorsHash: new Uint8Array(),
        proposerAddress: new Uint8Array()
      };
    }
    exports.RequestExtendVote = {
      typeUrl: "/tendermint.abci.RequestExtendVote",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.hash.length !== 0) {
          writer.uint32(10).bytes(message.hash);
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(16).int64(message.height);
        }
        if (message.time !== void 0) {
          timestamp_1.Timestamp.encode(message.time, writer.uint32(26).fork()).ldelim();
        }
        for (const v9 of message.txs) {
          writer.uint32(34).bytes(v9);
        }
        if (message.proposedLastCommit !== void 0) {
          exports.CommitInfo.encode(message.proposedLastCommit, writer.uint32(42).fork()).ldelim();
        }
        for (const v9 of message.misbehavior) {
          exports.Misbehavior.encode(v9, writer.uint32(50).fork()).ldelim();
        }
        if (message.nextValidatorsHash.length !== 0) {
          writer.uint32(58).bytes(message.nextValidatorsHash);
        }
        if (message.proposerAddress.length !== 0) {
          writer.uint32(66).bytes(message.proposerAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestExtendVote();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.bytes();
              break;
            case 2:
              message.height = reader.int64();
              break;
            case 3:
              message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 4:
              message.txs.push(reader.bytes());
              break;
            case 5:
              message.proposedLastCommit = exports.CommitInfo.decode(reader, reader.uint32());
              break;
            case 6:
              message.misbehavior.push(exports.Misbehavior.decode(reader, reader.uint32()));
              break;
            case 7:
              message.nextValidatorsHash = reader.bytes();
              break;
            case 8:
              message.proposerAddress = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestExtendVote();
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = (0, helpers_1.bytesFromBase64)(object.hash);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.time))
          obj.time = (0, helpers_1.fromJsonTimestamp)(object.time);
        if (Array.isArray(object?.txs))
          obj.txs = object.txs.map((e) => (0, helpers_1.bytesFromBase64)(e));
        if ((0, helpers_1.isSet)(object.proposedLastCommit))
          obj.proposedLastCommit = exports.CommitInfo.fromJSON(object.proposedLastCommit);
        if (Array.isArray(object?.misbehavior))
          obj.misbehavior = object.misbehavior.map((e) => exports.Misbehavior.fromJSON(e));
        if ((0, helpers_1.isSet)(object.nextValidatorsHash))
          obj.nextValidatorsHash = (0, helpers_1.bytesFromBase64)(object.nextValidatorsHash);
        if ((0, helpers_1.isSet)(object.proposerAddress))
          obj.proposerAddress = (0, helpers_1.bytesFromBase64)(object.proposerAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = (0, helpers_1.base64FromBytes)(message.hash !== void 0 ? message.hash : new Uint8Array()));
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.time !== void 0 && (obj.time = (0, helpers_1.fromTimestamp)(message.time).toISOString());
        if (message.txs) {
          obj.txs = message.txs.map((e) => (0, helpers_1.base64FromBytes)(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.txs = [];
        }
        message.proposedLastCommit !== void 0 && (obj.proposedLastCommit = message.proposedLastCommit ? exports.CommitInfo.toJSON(message.proposedLastCommit) : void 0);
        if (message.misbehavior) {
          obj.misbehavior = message.misbehavior.map((e) => e ? exports.Misbehavior.toJSON(e) : void 0);
        } else {
          obj.misbehavior = [];
        }
        message.nextValidatorsHash !== void 0 && (obj.nextValidatorsHash = (0, helpers_1.base64FromBytes)(message.nextValidatorsHash !== void 0 ? message.nextValidatorsHash : new Uint8Array()));
        message.proposerAddress !== void 0 && (obj.proposerAddress = (0, helpers_1.base64FromBytes)(message.proposerAddress !== void 0 ? message.proposerAddress : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequestExtendVote();
        message.hash = object.hash ?? new Uint8Array();
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        if (object.time !== void 0 && object.time !== null) {
          message.time = timestamp_1.Timestamp.fromPartial(object.time);
        }
        message.txs = object.txs?.map((e) => e) || [];
        if (object.proposedLastCommit !== void 0 && object.proposedLastCommit !== null) {
          message.proposedLastCommit = exports.CommitInfo.fromPartial(object.proposedLastCommit);
        }
        message.misbehavior = object.misbehavior?.map((e) => exports.Misbehavior.fromPartial(e)) || [];
        message.nextValidatorsHash = object.nextValidatorsHash ?? new Uint8Array();
        message.proposerAddress = object.proposerAddress ?? new Uint8Array();
        return message;
      }
    };
    function createBaseRequestVerifyVoteExtension() {
      return {
        hash: new Uint8Array(),
        validatorAddress: new Uint8Array(),
        height: BigInt(0),
        voteExtension: new Uint8Array()
      };
    }
    exports.RequestVerifyVoteExtension = {
      typeUrl: "/tendermint.abci.RequestVerifyVoteExtension",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.hash.length !== 0) {
          writer.uint32(10).bytes(message.hash);
        }
        if (message.validatorAddress.length !== 0) {
          writer.uint32(18).bytes(message.validatorAddress);
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(24).int64(message.height);
        }
        if (message.voteExtension.length !== 0) {
          writer.uint32(34).bytes(message.voteExtension);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestVerifyVoteExtension();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.bytes();
              break;
            case 2:
              message.validatorAddress = reader.bytes();
              break;
            case 3:
              message.height = reader.int64();
              break;
            case 4:
              message.voteExtension = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestVerifyVoteExtension();
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = (0, helpers_1.bytesFromBase64)(object.hash);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = (0, helpers_1.bytesFromBase64)(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.voteExtension))
          obj.voteExtension = (0, helpers_1.bytesFromBase64)(object.voteExtension);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = (0, helpers_1.base64FromBytes)(message.hash !== void 0 ? message.hash : new Uint8Array()));
        message.validatorAddress !== void 0 && (obj.validatorAddress = (0, helpers_1.base64FromBytes)(message.validatorAddress !== void 0 ? message.validatorAddress : new Uint8Array()));
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.voteExtension !== void 0 && (obj.voteExtension = (0, helpers_1.base64FromBytes)(message.voteExtension !== void 0 ? message.voteExtension : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequestVerifyVoteExtension();
        message.hash = object.hash ?? new Uint8Array();
        message.validatorAddress = object.validatorAddress ?? new Uint8Array();
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        message.voteExtension = object.voteExtension ?? new Uint8Array();
        return message;
      }
    };
    function createBaseRequestFinalizeBlock() {
      return {
        txs: [],
        decidedLastCommit: exports.CommitInfo.fromPartial({}),
        misbehavior: [],
        hash: new Uint8Array(),
        height: BigInt(0),
        time: timestamp_1.Timestamp.fromPartial({}),
        nextValidatorsHash: new Uint8Array(),
        proposerAddress: new Uint8Array()
      };
    }
    exports.RequestFinalizeBlock = {
      typeUrl: "/tendermint.abci.RequestFinalizeBlock",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.txs) {
          writer.uint32(10).bytes(v9);
        }
        if (message.decidedLastCommit !== void 0) {
          exports.CommitInfo.encode(message.decidedLastCommit, writer.uint32(18).fork()).ldelim();
        }
        for (const v9 of message.misbehavior) {
          exports.Misbehavior.encode(v9, writer.uint32(26).fork()).ldelim();
        }
        if (message.hash.length !== 0) {
          writer.uint32(34).bytes(message.hash);
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(40).int64(message.height);
        }
        if (message.time !== void 0) {
          timestamp_1.Timestamp.encode(message.time, writer.uint32(50).fork()).ldelim();
        }
        if (message.nextValidatorsHash.length !== 0) {
          writer.uint32(58).bytes(message.nextValidatorsHash);
        }
        if (message.proposerAddress.length !== 0) {
          writer.uint32(66).bytes(message.proposerAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRequestFinalizeBlock();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txs.push(reader.bytes());
              break;
            case 2:
              message.decidedLastCommit = exports.CommitInfo.decode(reader, reader.uint32());
              break;
            case 3:
              message.misbehavior.push(exports.Misbehavior.decode(reader, reader.uint32()));
              break;
            case 4:
              message.hash = reader.bytes();
              break;
            case 5:
              message.height = reader.int64();
              break;
            case 6:
              message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 7:
              message.nextValidatorsHash = reader.bytes();
              break;
            case 8:
              message.proposerAddress = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRequestFinalizeBlock();
        if (Array.isArray(object?.txs))
          obj.txs = object.txs.map((e) => (0, helpers_1.bytesFromBase64)(e));
        if ((0, helpers_1.isSet)(object.decidedLastCommit))
          obj.decidedLastCommit = exports.CommitInfo.fromJSON(object.decidedLastCommit);
        if (Array.isArray(object?.misbehavior))
          obj.misbehavior = object.misbehavior.map((e) => exports.Misbehavior.fromJSON(e));
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = (0, helpers_1.bytesFromBase64)(object.hash);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.time))
          obj.time = (0, helpers_1.fromJsonTimestamp)(object.time);
        if ((0, helpers_1.isSet)(object.nextValidatorsHash))
          obj.nextValidatorsHash = (0, helpers_1.bytesFromBase64)(object.nextValidatorsHash);
        if ((0, helpers_1.isSet)(object.proposerAddress))
          obj.proposerAddress = (0, helpers_1.bytesFromBase64)(object.proposerAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.txs) {
          obj.txs = message.txs.map((e) => (0, helpers_1.base64FromBytes)(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.txs = [];
        }
        message.decidedLastCommit !== void 0 && (obj.decidedLastCommit = message.decidedLastCommit ? exports.CommitInfo.toJSON(message.decidedLastCommit) : void 0);
        if (message.misbehavior) {
          obj.misbehavior = message.misbehavior.map((e) => e ? exports.Misbehavior.toJSON(e) : void 0);
        } else {
          obj.misbehavior = [];
        }
        message.hash !== void 0 && (obj.hash = (0, helpers_1.base64FromBytes)(message.hash !== void 0 ? message.hash : new Uint8Array()));
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.time !== void 0 && (obj.time = (0, helpers_1.fromTimestamp)(message.time).toISOString());
        message.nextValidatorsHash !== void 0 && (obj.nextValidatorsHash = (0, helpers_1.base64FromBytes)(message.nextValidatorsHash !== void 0 ? message.nextValidatorsHash : new Uint8Array()));
        message.proposerAddress !== void 0 && (obj.proposerAddress = (0, helpers_1.base64FromBytes)(message.proposerAddress !== void 0 ? message.proposerAddress : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRequestFinalizeBlock();
        message.txs = object.txs?.map((e) => e) || [];
        if (object.decidedLastCommit !== void 0 && object.decidedLastCommit !== null) {
          message.decidedLastCommit = exports.CommitInfo.fromPartial(object.decidedLastCommit);
        }
        message.misbehavior = object.misbehavior?.map((e) => exports.Misbehavior.fromPartial(e)) || [];
        message.hash = object.hash ?? new Uint8Array();
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        if (object.time !== void 0 && object.time !== null) {
          message.time = timestamp_1.Timestamp.fromPartial(object.time);
        }
        message.nextValidatorsHash = object.nextValidatorsHash ?? new Uint8Array();
        message.proposerAddress = object.proposerAddress ?? new Uint8Array();
        return message;
      }
    };
    function createBaseResponse() {
      return {
        exception: void 0,
        echo: void 0,
        flush: void 0,
        info: void 0,
        initChain: void 0,
        query: void 0,
        checkTx: void 0,
        commit: void 0,
        listSnapshots: void 0,
        offerSnapshot: void 0,
        loadSnapshotChunk: void 0,
        applySnapshotChunk: void 0,
        prepareProposal: void 0,
        processProposal: void 0,
        extendVote: void 0,
        verifyVoteExtension: void 0,
        finalizeBlock: void 0
      };
    }
    exports.Response = {
      typeUrl: "/tendermint.abci.Response",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.exception !== void 0) {
          exports.ResponseException.encode(message.exception, writer.uint32(10).fork()).ldelim();
        }
        if (message.echo !== void 0) {
          exports.ResponseEcho.encode(message.echo, writer.uint32(18).fork()).ldelim();
        }
        if (message.flush !== void 0) {
          exports.ResponseFlush.encode(message.flush, writer.uint32(26).fork()).ldelim();
        }
        if (message.info !== void 0) {
          exports.ResponseInfo.encode(message.info, writer.uint32(34).fork()).ldelim();
        }
        if (message.initChain !== void 0) {
          exports.ResponseInitChain.encode(message.initChain, writer.uint32(50).fork()).ldelim();
        }
        if (message.query !== void 0) {
          exports.ResponseQuery.encode(message.query, writer.uint32(58).fork()).ldelim();
        }
        if (message.checkTx !== void 0) {
          exports.ResponseCheckTx.encode(message.checkTx, writer.uint32(74).fork()).ldelim();
        }
        if (message.commit !== void 0) {
          exports.ResponseCommit.encode(message.commit, writer.uint32(98).fork()).ldelim();
        }
        if (message.listSnapshots !== void 0) {
          exports.ResponseListSnapshots.encode(message.listSnapshots, writer.uint32(106).fork()).ldelim();
        }
        if (message.offerSnapshot !== void 0) {
          exports.ResponseOfferSnapshot.encode(message.offerSnapshot, writer.uint32(114).fork()).ldelim();
        }
        if (message.loadSnapshotChunk !== void 0) {
          exports.ResponseLoadSnapshotChunk.encode(message.loadSnapshotChunk, writer.uint32(122).fork()).ldelim();
        }
        if (message.applySnapshotChunk !== void 0) {
          exports.ResponseApplySnapshotChunk.encode(message.applySnapshotChunk, writer.uint32(130).fork()).ldelim();
        }
        if (message.prepareProposal !== void 0) {
          exports.ResponsePrepareProposal.encode(message.prepareProposal, writer.uint32(138).fork()).ldelim();
        }
        if (message.processProposal !== void 0) {
          exports.ResponseProcessProposal.encode(message.processProposal, writer.uint32(146).fork()).ldelim();
        }
        if (message.extendVote !== void 0) {
          exports.ResponseExtendVote.encode(message.extendVote, writer.uint32(154).fork()).ldelim();
        }
        if (message.verifyVoteExtension !== void 0) {
          exports.ResponseVerifyVoteExtension.encode(message.verifyVoteExtension, writer.uint32(162).fork()).ldelim();
        }
        if (message.finalizeBlock !== void 0) {
          exports.ResponseFinalizeBlock.encode(message.finalizeBlock, writer.uint32(170).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.exception = exports.ResponseException.decode(reader, reader.uint32());
              break;
            case 2:
              message.echo = exports.ResponseEcho.decode(reader, reader.uint32());
              break;
            case 3:
              message.flush = exports.ResponseFlush.decode(reader, reader.uint32());
              break;
            case 4:
              message.info = exports.ResponseInfo.decode(reader, reader.uint32());
              break;
            case 6:
              message.initChain = exports.ResponseInitChain.decode(reader, reader.uint32());
              break;
            case 7:
              message.query = exports.ResponseQuery.decode(reader, reader.uint32());
              break;
            case 9:
              message.checkTx = exports.ResponseCheckTx.decode(reader, reader.uint32());
              break;
            case 12:
              message.commit = exports.ResponseCommit.decode(reader, reader.uint32());
              break;
            case 13:
              message.listSnapshots = exports.ResponseListSnapshots.decode(reader, reader.uint32());
              break;
            case 14:
              message.offerSnapshot = exports.ResponseOfferSnapshot.decode(reader, reader.uint32());
              break;
            case 15:
              message.loadSnapshotChunk = exports.ResponseLoadSnapshotChunk.decode(reader, reader.uint32());
              break;
            case 16:
              message.applySnapshotChunk = exports.ResponseApplySnapshotChunk.decode(reader, reader.uint32());
              break;
            case 17:
              message.prepareProposal = exports.ResponsePrepareProposal.decode(reader, reader.uint32());
              break;
            case 18:
              message.processProposal = exports.ResponseProcessProposal.decode(reader, reader.uint32());
              break;
            case 19:
              message.extendVote = exports.ResponseExtendVote.decode(reader, reader.uint32());
              break;
            case 20:
              message.verifyVoteExtension = exports.ResponseVerifyVoteExtension.decode(reader, reader.uint32());
              break;
            case 21:
              message.finalizeBlock = exports.ResponseFinalizeBlock.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponse();
        if ((0, helpers_1.isSet)(object.exception))
          obj.exception = exports.ResponseException.fromJSON(object.exception);
        if ((0, helpers_1.isSet)(object.echo))
          obj.echo = exports.ResponseEcho.fromJSON(object.echo);
        if ((0, helpers_1.isSet)(object.flush))
          obj.flush = exports.ResponseFlush.fromJSON(object.flush);
        if ((0, helpers_1.isSet)(object.info))
          obj.info = exports.ResponseInfo.fromJSON(object.info);
        if ((0, helpers_1.isSet)(object.initChain))
          obj.initChain = exports.ResponseInitChain.fromJSON(object.initChain);
        if ((0, helpers_1.isSet)(object.query))
          obj.query = exports.ResponseQuery.fromJSON(object.query);
        if ((0, helpers_1.isSet)(object.checkTx))
          obj.checkTx = exports.ResponseCheckTx.fromJSON(object.checkTx);
        if ((0, helpers_1.isSet)(object.commit))
          obj.commit = exports.ResponseCommit.fromJSON(object.commit);
        if ((0, helpers_1.isSet)(object.listSnapshots))
          obj.listSnapshots = exports.ResponseListSnapshots.fromJSON(object.listSnapshots);
        if ((0, helpers_1.isSet)(object.offerSnapshot))
          obj.offerSnapshot = exports.ResponseOfferSnapshot.fromJSON(object.offerSnapshot);
        if ((0, helpers_1.isSet)(object.loadSnapshotChunk))
          obj.loadSnapshotChunk = exports.ResponseLoadSnapshotChunk.fromJSON(object.loadSnapshotChunk);
        if ((0, helpers_1.isSet)(object.applySnapshotChunk))
          obj.applySnapshotChunk = exports.ResponseApplySnapshotChunk.fromJSON(object.applySnapshotChunk);
        if ((0, helpers_1.isSet)(object.prepareProposal))
          obj.prepareProposal = exports.ResponsePrepareProposal.fromJSON(object.prepareProposal);
        if ((0, helpers_1.isSet)(object.processProposal))
          obj.processProposal = exports.ResponseProcessProposal.fromJSON(object.processProposal);
        if ((0, helpers_1.isSet)(object.extendVote))
          obj.extendVote = exports.ResponseExtendVote.fromJSON(object.extendVote);
        if ((0, helpers_1.isSet)(object.verifyVoteExtension))
          obj.verifyVoteExtension = exports.ResponseVerifyVoteExtension.fromJSON(object.verifyVoteExtension);
        if ((0, helpers_1.isSet)(object.finalizeBlock))
          obj.finalizeBlock = exports.ResponseFinalizeBlock.fromJSON(object.finalizeBlock);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.exception !== void 0 && (obj.exception = message.exception ? exports.ResponseException.toJSON(message.exception) : void 0);
        message.echo !== void 0 && (obj.echo = message.echo ? exports.ResponseEcho.toJSON(message.echo) : void 0);
        message.flush !== void 0 && (obj.flush = message.flush ? exports.ResponseFlush.toJSON(message.flush) : void 0);
        message.info !== void 0 && (obj.info = message.info ? exports.ResponseInfo.toJSON(message.info) : void 0);
        message.initChain !== void 0 && (obj.initChain = message.initChain ? exports.ResponseInitChain.toJSON(message.initChain) : void 0);
        message.query !== void 0 && (obj.query = message.query ? exports.ResponseQuery.toJSON(message.query) : void 0);
        message.checkTx !== void 0 && (obj.checkTx = message.checkTx ? exports.ResponseCheckTx.toJSON(message.checkTx) : void 0);
        message.commit !== void 0 && (obj.commit = message.commit ? exports.ResponseCommit.toJSON(message.commit) : void 0);
        message.listSnapshots !== void 0 && (obj.listSnapshots = message.listSnapshots ? exports.ResponseListSnapshots.toJSON(message.listSnapshots) : void 0);
        message.offerSnapshot !== void 0 && (obj.offerSnapshot = message.offerSnapshot ? exports.ResponseOfferSnapshot.toJSON(message.offerSnapshot) : void 0);
        message.loadSnapshotChunk !== void 0 && (obj.loadSnapshotChunk = message.loadSnapshotChunk ? exports.ResponseLoadSnapshotChunk.toJSON(message.loadSnapshotChunk) : void 0);
        message.applySnapshotChunk !== void 0 && (obj.applySnapshotChunk = message.applySnapshotChunk ? exports.ResponseApplySnapshotChunk.toJSON(message.applySnapshotChunk) : void 0);
        message.prepareProposal !== void 0 && (obj.prepareProposal = message.prepareProposal ? exports.ResponsePrepareProposal.toJSON(message.prepareProposal) : void 0);
        message.processProposal !== void 0 && (obj.processProposal = message.processProposal ? exports.ResponseProcessProposal.toJSON(message.processProposal) : void 0);
        message.extendVote !== void 0 && (obj.extendVote = message.extendVote ? exports.ResponseExtendVote.toJSON(message.extendVote) : void 0);
        message.verifyVoteExtension !== void 0 && (obj.verifyVoteExtension = message.verifyVoteExtension ? exports.ResponseVerifyVoteExtension.toJSON(message.verifyVoteExtension) : void 0);
        message.finalizeBlock !== void 0 && (obj.finalizeBlock = message.finalizeBlock ? exports.ResponseFinalizeBlock.toJSON(message.finalizeBlock) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponse();
        if (object.exception !== void 0 && object.exception !== null) {
          message.exception = exports.ResponseException.fromPartial(object.exception);
        }
        if (object.echo !== void 0 && object.echo !== null) {
          message.echo = exports.ResponseEcho.fromPartial(object.echo);
        }
        if (object.flush !== void 0 && object.flush !== null) {
          message.flush = exports.ResponseFlush.fromPartial(object.flush);
        }
        if (object.info !== void 0 && object.info !== null) {
          message.info = exports.ResponseInfo.fromPartial(object.info);
        }
        if (object.initChain !== void 0 && object.initChain !== null) {
          message.initChain = exports.ResponseInitChain.fromPartial(object.initChain);
        }
        if (object.query !== void 0 && object.query !== null) {
          message.query = exports.ResponseQuery.fromPartial(object.query);
        }
        if (object.checkTx !== void 0 && object.checkTx !== null) {
          message.checkTx = exports.ResponseCheckTx.fromPartial(object.checkTx);
        }
        if (object.commit !== void 0 && object.commit !== null) {
          message.commit = exports.ResponseCommit.fromPartial(object.commit);
        }
        if (object.listSnapshots !== void 0 && object.listSnapshots !== null) {
          message.listSnapshots = exports.ResponseListSnapshots.fromPartial(object.listSnapshots);
        }
        if (object.offerSnapshot !== void 0 && object.offerSnapshot !== null) {
          message.offerSnapshot = exports.ResponseOfferSnapshot.fromPartial(object.offerSnapshot);
        }
        if (object.loadSnapshotChunk !== void 0 && object.loadSnapshotChunk !== null) {
          message.loadSnapshotChunk = exports.ResponseLoadSnapshotChunk.fromPartial(object.loadSnapshotChunk);
        }
        if (object.applySnapshotChunk !== void 0 && object.applySnapshotChunk !== null) {
          message.applySnapshotChunk = exports.ResponseApplySnapshotChunk.fromPartial(object.applySnapshotChunk);
        }
        if (object.prepareProposal !== void 0 && object.prepareProposal !== null) {
          message.prepareProposal = exports.ResponsePrepareProposal.fromPartial(object.prepareProposal);
        }
        if (object.processProposal !== void 0 && object.processProposal !== null) {
          message.processProposal = exports.ResponseProcessProposal.fromPartial(object.processProposal);
        }
        if (object.extendVote !== void 0 && object.extendVote !== null) {
          message.extendVote = exports.ResponseExtendVote.fromPartial(object.extendVote);
        }
        if (object.verifyVoteExtension !== void 0 && object.verifyVoteExtension !== null) {
          message.verifyVoteExtension = exports.ResponseVerifyVoteExtension.fromPartial(object.verifyVoteExtension);
        }
        if (object.finalizeBlock !== void 0 && object.finalizeBlock !== null) {
          message.finalizeBlock = exports.ResponseFinalizeBlock.fromPartial(object.finalizeBlock);
        }
        return message;
      }
    };
    function createBaseResponseException() {
      return {
        error: ""
      };
    }
    exports.ResponseException = {
      typeUrl: "/tendermint.abci.ResponseException",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.error !== "") {
          writer.uint32(10).string(message.error);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseException();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.error = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseException();
        if ((0, helpers_1.isSet)(object.error))
          obj.error = String(object.error);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.error !== void 0 && (obj.error = message.error);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseException();
        message.error = object.error ?? "";
        return message;
      }
    };
    function createBaseResponseEcho() {
      return {
        message: ""
      };
    }
    exports.ResponseEcho = {
      typeUrl: "/tendermint.abci.ResponseEcho",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.message !== "") {
          writer.uint32(10).string(message.message);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseEcho();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.message = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseEcho();
        if ((0, helpers_1.isSet)(object.message))
          obj.message = String(object.message);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.message !== void 0 && (obj.message = message.message);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseEcho();
        message.message = object.message ?? "";
        return message;
      }
    };
    function createBaseResponseFlush() {
      return {};
    }
    exports.ResponseFlush = {
      typeUrl: "/tendermint.abci.ResponseFlush",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseFlush();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseResponseFlush();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseResponseFlush();
        return message;
      }
    };
    function createBaseResponseInfo() {
      return {
        data: "",
        version: "",
        appVersion: BigInt(0),
        lastBlockHeight: BigInt(0),
        lastBlockAppHash: new Uint8Array()
      };
    }
    exports.ResponseInfo = {
      typeUrl: "/tendermint.abci.ResponseInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.data !== "") {
          writer.uint32(10).string(message.data);
        }
        if (message.version !== "") {
          writer.uint32(18).string(message.version);
        }
        if (message.appVersion !== BigInt(0)) {
          writer.uint32(24).uint64(message.appVersion);
        }
        if (message.lastBlockHeight !== BigInt(0)) {
          writer.uint32(32).int64(message.lastBlockHeight);
        }
        if (message.lastBlockAppHash.length !== 0) {
          writer.uint32(42).bytes(message.lastBlockAppHash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.data = reader.string();
              break;
            case 2:
              message.version = reader.string();
              break;
            case 3:
              message.appVersion = reader.uint64();
              break;
            case 4:
              message.lastBlockHeight = reader.int64();
              break;
            case 5:
              message.lastBlockAppHash = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseInfo();
        if ((0, helpers_1.isSet)(object.data))
          obj.data = String(object.data);
        if ((0, helpers_1.isSet)(object.version))
          obj.version = String(object.version);
        if ((0, helpers_1.isSet)(object.appVersion))
          obj.appVersion = BigInt(object.appVersion.toString());
        if ((0, helpers_1.isSet)(object.lastBlockHeight))
          obj.lastBlockHeight = BigInt(object.lastBlockHeight.toString());
        if ((0, helpers_1.isSet)(object.lastBlockAppHash))
          obj.lastBlockAppHash = (0, helpers_1.bytesFromBase64)(object.lastBlockAppHash);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.data !== void 0 && (obj.data = message.data);
        message.version !== void 0 && (obj.version = message.version);
        message.appVersion !== void 0 && (obj.appVersion = (message.appVersion || BigInt(0)).toString());
        message.lastBlockHeight !== void 0 && (obj.lastBlockHeight = (message.lastBlockHeight || BigInt(0)).toString());
        message.lastBlockAppHash !== void 0 && (obj.lastBlockAppHash = (0, helpers_1.base64FromBytes)(message.lastBlockAppHash !== void 0 ? message.lastBlockAppHash : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseInfo();
        message.data = object.data ?? "";
        message.version = object.version ?? "";
        if (object.appVersion !== void 0 && object.appVersion !== null) {
          message.appVersion = BigInt(object.appVersion.toString());
        }
        if (object.lastBlockHeight !== void 0 && object.lastBlockHeight !== null) {
          message.lastBlockHeight = BigInt(object.lastBlockHeight.toString());
        }
        message.lastBlockAppHash = object.lastBlockAppHash ?? new Uint8Array();
        return message;
      }
    };
    function createBaseResponseInitChain() {
      return {
        consensusParams: void 0,
        validators: [],
        appHash: new Uint8Array()
      };
    }
    exports.ResponseInitChain = {
      typeUrl: "/tendermint.abci.ResponseInitChain",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.consensusParams !== void 0) {
          params_1.ConsensusParams.encode(message.consensusParams, writer.uint32(10).fork()).ldelim();
        }
        for (const v9 of message.validators) {
          exports.ValidatorUpdate.encode(v9, writer.uint32(18).fork()).ldelim();
        }
        if (message.appHash.length !== 0) {
          writer.uint32(26).bytes(message.appHash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseInitChain();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.consensusParams = params_1.ConsensusParams.decode(reader, reader.uint32());
              break;
            case 2:
              message.validators.push(exports.ValidatorUpdate.decode(reader, reader.uint32()));
              break;
            case 3:
              message.appHash = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseInitChain();
        if ((0, helpers_1.isSet)(object.consensusParams))
          obj.consensusParams = params_1.ConsensusParams.fromJSON(object.consensusParams);
        if (Array.isArray(object?.validators))
          obj.validators = object.validators.map((e) => exports.ValidatorUpdate.fromJSON(e));
        if ((0, helpers_1.isSet)(object.appHash))
          obj.appHash = (0, helpers_1.bytesFromBase64)(object.appHash);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.consensusParams !== void 0 && (obj.consensusParams = message.consensusParams ? params_1.ConsensusParams.toJSON(message.consensusParams) : void 0);
        if (message.validators) {
          obj.validators = message.validators.map((e) => e ? exports.ValidatorUpdate.toJSON(e) : void 0);
        } else {
          obj.validators = [];
        }
        message.appHash !== void 0 && (obj.appHash = (0, helpers_1.base64FromBytes)(message.appHash !== void 0 ? message.appHash : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseInitChain();
        if (object.consensusParams !== void 0 && object.consensusParams !== null) {
          message.consensusParams = params_1.ConsensusParams.fromPartial(object.consensusParams);
        }
        message.validators = object.validators?.map((e) => exports.ValidatorUpdate.fromPartial(e)) || [];
        message.appHash = object.appHash ?? new Uint8Array();
        return message;
      }
    };
    function createBaseResponseQuery() {
      return {
        code: 0,
        log: "",
        info: "",
        index: BigInt(0),
        key: new Uint8Array(),
        value: new Uint8Array(),
        proofOps: void 0,
        height: BigInt(0),
        codespace: ""
      };
    }
    exports.ResponseQuery = {
      typeUrl: "/tendermint.abci.ResponseQuery",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.code !== 0) {
          writer.uint32(8).uint32(message.code);
        }
        if (message.log !== "") {
          writer.uint32(26).string(message.log);
        }
        if (message.info !== "") {
          writer.uint32(34).string(message.info);
        }
        if (message.index !== BigInt(0)) {
          writer.uint32(40).int64(message.index);
        }
        if (message.key.length !== 0) {
          writer.uint32(50).bytes(message.key);
        }
        if (message.value.length !== 0) {
          writer.uint32(58).bytes(message.value);
        }
        if (message.proofOps !== void 0) {
          proof_1.ProofOps.encode(message.proofOps, writer.uint32(66).fork()).ldelim();
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(72).int64(message.height);
        }
        if (message.codespace !== "") {
          writer.uint32(82).string(message.codespace);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseQuery();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.code = reader.uint32();
              break;
            case 3:
              message.log = reader.string();
              break;
            case 4:
              message.info = reader.string();
              break;
            case 5:
              message.index = reader.int64();
              break;
            case 6:
              message.key = reader.bytes();
              break;
            case 7:
              message.value = reader.bytes();
              break;
            case 8:
              message.proofOps = proof_1.ProofOps.decode(reader, reader.uint32());
              break;
            case 9:
              message.height = reader.int64();
              break;
            case 10:
              message.codespace = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseQuery();
        if ((0, helpers_1.isSet)(object.code))
          obj.code = Number(object.code);
        if ((0, helpers_1.isSet)(object.log))
          obj.log = String(object.log);
        if ((0, helpers_1.isSet)(object.info))
          obj.info = String(object.info);
        if ((0, helpers_1.isSet)(object.index))
          obj.index = BigInt(object.index.toString());
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        if ((0, helpers_1.isSet)(object.value))
          obj.value = (0, helpers_1.bytesFromBase64)(object.value);
        if ((0, helpers_1.isSet)(object.proofOps))
          obj.proofOps = proof_1.ProofOps.fromJSON(object.proofOps);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.codespace))
          obj.codespace = String(object.codespace);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.code !== void 0 && (obj.code = Math.round(message.code));
        message.log !== void 0 && (obj.log = message.log);
        message.info !== void 0 && (obj.info = message.info);
        message.index !== void 0 && (obj.index = (message.index || BigInt(0)).toString());
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        message.value !== void 0 && (obj.value = (0, helpers_1.base64FromBytes)(message.value !== void 0 ? message.value : new Uint8Array()));
        message.proofOps !== void 0 && (obj.proofOps = message.proofOps ? proof_1.ProofOps.toJSON(message.proofOps) : void 0);
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.codespace !== void 0 && (obj.codespace = message.codespace);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseQuery();
        message.code = object.code ?? 0;
        message.log = object.log ?? "";
        message.info = object.info ?? "";
        if (object.index !== void 0 && object.index !== null) {
          message.index = BigInt(object.index.toString());
        }
        message.key = object.key ?? new Uint8Array();
        message.value = object.value ?? new Uint8Array();
        if (object.proofOps !== void 0 && object.proofOps !== null) {
          message.proofOps = proof_1.ProofOps.fromPartial(object.proofOps);
        }
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        message.codespace = object.codespace ?? "";
        return message;
      }
    };
    function createBaseResponseCheckTx() {
      return {
        code: 0,
        data: new Uint8Array(),
        log: "",
        info: "",
        gasWanted: BigInt(0),
        gasUsed: BigInt(0),
        events: [],
        codespace: ""
      };
    }
    exports.ResponseCheckTx = {
      typeUrl: "/tendermint.abci.ResponseCheckTx",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.code !== 0) {
          writer.uint32(8).uint32(message.code);
        }
        if (message.data.length !== 0) {
          writer.uint32(18).bytes(message.data);
        }
        if (message.log !== "") {
          writer.uint32(26).string(message.log);
        }
        if (message.info !== "") {
          writer.uint32(34).string(message.info);
        }
        if (message.gasWanted !== BigInt(0)) {
          writer.uint32(40).int64(message.gasWanted);
        }
        if (message.gasUsed !== BigInt(0)) {
          writer.uint32(48).int64(message.gasUsed);
        }
        for (const v9 of message.events) {
          exports.Event.encode(v9, writer.uint32(58).fork()).ldelim();
        }
        if (message.codespace !== "") {
          writer.uint32(66).string(message.codespace);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseCheckTx();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.code = reader.uint32();
              break;
            case 2:
              message.data = reader.bytes();
              break;
            case 3:
              message.log = reader.string();
              break;
            case 4:
              message.info = reader.string();
              break;
            case 5:
              message.gasWanted = reader.int64();
              break;
            case 6:
              message.gasUsed = reader.int64();
              break;
            case 7:
              message.events.push(exports.Event.decode(reader, reader.uint32()));
              break;
            case 8:
              message.codespace = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseCheckTx();
        if ((0, helpers_1.isSet)(object.code))
          obj.code = Number(object.code);
        if ((0, helpers_1.isSet)(object.data))
          obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        if ((0, helpers_1.isSet)(object.log))
          obj.log = String(object.log);
        if ((0, helpers_1.isSet)(object.info))
          obj.info = String(object.info);
        if ((0, helpers_1.isSet)(object.gas_wanted))
          obj.gasWanted = BigInt(object.gas_wanted.toString());
        if ((0, helpers_1.isSet)(object.gas_used))
          obj.gasUsed = BigInt(object.gas_used.toString());
        if (Array.isArray(object?.events))
          obj.events = object.events.map((e) => exports.Event.fromJSON(e));
        if ((0, helpers_1.isSet)(object.codespace))
          obj.codespace = String(object.codespace);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.code !== void 0 && (obj.code = Math.round(message.code));
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        message.log !== void 0 && (obj.log = message.log);
        message.info !== void 0 && (obj.info = message.info);
        message.gasWanted !== void 0 && (obj.gas_wanted = (message.gasWanted || BigInt(0)).toString());
        message.gasUsed !== void 0 && (obj.gas_used = (message.gasUsed || BigInt(0)).toString());
        if (message.events) {
          obj.events = message.events.map((e) => e ? exports.Event.toJSON(e) : void 0);
        } else {
          obj.events = [];
        }
        message.codespace !== void 0 && (obj.codespace = message.codespace);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseCheckTx();
        message.code = object.code ?? 0;
        message.data = object.data ?? new Uint8Array();
        message.log = object.log ?? "";
        message.info = object.info ?? "";
        if (object.gasWanted !== void 0 && object.gasWanted !== null) {
          message.gasWanted = BigInt(object.gasWanted.toString());
        }
        if (object.gasUsed !== void 0 && object.gasUsed !== null) {
          message.gasUsed = BigInt(object.gasUsed.toString());
        }
        message.events = object.events?.map((e) => exports.Event.fromPartial(e)) || [];
        message.codespace = object.codespace ?? "";
        return message;
      }
    };
    function createBaseResponseCommit() {
      return {
        retainHeight: BigInt(0)
      };
    }
    exports.ResponseCommit = {
      typeUrl: "/tendermint.abci.ResponseCommit",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.retainHeight !== BigInt(0)) {
          writer.uint32(24).int64(message.retainHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseCommit();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 3:
              message.retainHeight = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseCommit();
        if ((0, helpers_1.isSet)(object.retainHeight))
          obj.retainHeight = BigInt(object.retainHeight.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.retainHeight !== void 0 && (obj.retainHeight = (message.retainHeight || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseCommit();
        if (object.retainHeight !== void 0 && object.retainHeight !== null) {
          message.retainHeight = BigInt(object.retainHeight.toString());
        }
        return message;
      }
    };
    function createBaseResponseListSnapshots() {
      return {
        snapshots: []
      };
    }
    exports.ResponseListSnapshots = {
      typeUrl: "/tendermint.abci.ResponseListSnapshots",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.snapshots) {
          exports.Snapshot.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseListSnapshots();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.snapshots.push(exports.Snapshot.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseListSnapshots();
        if (Array.isArray(object?.snapshots))
          obj.snapshots = object.snapshots.map((e) => exports.Snapshot.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.snapshots) {
          obj.snapshots = message.snapshots.map((e) => e ? exports.Snapshot.toJSON(e) : void 0);
        } else {
          obj.snapshots = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseListSnapshots();
        message.snapshots = object.snapshots?.map((e) => exports.Snapshot.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseResponseOfferSnapshot() {
      return {
        result: 0
      };
    }
    exports.ResponseOfferSnapshot = {
      typeUrl: "/tendermint.abci.ResponseOfferSnapshot",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== 0) {
          writer.uint32(8).int32(message.result);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseOfferSnapshot();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.result = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseOfferSnapshot();
        if ((0, helpers_1.isSet)(object.result))
          obj.result = responseOfferSnapshot_ResultFromJSON(object.result);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = responseOfferSnapshot_ResultToJSON(message.result));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseOfferSnapshot();
        message.result = object.result ?? 0;
        return message;
      }
    };
    function createBaseResponseLoadSnapshotChunk() {
      return {
        chunk: new Uint8Array()
      };
    }
    exports.ResponseLoadSnapshotChunk = {
      typeUrl: "/tendermint.abci.ResponseLoadSnapshotChunk",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.chunk.length !== 0) {
          writer.uint32(10).bytes(message.chunk);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseLoadSnapshotChunk();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.chunk = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseLoadSnapshotChunk();
        if ((0, helpers_1.isSet)(object.chunk))
          obj.chunk = (0, helpers_1.bytesFromBase64)(object.chunk);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.chunk !== void 0 && (obj.chunk = (0, helpers_1.base64FromBytes)(message.chunk !== void 0 ? message.chunk : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseLoadSnapshotChunk();
        message.chunk = object.chunk ?? new Uint8Array();
        return message;
      }
    };
    function createBaseResponseApplySnapshotChunk() {
      return {
        result: 0,
        refetchChunks: [],
        rejectSenders: []
      };
    }
    exports.ResponseApplySnapshotChunk = {
      typeUrl: "/tendermint.abci.ResponseApplySnapshotChunk",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.result !== 0) {
          writer.uint32(8).int32(message.result);
        }
        writer.uint32(18).fork();
        for (const v9 of message.refetchChunks) {
          writer.uint32(v9);
        }
        writer.ldelim();
        for (const v9 of message.rejectSenders) {
          writer.uint32(26).string(v9);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseApplySnapshotChunk();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.result = reader.int32();
              break;
            case 2:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.refetchChunks.push(reader.uint32());
                }
              } else {
                message.refetchChunks.push(reader.uint32());
              }
              break;
            case 3:
              message.rejectSenders.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseApplySnapshotChunk();
        if ((0, helpers_1.isSet)(object.result))
          obj.result = responseApplySnapshotChunk_ResultFromJSON(object.result);
        if (Array.isArray(object?.refetchChunks))
          obj.refetchChunks = object.refetchChunks.map((e) => Number(e));
        if (Array.isArray(object?.rejectSenders))
          obj.rejectSenders = object.rejectSenders.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.result !== void 0 && (obj.result = responseApplySnapshotChunk_ResultToJSON(message.result));
        if (message.refetchChunks) {
          obj.refetchChunks = message.refetchChunks.map((e) => Math.round(e));
        } else {
          obj.refetchChunks = [];
        }
        if (message.rejectSenders) {
          obj.rejectSenders = message.rejectSenders.map((e) => e);
        } else {
          obj.rejectSenders = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseApplySnapshotChunk();
        message.result = object.result ?? 0;
        message.refetchChunks = object.refetchChunks?.map((e) => e) || [];
        message.rejectSenders = object.rejectSenders?.map((e) => e) || [];
        return message;
      }
    };
    function createBaseResponsePrepareProposal() {
      return {
        txs: []
      };
    }
    exports.ResponsePrepareProposal = {
      typeUrl: "/tendermint.abci.ResponsePrepareProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.txs) {
          writer.uint32(10).bytes(v9);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponsePrepareProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txs.push(reader.bytes());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponsePrepareProposal();
        if (Array.isArray(object?.txs))
          obj.txs = object.txs.map((e) => (0, helpers_1.bytesFromBase64)(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.txs) {
          obj.txs = message.txs.map((e) => (0, helpers_1.base64FromBytes)(e !== void 0 ? e : new Uint8Array()));
        } else {
          obj.txs = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponsePrepareProposal();
        message.txs = object.txs?.map((e) => e) || [];
        return message;
      }
    };
    function createBaseResponseProcessProposal() {
      return {
        status: 0
      };
    }
    exports.ResponseProcessProposal = {
      typeUrl: "/tendermint.abci.ResponseProcessProposal",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.status !== 0) {
          writer.uint32(8).int32(message.status);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseProcessProposal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.status = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseProcessProposal();
        if ((0, helpers_1.isSet)(object.status))
          obj.status = responseProcessProposal_ProposalStatusFromJSON(object.status);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.status !== void 0 && (obj.status = responseProcessProposal_ProposalStatusToJSON(message.status));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseProcessProposal();
        message.status = object.status ?? 0;
        return message;
      }
    };
    function createBaseResponseExtendVote() {
      return {
        voteExtension: new Uint8Array()
      };
    }
    exports.ResponseExtendVote = {
      typeUrl: "/tendermint.abci.ResponseExtendVote",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.voteExtension.length !== 0) {
          writer.uint32(10).bytes(message.voteExtension);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseExtendVote();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.voteExtension = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseExtendVote();
        if ((0, helpers_1.isSet)(object.voteExtension))
          obj.voteExtension = (0, helpers_1.bytesFromBase64)(object.voteExtension);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.voteExtension !== void 0 && (obj.voteExtension = (0, helpers_1.base64FromBytes)(message.voteExtension !== void 0 ? message.voteExtension : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseExtendVote();
        message.voteExtension = object.voteExtension ?? new Uint8Array();
        return message;
      }
    };
    function createBaseResponseVerifyVoteExtension() {
      return {
        status: 0
      };
    }
    exports.ResponseVerifyVoteExtension = {
      typeUrl: "/tendermint.abci.ResponseVerifyVoteExtension",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.status !== 0) {
          writer.uint32(8).int32(message.status);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseVerifyVoteExtension();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.status = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseVerifyVoteExtension();
        if ((0, helpers_1.isSet)(object.status))
          obj.status = responseVerifyVoteExtension_VerifyStatusFromJSON(object.status);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.status !== void 0 && (obj.status = responseVerifyVoteExtension_VerifyStatusToJSON(message.status));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseVerifyVoteExtension();
        message.status = object.status ?? 0;
        return message;
      }
    };
    function createBaseResponseFinalizeBlock() {
      return {
        events: [],
        txResults: [],
        validatorUpdates: [],
        consensusParamUpdates: void 0,
        appHash: new Uint8Array()
      };
    }
    exports.ResponseFinalizeBlock = {
      typeUrl: "/tendermint.abci.ResponseFinalizeBlock",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.events) {
          exports.Event.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        for (const v9 of message.txResults) {
          exports.ExecTxResult.encode(v9, writer.uint32(18).fork()).ldelim();
        }
        for (const v9 of message.validatorUpdates) {
          exports.ValidatorUpdate.encode(v9, writer.uint32(26).fork()).ldelim();
        }
        if (message.consensusParamUpdates !== void 0) {
          params_1.ConsensusParams.encode(message.consensusParamUpdates, writer.uint32(34).fork()).ldelim();
        }
        if (message.appHash.length !== 0) {
          writer.uint32(42).bytes(message.appHash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResponseFinalizeBlock();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.events.push(exports.Event.decode(reader, reader.uint32()));
              break;
            case 2:
              message.txResults.push(exports.ExecTxResult.decode(reader, reader.uint32()));
              break;
            case 3:
              message.validatorUpdates.push(exports.ValidatorUpdate.decode(reader, reader.uint32()));
              break;
            case 4:
              message.consensusParamUpdates = params_1.ConsensusParams.decode(reader, reader.uint32());
              break;
            case 5:
              message.appHash = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResponseFinalizeBlock();
        if (Array.isArray(object?.events))
          obj.events = object.events.map((e) => exports.Event.fromJSON(e));
        if (Array.isArray(object?.txResults))
          obj.txResults = object.txResults.map((e) => exports.ExecTxResult.fromJSON(e));
        if (Array.isArray(object?.validatorUpdates))
          obj.validatorUpdates = object.validatorUpdates.map((e) => exports.ValidatorUpdate.fromJSON(e));
        if ((0, helpers_1.isSet)(object.consensusParamUpdates))
          obj.consensusParamUpdates = params_1.ConsensusParams.fromJSON(object.consensusParamUpdates);
        if ((0, helpers_1.isSet)(object.appHash))
          obj.appHash = (0, helpers_1.bytesFromBase64)(object.appHash);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.events) {
          obj.events = message.events.map((e) => e ? exports.Event.toJSON(e) : void 0);
        } else {
          obj.events = [];
        }
        if (message.txResults) {
          obj.txResults = message.txResults.map((e) => e ? exports.ExecTxResult.toJSON(e) : void 0);
        } else {
          obj.txResults = [];
        }
        if (message.validatorUpdates) {
          obj.validatorUpdates = message.validatorUpdates.map((e) => e ? exports.ValidatorUpdate.toJSON(e) : void 0);
        } else {
          obj.validatorUpdates = [];
        }
        message.consensusParamUpdates !== void 0 && (obj.consensusParamUpdates = message.consensusParamUpdates ? params_1.ConsensusParams.toJSON(message.consensusParamUpdates) : void 0);
        message.appHash !== void 0 && (obj.appHash = (0, helpers_1.base64FromBytes)(message.appHash !== void 0 ? message.appHash : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResponseFinalizeBlock();
        message.events = object.events?.map((e) => exports.Event.fromPartial(e)) || [];
        message.txResults = object.txResults?.map((e) => exports.ExecTxResult.fromPartial(e)) || [];
        message.validatorUpdates = object.validatorUpdates?.map((e) => exports.ValidatorUpdate.fromPartial(e)) || [];
        if (object.consensusParamUpdates !== void 0 && object.consensusParamUpdates !== null) {
          message.consensusParamUpdates = params_1.ConsensusParams.fromPartial(object.consensusParamUpdates);
        }
        message.appHash = object.appHash ?? new Uint8Array();
        return message;
      }
    };
    function createBaseCommitInfo() {
      return {
        round: 0,
        votes: []
      };
    }
    exports.CommitInfo = {
      typeUrl: "/tendermint.abci.CommitInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.round !== 0) {
          writer.uint32(8).int32(message.round);
        }
        for (const v9 of message.votes) {
          exports.VoteInfo.encode(v9, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommitInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.round = reader.int32();
              break;
            case 2:
              message.votes.push(exports.VoteInfo.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCommitInfo();
        if ((0, helpers_1.isSet)(object.round))
          obj.round = Number(object.round);
        if (Array.isArray(object?.votes))
          obj.votes = object.votes.map((e) => exports.VoteInfo.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.round !== void 0 && (obj.round = Math.round(message.round));
        if (message.votes) {
          obj.votes = message.votes.map((e) => e ? exports.VoteInfo.toJSON(e) : void 0);
        } else {
          obj.votes = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCommitInfo();
        message.round = object.round ?? 0;
        message.votes = object.votes?.map((e) => exports.VoteInfo.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseExtendedCommitInfo() {
      return {
        round: 0,
        votes: []
      };
    }
    exports.ExtendedCommitInfo = {
      typeUrl: "/tendermint.abci.ExtendedCommitInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.round !== 0) {
          writer.uint32(8).int32(message.round);
        }
        for (const v9 of message.votes) {
          exports.ExtendedVoteInfo.encode(v9, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseExtendedCommitInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.round = reader.int32();
              break;
            case 2:
              message.votes.push(exports.ExtendedVoteInfo.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseExtendedCommitInfo();
        if ((0, helpers_1.isSet)(object.round))
          obj.round = Number(object.round);
        if (Array.isArray(object?.votes))
          obj.votes = object.votes.map((e) => exports.ExtendedVoteInfo.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.round !== void 0 && (obj.round = Math.round(message.round));
        if (message.votes) {
          obj.votes = message.votes.map((e) => e ? exports.ExtendedVoteInfo.toJSON(e) : void 0);
        } else {
          obj.votes = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseExtendedCommitInfo();
        message.round = object.round ?? 0;
        message.votes = object.votes?.map((e) => exports.ExtendedVoteInfo.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseEvent() {
      return {
        type: "",
        attributes: []
      };
    }
    exports.Event = {
      typeUrl: "/tendermint.abci.Event",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.type !== "") {
          writer.uint32(10).string(message.type);
        }
        for (const v9 of message.attributes) {
          exports.EventAttribute.encode(v9, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseEvent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.type = reader.string();
              break;
            case 2:
              message.attributes.push(exports.EventAttribute.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseEvent();
        if ((0, helpers_1.isSet)(object.type))
          obj.type = String(object.type);
        if (Array.isArray(object?.attributes))
          obj.attributes = object.attributes.map((e) => exports.EventAttribute.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.type !== void 0 && (obj.type = message.type);
        if (message.attributes) {
          obj.attributes = message.attributes.map((e) => e ? exports.EventAttribute.toJSON(e) : void 0);
        } else {
          obj.attributes = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseEvent();
        message.type = object.type ?? "";
        message.attributes = object.attributes?.map((e) => exports.EventAttribute.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseEventAttribute() {
      return {
        key: "",
        value: "",
        index: false
      };
    }
    exports.EventAttribute = {
      typeUrl: "/tendermint.abci.EventAttribute",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key !== "") {
          writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
          writer.uint32(18).string(message.value);
        }
        if (message.index === true) {
          writer.uint32(24).bool(message.index);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseEventAttribute();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.string();
              break;
            case 2:
              message.value = reader.string();
              break;
            case 3:
              message.index = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseEventAttribute();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = String(object.key);
        if ((0, helpers_1.isSet)(object.value))
          obj.value = String(object.value);
        if ((0, helpers_1.isSet)(object.index))
          obj.index = Boolean(object.index);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = message.key);
        message.value !== void 0 && (obj.value = message.value);
        message.index !== void 0 && (obj.index = message.index);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseEventAttribute();
        message.key = object.key ?? "";
        message.value = object.value ?? "";
        message.index = object.index ?? false;
        return message;
      }
    };
    function createBaseExecTxResult() {
      return {
        code: 0,
        data: new Uint8Array(),
        log: "",
        info: "",
        gasWanted: BigInt(0),
        gasUsed: BigInt(0),
        events: [],
        codespace: ""
      };
    }
    exports.ExecTxResult = {
      typeUrl: "/tendermint.abci.ExecTxResult",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.code !== 0) {
          writer.uint32(8).uint32(message.code);
        }
        if (message.data.length !== 0) {
          writer.uint32(18).bytes(message.data);
        }
        if (message.log !== "") {
          writer.uint32(26).string(message.log);
        }
        if (message.info !== "") {
          writer.uint32(34).string(message.info);
        }
        if (message.gasWanted !== BigInt(0)) {
          writer.uint32(40).int64(message.gasWanted);
        }
        if (message.gasUsed !== BigInt(0)) {
          writer.uint32(48).int64(message.gasUsed);
        }
        for (const v9 of message.events) {
          exports.Event.encode(v9, writer.uint32(58).fork()).ldelim();
        }
        if (message.codespace !== "") {
          writer.uint32(66).string(message.codespace);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseExecTxResult();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.code = reader.uint32();
              break;
            case 2:
              message.data = reader.bytes();
              break;
            case 3:
              message.log = reader.string();
              break;
            case 4:
              message.info = reader.string();
              break;
            case 5:
              message.gasWanted = reader.int64();
              break;
            case 6:
              message.gasUsed = reader.int64();
              break;
            case 7:
              message.events.push(exports.Event.decode(reader, reader.uint32()));
              break;
            case 8:
              message.codespace = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseExecTxResult();
        if ((0, helpers_1.isSet)(object.code))
          obj.code = Number(object.code);
        if ((0, helpers_1.isSet)(object.data))
          obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        if ((0, helpers_1.isSet)(object.log))
          obj.log = String(object.log);
        if ((0, helpers_1.isSet)(object.info))
          obj.info = String(object.info);
        if ((0, helpers_1.isSet)(object.gas_wanted))
          obj.gasWanted = BigInt(object.gas_wanted.toString());
        if ((0, helpers_1.isSet)(object.gas_used))
          obj.gasUsed = BigInt(object.gas_used.toString());
        if (Array.isArray(object?.events))
          obj.events = object.events.map((e) => exports.Event.fromJSON(e));
        if ((0, helpers_1.isSet)(object.codespace))
          obj.codespace = String(object.codespace);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.code !== void 0 && (obj.code = Math.round(message.code));
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        message.log !== void 0 && (obj.log = message.log);
        message.info !== void 0 && (obj.info = message.info);
        message.gasWanted !== void 0 && (obj.gas_wanted = (message.gasWanted || BigInt(0)).toString());
        message.gasUsed !== void 0 && (obj.gas_used = (message.gasUsed || BigInt(0)).toString());
        if (message.events) {
          obj.events = message.events.map((e) => e ? exports.Event.toJSON(e) : void 0);
        } else {
          obj.events = [];
        }
        message.codespace !== void 0 && (obj.codespace = message.codespace);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseExecTxResult();
        message.code = object.code ?? 0;
        message.data = object.data ?? new Uint8Array();
        message.log = object.log ?? "";
        message.info = object.info ?? "";
        if (object.gasWanted !== void 0 && object.gasWanted !== null) {
          message.gasWanted = BigInt(object.gasWanted.toString());
        }
        if (object.gasUsed !== void 0 && object.gasUsed !== null) {
          message.gasUsed = BigInt(object.gasUsed.toString());
        }
        message.events = object.events?.map((e) => exports.Event.fromPartial(e)) || [];
        message.codespace = object.codespace ?? "";
        return message;
      }
    };
    function createBaseTxResult() {
      return {
        height: BigInt(0),
        index: 0,
        tx: new Uint8Array(),
        result: exports.ExecTxResult.fromPartial({})
      };
    }
    exports.TxResult = {
      typeUrl: "/tendermint.abci.TxResult",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== BigInt(0)) {
          writer.uint32(8).int64(message.height);
        }
        if (message.index !== 0) {
          writer.uint32(16).uint32(message.index);
        }
        if (message.tx.length !== 0) {
          writer.uint32(26).bytes(message.tx);
        }
        if (message.result !== void 0) {
          exports.ExecTxResult.encode(message.result, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxResult();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = reader.int64();
              break;
            case 2:
              message.index = reader.uint32();
              break;
            case 3:
              message.tx = reader.bytes();
              break;
            case 4:
              message.result = exports.ExecTxResult.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxResult();
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.index))
          obj.index = Number(object.index);
        if ((0, helpers_1.isSet)(object.tx))
          obj.tx = (0, helpers_1.bytesFromBase64)(object.tx);
        if ((0, helpers_1.isSet)(object.result))
          obj.result = exports.ExecTxResult.fromJSON(object.result);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.index !== void 0 && (obj.index = Math.round(message.index));
        message.tx !== void 0 && (obj.tx = (0, helpers_1.base64FromBytes)(message.tx !== void 0 ? message.tx : new Uint8Array()));
        message.result !== void 0 && (obj.result = message.result ? exports.ExecTxResult.toJSON(message.result) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxResult();
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        message.index = object.index ?? 0;
        message.tx = object.tx ?? new Uint8Array();
        if (object.result !== void 0 && object.result !== null) {
          message.result = exports.ExecTxResult.fromPartial(object.result);
        }
        return message;
      }
    };
    function createBaseValidator() {
      return {
        address: new Uint8Array(),
        power: BigInt(0)
      };
    }
    exports.Validator = {
      typeUrl: "/tendermint.abci.Validator",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address.length !== 0) {
          writer.uint32(10).bytes(message.address);
        }
        if (message.power !== BigInt(0)) {
          writer.uint32(24).int64(message.power);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidator();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.bytes();
              break;
            case 3:
              message.power = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidator();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = (0, helpers_1.bytesFromBase64)(object.address);
        if ((0, helpers_1.isSet)(object.power))
          obj.power = BigInt(object.power.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = (0, helpers_1.base64FromBytes)(message.address !== void 0 ? message.address : new Uint8Array()));
        message.power !== void 0 && (obj.power = (message.power || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseValidator();
        message.address = object.address ?? new Uint8Array();
        if (object.power !== void 0 && object.power !== null) {
          message.power = BigInt(object.power.toString());
        }
        return message;
      }
    };
    function createBaseValidatorUpdate() {
      return {
        pubKey: keys_1.PublicKey.fromPartial({}),
        power: BigInt(0)
      };
    }
    exports.ValidatorUpdate = {
      typeUrl: "/tendermint.abci.ValidatorUpdate",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pubKey !== void 0) {
          keys_1.PublicKey.encode(message.pubKey, writer.uint32(10).fork()).ldelim();
        }
        if (message.power !== BigInt(0)) {
          writer.uint32(16).int64(message.power);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorUpdate();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pubKey = keys_1.PublicKey.decode(reader, reader.uint32());
              break;
            case 2:
              message.power = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidatorUpdate();
        if ((0, helpers_1.isSet)(object.pubKey))
          obj.pubKey = keys_1.PublicKey.fromJSON(object.pubKey);
        if ((0, helpers_1.isSet)(object.power))
          obj.power = BigInt(object.power.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.pubKey !== void 0 && (obj.pubKey = message.pubKey ? keys_1.PublicKey.toJSON(message.pubKey) : void 0);
        message.power !== void 0 && (obj.power = (message.power || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseValidatorUpdate();
        if (object.pubKey !== void 0 && object.pubKey !== null) {
          message.pubKey = keys_1.PublicKey.fromPartial(object.pubKey);
        }
        if (object.power !== void 0 && object.power !== null) {
          message.power = BigInt(object.power.toString());
        }
        return message;
      }
    };
    function createBaseVoteInfo() {
      return {
        validator: exports.Validator.fromPartial({}),
        blockIdFlag: 0
      };
    }
    exports.VoteInfo = {
      typeUrl: "/tendermint.abci.VoteInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validator !== void 0) {
          exports.Validator.encode(message.validator, writer.uint32(10).fork()).ldelim();
        }
        if (message.blockIdFlag !== 0) {
          writer.uint32(24).int32(message.blockIdFlag);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVoteInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validator = exports.Validator.decode(reader, reader.uint32());
              break;
            case 3:
              message.blockIdFlag = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseVoteInfo();
        if ((0, helpers_1.isSet)(object.validator))
          obj.validator = exports.Validator.fromJSON(object.validator);
        if ((0, helpers_1.isSet)(object.blockIdFlag))
          obj.blockIdFlag = (0, validator_1.blockIDFlagFromJSON)(object.blockIdFlag);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validator !== void 0 && (obj.validator = message.validator ? exports.Validator.toJSON(message.validator) : void 0);
        message.blockIdFlag !== void 0 && (obj.blockIdFlag = (0, validator_1.blockIDFlagToJSON)(message.blockIdFlag));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseVoteInfo();
        if (object.validator !== void 0 && object.validator !== null) {
          message.validator = exports.Validator.fromPartial(object.validator);
        }
        message.blockIdFlag = object.blockIdFlag ?? 0;
        return message;
      }
    };
    function createBaseExtendedVoteInfo() {
      return {
        validator: exports.Validator.fromPartial({}),
        voteExtension: new Uint8Array(),
        extensionSignature: new Uint8Array(),
        blockIdFlag: 0
      };
    }
    exports.ExtendedVoteInfo = {
      typeUrl: "/tendermint.abci.ExtendedVoteInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validator !== void 0) {
          exports.Validator.encode(message.validator, writer.uint32(10).fork()).ldelim();
        }
        if (message.voteExtension.length !== 0) {
          writer.uint32(26).bytes(message.voteExtension);
        }
        if (message.extensionSignature.length !== 0) {
          writer.uint32(34).bytes(message.extensionSignature);
        }
        if (message.blockIdFlag !== 0) {
          writer.uint32(40).int32(message.blockIdFlag);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseExtendedVoteInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validator = exports.Validator.decode(reader, reader.uint32());
              break;
            case 3:
              message.voteExtension = reader.bytes();
              break;
            case 4:
              message.extensionSignature = reader.bytes();
              break;
            case 5:
              message.blockIdFlag = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseExtendedVoteInfo();
        if ((0, helpers_1.isSet)(object.validator))
          obj.validator = exports.Validator.fromJSON(object.validator);
        if ((0, helpers_1.isSet)(object.voteExtension))
          obj.voteExtension = (0, helpers_1.bytesFromBase64)(object.voteExtension);
        if ((0, helpers_1.isSet)(object.extensionSignature))
          obj.extensionSignature = (0, helpers_1.bytesFromBase64)(object.extensionSignature);
        if ((0, helpers_1.isSet)(object.blockIdFlag))
          obj.blockIdFlag = (0, validator_1.blockIDFlagFromJSON)(object.blockIdFlag);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validator !== void 0 && (obj.validator = message.validator ? exports.Validator.toJSON(message.validator) : void 0);
        message.voteExtension !== void 0 && (obj.voteExtension = (0, helpers_1.base64FromBytes)(message.voteExtension !== void 0 ? message.voteExtension : new Uint8Array()));
        message.extensionSignature !== void 0 && (obj.extensionSignature = (0, helpers_1.base64FromBytes)(message.extensionSignature !== void 0 ? message.extensionSignature : new Uint8Array()));
        message.blockIdFlag !== void 0 && (obj.blockIdFlag = (0, validator_1.blockIDFlagToJSON)(message.blockIdFlag));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseExtendedVoteInfo();
        if (object.validator !== void 0 && object.validator !== null) {
          message.validator = exports.Validator.fromPartial(object.validator);
        }
        message.voteExtension = object.voteExtension ?? new Uint8Array();
        message.extensionSignature = object.extensionSignature ?? new Uint8Array();
        message.blockIdFlag = object.blockIdFlag ?? 0;
        return message;
      }
    };
    function createBaseMisbehavior() {
      return {
        type: 0,
        validator: exports.Validator.fromPartial({}),
        height: BigInt(0),
        time: timestamp_1.Timestamp.fromPartial({}),
        totalVotingPower: BigInt(0)
      };
    }
    exports.Misbehavior = {
      typeUrl: "/tendermint.abci.Misbehavior",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.type !== 0) {
          writer.uint32(8).int32(message.type);
        }
        if (message.validator !== void 0) {
          exports.Validator.encode(message.validator, writer.uint32(18).fork()).ldelim();
        }
        if (message.height !== BigInt(0)) {
          writer.uint32(24).int64(message.height);
        }
        if (message.time !== void 0) {
          timestamp_1.Timestamp.encode(message.time, writer.uint32(34).fork()).ldelim();
        }
        if (message.totalVotingPower !== BigInt(0)) {
          writer.uint32(40).int64(message.totalVotingPower);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMisbehavior();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.type = reader.int32();
              break;
            case 2:
              message.validator = exports.Validator.decode(reader, reader.uint32());
              break;
            case 3:
              message.height = reader.int64();
              break;
            case 4:
              message.time = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 5:
              message.totalVotingPower = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMisbehavior();
        if ((0, helpers_1.isSet)(object.type))
          obj.type = misbehaviorTypeFromJSON(object.type);
        if ((0, helpers_1.isSet)(object.validator))
          obj.validator = exports.Validator.fromJSON(object.validator);
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.time))
          obj.time = (0, helpers_1.fromJsonTimestamp)(object.time);
        if ((0, helpers_1.isSet)(object.totalVotingPower))
          obj.totalVotingPower = BigInt(object.totalVotingPower.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.type !== void 0 && (obj.type = misbehaviorTypeToJSON(message.type));
        message.validator !== void 0 && (obj.validator = message.validator ? exports.Validator.toJSON(message.validator) : void 0);
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.time !== void 0 && (obj.time = (0, helpers_1.fromTimestamp)(message.time).toISOString());
        message.totalVotingPower !== void 0 && (obj.totalVotingPower = (message.totalVotingPower || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMisbehavior();
        message.type = object.type ?? 0;
        if (object.validator !== void 0 && object.validator !== null) {
          message.validator = exports.Validator.fromPartial(object.validator);
        }
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        if (object.time !== void 0 && object.time !== null) {
          message.time = timestamp_1.Timestamp.fromPartial(object.time);
        }
        if (object.totalVotingPower !== void 0 && object.totalVotingPower !== null) {
          message.totalVotingPower = BigInt(object.totalVotingPower.toString());
        }
        return message;
      }
    };
    function createBaseSnapshot() {
      return {
        height: BigInt(0),
        format: 0,
        chunks: 0,
        hash: new Uint8Array(),
        metadata: new Uint8Array()
      };
    }
    exports.Snapshot = {
      typeUrl: "/tendermint.abci.Snapshot",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== BigInt(0)) {
          writer.uint32(8).uint64(message.height);
        }
        if (message.format !== 0) {
          writer.uint32(16).uint32(message.format);
        }
        if (message.chunks !== 0) {
          writer.uint32(24).uint32(message.chunks);
        }
        if (message.hash.length !== 0) {
          writer.uint32(34).bytes(message.hash);
        }
        if (message.metadata.length !== 0) {
          writer.uint32(42).bytes(message.metadata);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSnapshot();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = reader.uint64();
              break;
            case 2:
              message.format = reader.uint32();
              break;
            case 3:
              message.chunks = reader.uint32();
              break;
            case 4:
              message.hash = reader.bytes();
              break;
            case 5:
              message.metadata = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSnapshot();
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.format))
          obj.format = Number(object.format);
        if ((0, helpers_1.isSet)(object.chunks))
          obj.chunks = Number(object.chunks);
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = (0, helpers_1.bytesFromBase64)(object.hash);
        if ((0, helpers_1.isSet)(object.metadata))
          obj.metadata = (0, helpers_1.bytesFromBase64)(object.metadata);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.format !== void 0 && (obj.format = Math.round(message.format));
        message.chunks !== void 0 && (obj.chunks = Math.round(message.chunks));
        message.hash !== void 0 && (obj.hash = (0, helpers_1.base64FromBytes)(message.hash !== void 0 ? message.hash : new Uint8Array()));
        message.metadata !== void 0 && (obj.metadata = (0, helpers_1.base64FromBytes)(message.metadata !== void 0 ? message.metadata : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSnapshot();
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        message.format = object.format ?? 0;
        message.chunks = object.chunks ?? 0;
        message.hash = object.hash ?? new Uint8Array();
        message.metadata = object.metadata ?? new Uint8Array();
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/staking/v1beta1/staking.js
var require_staking = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/staking/v1beta1/staking.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValidatorUpdates = exports.Pool = exports.RedelegationResponse = exports.RedelegationEntryResponse = exports.DelegationResponse = exports.Params = exports.Redelegation = exports.RedelegationEntry = exports.UnbondingDelegationEntry = exports.UnbondingDelegation = exports.Delegation = exports.DVVTriplets = exports.DVVTriplet = exports.DVPairs = exports.DVPair = exports.ValAddresses = exports.Validator = exports.Description = exports.Commission = exports.CommissionRates = exports.HistoricalInfo = exports.infractionToJSON = exports.infractionFromJSON = exports.Infraction = exports.bondStatusToJSON = exports.bondStatusFromJSON = exports.BondStatus = exports.protobufPackage = void 0;
    var types_1 = require_types3();
    var timestamp_1 = require_timestamp();
    var any_1 = require_any();
    var duration_1 = require_duration();
    var coin_1 = require_coin();
    var types_2 = require_types4();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.staking.v1beta1";
    var BondStatus;
    (function(BondStatus2) {
      BondStatus2[BondStatus2["BOND_STATUS_UNSPECIFIED"] = 0] = "BOND_STATUS_UNSPECIFIED";
      BondStatus2[BondStatus2["BOND_STATUS_UNBONDED"] = 1] = "BOND_STATUS_UNBONDED";
      BondStatus2[BondStatus2["BOND_STATUS_UNBONDING"] = 2] = "BOND_STATUS_UNBONDING";
      BondStatus2[BondStatus2["BOND_STATUS_BONDED"] = 3] = "BOND_STATUS_BONDED";
      BondStatus2[BondStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(BondStatus || (exports.BondStatus = BondStatus = {}));
    function bondStatusFromJSON(object) {
      switch (object) {
        case 0:
        case "BOND_STATUS_UNSPECIFIED":
          return BondStatus.BOND_STATUS_UNSPECIFIED;
        case 1:
        case "BOND_STATUS_UNBONDED":
          return BondStatus.BOND_STATUS_UNBONDED;
        case 2:
        case "BOND_STATUS_UNBONDING":
          return BondStatus.BOND_STATUS_UNBONDING;
        case 3:
        case "BOND_STATUS_BONDED":
          return BondStatus.BOND_STATUS_BONDED;
        case -1:
        case "UNRECOGNIZED":
        default:
          return BondStatus.UNRECOGNIZED;
      }
    }
    exports.bondStatusFromJSON = bondStatusFromJSON;
    function bondStatusToJSON(object) {
      switch (object) {
        case BondStatus.BOND_STATUS_UNSPECIFIED:
          return "BOND_STATUS_UNSPECIFIED";
        case BondStatus.BOND_STATUS_UNBONDED:
          return "BOND_STATUS_UNBONDED";
        case BondStatus.BOND_STATUS_UNBONDING:
          return "BOND_STATUS_UNBONDING";
        case BondStatus.BOND_STATUS_BONDED:
          return "BOND_STATUS_BONDED";
        case BondStatus.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.bondStatusToJSON = bondStatusToJSON;
    var Infraction;
    (function(Infraction2) {
      Infraction2[Infraction2["INFRACTION_UNSPECIFIED"] = 0] = "INFRACTION_UNSPECIFIED";
      Infraction2[Infraction2["INFRACTION_DOUBLE_SIGN"] = 1] = "INFRACTION_DOUBLE_SIGN";
      Infraction2[Infraction2["INFRACTION_DOWNTIME"] = 2] = "INFRACTION_DOWNTIME";
      Infraction2[Infraction2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(Infraction || (exports.Infraction = Infraction = {}));
    function infractionFromJSON(object) {
      switch (object) {
        case 0:
        case "INFRACTION_UNSPECIFIED":
          return Infraction.INFRACTION_UNSPECIFIED;
        case 1:
        case "INFRACTION_DOUBLE_SIGN":
          return Infraction.INFRACTION_DOUBLE_SIGN;
        case 2:
        case "INFRACTION_DOWNTIME":
          return Infraction.INFRACTION_DOWNTIME;
        case -1:
        case "UNRECOGNIZED":
        default:
          return Infraction.UNRECOGNIZED;
      }
    }
    exports.infractionFromJSON = infractionFromJSON;
    function infractionToJSON(object) {
      switch (object) {
        case Infraction.INFRACTION_UNSPECIFIED:
          return "INFRACTION_UNSPECIFIED";
        case Infraction.INFRACTION_DOUBLE_SIGN:
          return "INFRACTION_DOUBLE_SIGN";
        case Infraction.INFRACTION_DOWNTIME:
          return "INFRACTION_DOWNTIME";
        case Infraction.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.infractionToJSON = infractionToJSON;
    function createBaseHistoricalInfo() {
      return {
        header: types_1.Header.fromPartial({}),
        valset: []
      };
    }
    exports.HistoricalInfo = {
      typeUrl: "/cosmos.staking.v1beta1.HistoricalInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.header !== void 0) {
          types_1.Header.encode(message.header, writer.uint32(10).fork()).ldelim();
        }
        for (const v9 of message.valset) {
          exports.Validator.encode(v9, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseHistoricalInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.header = types_1.Header.decode(reader, reader.uint32());
              break;
            case 2:
              message.valset.push(exports.Validator.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseHistoricalInfo();
        if ((0, helpers_1.isSet)(object.header))
          obj.header = types_1.Header.fromJSON(object.header);
        if (Array.isArray(object?.valset))
          obj.valset = object.valset.map((e) => exports.Validator.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.header !== void 0 && (obj.header = message.header ? types_1.Header.toJSON(message.header) : void 0);
        if (message.valset) {
          obj.valset = message.valset.map((e) => e ? exports.Validator.toJSON(e) : void 0);
        } else {
          obj.valset = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseHistoricalInfo();
        if (object.header !== void 0 && object.header !== null) {
          message.header = types_1.Header.fromPartial(object.header);
        }
        message.valset = object.valset?.map((e) => exports.Validator.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseCommissionRates() {
      return {
        rate: "",
        maxRate: "",
        maxChangeRate: ""
      };
    }
    exports.CommissionRates = {
      typeUrl: "/cosmos.staking.v1beta1.CommissionRates",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.rate !== "") {
          writer.uint32(10).string(message.rate);
        }
        if (message.maxRate !== "") {
          writer.uint32(18).string(message.maxRate);
        }
        if (message.maxChangeRate !== "") {
          writer.uint32(26).string(message.maxChangeRate);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommissionRates();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.rate = reader.string();
              break;
            case 2:
              message.maxRate = reader.string();
              break;
            case 3:
              message.maxChangeRate = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCommissionRates();
        if ((0, helpers_1.isSet)(object.rate))
          obj.rate = String(object.rate);
        if ((0, helpers_1.isSet)(object.maxRate))
          obj.maxRate = String(object.maxRate);
        if ((0, helpers_1.isSet)(object.maxChangeRate))
          obj.maxChangeRate = String(object.maxChangeRate);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.rate !== void 0 && (obj.rate = message.rate);
        message.maxRate !== void 0 && (obj.maxRate = message.maxRate);
        message.maxChangeRate !== void 0 && (obj.maxChangeRate = message.maxChangeRate);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCommissionRates();
        message.rate = object.rate ?? "";
        message.maxRate = object.maxRate ?? "";
        message.maxChangeRate = object.maxChangeRate ?? "";
        return message;
      }
    };
    function createBaseCommission() {
      return {
        commissionRates: exports.CommissionRates.fromPartial({}),
        updateTime: timestamp_1.Timestamp.fromPartial({})
      };
    }
    exports.Commission = {
      typeUrl: "/cosmos.staking.v1beta1.Commission",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.commissionRates !== void 0) {
          exports.CommissionRates.encode(message.commissionRates, writer.uint32(10).fork()).ldelim();
        }
        if (message.updateTime !== void 0) {
          timestamp_1.Timestamp.encode(message.updateTime, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommission();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.commissionRates = exports.CommissionRates.decode(reader, reader.uint32());
              break;
            case 2:
              message.updateTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCommission();
        if ((0, helpers_1.isSet)(object.commissionRates))
          obj.commissionRates = exports.CommissionRates.fromJSON(object.commissionRates);
        if ((0, helpers_1.isSet)(object.updateTime))
          obj.updateTime = (0, helpers_1.fromJsonTimestamp)(object.updateTime);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.commissionRates !== void 0 && (obj.commissionRates = message.commissionRates ? exports.CommissionRates.toJSON(message.commissionRates) : void 0);
        message.updateTime !== void 0 && (obj.updateTime = (0, helpers_1.fromTimestamp)(message.updateTime).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCommission();
        if (object.commissionRates !== void 0 && object.commissionRates !== null) {
          message.commissionRates = exports.CommissionRates.fromPartial(object.commissionRates);
        }
        if (object.updateTime !== void 0 && object.updateTime !== null) {
          message.updateTime = timestamp_1.Timestamp.fromPartial(object.updateTime);
        }
        return message;
      }
    };
    function createBaseDescription() {
      return {
        moniker: "",
        identity: "",
        website: "",
        securityContact: "",
        details: ""
      };
    }
    exports.Description = {
      typeUrl: "/cosmos.staking.v1beta1.Description",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.moniker !== "") {
          writer.uint32(10).string(message.moniker);
        }
        if (message.identity !== "") {
          writer.uint32(18).string(message.identity);
        }
        if (message.website !== "") {
          writer.uint32(26).string(message.website);
        }
        if (message.securityContact !== "") {
          writer.uint32(34).string(message.securityContact);
        }
        if (message.details !== "") {
          writer.uint32(42).string(message.details);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDescription();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.moniker = reader.string();
              break;
            case 2:
              message.identity = reader.string();
              break;
            case 3:
              message.website = reader.string();
              break;
            case 4:
              message.securityContact = reader.string();
              break;
            case 5:
              message.details = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDescription();
        if ((0, helpers_1.isSet)(object.moniker))
          obj.moniker = String(object.moniker);
        if ((0, helpers_1.isSet)(object.identity))
          obj.identity = String(object.identity);
        if ((0, helpers_1.isSet)(object.website))
          obj.website = String(object.website);
        if ((0, helpers_1.isSet)(object.securityContact))
          obj.securityContact = String(object.securityContact);
        if ((0, helpers_1.isSet)(object.details))
          obj.details = String(object.details);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.moniker !== void 0 && (obj.moniker = message.moniker);
        message.identity !== void 0 && (obj.identity = message.identity);
        message.website !== void 0 && (obj.website = message.website);
        message.securityContact !== void 0 && (obj.securityContact = message.securityContact);
        message.details !== void 0 && (obj.details = message.details);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDescription();
        message.moniker = object.moniker ?? "";
        message.identity = object.identity ?? "";
        message.website = object.website ?? "";
        message.securityContact = object.securityContact ?? "";
        message.details = object.details ?? "";
        return message;
      }
    };
    function createBaseValidator() {
      return {
        operatorAddress: "",
        consensusPubkey: void 0,
        jailed: false,
        status: 0,
        tokens: "",
        delegatorShares: "",
        description: exports.Description.fromPartial({}),
        unbondingHeight: BigInt(0),
        unbondingTime: timestamp_1.Timestamp.fromPartial({}),
        commission: exports.Commission.fromPartial({}),
        minSelfDelegation: "",
        unbondingOnHoldRefCount: BigInt(0),
        unbondingIds: []
      };
    }
    exports.Validator = {
      typeUrl: "/cosmos.staking.v1beta1.Validator",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.operatorAddress !== "") {
          writer.uint32(10).string(message.operatorAddress);
        }
        if (message.consensusPubkey !== void 0) {
          any_1.Any.encode(message.consensusPubkey, writer.uint32(18).fork()).ldelim();
        }
        if (message.jailed === true) {
          writer.uint32(24).bool(message.jailed);
        }
        if (message.status !== 0) {
          writer.uint32(32).int32(message.status);
        }
        if (message.tokens !== "") {
          writer.uint32(42).string(message.tokens);
        }
        if (message.delegatorShares !== "") {
          writer.uint32(50).string(message.delegatorShares);
        }
        if (message.description !== void 0) {
          exports.Description.encode(message.description, writer.uint32(58).fork()).ldelim();
        }
        if (message.unbondingHeight !== BigInt(0)) {
          writer.uint32(64).int64(message.unbondingHeight);
        }
        if (message.unbondingTime !== void 0) {
          timestamp_1.Timestamp.encode(message.unbondingTime, writer.uint32(74).fork()).ldelim();
        }
        if (message.commission !== void 0) {
          exports.Commission.encode(message.commission, writer.uint32(82).fork()).ldelim();
        }
        if (message.minSelfDelegation !== "") {
          writer.uint32(90).string(message.minSelfDelegation);
        }
        if (message.unbondingOnHoldRefCount !== BigInt(0)) {
          writer.uint32(96).int64(message.unbondingOnHoldRefCount);
        }
        writer.uint32(106).fork();
        for (const v9 of message.unbondingIds) {
          writer.uint64(v9);
        }
        writer.ldelim();
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidator();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.operatorAddress = reader.string();
              break;
            case 2:
              message.consensusPubkey = any_1.Any.decode(reader, reader.uint32());
              break;
            case 3:
              message.jailed = reader.bool();
              break;
            case 4:
              message.status = reader.int32();
              break;
            case 5:
              message.tokens = reader.string();
              break;
            case 6:
              message.delegatorShares = reader.string();
              break;
            case 7:
              message.description = exports.Description.decode(reader, reader.uint32());
              break;
            case 8:
              message.unbondingHeight = reader.int64();
              break;
            case 9:
              message.unbondingTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 10:
              message.commission = exports.Commission.decode(reader, reader.uint32());
              break;
            case 11:
              message.minSelfDelegation = reader.string();
              break;
            case 12:
              message.unbondingOnHoldRefCount = reader.int64();
              break;
            case 13:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.unbondingIds.push(reader.uint64());
                }
              } else {
                message.unbondingIds.push(reader.uint64());
              }
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidator();
        if ((0, helpers_1.isSet)(object.operatorAddress))
          obj.operatorAddress = String(object.operatorAddress);
        if ((0, helpers_1.isSet)(object.consensusPubkey))
          obj.consensusPubkey = any_1.Any.fromJSON(object.consensusPubkey);
        if ((0, helpers_1.isSet)(object.jailed))
          obj.jailed = Boolean(object.jailed);
        if ((0, helpers_1.isSet)(object.status))
          obj.status = bondStatusFromJSON(object.status);
        if ((0, helpers_1.isSet)(object.tokens))
          obj.tokens = String(object.tokens);
        if ((0, helpers_1.isSet)(object.delegatorShares))
          obj.delegatorShares = String(object.delegatorShares);
        if ((0, helpers_1.isSet)(object.description))
          obj.description = exports.Description.fromJSON(object.description);
        if ((0, helpers_1.isSet)(object.unbondingHeight))
          obj.unbondingHeight = BigInt(object.unbondingHeight.toString());
        if ((0, helpers_1.isSet)(object.unbondingTime))
          obj.unbondingTime = (0, helpers_1.fromJsonTimestamp)(object.unbondingTime);
        if ((0, helpers_1.isSet)(object.commission))
          obj.commission = exports.Commission.fromJSON(object.commission);
        if ((0, helpers_1.isSet)(object.minSelfDelegation))
          obj.minSelfDelegation = String(object.minSelfDelegation);
        if ((0, helpers_1.isSet)(object.unbondingOnHoldRefCount))
          obj.unbondingOnHoldRefCount = BigInt(object.unbondingOnHoldRefCount.toString());
        if (Array.isArray(object?.unbondingIds))
          obj.unbondingIds = object.unbondingIds.map((e) => BigInt(e.toString()));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.operatorAddress !== void 0 && (obj.operatorAddress = message.operatorAddress);
        message.consensusPubkey !== void 0 && (obj.consensusPubkey = message.consensusPubkey ? any_1.Any.toJSON(message.consensusPubkey) : void 0);
        message.jailed !== void 0 && (obj.jailed = message.jailed);
        message.status !== void 0 && (obj.status = bondStatusToJSON(message.status));
        message.tokens !== void 0 && (obj.tokens = message.tokens);
        message.delegatorShares !== void 0 && (obj.delegatorShares = message.delegatorShares);
        message.description !== void 0 && (obj.description = message.description ? exports.Description.toJSON(message.description) : void 0);
        message.unbondingHeight !== void 0 && (obj.unbondingHeight = (message.unbondingHeight || BigInt(0)).toString());
        message.unbondingTime !== void 0 && (obj.unbondingTime = (0, helpers_1.fromTimestamp)(message.unbondingTime).toISOString());
        message.commission !== void 0 && (obj.commission = message.commission ? exports.Commission.toJSON(message.commission) : void 0);
        message.minSelfDelegation !== void 0 && (obj.minSelfDelegation = message.minSelfDelegation);
        message.unbondingOnHoldRefCount !== void 0 && (obj.unbondingOnHoldRefCount = (message.unbondingOnHoldRefCount || BigInt(0)).toString());
        if (message.unbondingIds) {
          obj.unbondingIds = message.unbondingIds.map((e) => (e || BigInt(0)).toString());
        } else {
          obj.unbondingIds = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseValidator();
        message.operatorAddress = object.operatorAddress ?? "";
        if (object.consensusPubkey !== void 0 && object.consensusPubkey !== null) {
          message.consensusPubkey = any_1.Any.fromPartial(object.consensusPubkey);
        }
        message.jailed = object.jailed ?? false;
        message.status = object.status ?? 0;
        message.tokens = object.tokens ?? "";
        message.delegatorShares = object.delegatorShares ?? "";
        if (object.description !== void 0 && object.description !== null) {
          message.description = exports.Description.fromPartial(object.description);
        }
        if (object.unbondingHeight !== void 0 && object.unbondingHeight !== null) {
          message.unbondingHeight = BigInt(object.unbondingHeight.toString());
        }
        if (object.unbondingTime !== void 0 && object.unbondingTime !== null) {
          message.unbondingTime = timestamp_1.Timestamp.fromPartial(object.unbondingTime);
        }
        if (object.commission !== void 0 && object.commission !== null) {
          message.commission = exports.Commission.fromPartial(object.commission);
        }
        message.minSelfDelegation = object.minSelfDelegation ?? "";
        if (object.unbondingOnHoldRefCount !== void 0 && object.unbondingOnHoldRefCount !== null) {
          message.unbondingOnHoldRefCount = BigInt(object.unbondingOnHoldRefCount.toString());
        }
        message.unbondingIds = object.unbondingIds?.map((e) => BigInt(e.toString())) || [];
        return message;
      }
    };
    function createBaseValAddresses() {
      return {
        addresses: []
      };
    }
    exports.ValAddresses = {
      typeUrl: "/cosmos.staking.v1beta1.ValAddresses",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.addresses) {
          writer.uint32(10).string(v9);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValAddresses();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.addresses.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValAddresses();
        if (Array.isArray(object?.addresses))
          obj.addresses = object.addresses.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.addresses) {
          obj.addresses = message.addresses.map((e) => e);
        } else {
          obj.addresses = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseValAddresses();
        message.addresses = object.addresses?.map((e) => e) || [];
        return message;
      }
    };
    function createBaseDVPair() {
      return {
        delegatorAddress: "",
        validatorAddress: ""
      };
    }
    exports.DVPair = {
      typeUrl: "/cosmos.staking.v1beta1.DVPair",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDVPair();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDVPair();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDVPair();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        return message;
      }
    };
    function createBaseDVPairs() {
      return {
        pairs: []
      };
    }
    exports.DVPairs = {
      typeUrl: "/cosmos.staking.v1beta1.DVPairs",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.pairs) {
          exports.DVPair.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDVPairs();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pairs.push(exports.DVPair.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDVPairs();
        if (Array.isArray(object?.pairs))
          obj.pairs = object.pairs.map((e) => exports.DVPair.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.pairs) {
          obj.pairs = message.pairs.map((e) => e ? exports.DVPair.toJSON(e) : void 0);
        } else {
          obj.pairs = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDVPairs();
        message.pairs = object.pairs?.map((e) => exports.DVPair.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseDVVTriplet() {
      return {
        delegatorAddress: "",
        validatorSrcAddress: "",
        validatorDstAddress: ""
      };
    }
    exports.DVVTriplet = {
      typeUrl: "/cosmos.staking.v1beta1.DVVTriplet",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorSrcAddress !== "") {
          writer.uint32(18).string(message.validatorSrcAddress);
        }
        if (message.validatorDstAddress !== "") {
          writer.uint32(26).string(message.validatorDstAddress);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDVVTriplet();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorSrcAddress = reader.string();
              break;
            case 3:
              message.validatorDstAddress = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDVVTriplet();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorSrcAddress))
          obj.validatorSrcAddress = String(object.validatorSrcAddress);
        if ((0, helpers_1.isSet)(object.validatorDstAddress))
          obj.validatorDstAddress = String(object.validatorDstAddress);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorSrcAddress !== void 0 && (obj.validatorSrcAddress = message.validatorSrcAddress);
        message.validatorDstAddress !== void 0 && (obj.validatorDstAddress = message.validatorDstAddress);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDVVTriplet();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorSrcAddress = object.validatorSrcAddress ?? "";
        message.validatorDstAddress = object.validatorDstAddress ?? "";
        return message;
      }
    };
    function createBaseDVVTriplets() {
      return {
        triplets: []
      };
    }
    exports.DVVTriplets = {
      typeUrl: "/cosmos.staking.v1beta1.DVVTriplets",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.triplets) {
          exports.DVVTriplet.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDVVTriplets();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.triplets.push(exports.DVVTriplet.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDVVTriplets();
        if (Array.isArray(object?.triplets))
          obj.triplets = object.triplets.map((e) => exports.DVVTriplet.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.triplets) {
          obj.triplets = message.triplets.map((e) => e ? exports.DVVTriplet.toJSON(e) : void 0);
        } else {
          obj.triplets = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDVVTriplets();
        message.triplets = object.triplets?.map((e) => exports.DVVTriplet.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseDelegation() {
      return {
        delegatorAddress: "",
        validatorAddress: "",
        shares: ""
      };
    }
    exports.Delegation = {
      typeUrl: "/cosmos.staking.v1beta1.Delegation",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        if (message.shares !== "") {
          writer.uint32(26).string(message.shares);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDelegation();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.shares = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDelegation();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.shares))
          obj.shares = String(object.shares);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.shares !== void 0 && (obj.shares = message.shares);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDelegation();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        message.shares = object.shares ?? "";
        return message;
      }
    };
    function createBaseUnbondingDelegation() {
      return {
        delegatorAddress: "",
        validatorAddress: "",
        entries: []
      };
    }
    exports.UnbondingDelegation = {
      typeUrl: "/cosmos.staking.v1beta1.UnbondingDelegation",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        for (const v9 of message.entries) {
          exports.UnbondingDelegationEntry.encode(v9, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUnbondingDelegation();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.entries.push(exports.UnbondingDelegationEntry.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseUnbondingDelegation();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        if (Array.isArray(object?.entries))
          obj.entries = object.entries.map((e) => exports.UnbondingDelegationEntry.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        if (message.entries) {
          obj.entries = message.entries.map((e) => e ? exports.UnbondingDelegationEntry.toJSON(e) : void 0);
        } else {
          obj.entries = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseUnbondingDelegation();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        message.entries = object.entries?.map((e) => exports.UnbondingDelegationEntry.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseUnbondingDelegationEntry() {
      return {
        creationHeight: BigInt(0),
        completionTime: timestamp_1.Timestamp.fromPartial({}),
        initialBalance: "",
        balance: "",
        unbondingId: BigInt(0),
        unbondingOnHoldRefCount: BigInt(0)
      };
    }
    exports.UnbondingDelegationEntry = {
      typeUrl: "/cosmos.staking.v1beta1.UnbondingDelegationEntry",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.creationHeight !== BigInt(0)) {
          writer.uint32(8).int64(message.creationHeight);
        }
        if (message.completionTime !== void 0) {
          timestamp_1.Timestamp.encode(message.completionTime, writer.uint32(18).fork()).ldelim();
        }
        if (message.initialBalance !== "") {
          writer.uint32(26).string(message.initialBalance);
        }
        if (message.balance !== "") {
          writer.uint32(34).string(message.balance);
        }
        if (message.unbondingId !== BigInt(0)) {
          writer.uint32(40).uint64(message.unbondingId);
        }
        if (message.unbondingOnHoldRefCount !== BigInt(0)) {
          writer.uint32(48).int64(message.unbondingOnHoldRefCount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUnbondingDelegationEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.creationHeight = reader.int64();
              break;
            case 2:
              message.completionTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 3:
              message.initialBalance = reader.string();
              break;
            case 4:
              message.balance = reader.string();
              break;
            case 5:
              message.unbondingId = reader.uint64();
              break;
            case 6:
              message.unbondingOnHoldRefCount = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseUnbondingDelegationEntry();
        if ((0, helpers_1.isSet)(object.creationHeight))
          obj.creationHeight = BigInt(object.creationHeight.toString());
        if ((0, helpers_1.isSet)(object.completionTime))
          obj.completionTime = (0, helpers_1.fromJsonTimestamp)(object.completionTime);
        if ((0, helpers_1.isSet)(object.initialBalance))
          obj.initialBalance = String(object.initialBalance);
        if ((0, helpers_1.isSet)(object.balance))
          obj.balance = String(object.balance);
        if ((0, helpers_1.isSet)(object.unbondingId))
          obj.unbondingId = BigInt(object.unbondingId.toString());
        if ((0, helpers_1.isSet)(object.unbondingOnHoldRefCount))
          obj.unbondingOnHoldRefCount = BigInt(object.unbondingOnHoldRefCount.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.creationHeight !== void 0 && (obj.creationHeight = (message.creationHeight || BigInt(0)).toString());
        message.completionTime !== void 0 && (obj.completionTime = (0, helpers_1.fromTimestamp)(message.completionTime).toISOString());
        message.initialBalance !== void 0 && (obj.initialBalance = message.initialBalance);
        message.balance !== void 0 && (obj.balance = message.balance);
        message.unbondingId !== void 0 && (obj.unbondingId = (message.unbondingId || BigInt(0)).toString());
        message.unbondingOnHoldRefCount !== void 0 && (obj.unbondingOnHoldRefCount = (message.unbondingOnHoldRefCount || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseUnbondingDelegationEntry();
        if (object.creationHeight !== void 0 && object.creationHeight !== null) {
          message.creationHeight = BigInt(object.creationHeight.toString());
        }
        if (object.completionTime !== void 0 && object.completionTime !== null) {
          message.completionTime = timestamp_1.Timestamp.fromPartial(object.completionTime);
        }
        message.initialBalance = object.initialBalance ?? "";
        message.balance = object.balance ?? "";
        if (object.unbondingId !== void 0 && object.unbondingId !== null) {
          message.unbondingId = BigInt(object.unbondingId.toString());
        }
        if (object.unbondingOnHoldRefCount !== void 0 && object.unbondingOnHoldRefCount !== null) {
          message.unbondingOnHoldRefCount = BigInt(object.unbondingOnHoldRefCount.toString());
        }
        return message;
      }
    };
    function createBaseRedelegationEntry() {
      return {
        creationHeight: BigInt(0),
        completionTime: timestamp_1.Timestamp.fromPartial({}),
        initialBalance: "",
        sharesDst: "",
        unbondingId: BigInt(0),
        unbondingOnHoldRefCount: BigInt(0)
      };
    }
    exports.RedelegationEntry = {
      typeUrl: "/cosmos.staking.v1beta1.RedelegationEntry",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.creationHeight !== BigInt(0)) {
          writer.uint32(8).int64(message.creationHeight);
        }
        if (message.completionTime !== void 0) {
          timestamp_1.Timestamp.encode(message.completionTime, writer.uint32(18).fork()).ldelim();
        }
        if (message.initialBalance !== "") {
          writer.uint32(26).string(message.initialBalance);
        }
        if (message.sharesDst !== "") {
          writer.uint32(34).string(message.sharesDst);
        }
        if (message.unbondingId !== BigInt(0)) {
          writer.uint32(40).uint64(message.unbondingId);
        }
        if (message.unbondingOnHoldRefCount !== BigInt(0)) {
          writer.uint32(48).int64(message.unbondingOnHoldRefCount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRedelegationEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.creationHeight = reader.int64();
              break;
            case 2:
              message.completionTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 3:
              message.initialBalance = reader.string();
              break;
            case 4:
              message.sharesDst = reader.string();
              break;
            case 5:
              message.unbondingId = reader.uint64();
              break;
            case 6:
              message.unbondingOnHoldRefCount = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRedelegationEntry();
        if ((0, helpers_1.isSet)(object.creationHeight))
          obj.creationHeight = BigInt(object.creationHeight.toString());
        if ((0, helpers_1.isSet)(object.completionTime))
          obj.completionTime = (0, helpers_1.fromJsonTimestamp)(object.completionTime);
        if ((0, helpers_1.isSet)(object.initialBalance))
          obj.initialBalance = String(object.initialBalance);
        if ((0, helpers_1.isSet)(object.sharesDst))
          obj.sharesDst = String(object.sharesDst);
        if ((0, helpers_1.isSet)(object.unbondingId))
          obj.unbondingId = BigInt(object.unbondingId.toString());
        if ((0, helpers_1.isSet)(object.unbondingOnHoldRefCount))
          obj.unbondingOnHoldRefCount = BigInt(object.unbondingOnHoldRefCount.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.creationHeight !== void 0 && (obj.creationHeight = (message.creationHeight || BigInt(0)).toString());
        message.completionTime !== void 0 && (obj.completionTime = (0, helpers_1.fromTimestamp)(message.completionTime).toISOString());
        message.initialBalance !== void 0 && (obj.initialBalance = message.initialBalance);
        message.sharesDst !== void 0 && (obj.sharesDst = message.sharesDst);
        message.unbondingId !== void 0 && (obj.unbondingId = (message.unbondingId || BigInt(0)).toString());
        message.unbondingOnHoldRefCount !== void 0 && (obj.unbondingOnHoldRefCount = (message.unbondingOnHoldRefCount || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRedelegationEntry();
        if (object.creationHeight !== void 0 && object.creationHeight !== null) {
          message.creationHeight = BigInt(object.creationHeight.toString());
        }
        if (object.completionTime !== void 0 && object.completionTime !== null) {
          message.completionTime = timestamp_1.Timestamp.fromPartial(object.completionTime);
        }
        message.initialBalance = object.initialBalance ?? "";
        message.sharesDst = object.sharesDst ?? "";
        if (object.unbondingId !== void 0 && object.unbondingId !== null) {
          message.unbondingId = BigInt(object.unbondingId.toString());
        }
        if (object.unbondingOnHoldRefCount !== void 0 && object.unbondingOnHoldRefCount !== null) {
          message.unbondingOnHoldRefCount = BigInt(object.unbondingOnHoldRefCount.toString());
        }
        return message;
      }
    };
    function createBaseRedelegation() {
      return {
        delegatorAddress: "",
        validatorSrcAddress: "",
        validatorDstAddress: "",
        entries: []
      };
    }
    exports.Redelegation = {
      typeUrl: "/cosmos.staking.v1beta1.Redelegation",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorSrcAddress !== "") {
          writer.uint32(18).string(message.validatorSrcAddress);
        }
        if (message.validatorDstAddress !== "") {
          writer.uint32(26).string(message.validatorDstAddress);
        }
        for (const v9 of message.entries) {
          exports.RedelegationEntry.encode(v9, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRedelegation();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorSrcAddress = reader.string();
              break;
            case 3:
              message.validatorDstAddress = reader.string();
              break;
            case 4:
              message.entries.push(exports.RedelegationEntry.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRedelegation();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorSrcAddress))
          obj.validatorSrcAddress = String(object.validatorSrcAddress);
        if ((0, helpers_1.isSet)(object.validatorDstAddress))
          obj.validatorDstAddress = String(object.validatorDstAddress);
        if (Array.isArray(object?.entries))
          obj.entries = object.entries.map((e) => exports.RedelegationEntry.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorSrcAddress !== void 0 && (obj.validatorSrcAddress = message.validatorSrcAddress);
        message.validatorDstAddress !== void 0 && (obj.validatorDstAddress = message.validatorDstAddress);
        if (message.entries) {
          obj.entries = message.entries.map((e) => e ? exports.RedelegationEntry.toJSON(e) : void 0);
        } else {
          obj.entries = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRedelegation();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorSrcAddress = object.validatorSrcAddress ?? "";
        message.validatorDstAddress = object.validatorDstAddress ?? "";
        message.entries = object.entries?.map((e) => exports.RedelegationEntry.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseParams() {
      return {
        unbondingTime: duration_1.Duration.fromPartial({}),
        maxValidators: 0,
        maxEntries: 0,
        historicalEntries: 0,
        bondDenom: "",
        minCommissionRate: ""
      };
    }
    exports.Params = {
      typeUrl: "/cosmos.staking.v1beta1.Params",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.unbondingTime !== void 0) {
          duration_1.Duration.encode(message.unbondingTime, writer.uint32(10).fork()).ldelim();
        }
        if (message.maxValidators !== 0) {
          writer.uint32(16).uint32(message.maxValidators);
        }
        if (message.maxEntries !== 0) {
          writer.uint32(24).uint32(message.maxEntries);
        }
        if (message.historicalEntries !== 0) {
          writer.uint32(32).uint32(message.historicalEntries);
        }
        if (message.bondDenom !== "") {
          writer.uint32(42).string(message.bondDenom);
        }
        if (message.minCommissionRate !== "") {
          writer.uint32(50).string(message.minCommissionRate);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.unbondingTime = duration_1.Duration.decode(reader, reader.uint32());
              break;
            case 2:
              message.maxValidators = reader.uint32();
              break;
            case 3:
              message.maxEntries = reader.uint32();
              break;
            case 4:
              message.historicalEntries = reader.uint32();
              break;
            case 5:
              message.bondDenom = reader.string();
              break;
            case 6:
              message.minCommissionRate = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseParams();
        if ((0, helpers_1.isSet)(object.unbondingTime))
          obj.unbondingTime = duration_1.Duration.fromJSON(object.unbondingTime);
        if ((0, helpers_1.isSet)(object.maxValidators))
          obj.maxValidators = Number(object.maxValidators);
        if ((0, helpers_1.isSet)(object.maxEntries))
          obj.maxEntries = Number(object.maxEntries);
        if ((0, helpers_1.isSet)(object.historicalEntries))
          obj.historicalEntries = Number(object.historicalEntries);
        if ((0, helpers_1.isSet)(object.bondDenom))
          obj.bondDenom = String(object.bondDenom);
        if ((0, helpers_1.isSet)(object.minCommissionRate))
          obj.minCommissionRate = String(object.minCommissionRate);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.unbondingTime !== void 0 && (obj.unbondingTime = message.unbondingTime ? duration_1.Duration.toJSON(message.unbondingTime) : void 0);
        message.maxValidators !== void 0 && (obj.maxValidators = Math.round(message.maxValidators));
        message.maxEntries !== void 0 && (obj.maxEntries = Math.round(message.maxEntries));
        message.historicalEntries !== void 0 && (obj.historicalEntries = Math.round(message.historicalEntries));
        message.bondDenom !== void 0 && (obj.bondDenom = message.bondDenom);
        message.minCommissionRate !== void 0 && (obj.minCommissionRate = message.minCommissionRate);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseParams();
        if (object.unbondingTime !== void 0 && object.unbondingTime !== null) {
          message.unbondingTime = duration_1.Duration.fromPartial(object.unbondingTime);
        }
        message.maxValidators = object.maxValidators ?? 0;
        message.maxEntries = object.maxEntries ?? 0;
        message.historicalEntries = object.historicalEntries ?? 0;
        message.bondDenom = object.bondDenom ?? "";
        message.minCommissionRate = object.minCommissionRate ?? "";
        return message;
      }
    };
    function createBaseDelegationResponse() {
      return {
        delegation: exports.Delegation.fromPartial({}),
        balance: coin_1.Coin.fromPartial({})
      };
    }
    exports.DelegationResponse = {
      typeUrl: "/cosmos.staking.v1beta1.DelegationResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegation !== void 0) {
          exports.Delegation.encode(message.delegation, writer.uint32(10).fork()).ldelim();
        }
        if (message.balance !== void 0) {
          coin_1.Coin.encode(message.balance, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDelegationResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegation = exports.Delegation.decode(reader, reader.uint32());
              break;
            case 2:
              message.balance = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDelegationResponse();
        if ((0, helpers_1.isSet)(object.delegation))
          obj.delegation = exports.Delegation.fromJSON(object.delegation);
        if ((0, helpers_1.isSet)(object.balance))
          obj.balance = coin_1.Coin.fromJSON(object.balance);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegation !== void 0 && (obj.delegation = message.delegation ? exports.Delegation.toJSON(message.delegation) : void 0);
        message.balance !== void 0 && (obj.balance = message.balance ? coin_1.Coin.toJSON(message.balance) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDelegationResponse();
        if (object.delegation !== void 0 && object.delegation !== null) {
          message.delegation = exports.Delegation.fromPartial(object.delegation);
        }
        if (object.balance !== void 0 && object.balance !== null) {
          message.balance = coin_1.Coin.fromPartial(object.balance);
        }
        return message;
      }
    };
    function createBaseRedelegationEntryResponse() {
      return {
        redelegationEntry: exports.RedelegationEntry.fromPartial({}),
        balance: ""
      };
    }
    exports.RedelegationEntryResponse = {
      typeUrl: "/cosmos.staking.v1beta1.RedelegationEntryResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.redelegationEntry !== void 0) {
          exports.RedelegationEntry.encode(message.redelegationEntry, writer.uint32(10).fork()).ldelim();
        }
        if (message.balance !== "") {
          writer.uint32(34).string(message.balance);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRedelegationEntryResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.redelegationEntry = exports.RedelegationEntry.decode(reader, reader.uint32());
              break;
            case 4:
              message.balance = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRedelegationEntryResponse();
        if ((0, helpers_1.isSet)(object.redelegationEntry))
          obj.redelegationEntry = exports.RedelegationEntry.fromJSON(object.redelegationEntry);
        if ((0, helpers_1.isSet)(object.balance))
          obj.balance = String(object.balance);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.redelegationEntry !== void 0 && (obj.redelegationEntry = message.redelegationEntry ? exports.RedelegationEntry.toJSON(message.redelegationEntry) : void 0);
        message.balance !== void 0 && (obj.balance = message.balance);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRedelegationEntryResponse();
        if (object.redelegationEntry !== void 0 && object.redelegationEntry !== null) {
          message.redelegationEntry = exports.RedelegationEntry.fromPartial(object.redelegationEntry);
        }
        message.balance = object.balance ?? "";
        return message;
      }
    };
    function createBaseRedelegationResponse() {
      return {
        redelegation: exports.Redelegation.fromPartial({}),
        entries: []
      };
    }
    exports.RedelegationResponse = {
      typeUrl: "/cosmos.staking.v1beta1.RedelegationResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.redelegation !== void 0) {
          exports.Redelegation.encode(message.redelegation, writer.uint32(10).fork()).ldelim();
        }
        for (const v9 of message.entries) {
          exports.RedelegationEntryResponse.encode(v9, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRedelegationResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.redelegation = exports.Redelegation.decode(reader, reader.uint32());
              break;
            case 2:
              message.entries.push(exports.RedelegationEntryResponse.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseRedelegationResponse();
        if ((0, helpers_1.isSet)(object.redelegation))
          obj.redelegation = exports.Redelegation.fromJSON(object.redelegation);
        if (Array.isArray(object?.entries))
          obj.entries = object.entries.map((e) => exports.RedelegationEntryResponse.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.redelegation !== void 0 && (obj.redelegation = message.redelegation ? exports.Redelegation.toJSON(message.redelegation) : void 0);
        if (message.entries) {
          obj.entries = message.entries.map((e) => e ? exports.RedelegationEntryResponse.toJSON(e) : void 0);
        } else {
          obj.entries = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseRedelegationResponse();
        if (object.redelegation !== void 0 && object.redelegation !== null) {
          message.redelegation = exports.Redelegation.fromPartial(object.redelegation);
        }
        message.entries = object.entries?.map((e) => exports.RedelegationEntryResponse.fromPartial(e)) || [];
        return message;
      }
    };
    function createBasePool() {
      return {
        notBondedTokens: "",
        bondedTokens: ""
      };
    }
    exports.Pool = {
      typeUrl: "/cosmos.staking.v1beta1.Pool",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.notBondedTokens !== "") {
          writer.uint32(10).string(message.notBondedTokens);
        }
        if (message.bondedTokens !== "") {
          writer.uint32(18).string(message.bondedTokens);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePool();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.notBondedTokens = reader.string();
              break;
            case 2:
              message.bondedTokens = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBasePool();
        if ((0, helpers_1.isSet)(object.notBondedTokens))
          obj.notBondedTokens = String(object.notBondedTokens);
        if ((0, helpers_1.isSet)(object.bondedTokens))
          obj.bondedTokens = String(object.bondedTokens);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.notBondedTokens !== void 0 && (obj.notBondedTokens = message.notBondedTokens);
        message.bondedTokens !== void 0 && (obj.bondedTokens = message.bondedTokens);
        return obj;
      },
      fromPartial(object) {
        const message = createBasePool();
        message.notBondedTokens = object.notBondedTokens ?? "";
        message.bondedTokens = object.bondedTokens ?? "";
        return message;
      }
    };
    function createBaseValidatorUpdates() {
      return {
        updates: []
      };
    }
    exports.ValidatorUpdates = {
      typeUrl: "/cosmos.staking.v1beta1.ValidatorUpdates",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.updates) {
          types_2.ValidatorUpdate.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValidatorUpdates();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.updates.push(types_2.ValidatorUpdate.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseValidatorUpdates();
        if (Array.isArray(object?.updates))
          obj.updates = object.updates.map((e) => types_2.ValidatorUpdate.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.updates) {
          obj.updates = message.updates.map((e) => e ? types_2.ValidatorUpdate.toJSON(e) : void 0);
        } else {
          obj.updates = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseValidatorUpdates();
        message.updates = object.updates?.map((e) => types_2.ValidatorUpdate.fromPartial(e)) || [];
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/staking/v1beta1/tx.js
var require_tx13 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/staking/v1beta1/tx.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MsgClientImpl = exports.MsgUpdateParamsResponse = exports.MsgUpdateParams = exports.MsgCancelUnbondingDelegationResponse = exports.MsgCancelUnbondingDelegation = exports.MsgUndelegateResponse = exports.MsgUndelegate = exports.MsgBeginRedelegateResponse = exports.MsgBeginRedelegate = exports.MsgDelegateResponse = exports.MsgDelegate = exports.MsgEditValidatorResponse = exports.MsgEditValidator = exports.MsgCreateValidatorResponse = exports.MsgCreateValidator = exports.protobufPackage = void 0;
    var staking_1 = require_staking();
    var any_1 = require_any();
    var coin_1 = require_coin();
    var timestamp_1 = require_timestamp();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.staking.v1beta1";
    function createBaseMsgCreateValidator() {
      return {
        description: staking_1.Description.fromPartial({}),
        commission: staking_1.CommissionRates.fromPartial({}),
        minSelfDelegation: "",
        delegatorAddress: "",
        validatorAddress: "",
        pubkey: void 0,
        value: coin_1.Coin.fromPartial({})
      };
    }
    exports.MsgCreateValidator = {
      typeUrl: "/cosmos.staking.v1beta1.MsgCreateValidator",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.description !== void 0) {
          staking_1.Description.encode(message.description, writer.uint32(10).fork()).ldelim();
        }
        if (message.commission !== void 0) {
          staking_1.CommissionRates.encode(message.commission, writer.uint32(18).fork()).ldelim();
        }
        if (message.minSelfDelegation !== "") {
          writer.uint32(26).string(message.minSelfDelegation);
        }
        if (message.delegatorAddress !== "") {
          writer.uint32(34).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(42).string(message.validatorAddress);
        }
        if (message.pubkey !== void 0) {
          any_1.Any.encode(message.pubkey, writer.uint32(50).fork()).ldelim();
        }
        if (message.value !== void 0) {
          coin_1.Coin.encode(message.value, writer.uint32(58).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateValidator();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.description = staking_1.Description.decode(reader, reader.uint32());
              break;
            case 2:
              message.commission = staking_1.CommissionRates.decode(reader, reader.uint32());
              break;
            case 3:
              message.minSelfDelegation = reader.string();
              break;
            case 4:
              message.delegatorAddress = reader.string();
              break;
            case 5:
              message.validatorAddress = reader.string();
              break;
            case 6:
              message.pubkey = any_1.Any.decode(reader, reader.uint32());
              break;
            case 7:
              message.value = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCreateValidator();
        if ((0, helpers_1.isSet)(object.description))
          obj.description = staking_1.Description.fromJSON(object.description);
        if ((0, helpers_1.isSet)(object.commission))
          obj.commission = staking_1.CommissionRates.fromJSON(object.commission);
        if ((0, helpers_1.isSet)(object.minSelfDelegation))
          obj.minSelfDelegation = String(object.minSelfDelegation);
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.pubkey))
          obj.pubkey = any_1.Any.fromJSON(object.pubkey);
        if ((0, helpers_1.isSet)(object.value))
          obj.value = coin_1.Coin.fromJSON(object.value);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.description !== void 0 && (obj.description = message.description ? staking_1.Description.toJSON(message.description) : void 0);
        message.commission !== void 0 && (obj.commission = message.commission ? staking_1.CommissionRates.toJSON(message.commission) : void 0);
        message.minSelfDelegation !== void 0 && (obj.minSelfDelegation = message.minSelfDelegation);
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.pubkey !== void 0 && (obj.pubkey = message.pubkey ? any_1.Any.toJSON(message.pubkey) : void 0);
        message.value !== void 0 && (obj.value = message.value ? coin_1.Coin.toJSON(message.value) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgCreateValidator();
        if (object.description !== void 0 && object.description !== null) {
          message.description = staking_1.Description.fromPartial(object.description);
        }
        if (object.commission !== void 0 && object.commission !== null) {
          message.commission = staking_1.CommissionRates.fromPartial(object.commission);
        }
        message.minSelfDelegation = object.minSelfDelegation ?? "";
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        if (object.pubkey !== void 0 && object.pubkey !== null) {
          message.pubkey = any_1.Any.fromPartial(object.pubkey);
        }
        if (object.value !== void 0 && object.value !== null) {
          message.value = coin_1.Coin.fromPartial(object.value);
        }
        return message;
      }
    };
    function createBaseMsgCreateValidatorResponse() {
      return {};
    }
    exports.MsgCreateValidatorResponse = {
      typeUrl: "/cosmos.staking.v1beta1.MsgCreateValidatorResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateValidatorResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgCreateValidatorResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgCreateValidatorResponse();
        return message;
      }
    };
    function createBaseMsgEditValidator() {
      return {
        description: staking_1.Description.fromPartial({}),
        validatorAddress: "",
        commissionRate: "",
        minSelfDelegation: ""
      };
    }
    exports.MsgEditValidator = {
      typeUrl: "/cosmos.staking.v1beta1.MsgEditValidator",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.description !== void 0) {
          staking_1.Description.encode(message.description, writer.uint32(10).fork()).ldelim();
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        if (message.commissionRate !== "") {
          writer.uint32(26).string(message.commissionRate);
        }
        if (message.minSelfDelegation !== "") {
          writer.uint32(34).string(message.minSelfDelegation);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgEditValidator();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.description = staking_1.Description.decode(reader, reader.uint32());
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.commissionRate = reader.string();
              break;
            case 4:
              message.minSelfDelegation = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgEditValidator();
        if ((0, helpers_1.isSet)(object.description))
          obj.description = staking_1.Description.fromJSON(object.description);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.commissionRate))
          obj.commissionRate = String(object.commissionRate);
        if ((0, helpers_1.isSet)(object.minSelfDelegation))
          obj.minSelfDelegation = String(object.minSelfDelegation);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.description !== void 0 && (obj.description = message.description ? staking_1.Description.toJSON(message.description) : void 0);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.commissionRate !== void 0 && (obj.commissionRate = message.commissionRate);
        message.minSelfDelegation !== void 0 && (obj.minSelfDelegation = message.minSelfDelegation);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgEditValidator();
        if (object.description !== void 0 && object.description !== null) {
          message.description = staking_1.Description.fromPartial(object.description);
        }
        message.validatorAddress = object.validatorAddress ?? "";
        message.commissionRate = object.commissionRate ?? "";
        message.minSelfDelegation = object.minSelfDelegation ?? "";
        return message;
      }
    };
    function createBaseMsgEditValidatorResponse() {
      return {};
    }
    exports.MsgEditValidatorResponse = {
      typeUrl: "/cosmos.staking.v1beta1.MsgEditValidatorResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgEditValidatorResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgEditValidatorResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgEditValidatorResponse();
        return message;
      }
    };
    function createBaseMsgDelegate() {
      return {
        delegatorAddress: "",
        validatorAddress: "",
        amount: coin_1.Coin.fromPartial({})
      };
    }
    exports.MsgDelegate = {
      typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        if (message.amount !== void 0) {
          coin_1.Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDelegate();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.amount = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgDelegate();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.amount))
          obj.amount = coin_1.Coin.fromJSON(object.amount);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.amount !== void 0 && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgDelegate();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        if (object.amount !== void 0 && object.amount !== null) {
          message.amount = coin_1.Coin.fromPartial(object.amount);
        }
        return message;
      }
    };
    function createBaseMsgDelegateResponse() {
      return {};
    }
    exports.MsgDelegateResponse = {
      typeUrl: "/cosmos.staking.v1beta1.MsgDelegateResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgDelegateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgDelegateResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgDelegateResponse();
        return message;
      }
    };
    function createBaseMsgBeginRedelegate() {
      return {
        delegatorAddress: "",
        validatorSrcAddress: "",
        validatorDstAddress: "",
        amount: coin_1.Coin.fromPartial({})
      };
    }
    exports.MsgBeginRedelegate = {
      typeUrl: "/cosmos.staking.v1beta1.MsgBeginRedelegate",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorSrcAddress !== "") {
          writer.uint32(18).string(message.validatorSrcAddress);
        }
        if (message.validatorDstAddress !== "") {
          writer.uint32(26).string(message.validatorDstAddress);
        }
        if (message.amount !== void 0) {
          coin_1.Coin.encode(message.amount, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgBeginRedelegate();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorSrcAddress = reader.string();
              break;
            case 3:
              message.validatorDstAddress = reader.string();
              break;
            case 4:
              message.amount = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgBeginRedelegate();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorSrcAddress))
          obj.validatorSrcAddress = String(object.validatorSrcAddress);
        if ((0, helpers_1.isSet)(object.validatorDstAddress))
          obj.validatorDstAddress = String(object.validatorDstAddress);
        if ((0, helpers_1.isSet)(object.amount))
          obj.amount = coin_1.Coin.fromJSON(object.amount);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorSrcAddress !== void 0 && (obj.validatorSrcAddress = message.validatorSrcAddress);
        message.validatorDstAddress !== void 0 && (obj.validatorDstAddress = message.validatorDstAddress);
        message.amount !== void 0 && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgBeginRedelegate();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorSrcAddress = object.validatorSrcAddress ?? "";
        message.validatorDstAddress = object.validatorDstAddress ?? "";
        if (object.amount !== void 0 && object.amount !== null) {
          message.amount = coin_1.Coin.fromPartial(object.amount);
        }
        return message;
      }
    };
    function createBaseMsgBeginRedelegateResponse() {
      return {
        completionTime: timestamp_1.Timestamp.fromPartial({})
      };
    }
    exports.MsgBeginRedelegateResponse = {
      typeUrl: "/cosmos.staking.v1beta1.MsgBeginRedelegateResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.completionTime !== void 0) {
          timestamp_1.Timestamp.encode(message.completionTime, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgBeginRedelegateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.completionTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgBeginRedelegateResponse();
        if ((0, helpers_1.isSet)(object.completionTime))
          obj.completionTime = (0, helpers_1.fromJsonTimestamp)(object.completionTime);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.completionTime !== void 0 && (obj.completionTime = (0, helpers_1.fromTimestamp)(message.completionTime).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgBeginRedelegateResponse();
        if (object.completionTime !== void 0 && object.completionTime !== null) {
          message.completionTime = timestamp_1.Timestamp.fromPartial(object.completionTime);
        }
        return message;
      }
    };
    function createBaseMsgUndelegate() {
      return {
        delegatorAddress: "",
        validatorAddress: "",
        amount: coin_1.Coin.fromPartial({})
      };
    }
    exports.MsgUndelegate = {
      typeUrl: "/cosmos.staking.v1beta1.MsgUndelegate",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        if (message.amount !== void 0) {
          coin_1.Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUndelegate();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.amount = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUndelegate();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.amount))
          obj.amount = coin_1.Coin.fromJSON(object.amount);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.amount !== void 0 && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUndelegate();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        if (object.amount !== void 0 && object.amount !== null) {
          message.amount = coin_1.Coin.fromPartial(object.amount);
        }
        return message;
      }
    };
    function createBaseMsgUndelegateResponse() {
      return {
        completionTime: timestamp_1.Timestamp.fromPartial({}),
        amount: coin_1.Coin.fromPartial({})
      };
    }
    exports.MsgUndelegateResponse = {
      typeUrl: "/cosmos.staking.v1beta1.MsgUndelegateResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.completionTime !== void 0) {
          timestamp_1.Timestamp.encode(message.completionTime, writer.uint32(10).fork()).ldelim();
        }
        if (message.amount !== void 0) {
          coin_1.Coin.encode(message.amount, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUndelegateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.completionTime = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            case 2:
              message.amount = coin_1.Coin.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUndelegateResponse();
        if ((0, helpers_1.isSet)(object.completionTime))
          obj.completionTime = (0, helpers_1.fromJsonTimestamp)(object.completionTime);
        if ((0, helpers_1.isSet)(object.amount))
          obj.amount = coin_1.Coin.fromJSON(object.amount);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.completionTime !== void 0 && (obj.completionTime = (0, helpers_1.fromTimestamp)(message.completionTime).toISOString());
        message.amount !== void 0 && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUndelegateResponse();
        if (object.completionTime !== void 0 && object.completionTime !== null) {
          message.completionTime = timestamp_1.Timestamp.fromPartial(object.completionTime);
        }
        if (object.amount !== void 0 && object.amount !== null) {
          message.amount = coin_1.Coin.fromPartial(object.amount);
        }
        return message;
      }
    };
    function createBaseMsgCancelUnbondingDelegation() {
      return {
        delegatorAddress: "",
        validatorAddress: "",
        amount: coin_1.Coin.fromPartial({}),
        creationHeight: BigInt(0)
      };
    }
    exports.MsgCancelUnbondingDelegation = {
      typeUrl: "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddress !== "") {
          writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
          writer.uint32(18).string(message.validatorAddress);
        }
        if (message.amount !== void 0) {
          coin_1.Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();
        }
        if (message.creationHeight !== BigInt(0)) {
          writer.uint32(32).int64(message.creationHeight);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCancelUnbondingDelegation();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddress = reader.string();
              break;
            case 2:
              message.validatorAddress = reader.string();
              break;
            case 3:
              message.amount = coin_1.Coin.decode(reader, reader.uint32());
              break;
            case 4:
              message.creationHeight = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCancelUnbondingDelegation();
        if ((0, helpers_1.isSet)(object.delegatorAddress))
          obj.delegatorAddress = String(object.delegatorAddress);
        if ((0, helpers_1.isSet)(object.validatorAddress))
          obj.validatorAddress = String(object.validatorAddress);
        if ((0, helpers_1.isSet)(object.amount))
          obj.amount = coin_1.Coin.fromJSON(object.amount);
        if ((0, helpers_1.isSet)(object.creationHeight))
          obj.creationHeight = BigInt(object.creationHeight.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddress !== void 0 && (obj.delegatorAddress = message.delegatorAddress);
        message.validatorAddress !== void 0 && (obj.validatorAddress = message.validatorAddress);
        message.amount !== void 0 && (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : void 0);
        message.creationHeight !== void 0 && (obj.creationHeight = (message.creationHeight || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgCancelUnbondingDelegation();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        if (object.amount !== void 0 && object.amount !== null) {
          message.amount = coin_1.Coin.fromPartial(object.amount);
        }
        if (object.creationHeight !== void 0 && object.creationHeight !== null) {
          message.creationHeight = BigInt(object.creationHeight.toString());
        }
        return message;
      }
    };
    function createBaseMsgCancelUnbondingDelegationResponse() {
      return {};
    }
    exports.MsgCancelUnbondingDelegationResponse = {
      typeUrl: "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegationResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCancelUnbondingDelegationResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgCancelUnbondingDelegationResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgCancelUnbondingDelegationResponse();
        return message;
      }
    };
    function createBaseMsgUpdateParams() {
      return {
        authority: "",
        params: staking_1.Params.fromPartial({})
      };
    }
    exports.MsgUpdateParams = {
      typeUrl: "/cosmos.staking.v1beta1.MsgUpdateParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.authority !== "") {
          writer.uint32(10).string(message.authority);
        }
        if (message.params !== void 0) {
          staking_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.authority = reader.string();
              break;
            case 2:
              message.params = staking_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateParams();
        if ((0, helpers_1.isSet)(object.authority))
          obj.authority = String(object.authority);
        if ((0, helpers_1.isSet)(object.params))
          obj.params = staking_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.authority !== void 0 && (obj.authority = message.authority);
        message.params !== void 0 && (obj.params = message.params ? staking_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateParams();
        message.authority = object.authority ?? "";
        if (object.params !== void 0 && object.params !== null) {
          message.params = staking_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseMsgUpdateParamsResponse() {
      return {};
    }
    exports.MsgUpdateParamsResponse = {
      typeUrl: "/cosmos.staking.v1beta1.MsgUpdateParamsResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgUpdateParamsResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgUpdateParamsResponse();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.CreateValidator = this.CreateValidator.bind(this);
        this.EditValidator = this.EditValidator.bind(this);
        this.Delegate = this.Delegate.bind(this);
        this.BeginRedelegate = this.BeginRedelegate.bind(this);
        this.Undelegate = this.Undelegate.bind(this);
        this.CancelUnbondingDelegation = this.CancelUnbondingDelegation.bind(this);
        this.UpdateParams = this.UpdateParams.bind(this);
      }
      CreateValidator(request) {
        const data2 = exports.MsgCreateValidator.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Msg", "CreateValidator", data2);
        return promise.then((data3) => exports.MsgCreateValidatorResponse.decode(new binary_1.BinaryReader(data3)));
      }
      EditValidator(request) {
        const data2 = exports.MsgEditValidator.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Msg", "EditValidator", data2);
        return promise.then((data3) => exports.MsgEditValidatorResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Delegate(request) {
        const data2 = exports.MsgDelegate.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Msg", "Delegate", data2);
        return promise.then((data3) => exports.MsgDelegateResponse.decode(new binary_1.BinaryReader(data3)));
      }
      BeginRedelegate(request) {
        const data2 = exports.MsgBeginRedelegate.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Msg", "BeginRedelegate", data2);
        return promise.then((data3) => exports.MsgBeginRedelegateResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Undelegate(request) {
        const data2 = exports.MsgUndelegate.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Msg", "Undelegate", data2);
        return promise.then((data3) => exports.MsgUndelegateResponse.decode(new binary_1.BinaryReader(data3)));
      }
      CancelUnbondingDelegation(request) {
        const data2 = exports.MsgCancelUnbondingDelegation.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Msg", "CancelUnbondingDelegation", data2);
        return promise.then((data3) => exports.MsgCancelUnbondingDelegationResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateParams(request) {
        const data2 = exports.MsgUpdateParams.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Msg", "UpdateParams", data2);
        return promise.then((data3) => exports.MsgUpdateParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.MsgClientImpl = MsgClientImpl;
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/staking/messages.js
var require_messages8 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/staking/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stakingTypes = void 0;
    exports.isMsgBeginRedelegateEncodeObject = isMsgBeginRedelegateEncodeObject;
    exports.isMsgCreateValidatorEncodeObject = isMsgCreateValidatorEncodeObject;
    exports.isMsgDelegateEncodeObject = isMsgDelegateEncodeObject;
    exports.isMsgEditValidatorEncodeObject = isMsgEditValidatorEncodeObject;
    exports.isMsgUndelegateEncodeObject = isMsgUndelegateEncodeObject;
    exports.isMsgCancelUnbondingDelegationEncodeObject = isMsgCancelUnbondingDelegationEncodeObject;
    var tx_1 = require_tx13();
    exports.stakingTypes = [
      ["/cosmos.staking.v1beta1.MsgBeginRedelegate", tx_1.MsgBeginRedelegate],
      ["/cosmos.staking.v1beta1.MsgCreateValidator", tx_1.MsgCreateValidator],
      ["/cosmos.staking.v1beta1.MsgDelegate", tx_1.MsgDelegate],
      ["/cosmos.staking.v1beta1.MsgEditValidator", tx_1.MsgEditValidator],
      ["/cosmos.staking.v1beta1.MsgUndelegate", tx_1.MsgUndelegate],
      ["/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation", tx_1.MsgCancelUnbondingDelegation]
    ];
    function isMsgBeginRedelegateEncodeObject(o3) {
      return o3.typeUrl === "/cosmos.staking.v1beta1.MsgBeginRedelegate";
    }
    function isMsgCreateValidatorEncodeObject(o3) {
      return o3.typeUrl === "/cosmos.staking.v1beta1.MsgCreateValidator";
    }
    function isMsgDelegateEncodeObject(object) {
      return object.typeUrl === "/cosmos.staking.v1beta1.MsgDelegate";
    }
    function isMsgEditValidatorEncodeObject(o3) {
      return o3.typeUrl === "/cosmos.staking.v1beta1.MsgEditValidator";
    }
    function isMsgUndelegateEncodeObject(object) {
      return object.typeUrl === "/cosmos.staking.v1beta1.MsgUndelegate";
    }
    function isMsgCancelUnbondingDelegationEncodeObject(object) {
      return object.typeUrl === "/cosmos.staking.v1beta1.MsgCancelUnbondingDelegation";
    }
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/staking/v1beta1/query.js
var require_query13 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/staking/v1beta1/query.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryClientImpl = exports.QueryParamsResponse = exports.QueryParamsRequest = exports.QueryPoolResponse = exports.QueryPoolRequest = exports.QueryHistoricalInfoResponse = exports.QueryHistoricalInfoRequest = exports.QueryDelegatorValidatorResponse = exports.QueryDelegatorValidatorRequest = exports.QueryDelegatorValidatorsResponse = exports.QueryDelegatorValidatorsRequest = exports.QueryRedelegationsResponse = exports.QueryRedelegationsRequest = exports.QueryDelegatorUnbondingDelegationsResponse = exports.QueryDelegatorUnbondingDelegationsRequest = exports.QueryDelegatorDelegationsResponse = exports.QueryDelegatorDelegationsRequest = exports.QueryUnbondingDelegationResponse = exports.QueryUnbondingDelegationRequest = exports.QueryDelegationResponse = exports.QueryDelegationRequest = exports.QueryValidatorUnbondingDelegationsResponse = exports.QueryValidatorUnbondingDelegationsRequest = exports.QueryValidatorDelegationsResponse = exports.QueryValidatorDelegationsRequest = exports.QueryValidatorResponse = exports.QueryValidatorRequest = exports.QueryValidatorsResponse = exports.QueryValidatorsRequest = exports.protobufPackage = void 0;
    var pagination_1 = require_pagination();
    var staking_1 = require_staking();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.staking.v1beta1";
    function createBaseQueryValidatorsRequest() {
      return {
        status: "",
        pagination: void 0
      };
    }
    exports.QueryValidatorsRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryValidatorsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.status !== "") {
          writer.uint32(10).string(message.status);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.status = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorsRequest();
        if ((0, helpers_1.isSet)(object.status))
          obj.status = String(object.status);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.status !== void 0 && (obj.status = message.status);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorsRequest();
        message.status = object.status ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryValidatorsResponse() {
      return {
        validators: [],
        pagination: void 0
      };
    }
    exports.QueryValidatorsResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryValidatorsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.validators) {
          staking_1.Validator.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validators.push(staking_1.Validator.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorsResponse();
        if (Array.isArray(object?.validators))
          obj.validators = object.validators.map((e) => staking_1.Validator.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.validators) {
          obj.validators = message.validators.map((e) => e ? staking_1.Validator.toJSON(e) : void 0);
        } else {
          obj.validators = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorsResponse();
        message.validators = object.validators?.map((e) => staking_1.Validator.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryValidatorRequest() {
      return {
        validatorAddr: ""
      };
    }
    exports.QueryValidatorRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryValidatorRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorAddr !== "") {
          writer.uint32(10).string(message.validatorAddr);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddr = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorRequest();
        if ((0, helpers_1.isSet)(object.validatorAddr))
          obj.validatorAddr = String(object.validatorAddr);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddr !== void 0 && (obj.validatorAddr = message.validatorAddr);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorRequest();
        message.validatorAddr = object.validatorAddr ?? "";
        return message;
      }
    };
    function createBaseQueryValidatorResponse() {
      return {
        validator: staking_1.Validator.fromPartial({})
      };
    }
    exports.QueryValidatorResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryValidatorResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validator !== void 0) {
          staking_1.Validator.encode(message.validator, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validator = staking_1.Validator.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorResponse();
        if ((0, helpers_1.isSet)(object.validator))
          obj.validator = staking_1.Validator.fromJSON(object.validator);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validator !== void 0 && (obj.validator = message.validator ? staking_1.Validator.toJSON(message.validator) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorResponse();
        if (object.validator !== void 0 && object.validator !== null) {
          message.validator = staking_1.Validator.fromPartial(object.validator);
        }
        return message;
      }
    };
    function createBaseQueryValidatorDelegationsRequest() {
      return {
        validatorAddr: "",
        pagination: void 0
      };
    }
    exports.QueryValidatorDelegationsRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryValidatorDelegationsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorAddr !== "") {
          writer.uint32(10).string(message.validatorAddr);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorDelegationsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddr = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorDelegationsRequest();
        if ((0, helpers_1.isSet)(object.validatorAddr))
          obj.validatorAddr = String(object.validatorAddr);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddr !== void 0 && (obj.validatorAddr = message.validatorAddr);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorDelegationsRequest();
        message.validatorAddr = object.validatorAddr ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryValidatorDelegationsResponse() {
      return {
        delegationResponses: [],
        pagination: void 0
      };
    }
    exports.QueryValidatorDelegationsResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryValidatorDelegationsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.delegationResponses) {
          staking_1.DelegationResponse.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorDelegationsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegationResponses.push(staking_1.DelegationResponse.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorDelegationsResponse();
        if (Array.isArray(object?.delegationResponses))
          obj.delegationResponses = object.delegationResponses.map((e) => staking_1.DelegationResponse.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.delegationResponses) {
          obj.delegationResponses = message.delegationResponses.map((e) => e ? staking_1.DelegationResponse.toJSON(e) : void 0);
        } else {
          obj.delegationResponses = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorDelegationsResponse();
        message.delegationResponses = object.delegationResponses?.map((e) => staking_1.DelegationResponse.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryValidatorUnbondingDelegationsRequest() {
      return {
        validatorAddr: "",
        pagination: void 0
      };
    }
    exports.QueryValidatorUnbondingDelegationsRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryValidatorUnbondingDelegationsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validatorAddr !== "") {
          writer.uint32(10).string(message.validatorAddr);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorUnbondingDelegationsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validatorAddr = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorUnbondingDelegationsRequest();
        if ((0, helpers_1.isSet)(object.validatorAddr))
          obj.validatorAddr = String(object.validatorAddr);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validatorAddr !== void 0 && (obj.validatorAddr = message.validatorAddr);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorUnbondingDelegationsRequest();
        message.validatorAddr = object.validatorAddr ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryValidatorUnbondingDelegationsResponse() {
      return {
        unbondingResponses: [],
        pagination: void 0
      };
    }
    exports.QueryValidatorUnbondingDelegationsResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryValidatorUnbondingDelegationsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.unbondingResponses) {
          staking_1.UnbondingDelegation.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorUnbondingDelegationsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.unbondingResponses.push(staking_1.UnbondingDelegation.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryValidatorUnbondingDelegationsResponse();
        if (Array.isArray(object?.unbondingResponses))
          obj.unbondingResponses = object.unbondingResponses.map((e) => staking_1.UnbondingDelegation.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.unbondingResponses) {
          obj.unbondingResponses = message.unbondingResponses.map((e) => e ? staking_1.UnbondingDelegation.toJSON(e) : void 0);
        } else {
          obj.unbondingResponses = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryValidatorUnbondingDelegationsResponse();
        message.unbondingResponses = object.unbondingResponses?.map((e) => staking_1.UnbondingDelegation.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDelegationRequest() {
      return {
        delegatorAddr: "",
        validatorAddr: ""
      };
    }
    exports.QueryDelegationRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryDelegationRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddr !== "") {
          writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.validatorAddr !== "") {
          writer.uint32(18).string(message.validatorAddr);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegationRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddr = reader.string();
              break;
            case 2:
              message.validatorAddr = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegationRequest();
        if ((0, helpers_1.isSet)(object.delegatorAddr))
          obj.delegatorAddr = String(object.delegatorAddr);
        if ((0, helpers_1.isSet)(object.validatorAddr))
          obj.validatorAddr = String(object.validatorAddr);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddr !== void 0 && (obj.delegatorAddr = message.delegatorAddr);
        message.validatorAddr !== void 0 && (obj.validatorAddr = message.validatorAddr);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegationRequest();
        message.delegatorAddr = object.delegatorAddr ?? "";
        message.validatorAddr = object.validatorAddr ?? "";
        return message;
      }
    };
    function createBaseQueryDelegationResponse() {
      return {
        delegationResponse: void 0
      };
    }
    exports.QueryDelegationResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryDelegationResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegationResponse !== void 0) {
          staking_1.DelegationResponse.encode(message.delegationResponse, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegationResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegationResponse = staking_1.DelegationResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegationResponse();
        if ((0, helpers_1.isSet)(object.delegationResponse))
          obj.delegationResponse = staking_1.DelegationResponse.fromJSON(object.delegationResponse);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegationResponse !== void 0 && (obj.delegationResponse = message.delegationResponse ? staking_1.DelegationResponse.toJSON(message.delegationResponse) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegationResponse();
        if (object.delegationResponse !== void 0 && object.delegationResponse !== null) {
          message.delegationResponse = staking_1.DelegationResponse.fromPartial(object.delegationResponse);
        }
        return message;
      }
    };
    function createBaseQueryUnbondingDelegationRequest() {
      return {
        delegatorAddr: "",
        validatorAddr: ""
      };
    }
    exports.QueryUnbondingDelegationRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryUnbondingDelegationRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddr !== "") {
          writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.validatorAddr !== "") {
          writer.uint32(18).string(message.validatorAddr);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUnbondingDelegationRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddr = reader.string();
              break;
            case 2:
              message.validatorAddr = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryUnbondingDelegationRequest();
        if ((0, helpers_1.isSet)(object.delegatorAddr))
          obj.delegatorAddr = String(object.delegatorAddr);
        if ((0, helpers_1.isSet)(object.validatorAddr))
          obj.validatorAddr = String(object.validatorAddr);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddr !== void 0 && (obj.delegatorAddr = message.delegatorAddr);
        message.validatorAddr !== void 0 && (obj.validatorAddr = message.validatorAddr);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryUnbondingDelegationRequest();
        message.delegatorAddr = object.delegatorAddr ?? "";
        message.validatorAddr = object.validatorAddr ?? "";
        return message;
      }
    };
    function createBaseQueryUnbondingDelegationResponse() {
      return {
        unbond: staking_1.UnbondingDelegation.fromPartial({})
      };
    }
    exports.QueryUnbondingDelegationResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryUnbondingDelegationResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.unbond !== void 0) {
          staking_1.UnbondingDelegation.encode(message.unbond, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryUnbondingDelegationResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.unbond = staking_1.UnbondingDelegation.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryUnbondingDelegationResponse();
        if ((0, helpers_1.isSet)(object.unbond))
          obj.unbond = staking_1.UnbondingDelegation.fromJSON(object.unbond);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.unbond !== void 0 && (obj.unbond = message.unbond ? staking_1.UnbondingDelegation.toJSON(message.unbond) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryUnbondingDelegationResponse();
        if (object.unbond !== void 0 && object.unbond !== null) {
          message.unbond = staking_1.UnbondingDelegation.fromPartial(object.unbond);
        }
        return message;
      }
    };
    function createBaseQueryDelegatorDelegationsRequest() {
      return {
        delegatorAddr: "",
        pagination: void 0
      };
    }
    exports.QueryDelegatorDelegationsRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorDelegationsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddr !== "") {
          writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorDelegationsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddr = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorDelegationsRequest();
        if ((0, helpers_1.isSet)(object.delegatorAddr))
          obj.delegatorAddr = String(object.delegatorAddr);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddr !== void 0 && (obj.delegatorAddr = message.delegatorAddr);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegatorDelegationsRequest();
        message.delegatorAddr = object.delegatorAddr ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDelegatorDelegationsResponse() {
      return {
        delegationResponses: [],
        pagination: void 0
      };
    }
    exports.QueryDelegatorDelegationsResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorDelegationsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.delegationResponses) {
          staking_1.DelegationResponse.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorDelegationsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegationResponses.push(staking_1.DelegationResponse.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorDelegationsResponse();
        if (Array.isArray(object?.delegationResponses))
          obj.delegationResponses = object.delegationResponses.map((e) => staking_1.DelegationResponse.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.delegationResponses) {
          obj.delegationResponses = message.delegationResponses.map((e) => e ? staking_1.DelegationResponse.toJSON(e) : void 0);
        } else {
          obj.delegationResponses = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegatorDelegationsResponse();
        message.delegationResponses = object.delegationResponses?.map((e) => staking_1.DelegationResponse.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDelegatorUnbondingDelegationsRequest() {
      return {
        delegatorAddr: "",
        pagination: void 0
      };
    }
    exports.QueryDelegatorUnbondingDelegationsRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorUnbondingDelegationsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddr !== "") {
          writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorUnbondingDelegationsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddr = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorUnbondingDelegationsRequest();
        if ((0, helpers_1.isSet)(object.delegatorAddr))
          obj.delegatorAddr = String(object.delegatorAddr);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddr !== void 0 && (obj.delegatorAddr = message.delegatorAddr);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegatorUnbondingDelegationsRequest();
        message.delegatorAddr = object.delegatorAddr ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDelegatorUnbondingDelegationsResponse() {
      return {
        unbondingResponses: [],
        pagination: void 0
      };
    }
    exports.QueryDelegatorUnbondingDelegationsResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorUnbondingDelegationsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.unbondingResponses) {
          staking_1.UnbondingDelegation.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorUnbondingDelegationsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.unbondingResponses.push(staking_1.UnbondingDelegation.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorUnbondingDelegationsResponse();
        if (Array.isArray(object?.unbondingResponses))
          obj.unbondingResponses = object.unbondingResponses.map((e) => staking_1.UnbondingDelegation.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.unbondingResponses) {
          obj.unbondingResponses = message.unbondingResponses.map((e) => e ? staking_1.UnbondingDelegation.toJSON(e) : void 0);
        } else {
          obj.unbondingResponses = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegatorUnbondingDelegationsResponse();
        message.unbondingResponses = object.unbondingResponses?.map((e) => staking_1.UnbondingDelegation.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryRedelegationsRequest() {
      return {
        delegatorAddr: "",
        srcValidatorAddr: "",
        dstValidatorAddr: "",
        pagination: void 0
      };
    }
    exports.QueryRedelegationsRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryRedelegationsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddr !== "") {
          writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.srcValidatorAddr !== "") {
          writer.uint32(18).string(message.srcValidatorAddr);
        }
        if (message.dstValidatorAddr !== "") {
          writer.uint32(26).string(message.dstValidatorAddr);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryRedelegationsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddr = reader.string();
              break;
            case 2:
              message.srcValidatorAddr = reader.string();
              break;
            case 3:
              message.dstValidatorAddr = reader.string();
              break;
            case 4:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryRedelegationsRequest();
        if ((0, helpers_1.isSet)(object.delegatorAddr))
          obj.delegatorAddr = String(object.delegatorAddr);
        if ((0, helpers_1.isSet)(object.srcValidatorAddr))
          obj.srcValidatorAddr = String(object.srcValidatorAddr);
        if ((0, helpers_1.isSet)(object.dstValidatorAddr))
          obj.dstValidatorAddr = String(object.dstValidatorAddr);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddr !== void 0 && (obj.delegatorAddr = message.delegatorAddr);
        message.srcValidatorAddr !== void 0 && (obj.srcValidatorAddr = message.srcValidatorAddr);
        message.dstValidatorAddr !== void 0 && (obj.dstValidatorAddr = message.dstValidatorAddr);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryRedelegationsRequest();
        message.delegatorAddr = object.delegatorAddr ?? "";
        message.srcValidatorAddr = object.srcValidatorAddr ?? "";
        message.dstValidatorAddr = object.dstValidatorAddr ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryRedelegationsResponse() {
      return {
        redelegationResponses: [],
        pagination: void 0
      };
    }
    exports.QueryRedelegationsResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryRedelegationsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.redelegationResponses) {
          staking_1.RedelegationResponse.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryRedelegationsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.redelegationResponses.push(staking_1.RedelegationResponse.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryRedelegationsResponse();
        if (Array.isArray(object?.redelegationResponses))
          obj.redelegationResponses = object.redelegationResponses.map((e) => staking_1.RedelegationResponse.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.redelegationResponses) {
          obj.redelegationResponses = message.redelegationResponses.map((e) => e ? staking_1.RedelegationResponse.toJSON(e) : void 0);
        } else {
          obj.redelegationResponses = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryRedelegationsResponse();
        message.redelegationResponses = object.redelegationResponses?.map((e) => staking_1.RedelegationResponse.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDelegatorValidatorsRequest() {
      return {
        delegatorAddr: "",
        pagination: void 0
      };
    }
    exports.QueryDelegatorValidatorsRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorValidatorsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddr !== "") {
          writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorValidatorsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddr = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorValidatorsRequest();
        if ((0, helpers_1.isSet)(object.delegatorAddr))
          obj.delegatorAddr = String(object.delegatorAddr);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddr !== void 0 && (obj.delegatorAddr = message.delegatorAddr);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegatorValidatorsRequest();
        message.delegatorAddr = object.delegatorAddr ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDelegatorValidatorsResponse() {
      return {
        validators: [],
        pagination: void 0
      };
    }
    exports.QueryDelegatorValidatorsResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorValidatorsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.validators) {
          staking_1.Validator.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorValidatorsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validators.push(staking_1.Validator.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorValidatorsResponse();
        if (Array.isArray(object?.validators))
          obj.validators = object.validators.map((e) => staking_1.Validator.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.validators) {
          obj.validators = message.validators.map((e) => e ? staking_1.Validator.toJSON(e) : void 0);
        } else {
          obj.validators = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegatorValidatorsResponse();
        message.validators = object.validators?.map((e) => staking_1.Validator.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryDelegatorValidatorRequest() {
      return {
        delegatorAddr: "",
        validatorAddr: ""
      };
    }
    exports.QueryDelegatorValidatorRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorValidatorRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.delegatorAddr !== "") {
          writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.validatorAddr !== "") {
          writer.uint32(18).string(message.validatorAddr);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorValidatorRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.delegatorAddr = reader.string();
              break;
            case 2:
              message.validatorAddr = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorValidatorRequest();
        if ((0, helpers_1.isSet)(object.delegatorAddr))
          obj.delegatorAddr = String(object.delegatorAddr);
        if ((0, helpers_1.isSet)(object.validatorAddr))
          obj.validatorAddr = String(object.validatorAddr);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.delegatorAddr !== void 0 && (obj.delegatorAddr = message.delegatorAddr);
        message.validatorAddr !== void 0 && (obj.validatorAddr = message.validatorAddr);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegatorValidatorRequest();
        message.delegatorAddr = object.delegatorAddr ?? "";
        message.validatorAddr = object.validatorAddr ?? "";
        return message;
      }
    };
    function createBaseQueryDelegatorValidatorResponse() {
      return {
        validator: staking_1.Validator.fromPartial({})
      };
    }
    exports.QueryDelegatorValidatorResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryDelegatorValidatorResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.validator !== void 0) {
          staking_1.Validator.encode(message.validator, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorValidatorResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.validator = staking_1.Validator.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryDelegatorValidatorResponse();
        if ((0, helpers_1.isSet)(object.validator))
          obj.validator = staking_1.Validator.fromJSON(object.validator);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.validator !== void 0 && (obj.validator = message.validator ? staking_1.Validator.toJSON(message.validator) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryDelegatorValidatorResponse();
        if (object.validator !== void 0 && object.validator !== null) {
          message.validator = staking_1.Validator.fromPartial(object.validator);
        }
        return message;
      }
    };
    function createBaseQueryHistoricalInfoRequest() {
      return {
        height: BigInt(0)
      };
    }
    exports.QueryHistoricalInfoRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryHistoricalInfoRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== BigInt(0)) {
          writer.uint32(8).int64(message.height);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryHistoricalInfoRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = reader.int64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryHistoricalInfoRequest();
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryHistoricalInfoRequest();
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        return message;
      }
    };
    function createBaseQueryHistoricalInfoResponse() {
      return {
        hist: void 0
      };
    }
    exports.QueryHistoricalInfoResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryHistoricalInfoResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.hist !== void 0) {
          staking_1.HistoricalInfo.encode(message.hist, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryHistoricalInfoResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hist = staking_1.HistoricalInfo.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryHistoricalInfoResponse();
        if ((0, helpers_1.isSet)(object.hist))
          obj.hist = staking_1.HistoricalInfo.fromJSON(object.hist);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.hist !== void 0 && (obj.hist = message.hist ? staking_1.HistoricalInfo.toJSON(message.hist) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryHistoricalInfoResponse();
        if (object.hist !== void 0 && object.hist !== null) {
          message.hist = staking_1.HistoricalInfo.fromPartial(object.hist);
        }
        return message;
      }
    };
    function createBaseQueryPoolRequest() {
      return {};
    }
    exports.QueryPoolRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryPoolRequest",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPoolRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseQueryPoolRequest();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseQueryPoolRequest();
        return message;
      }
    };
    function createBaseQueryPoolResponse() {
      return {
        pool: staking_1.Pool.fromPartial({})
      };
    }
    exports.QueryPoolResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryPoolResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pool !== void 0) {
          staking_1.Pool.encode(message.pool, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPoolResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pool = staking_1.Pool.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryPoolResponse();
        if ((0, helpers_1.isSet)(object.pool))
          obj.pool = staking_1.Pool.fromJSON(object.pool);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.pool !== void 0 && (obj.pool = message.pool ? staking_1.Pool.toJSON(message.pool) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryPoolResponse();
        if (object.pool !== void 0 && object.pool !== null) {
          message.pool = staking_1.Pool.fromPartial(object.pool);
        }
        return message;
      }
    };
    function createBaseQueryParamsRequest() {
      return {};
    }
    exports.QueryParamsRequest = {
      typeUrl: "/cosmos.staking.v1beta1.QueryParamsRequest",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseQueryParamsRequest();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseQueryParamsRequest();
        return message;
      }
    };
    function createBaseQueryParamsResponse() {
      return {
        params: staking_1.Params.fromPartial({})
      };
    }
    exports.QueryParamsResponse = {
      typeUrl: "/cosmos.staking.v1beta1.QueryParamsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== void 0) {
          staking_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = staking_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryParamsResponse();
        if ((0, helpers_1.isSet)(object.params))
          obj.params = staking_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? staking_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryParamsResponse();
        if (object.params !== void 0 && object.params !== null) {
          message.params = staking_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Validators = this.Validators.bind(this);
        this.Validator = this.Validator.bind(this);
        this.ValidatorDelegations = this.ValidatorDelegations.bind(this);
        this.ValidatorUnbondingDelegations = this.ValidatorUnbondingDelegations.bind(this);
        this.Delegation = this.Delegation.bind(this);
        this.UnbondingDelegation = this.UnbondingDelegation.bind(this);
        this.DelegatorDelegations = this.DelegatorDelegations.bind(this);
        this.DelegatorUnbondingDelegations = this.DelegatorUnbondingDelegations.bind(this);
        this.Redelegations = this.Redelegations.bind(this);
        this.DelegatorValidators = this.DelegatorValidators.bind(this);
        this.DelegatorValidator = this.DelegatorValidator.bind(this);
        this.HistoricalInfo = this.HistoricalInfo.bind(this);
        this.Pool = this.Pool.bind(this);
        this.Params = this.Params.bind(this);
      }
      Validators(request) {
        const data2 = exports.QueryValidatorsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "Validators", data2);
        return promise.then((data3) => exports.QueryValidatorsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Validator(request) {
        const data2 = exports.QueryValidatorRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "Validator", data2);
        return promise.then((data3) => exports.QueryValidatorResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ValidatorDelegations(request) {
        const data2 = exports.QueryValidatorDelegationsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "ValidatorDelegations", data2);
        return promise.then((data3) => exports.QueryValidatorDelegationsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ValidatorUnbondingDelegations(request) {
        const data2 = exports.QueryValidatorUnbondingDelegationsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "ValidatorUnbondingDelegations", data2);
        return promise.then((data3) => exports.QueryValidatorUnbondingDelegationsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Delegation(request) {
        const data2 = exports.QueryDelegationRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "Delegation", data2);
        return promise.then((data3) => exports.QueryDelegationResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UnbondingDelegation(request) {
        const data2 = exports.QueryUnbondingDelegationRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "UnbondingDelegation", data2);
        return promise.then((data3) => exports.QueryUnbondingDelegationResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DelegatorDelegations(request) {
        const data2 = exports.QueryDelegatorDelegationsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorDelegations", data2);
        return promise.then((data3) => exports.QueryDelegatorDelegationsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DelegatorUnbondingDelegations(request) {
        const data2 = exports.QueryDelegatorUnbondingDelegationsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorUnbondingDelegations", data2);
        return promise.then((data3) => exports.QueryDelegatorUnbondingDelegationsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Redelegations(request) {
        const data2 = exports.QueryRedelegationsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "Redelegations", data2);
        return promise.then((data3) => exports.QueryRedelegationsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DelegatorValidators(request) {
        const data2 = exports.QueryDelegatorValidatorsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorValidators", data2);
        return promise.then((data3) => exports.QueryDelegatorValidatorsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      DelegatorValidator(request) {
        const data2 = exports.QueryDelegatorValidatorRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "DelegatorValidator", data2);
        return promise.then((data3) => exports.QueryDelegatorValidatorResponse.decode(new binary_1.BinaryReader(data3)));
      }
      HistoricalInfo(request) {
        const data2 = exports.QueryHistoricalInfoRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "HistoricalInfo", data2);
        return promise.then((data3) => exports.QueryHistoricalInfoResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Pool(request = {}) {
        const data2 = exports.QueryPoolRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "Pool", data2);
        return promise.then((data3) => exports.QueryPoolResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Params(request = {}) {
        const data2 = exports.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.staking.v1beta1.Query", "Params", data2);
        return promise.then((data3) => exports.QueryParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.QueryClientImpl = QueryClientImpl;
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/staking/queries.js
var require_queries10 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/staking/queries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupStakingExtension = setupStakingExtension;
    var query_1 = require_query13();
    var queryclient_1 = require_queryclient2();
    function setupStakingExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        staking: {
          delegation: async (delegatorAddress, validatorAddress) => {
            const response = await queryService.Delegation({
              delegatorAddr: delegatorAddress,
              validatorAddr: validatorAddress
            });
            return response;
          },
          delegatorDelegations: async (delegatorAddress, paginationKey) => {
            const response = await queryService.DelegatorDelegations({
              delegatorAddr: delegatorAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          delegatorUnbondingDelegations: async (delegatorAddress, paginationKey) => {
            const response = await queryService.DelegatorUnbondingDelegations({
              delegatorAddr: delegatorAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          delegatorValidator: async (delegatorAddress, validatorAddress) => {
            const response = await queryService.DelegatorValidator({
              delegatorAddr: delegatorAddress,
              validatorAddr: validatorAddress
            });
            return response;
          },
          delegatorValidators: async (delegatorAddress, paginationKey) => {
            const response = await queryService.DelegatorValidators({
              delegatorAddr: delegatorAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          historicalInfo: async (height) => {
            const response = await queryService.HistoricalInfo({
              height: BigInt(height)
            });
            return response;
          },
          params: async () => {
            const response = await queryService.Params({});
            return response;
          },
          pool: async () => {
            const response = await queryService.Pool({});
            return response;
          },
          redelegations: async (delegatorAddress, sourceValidatorAddress, destinationValidatorAddress, paginationKey) => {
            const response = await queryService.Redelegations({
              delegatorAddr: delegatorAddress,
              srcValidatorAddr: sourceValidatorAddress,
              dstValidatorAddr: destinationValidatorAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          unbondingDelegation: async (delegatorAddress, validatorAddress) => {
            const response = await queryService.UnbondingDelegation({
              delegatorAddr: delegatorAddress,
              validatorAddr: validatorAddress
            });
            return response;
          },
          validator: async (validatorAddress) => {
            const response = await queryService.Validator({ validatorAddr: validatorAddress });
            return response;
          },
          validatorDelegations: async (validatorAddress, paginationKey) => {
            const response = await queryService.ValidatorDelegations({
              validatorAddr: validatorAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          validators: async (status, paginationKey) => {
            const response = await queryService.Validators({
              status,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          },
          validatorUnbondingDelegations: async (validatorAddress, paginationKey) => {
            const response = await queryService.ValidatorUnbondingDelegations({
              validatorAddr: validatorAddress,
              pagination: (0, queryclient_1.createPagination)(paginationKey)
            });
            return response;
          }
        }
      };
    }
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/tendermint/types/evidence.js
var require_evidence = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/tendermint/types/evidence.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EvidenceList = exports.LightClientAttackEvidence = exports.DuplicateVoteEvidence = exports.Evidence = exports.protobufPackage = void 0;
    var types_1 = require_types3();
    var timestamp_1 = require_timestamp();
    var validator_1 = require_validator();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "tendermint.types";
    function createBaseEvidence() {
      return {
        duplicateVoteEvidence: void 0,
        lightClientAttackEvidence: void 0
      };
    }
    exports.Evidence = {
      typeUrl: "/tendermint.types.Evidence",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.duplicateVoteEvidence !== void 0) {
          exports.DuplicateVoteEvidence.encode(message.duplicateVoteEvidence, writer.uint32(10).fork()).ldelim();
        }
        if (message.lightClientAttackEvidence !== void 0) {
          exports.LightClientAttackEvidence.encode(message.lightClientAttackEvidence, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseEvidence();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.duplicateVoteEvidence = exports.DuplicateVoteEvidence.decode(reader, reader.uint32());
              break;
            case 2:
              message.lightClientAttackEvidence = exports.LightClientAttackEvidence.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseEvidence();
        if ((0, helpers_1.isSet)(object.duplicateVoteEvidence))
          obj.duplicateVoteEvidence = exports.DuplicateVoteEvidence.fromJSON(object.duplicateVoteEvidence);
        if ((0, helpers_1.isSet)(object.lightClientAttackEvidence))
          obj.lightClientAttackEvidence = exports.LightClientAttackEvidence.fromJSON(object.lightClientAttackEvidence);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.duplicateVoteEvidence !== void 0 && (obj.duplicateVoteEvidence = message.duplicateVoteEvidence ? exports.DuplicateVoteEvidence.toJSON(message.duplicateVoteEvidence) : void 0);
        message.lightClientAttackEvidence !== void 0 && (obj.lightClientAttackEvidence = message.lightClientAttackEvidence ? exports.LightClientAttackEvidence.toJSON(message.lightClientAttackEvidence) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseEvidence();
        if (object.duplicateVoteEvidence !== void 0 && object.duplicateVoteEvidence !== null) {
          message.duplicateVoteEvidence = exports.DuplicateVoteEvidence.fromPartial(object.duplicateVoteEvidence);
        }
        if (object.lightClientAttackEvidence !== void 0 && object.lightClientAttackEvidence !== null) {
          message.lightClientAttackEvidence = exports.LightClientAttackEvidence.fromPartial(object.lightClientAttackEvidence);
        }
        return message;
      }
    };
    function createBaseDuplicateVoteEvidence() {
      return {
        voteA: void 0,
        voteB: void 0,
        totalVotingPower: BigInt(0),
        validatorPower: BigInt(0),
        timestamp: timestamp_1.Timestamp.fromPartial({})
      };
    }
    exports.DuplicateVoteEvidence = {
      typeUrl: "/tendermint.types.DuplicateVoteEvidence",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.voteA !== void 0) {
          types_1.Vote.encode(message.voteA, writer.uint32(10).fork()).ldelim();
        }
        if (message.voteB !== void 0) {
          types_1.Vote.encode(message.voteB, writer.uint32(18).fork()).ldelim();
        }
        if (message.totalVotingPower !== BigInt(0)) {
          writer.uint32(24).int64(message.totalVotingPower);
        }
        if (message.validatorPower !== BigInt(0)) {
          writer.uint32(32).int64(message.validatorPower);
        }
        if (message.timestamp !== void 0) {
          timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(42).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDuplicateVoteEvidence();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.voteA = types_1.Vote.decode(reader, reader.uint32());
              break;
            case 2:
              message.voteB = types_1.Vote.decode(reader, reader.uint32());
              break;
            case 3:
              message.totalVotingPower = reader.int64();
              break;
            case 4:
              message.validatorPower = reader.int64();
              break;
            case 5:
              message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseDuplicateVoteEvidence();
        if ((0, helpers_1.isSet)(object.voteA))
          obj.voteA = types_1.Vote.fromJSON(object.voteA);
        if ((0, helpers_1.isSet)(object.voteB))
          obj.voteB = types_1.Vote.fromJSON(object.voteB);
        if ((0, helpers_1.isSet)(object.totalVotingPower))
          obj.totalVotingPower = BigInt(object.totalVotingPower.toString());
        if ((0, helpers_1.isSet)(object.validatorPower))
          obj.validatorPower = BigInt(object.validatorPower.toString());
        if ((0, helpers_1.isSet)(object.timestamp))
          obj.timestamp = (0, helpers_1.fromJsonTimestamp)(object.timestamp);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.voteA !== void 0 && (obj.voteA = message.voteA ? types_1.Vote.toJSON(message.voteA) : void 0);
        message.voteB !== void 0 && (obj.voteB = message.voteB ? types_1.Vote.toJSON(message.voteB) : void 0);
        message.totalVotingPower !== void 0 && (obj.totalVotingPower = (message.totalVotingPower || BigInt(0)).toString());
        message.validatorPower !== void 0 && (obj.validatorPower = (message.validatorPower || BigInt(0)).toString());
        message.timestamp !== void 0 && (obj.timestamp = (0, helpers_1.fromTimestamp)(message.timestamp).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseDuplicateVoteEvidence();
        if (object.voteA !== void 0 && object.voteA !== null) {
          message.voteA = types_1.Vote.fromPartial(object.voteA);
        }
        if (object.voteB !== void 0 && object.voteB !== null) {
          message.voteB = types_1.Vote.fromPartial(object.voteB);
        }
        if (object.totalVotingPower !== void 0 && object.totalVotingPower !== null) {
          message.totalVotingPower = BigInt(object.totalVotingPower.toString());
        }
        if (object.validatorPower !== void 0 && object.validatorPower !== null) {
          message.validatorPower = BigInt(object.validatorPower.toString());
        }
        if (object.timestamp !== void 0 && object.timestamp !== null) {
          message.timestamp = timestamp_1.Timestamp.fromPartial(object.timestamp);
        }
        return message;
      }
    };
    function createBaseLightClientAttackEvidence() {
      return {
        conflictingBlock: void 0,
        commonHeight: BigInt(0),
        byzantineValidators: [],
        totalVotingPower: BigInt(0),
        timestamp: timestamp_1.Timestamp.fromPartial({})
      };
    }
    exports.LightClientAttackEvidence = {
      typeUrl: "/tendermint.types.LightClientAttackEvidence",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.conflictingBlock !== void 0) {
          types_1.LightBlock.encode(message.conflictingBlock, writer.uint32(10).fork()).ldelim();
        }
        if (message.commonHeight !== BigInt(0)) {
          writer.uint32(16).int64(message.commonHeight);
        }
        for (const v9 of message.byzantineValidators) {
          validator_1.Validator.encode(v9, writer.uint32(26).fork()).ldelim();
        }
        if (message.totalVotingPower !== BigInt(0)) {
          writer.uint32(32).int64(message.totalVotingPower);
        }
        if (message.timestamp !== void 0) {
          timestamp_1.Timestamp.encode(message.timestamp, writer.uint32(42).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLightClientAttackEvidence();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.conflictingBlock = types_1.LightBlock.decode(reader, reader.uint32());
              break;
            case 2:
              message.commonHeight = reader.int64();
              break;
            case 3:
              message.byzantineValidators.push(validator_1.Validator.decode(reader, reader.uint32()));
              break;
            case 4:
              message.totalVotingPower = reader.int64();
              break;
            case 5:
              message.timestamp = timestamp_1.Timestamp.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseLightClientAttackEvidence();
        if ((0, helpers_1.isSet)(object.conflictingBlock))
          obj.conflictingBlock = types_1.LightBlock.fromJSON(object.conflictingBlock);
        if ((0, helpers_1.isSet)(object.commonHeight))
          obj.commonHeight = BigInt(object.commonHeight.toString());
        if (Array.isArray(object?.byzantineValidators))
          obj.byzantineValidators = object.byzantineValidators.map((e) => validator_1.Validator.fromJSON(e));
        if ((0, helpers_1.isSet)(object.totalVotingPower))
          obj.totalVotingPower = BigInt(object.totalVotingPower.toString());
        if ((0, helpers_1.isSet)(object.timestamp))
          obj.timestamp = (0, helpers_1.fromJsonTimestamp)(object.timestamp);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.conflictingBlock !== void 0 && (obj.conflictingBlock = message.conflictingBlock ? types_1.LightBlock.toJSON(message.conflictingBlock) : void 0);
        message.commonHeight !== void 0 && (obj.commonHeight = (message.commonHeight || BigInt(0)).toString());
        if (message.byzantineValidators) {
          obj.byzantineValidators = message.byzantineValidators.map((e) => e ? validator_1.Validator.toJSON(e) : void 0);
        } else {
          obj.byzantineValidators = [];
        }
        message.totalVotingPower !== void 0 && (obj.totalVotingPower = (message.totalVotingPower || BigInt(0)).toString());
        message.timestamp !== void 0 && (obj.timestamp = (0, helpers_1.fromTimestamp)(message.timestamp).toISOString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseLightClientAttackEvidence();
        if (object.conflictingBlock !== void 0 && object.conflictingBlock !== null) {
          message.conflictingBlock = types_1.LightBlock.fromPartial(object.conflictingBlock);
        }
        if (object.commonHeight !== void 0 && object.commonHeight !== null) {
          message.commonHeight = BigInt(object.commonHeight.toString());
        }
        message.byzantineValidators = object.byzantineValidators?.map((e) => validator_1.Validator.fromPartial(e)) || [];
        if (object.totalVotingPower !== void 0 && object.totalVotingPower !== null) {
          message.totalVotingPower = BigInt(object.totalVotingPower.toString());
        }
        if (object.timestamp !== void 0 && object.timestamp !== null) {
          message.timestamp = timestamp_1.Timestamp.fromPartial(object.timestamp);
        }
        return message;
      }
    };
    function createBaseEvidenceList() {
      return {
        evidence: []
      };
    }
    exports.EvidenceList = {
      typeUrl: "/tendermint.types.EvidenceList",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.evidence) {
          exports.Evidence.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseEvidenceList();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.evidence.push(exports.Evidence.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseEvidenceList();
        if (Array.isArray(object?.evidence))
          obj.evidence = object.evidence.map((e) => exports.Evidence.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.evidence) {
          obj.evidence = message.evidence.map((e) => e ? exports.Evidence.toJSON(e) : void 0);
        } else {
          obj.evidence = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseEvidenceList();
        message.evidence = object.evidence?.map((e) => exports.Evidence.fromPartial(e)) || [];
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/tendermint/types/block.js
var require_block = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/tendermint/types/block.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Block = exports.protobufPackage = void 0;
    var types_1 = require_types3();
    var evidence_1 = require_evidence();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "tendermint.types";
    function createBaseBlock() {
      return {
        header: types_1.Header.fromPartial({}),
        data: types_1.Data.fromPartial({}),
        evidence: evidence_1.EvidenceList.fromPartial({}),
        lastCommit: void 0
      };
    }
    exports.Block = {
      typeUrl: "/tendermint.types.Block",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.header !== void 0) {
          types_1.Header.encode(message.header, writer.uint32(10).fork()).ldelim();
        }
        if (message.data !== void 0) {
          types_1.Data.encode(message.data, writer.uint32(18).fork()).ldelim();
        }
        if (message.evidence !== void 0) {
          evidence_1.EvidenceList.encode(message.evidence, writer.uint32(26).fork()).ldelim();
        }
        if (message.lastCommit !== void 0) {
          types_1.Commit.encode(message.lastCommit, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBlock();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.header = types_1.Header.decode(reader, reader.uint32());
              break;
            case 2:
              message.data = types_1.Data.decode(reader, reader.uint32());
              break;
            case 3:
              message.evidence = evidence_1.EvidenceList.decode(reader, reader.uint32());
              break;
            case 4:
              message.lastCommit = types_1.Commit.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBlock();
        if ((0, helpers_1.isSet)(object.header))
          obj.header = types_1.Header.fromJSON(object.header);
        if ((0, helpers_1.isSet)(object.data))
          obj.data = types_1.Data.fromJSON(object.data);
        if ((0, helpers_1.isSet)(object.evidence))
          obj.evidence = evidence_1.EvidenceList.fromJSON(object.evidence);
        if ((0, helpers_1.isSet)(object.lastCommit))
          obj.lastCommit = types_1.Commit.fromJSON(object.lastCommit);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.header !== void 0 && (obj.header = message.header ? types_1.Header.toJSON(message.header) : void 0);
        message.data !== void 0 && (obj.data = message.data ? types_1.Data.toJSON(message.data) : void 0);
        message.evidence !== void 0 && (obj.evidence = message.evidence ? evidence_1.EvidenceList.toJSON(message.evidence) : void 0);
        message.lastCommit !== void 0 && (obj.lastCommit = message.lastCommit ? types_1.Commit.toJSON(message.lastCommit) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBlock();
        if (object.header !== void 0 && object.header !== null) {
          message.header = types_1.Header.fromPartial(object.header);
        }
        if (object.data !== void 0 && object.data !== null) {
          message.data = types_1.Data.fromPartial(object.data);
        }
        if (object.evidence !== void 0 && object.evidence !== null) {
          message.evidence = evidence_1.EvidenceList.fromPartial(object.evidence);
        }
        if (object.lastCommit !== void 0 && object.lastCommit !== null) {
          message.lastCommit = types_1.Commit.fromPartial(object.lastCommit);
        }
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/base/abci/v1beta1/abci.js
var require_abci = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/base/abci/v1beta1/abci.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SearchBlocksResult = exports.SearchTxsResult = exports.TxMsgData = exports.MsgData = exports.SimulationResponse = exports.Result = exports.GasInfo = exports.Attribute = exports.StringEvent = exports.ABCIMessageLog = exports.TxResponse = exports.protobufPackage = void 0;
    var any_1 = require_any();
    var types_1 = require_types4();
    var block_1 = require_block();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.base.abci.v1beta1";
    function createBaseTxResponse() {
      return {
        height: BigInt(0),
        txhash: "",
        codespace: "",
        code: 0,
        data: "",
        rawLog: "",
        logs: [],
        info: "",
        gasWanted: BigInt(0),
        gasUsed: BigInt(0),
        tx: void 0,
        timestamp: "",
        events: []
      };
    }
    exports.TxResponse = {
      typeUrl: "/cosmos.base.abci.v1beta1.TxResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== BigInt(0)) {
          writer.uint32(8).int64(message.height);
        }
        if (message.txhash !== "") {
          writer.uint32(18).string(message.txhash);
        }
        if (message.codespace !== "") {
          writer.uint32(26).string(message.codespace);
        }
        if (message.code !== 0) {
          writer.uint32(32).uint32(message.code);
        }
        if (message.data !== "") {
          writer.uint32(42).string(message.data);
        }
        if (message.rawLog !== "") {
          writer.uint32(50).string(message.rawLog);
        }
        for (const v9 of message.logs) {
          exports.ABCIMessageLog.encode(v9, writer.uint32(58).fork()).ldelim();
        }
        if (message.info !== "") {
          writer.uint32(66).string(message.info);
        }
        if (message.gasWanted !== BigInt(0)) {
          writer.uint32(72).int64(message.gasWanted);
        }
        if (message.gasUsed !== BigInt(0)) {
          writer.uint32(80).int64(message.gasUsed);
        }
        if (message.tx !== void 0) {
          any_1.Any.encode(message.tx, writer.uint32(90).fork()).ldelim();
        }
        if (message.timestamp !== "") {
          writer.uint32(98).string(message.timestamp);
        }
        for (const v9 of message.events) {
          types_1.Event.encode(v9, writer.uint32(106).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = reader.int64();
              break;
            case 2:
              message.txhash = reader.string();
              break;
            case 3:
              message.codespace = reader.string();
              break;
            case 4:
              message.code = reader.uint32();
              break;
            case 5:
              message.data = reader.string();
              break;
            case 6:
              message.rawLog = reader.string();
              break;
            case 7:
              message.logs.push(exports.ABCIMessageLog.decode(reader, reader.uint32()));
              break;
            case 8:
              message.info = reader.string();
              break;
            case 9:
              message.gasWanted = reader.int64();
              break;
            case 10:
              message.gasUsed = reader.int64();
              break;
            case 11:
              message.tx = any_1.Any.decode(reader, reader.uint32());
              break;
            case 12:
              message.timestamp = reader.string();
              break;
            case 13:
              message.events.push(types_1.Event.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxResponse();
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.txhash))
          obj.txhash = String(object.txhash);
        if ((0, helpers_1.isSet)(object.codespace))
          obj.codespace = String(object.codespace);
        if ((0, helpers_1.isSet)(object.code))
          obj.code = Number(object.code);
        if ((0, helpers_1.isSet)(object.data))
          obj.data = String(object.data);
        if ((0, helpers_1.isSet)(object.rawLog))
          obj.rawLog = String(object.rawLog);
        if (Array.isArray(object?.logs))
          obj.logs = object.logs.map((e) => exports.ABCIMessageLog.fromJSON(e));
        if ((0, helpers_1.isSet)(object.info))
          obj.info = String(object.info);
        if ((0, helpers_1.isSet)(object.gasWanted))
          obj.gasWanted = BigInt(object.gasWanted.toString());
        if ((0, helpers_1.isSet)(object.gasUsed))
          obj.gasUsed = BigInt(object.gasUsed.toString());
        if ((0, helpers_1.isSet)(object.tx))
          obj.tx = any_1.Any.fromJSON(object.tx);
        if ((0, helpers_1.isSet)(object.timestamp))
          obj.timestamp = String(object.timestamp);
        if (Array.isArray(object?.events))
          obj.events = object.events.map((e) => types_1.Event.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.txhash !== void 0 && (obj.txhash = message.txhash);
        message.codespace !== void 0 && (obj.codespace = message.codespace);
        message.code !== void 0 && (obj.code = Math.round(message.code));
        message.data !== void 0 && (obj.data = message.data);
        message.rawLog !== void 0 && (obj.rawLog = message.rawLog);
        if (message.logs) {
          obj.logs = message.logs.map((e) => e ? exports.ABCIMessageLog.toJSON(e) : void 0);
        } else {
          obj.logs = [];
        }
        message.info !== void 0 && (obj.info = message.info);
        message.gasWanted !== void 0 && (obj.gasWanted = (message.gasWanted || BigInt(0)).toString());
        message.gasUsed !== void 0 && (obj.gasUsed = (message.gasUsed || BigInt(0)).toString());
        message.tx !== void 0 && (obj.tx = message.tx ? any_1.Any.toJSON(message.tx) : void 0);
        message.timestamp !== void 0 && (obj.timestamp = message.timestamp);
        if (message.events) {
          obj.events = message.events.map((e) => e ? types_1.Event.toJSON(e) : void 0);
        } else {
          obj.events = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxResponse();
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        message.txhash = object.txhash ?? "";
        message.codespace = object.codespace ?? "";
        message.code = object.code ?? 0;
        message.data = object.data ?? "";
        message.rawLog = object.rawLog ?? "";
        message.logs = object.logs?.map((e) => exports.ABCIMessageLog.fromPartial(e)) || [];
        message.info = object.info ?? "";
        if (object.gasWanted !== void 0 && object.gasWanted !== null) {
          message.gasWanted = BigInt(object.gasWanted.toString());
        }
        if (object.gasUsed !== void 0 && object.gasUsed !== null) {
          message.gasUsed = BigInt(object.gasUsed.toString());
        }
        if (object.tx !== void 0 && object.tx !== null) {
          message.tx = any_1.Any.fromPartial(object.tx);
        }
        message.timestamp = object.timestamp ?? "";
        message.events = object.events?.map((e) => types_1.Event.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseABCIMessageLog() {
      return {
        msgIndex: 0,
        log: "",
        events: []
      };
    }
    exports.ABCIMessageLog = {
      typeUrl: "/cosmos.base.abci.v1beta1.ABCIMessageLog",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.msgIndex !== 0) {
          writer.uint32(8).uint32(message.msgIndex);
        }
        if (message.log !== "") {
          writer.uint32(18).string(message.log);
        }
        for (const v9 of message.events) {
          exports.StringEvent.encode(v9, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseABCIMessageLog();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.msgIndex = reader.uint32();
              break;
            case 2:
              message.log = reader.string();
              break;
            case 3:
              message.events.push(exports.StringEvent.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseABCIMessageLog();
        if ((0, helpers_1.isSet)(object.msgIndex))
          obj.msgIndex = Number(object.msgIndex);
        if ((0, helpers_1.isSet)(object.log))
          obj.log = String(object.log);
        if (Array.isArray(object?.events))
          obj.events = object.events.map((e) => exports.StringEvent.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.msgIndex !== void 0 && (obj.msgIndex = Math.round(message.msgIndex));
        message.log !== void 0 && (obj.log = message.log);
        if (message.events) {
          obj.events = message.events.map((e) => e ? exports.StringEvent.toJSON(e) : void 0);
        } else {
          obj.events = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseABCIMessageLog();
        message.msgIndex = object.msgIndex ?? 0;
        message.log = object.log ?? "";
        message.events = object.events?.map((e) => exports.StringEvent.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseStringEvent() {
      return {
        type: "",
        attributes: []
      };
    }
    exports.StringEvent = {
      typeUrl: "/cosmos.base.abci.v1beta1.StringEvent",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.type !== "") {
          writer.uint32(10).string(message.type);
        }
        for (const v9 of message.attributes) {
          exports.Attribute.encode(v9, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseStringEvent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.type = reader.string();
              break;
            case 2:
              message.attributes.push(exports.Attribute.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseStringEvent();
        if ((0, helpers_1.isSet)(object.type))
          obj.type = String(object.type);
        if (Array.isArray(object?.attributes))
          obj.attributes = object.attributes.map((e) => exports.Attribute.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.type !== void 0 && (obj.type = message.type);
        if (message.attributes) {
          obj.attributes = message.attributes.map((e) => e ? exports.Attribute.toJSON(e) : void 0);
        } else {
          obj.attributes = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseStringEvent();
        message.type = object.type ?? "";
        message.attributes = object.attributes?.map((e) => exports.Attribute.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseAttribute() {
      return {
        key: "",
        value: ""
      };
    }
    exports.Attribute = {
      typeUrl: "/cosmos.base.abci.v1beta1.Attribute",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key !== "") {
          writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
          writer.uint32(18).string(message.value);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAttribute();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.string();
              break;
            case 2:
              message.value = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseAttribute();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = String(object.key);
        if ((0, helpers_1.isSet)(object.value))
          obj.value = String(object.value);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = message.key);
        message.value !== void 0 && (obj.value = message.value);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseAttribute();
        message.key = object.key ?? "";
        message.value = object.value ?? "";
        return message;
      }
    };
    function createBaseGasInfo() {
      return {
        gasWanted: BigInt(0),
        gasUsed: BigInt(0)
      };
    }
    exports.GasInfo = {
      typeUrl: "/cosmos.base.abci.v1beta1.GasInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.gasWanted !== BigInt(0)) {
          writer.uint32(8).uint64(message.gasWanted);
        }
        if (message.gasUsed !== BigInt(0)) {
          writer.uint32(16).uint64(message.gasUsed);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGasInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.gasWanted = reader.uint64();
              break;
            case 2:
              message.gasUsed = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGasInfo();
        if ((0, helpers_1.isSet)(object.gasWanted))
          obj.gasWanted = BigInt(object.gasWanted.toString());
        if ((0, helpers_1.isSet)(object.gasUsed))
          obj.gasUsed = BigInt(object.gasUsed.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.gasWanted !== void 0 && (obj.gasWanted = (message.gasWanted || BigInt(0)).toString());
        message.gasUsed !== void 0 && (obj.gasUsed = (message.gasUsed || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGasInfo();
        if (object.gasWanted !== void 0 && object.gasWanted !== null) {
          message.gasWanted = BigInt(object.gasWanted.toString());
        }
        if (object.gasUsed !== void 0 && object.gasUsed !== null) {
          message.gasUsed = BigInt(object.gasUsed.toString());
        }
        return message;
      }
    };
    function createBaseResult() {
      return {
        data: new Uint8Array(),
        log: "",
        events: [],
        msgResponses: []
      };
    }
    exports.Result = {
      typeUrl: "/cosmos.base.abci.v1beta1.Result",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.data.length !== 0) {
          writer.uint32(10).bytes(message.data);
        }
        if (message.log !== "") {
          writer.uint32(18).string(message.log);
        }
        for (const v9 of message.events) {
          types_1.Event.encode(v9, writer.uint32(26).fork()).ldelim();
        }
        for (const v9 of message.msgResponses) {
          any_1.Any.encode(v9, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseResult();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.data = reader.bytes();
              break;
            case 2:
              message.log = reader.string();
              break;
            case 3:
              message.events.push(types_1.Event.decode(reader, reader.uint32()));
              break;
            case 4:
              message.msgResponses.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseResult();
        if ((0, helpers_1.isSet)(object.data))
          obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        if ((0, helpers_1.isSet)(object.log))
          obj.log = String(object.log);
        if (Array.isArray(object?.events))
          obj.events = object.events.map((e) => types_1.Event.fromJSON(e));
        if (Array.isArray(object?.msgResponses))
          obj.msgResponses = object.msgResponses.map((e) => any_1.Any.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        message.log !== void 0 && (obj.log = message.log);
        if (message.events) {
          obj.events = message.events.map((e) => e ? types_1.Event.toJSON(e) : void 0);
        } else {
          obj.events = [];
        }
        if (message.msgResponses) {
          obj.msgResponses = message.msgResponses.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.msgResponses = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseResult();
        message.data = object.data ?? new Uint8Array();
        message.log = object.log ?? "";
        message.events = object.events?.map((e) => types_1.Event.fromPartial(e)) || [];
        message.msgResponses = object.msgResponses?.map((e) => any_1.Any.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseSimulationResponse() {
      return {
        gasInfo: exports.GasInfo.fromPartial({}),
        result: void 0
      };
    }
    exports.SimulationResponse = {
      typeUrl: "/cosmos.base.abci.v1beta1.SimulationResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.gasInfo !== void 0) {
          exports.GasInfo.encode(message.gasInfo, writer.uint32(10).fork()).ldelim();
        }
        if (message.result !== void 0) {
          exports.Result.encode(message.result, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSimulationResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.gasInfo = exports.GasInfo.decode(reader, reader.uint32());
              break;
            case 2:
              message.result = exports.Result.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSimulationResponse();
        if ((0, helpers_1.isSet)(object.gasInfo))
          obj.gasInfo = exports.GasInfo.fromJSON(object.gasInfo);
        if ((0, helpers_1.isSet)(object.result))
          obj.result = exports.Result.fromJSON(object.result);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.gasInfo !== void 0 && (obj.gasInfo = message.gasInfo ? exports.GasInfo.toJSON(message.gasInfo) : void 0);
        message.result !== void 0 && (obj.result = message.result ? exports.Result.toJSON(message.result) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSimulationResponse();
        if (object.gasInfo !== void 0 && object.gasInfo !== null) {
          message.gasInfo = exports.GasInfo.fromPartial(object.gasInfo);
        }
        if (object.result !== void 0 && object.result !== null) {
          message.result = exports.Result.fromPartial(object.result);
        }
        return message;
      }
    };
    function createBaseMsgData() {
      return {
        msgType: "",
        data: new Uint8Array()
      };
    }
    exports.MsgData = {
      typeUrl: "/cosmos.base.abci.v1beta1.MsgData",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.msgType !== "") {
          writer.uint32(10).string(message.msgType);
        }
        if (message.data.length !== 0) {
          writer.uint32(18).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgData();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.msgType = reader.string();
              break;
            case 2:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgData();
        if ((0, helpers_1.isSet)(object.msgType))
          obj.msgType = String(object.msgType);
        if ((0, helpers_1.isSet)(object.data))
          obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.msgType !== void 0 && (obj.msgType = message.msgType);
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgData();
        message.msgType = object.msgType ?? "";
        message.data = object.data ?? new Uint8Array();
        return message;
      }
    };
    function createBaseTxMsgData() {
      return {
        data: [],
        msgResponses: []
      };
    }
    exports.TxMsgData = {
      typeUrl: "/cosmos.base.abci.v1beta1.TxMsgData",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.data) {
          exports.MsgData.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        for (const v9 of message.msgResponses) {
          any_1.Any.encode(v9, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxMsgData();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.data.push(exports.MsgData.decode(reader, reader.uint32()));
              break;
            case 2:
              message.msgResponses.push(any_1.Any.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxMsgData();
        if (Array.isArray(object?.data))
          obj.data = object.data.map((e) => exports.MsgData.fromJSON(e));
        if (Array.isArray(object?.msgResponses))
          obj.msgResponses = object.msgResponses.map((e) => any_1.Any.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.data) {
          obj.data = message.data.map((e) => e ? exports.MsgData.toJSON(e) : void 0);
        } else {
          obj.data = [];
        }
        if (message.msgResponses) {
          obj.msgResponses = message.msgResponses.map((e) => e ? any_1.Any.toJSON(e) : void 0);
        } else {
          obj.msgResponses = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxMsgData();
        message.data = object.data?.map((e) => exports.MsgData.fromPartial(e)) || [];
        message.msgResponses = object.msgResponses?.map((e) => any_1.Any.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseSearchTxsResult() {
      return {
        totalCount: BigInt(0),
        count: BigInt(0),
        pageNumber: BigInt(0),
        pageTotal: BigInt(0),
        limit: BigInt(0),
        txs: []
      };
    }
    exports.SearchTxsResult = {
      typeUrl: "/cosmos.base.abci.v1beta1.SearchTxsResult",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.totalCount !== BigInt(0)) {
          writer.uint32(8).uint64(message.totalCount);
        }
        if (message.count !== BigInt(0)) {
          writer.uint32(16).uint64(message.count);
        }
        if (message.pageNumber !== BigInt(0)) {
          writer.uint32(24).uint64(message.pageNumber);
        }
        if (message.pageTotal !== BigInt(0)) {
          writer.uint32(32).uint64(message.pageTotal);
        }
        if (message.limit !== BigInt(0)) {
          writer.uint32(40).uint64(message.limit);
        }
        for (const v9 of message.txs) {
          exports.TxResponse.encode(v9, writer.uint32(50).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSearchTxsResult();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.totalCount = reader.uint64();
              break;
            case 2:
              message.count = reader.uint64();
              break;
            case 3:
              message.pageNumber = reader.uint64();
              break;
            case 4:
              message.pageTotal = reader.uint64();
              break;
            case 5:
              message.limit = reader.uint64();
              break;
            case 6:
              message.txs.push(exports.TxResponse.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSearchTxsResult();
        if ((0, helpers_1.isSet)(object.totalCount))
          obj.totalCount = BigInt(object.totalCount.toString());
        if ((0, helpers_1.isSet)(object.count))
          obj.count = BigInt(object.count.toString());
        if ((0, helpers_1.isSet)(object.pageNumber))
          obj.pageNumber = BigInt(object.pageNumber.toString());
        if ((0, helpers_1.isSet)(object.pageTotal))
          obj.pageTotal = BigInt(object.pageTotal.toString());
        if ((0, helpers_1.isSet)(object.limit))
          obj.limit = BigInt(object.limit.toString());
        if (Array.isArray(object?.txs))
          obj.txs = object.txs.map((e) => exports.TxResponse.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.totalCount !== void 0 && (obj.totalCount = (message.totalCount || BigInt(0)).toString());
        message.count !== void 0 && (obj.count = (message.count || BigInt(0)).toString());
        message.pageNumber !== void 0 && (obj.pageNumber = (message.pageNumber || BigInt(0)).toString());
        message.pageTotal !== void 0 && (obj.pageTotal = (message.pageTotal || BigInt(0)).toString());
        message.limit !== void 0 && (obj.limit = (message.limit || BigInt(0)).toString());
        if (message.txs) {
          obj.txs = message.txs.map((e) => e ? exports.TxResponse.toJSON(e) : void 0);
        } else {
          obj.txs = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSearchTxsResult();
        if (object.totalCount !== void 0 && object.totalCount !== null) {
          message.totalCount = BigInt(object.totalCount.toString());
        }
        if (object.count !== void 0 && object.count !== null) {
          message.count = BigInt(object.count.toString());
        }
        if (object.pageNumber !== void 0 && object.pageNumber !== null) {
          message.pageNumber = BigInt(object.pageNumber.toString());
        }
        if (object.pageTotal !== void 0 && object.pageTotal !== null) {
          message.pageTotal = BigInt(object.pageTotal.toString());
        }
        if (object.limit !== void 0 && object.limit !== null) {
          message.limit = BigInt(object.limit.toString());
        }
        message.txs = object.txs?.map((e) => exports.TxResponse.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseSearchBlocksResult() {
      return {
        totalCount: BigInt(0),
        count: BigInt(0),
        pageNumber: BigInt(0),
        pageTotal: BigInt(0),
        limit: BigInt(0),
        blocks: []
      };
    }
    exports.SearchBlocksResult = {
      typeUrl: "/cosmos.base.abci.v1beta1.SearchBlocksResult",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.totalCount !== BigInt(0)) {
          writer.uint32(8).int64(message.totalCount);
        }
        if (message.count !== BigInt(0)) {
          writer.uint32(16).int64(message.count);
        }
        if (message.pageNumber !== BigInt(0)) {
          writer.uint32(24).int64(message.pageNumber);
        }
        if (message.pageTotal !== BigInt(0)) {
          writer.uint32(32).int64(message.pageTotal);
        }
        if (message.limit !== BigInt(0)) {
          writer.uint32(40).int64(message.limit);
        }
        for (const v9 of message.blocks) {
          block_1.Block.encode(v9, writer.uint32(50).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSearchBlocksResult();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.totalCount = reader.int64();
              break;
            case 2:
              message.count = reader.int64();
              break;
            case 3:
              message.pageNumber = reader.int64();
              break;
            case 4:
              message.pageTotal = reader.int64();
              break;
            case 5:
              message.limit = reader.int64();
              break;
            case 6:
              message.blocks.push(block_1.Block.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSearchBlocksResult();
        if ((0, helpers_1.isSet)(object.totalCount))
          obj.totalCount = BigInt(object.totalCount.toString());
        if ((0, helpers_1.isSet)(object.count))
          obj.count = BigInt(object.count.toString());
        if ((0, helpers_1.isSet)(object.pageNumber))
          obj.pageNumber = BigInt(object.pageNumber.toString());
        if ((0, helpers_1.isSet)(object.pageTotal))
          obj.pageTotal = BigInt(object.pageTotal.toString());
        if ((0, helpers_1.isSet)(object.limit))
          obj.limit = BigInt(object.limit.toString());
        if (Array.isArray(object?.blocks))
          obj.blocks = object.blocks.map((e) => block_1.Block.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.totalCount !== void 0 && (obj.totalCount = (message.totalCount || BigInt(0)).toString());
        message.count !== void 0 && (obj.count = (message.count || BigInt(0)).toString());
        message.pageNumber !== void 0 && (obj.pageNumber = (message.pageNumber || BigInt(0)).toString());
        message.pageTotal !== void 0 && (obj.pageTotal = (message.pageTotal || BigInt(0)).toString());
        message.limit !== void 0 && (obj.limit = (message.limit || BigInt(0)).toString());
        if (message.blocks) {
          obj.blocks = message.blocks.map((e) => e ? block_1.Block.toJSON(e) : void 0);
        } else {
          obj.blocks = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSearchBlocksResult();
        if (object.totalCount !== void 0 && object.totalCount !== null) {
          message.totalCount = BigInt(object.totalCount.toString());
        }
        if (object.count !== void 0 && object.count !== null) {
          message.count = BigInt(object.count.toString());
        }
        if (object.pageNumber !== void 0 && object.pageNumber !== null) {
          message.pageNumber = BigInt(object.pageNumber.toString());
        }
        if (object.pageTotal !== void 0 && object.pageTotal !== null) {
          message.pageTotal = BigInt(object.pageTotal.toString());
        }
        if (object.limit !== void 0 && object.limit !== null) {
          message.limit = BigInt(object.limit.toString());
        }
        message.blocks = object.blocks?.map((e) => block_1.Block.fromPartial(e)) || [];
        return message;
      }
    };
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/tx/v1beta1/service.js
var require_service = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/tx/v1beta1/service.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ServiceClientImpl = exports.TxDecodeAminoResponse = exports.TxDecodeAminoRequest = exports.TxEncodeAminoResponse = exports.TxEncodeAminoRequest = exports.TxEncodeResponse = exports.TxEncodeRequest = exports.TxDecodeResponse = exports.TxDecodeRequest = exports.GetBlockWithTxsResponse = exports.GetBlockWithTxsRequest = exports.GetTxResponse = exports.GetTxRequest = exports.SimulateResponse = exports.SimulateRequest = exports.BroadcastTxResponse = exports.BroadcastTxRequest = exports.GetTxsEventResponse = exports.GetTxsEventRequest = exports.broadcastModeToJSON = exports.broadcastModeFromJSON = exports.BroadcastMode = exports.orderByToJSON = exports.orderByFromJSON = exports.OrderBy = exports.protobufPackage = void 0;
    var tx_1 = require_tx();
    var pagination_1 = require_pagination();
    var abci_1 = require_abci();
    var types_1 = require_types3();
    var block_1 = require_block();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.tx.v1beta1";
    var OrderBy;
    (function(OrderBy2) {
      OrderBy2[OrderBy2["ORDER_BY_UNSPECIFIED"] = 0] = "ORDER_BY_UNSPECIFIED";
      OrderBy2[OrderBy2["ORDER_BY_ASC"] = 1] = "ORDER_BY_ASC";
      OrderBy2[OrderBy2["ORDER_BY_DESC"] = 2] = "ORDER_BY_DESC";
      OrderBy2[OrderBy2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(OrderBy || (exports.OrderBy = OrderBy = {}));
    function orderByFromJSON(object) {
      switch (object) {
        case 0:
        case "ORDER_BY_UNSPECIFIED":
          return OrderBy.ORDER_BY_UNSPECIFIED;
        case 1:
        case "ORDER_BY_ASC":
          return OrderBy.ORDER_BY_ASC;
        case 2:
        case "ORDER_BY_DESC":
          return OrderBy.ORDER_BY_DESC;
        case -1:
        case "UNRECOGNIZED":
        default:
          return OrderBy.UNRECOGNIZED;
      }
    }
    exports.orderByFromJSON = orderByFromJSON;
    function orderByToJSON(object) {
      switch (object) {
        case OrderBy.ORDER_BY_UNSPECIFIED:
          return "ORDER_BY_UNSPECIFIED";
        case OrderBy.ORDER_BY_ASC:
          return "ORDER_BY_ASC";
        case OrderBy.ORDER_BY_DESC:
          return "ORDER_BY_DESC";
        case OrderBy.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.orderByToJSON = orderByToJSON;
    var BroadcastMode;
    (function(BroadcastMode2) {
      BroadcastMode2[BroadcastMode2["BROADCAST_MODE_UNSPECIFIED"] = 0] = "BROADCAST_MODE_UNSPECIFIED";
      BroadcastMode2[BroadcastMode2["BROADCAST_MODE_BLOCK"] = 1] = "BROADCAST_MODE_BLOCK";
      BroadcastMode2[BroadcastMode2["BROADCAST_MODE_SYNC"] = 2] = "BROADCAST_MODE_SYNC";
      BroadcastMode2[BroadcastMode2["BROADCAST_MODE_ASYNC"] = 3] = "BROADCAST_MODE_ASYNC";
      BroadcastMode2[BroadcastMode2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(BroadcastMode || (exports.BroadcastMode = BroadcastMode = {}));
    function broadcastModeFromJSON(object) {
      switch (object) {
        case 0:
        case "BROADCAST_MODE_UNSPECIFIED":
          return BroadcastMode.BROADCAST_MODE_UNSPECIFIED;
        case 1:
        case "BROADCAST_MODE_BLOCK":
          return BroadcastMode.BROADCAST_MODE_BLOCK;
        case 2:
        case "BROADCAST_MODE_SYNC":
          return BroadcastMode.BROADCAST_MODE_SYNC;
        case 3:
        case "BROADCAST_MODE_ASYNC":
          return BroadcastMode.BROADCAST_MODE_ASYNC;
        case -1:
        case "UNRECOGNIZED":
        default:
          return BroadcastMode.UNRECOGNIZED;
      }
    }
    exports.broadcastModeFromJSON = broadcastModeFromJSON;
    function broadcastModeToJSON(object) {
      switch (object) {
        case BroadcastMode.BROADCAST_MODE_UNSPECIFIED:
          return "BROADCAST_MODE_UNSPECIFIED";
        case BroadcastMode.BROADCAST_MODE_BLOCK:
          return "BROADCAST_MODE_BLOCK";
        case BroadcastMode.BROADCAST_MODE_SYNC:
          return "BROADCAST_MODE_SYNC";
        case BroadcastMode.BROADCAST_MODE_ASYNC:
          return "BROADCAST_MODE_ASYNC";
        case BroadcastMode.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.broadcastModeToJSON = broadcastModeToJSON;
    function createBaseGetTxsEventRequest() {
      return {
        events: [],
        pagination: void 0,
        orderBy: 0,
        page: BigInt(0),
        limit: BigInt(0),
        query: ""
      };
    }
    exports.GetTxsEventRequest = {
      typeUrl: "/cosmos.tx.v1beta1.GetTxsEventRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.events) {
          writer.uint32(10).string(v9);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        if (message.orderBy !== 0) {
          writer.uint32(24).int32(message.orderBy);
        }
        if (message.page !== BigInt(0)) {
          writer.uint32(32).uint64(message.page);
        }
        if (message.limit !== BigInt(0)) {
          writer.uint32(40).uint64(message.limit);
        }
        if (message.query !== "") {
          writer.uint32(50).string(message.query);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetTxsEventRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.events.push(reader.string());
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            case 3:
              message.orderBy = reader.int32();
              break;
            case 4:
              message.page = reader.uint64();
              break;
            case 5:
              message.limit = reader.uint64();
              break;
            case 6:
              message.query = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGetTxsEventRequest();
        if (Array.isArray(object?.events))
          obj.events = object.events.map((e) => String(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        if ((0, helpers_1.isSet)(object.orderBy))
          obj.orderBy = orderByFromJSON(object.orderBy);
        if ((0, helpers_1.isSet)(object.page))
          obj.page = BigInt(object.page.toString());
        if ((0, helpers_1.isSet)(object.limit))
          obj.limit = BigInt(object.limit.toString());
        if ((0, helpers_1.isSet)(object.query))
          obj.query = String(object.query);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.events) {
          obj.events = message.events.map((e) => e);
        } else {
          obj.events = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        message.orderBy !== void 0 && (obj.orderBy = orderByToJSON(message.orderBy));
        message.page !== void 0 && (obj.page = (message.page || BigInt(0)).toString());
        message.limit !== void 0 && (obj.limit = (message.limit || BigInt(0)).toString());
        message.query !== void 0 && (obj.query = message.query);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGetTxsEventRequest();
        message.events = object.events?.map((e) => e) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        message.orderBy = object.orderBy ?? 0;
        if (object.page !== void 0 && object.page !== null) {
          message.page = BigInt(object.page.toString());
        }
        if (object.limit !== void 0 && object.limit !== null) {
          message.limit = BigInt(object.limit.toString());
        }
        message.query = object.query ?? "";
        return message;
      }
    };
    function createBaseGetTxsEventResponse() {
      return {
        txs: [],
        txResponses: [],
        pagination: void 0,
        total: BigInt(0)
      };
    }
    exports.GetTxsEventResponse = {
      typeUrl: "/cosmos.tx.v1beta1.GetTxsEventResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.txs) {
          tx_1.Tx.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        for (const v9 of message.txResponses) {
          abci_1.TxResponse.encode(v9, writer.uint32(18).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(26).fork()).ldelim();
        }
        if (message.total !== BigInt(0)) {
          writer.uint32(32).uint64(message.total);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetTxsEventResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txs.push(tx_1.Tx.decode(reader, reader.uint32()));
              break;
            case 2:
              message.txResponses.push(abci_1.TxResponse.decode(reader, reader.uint32()));
              break;
            case 3:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            case 4:
              message.total = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGetTxsEventResponse();
        if (Array.isArray(object?.txs))
          obj.txs = object.txs.map((e) => tx_1.Tx.fromJSON(e));
        if (Array.isArray(object?.txResponses))
          obj.txResponses = object.txResponses.map((e) => abci_1.TxResponse.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        if ((0, helpers_1.isSet)(object.total))
          obj.total = BigInt(object.total.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.txs) {
          obj.txs = message.txs.map((e) => e ? tx_1.Tx.toJSON(e) : void 0);
        } else {
          obj.txs = [];
        }
        if (message.txResponses) {
          obj.txResponses = message.txResponses.map((e) => e ? abci_1.TxResponse.toJSON(e) : void 0);
        } else {
          obj.txResponses = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        message.total !== void 0 && (obj.total = (message.total || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGetTxsEventResponse();
        message.txs = object.txs?.map((e) => tx_1.Tx.fromPartial(e)) || [];
        message.txResponses = object.txResponses?.map((e) => abci_1.TxResponse.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        if (object.total !== void 0 && object.total !== null) {
          message.total = BigInt(object.total.toString());
        }
        return message;
      }
    };
    function createBaseBroadcastTxRequest() {
      return {
        txBytes: new Uint8Array(),
        mode: 0
      };
    }
    exports.BroadcastTxRequest = {
      typeUrl: "/cosmos.tx.v1beta1.BroadcastTxRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.txBytes.length !== 0) {
          writer.uint32(10).bytes(message.txBytes);
        }
        if (message.mode !== 0) {
          writer.uint32(16).int32(message.mode);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBroadcastTxRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txBytes = reader.bytes();
              break;
            case 2:
              message.mode = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBroadcastTxRequest();
        if ((0, helpers_1.isSet)(object.txBytes))
          obj.txBytes = (0, helpers_1.bytesFromBase64)(object.txBytes);
        if ((0, helpers_1.isSet)(object.mode))
          obj.mode = broadcastModeFromJSON(object.mode);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.txBytes !== void 0 && (obj.txBytes = (0, helpers_1.base64FromBytes)(message.txBytes !== void 0 ? message.txBytes : new Uint8Array()));
        message.mode !== void 0 && (obj.mode = broadcastModeToJSON(message.mode));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBroadcastTxRequest();
        message.txBytes = object.txBytes ?? new Uint8Array();
        message.mode = object.mode ?? 0;
        return message;
      }
    };
    function createBaseBroadcastTxResponse() {
      return {
        txResponse: void 0
      };
    }
    exports.BroadcastTxResponse = {
      typeUrl: "/cosmos.tx.v1beta1.BroadcastTxResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.txResponse !== void 0) {
          abci_1.TxResponse.encode(message.txResponse, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBroadcastTxResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txResponse = abci_1.TxResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseBroadcastTxResponse();
        if ((0, helpers_1.isSet)(object.txResponse))
          obj.txResponse = abci_1.TxResponse.fromJSON(object.txResponse);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.txResponse !== void 0 && (obj.txResponse = message.txResponse ? abci_1.TxResponse.toJSON(message.txResponse) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseBroadcastTxResponse();
        if (object.txResponse !== void 0 && object.txResponse !== null) {
          message.txResponse = abci_1.TxResponse.fromPartial(object.txResponse);
        }
        return message;
      }
    };
    function createBaseSimulateRequest() {
      return {
        tx: void 0,
        txBytes: new Uint8Array()
      };
    }
    exports.SimulateRequest = {
      typeUrl: "/cosmos.tx.v1beta1.SimulateRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.tx !== void 0) {
          tx_1.Tx.encode(message.tx, writer.uint32(10).fork()).ldelim();
        }
        if (message.txBytes.length !== 0) {
          writer.uint32(18).bytes(message.txBytes);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSimulateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.tx = tx_1.Tx.decode(reader, reader.uint32());
              break;
            case 2:
              message.txBytes = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSimulateRequest();
        if ((0, helpers_1.isSet)(object.tx))
          obj.tx = tx_1.Tx.fromJSON(object.tx);
        if ((0, helpers_1.isSet)(object.txBytes))
          obj.txBytes = (0, helpers_1.bytesFromBase64)(object.txBytes);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.tx !== void 0 && (obj.tx = message.tx ? tx_1.Tx.toJSON(message.tx) : void 0);
        message.txBytes !== void 0 && (obj.txBytes = (0, helpers_1.base64FromBytes)(message.txBytes !== void 0 ? message.txBytes : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSimulateRequest();
        if (object.tx !== void 0 && object.tx !== null) {
          message.tx = tx_1.Tx.fromPartial(object.tx);
        }
        message.txBytes = object.txBytes ?? new Uint8Array();
        return message;
      }
    };
    function createBaseSimulateResponse() {
      return {
        gasInfo: void 0,
        result: void 0
      };
    }
    exports.SimulateResponse = {
      typeUrl: "/cosmos.tx.v1beta1.SimulateResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.gasInfo !== void 0) {
          abci_1.GasInfo.encode(message.gasInfo, writer.uint32(10).fork()).ldelim();
        }
        if (message.result !== void 0) {
          abci_1.Result.encode(message.result, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSimulateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.gasInfo = abci_1.GasInfo.decode(reader, reader.uint32());
              break;
            case 2:
              message.result = abci_1.Result.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseSimulateResponse();
        if ((0, helpers_1.isSet)(object.gasInfo))
          obj.gasInfo = abci_1.GasInfo.fromJSON(object.gasInfo);
        if ((0, helpers_1.isSet)(object.result))
          obj.result = abci_1.Result.fromJSON(object.result);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.gasInfo !== void 0 && (obj.gasInfo = message.gasInfo ? abci_1.GasInfo.toJSON(message.gasInfo) : void 0);
        message.result !== void 0 && (obj.result = message.result ? abci_1.Result.toJSON(message.result) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseSimulateResponse();
        if (object.gasInfo !== void 0 && object.gasInfo !== null) {
          message.gasInfo = abci_1.GasInfo.fromPartial(object.gasInfo);
        }
        if (object.result !== void 0 && object.result !== null) {
          message.result = abci_1.Result.fromPartial(object.result);
        }
        return message;
      }
    };
    function createBaseGetTxRequest() {
      return {
        hash: ""
      };
    }
    exports.GetTxRequest = {
      typeUrl: "/cosmos.tx.v1beta1.GetTxRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.hash !== "") {
          writer.uint32(10).string(message.hash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetTxRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.hash = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGetTxRequest();
        if ((0, helpers_1.isSet)(object.hash))
          obj.hash = String(object.hash);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.hash !== void 0 && (obj.hash = message.hash);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGetTxRequest();
        message.hash = object.hash ?? "";
        return message;
      }
    };
    function createBaseGetTxResponse() {
      return {
        tx: void 0,
        txResponse: void 0
      };
    }
    exports.GetTxResponse = {
      typeUrl: "/cosmos.tx.v1beta1.GetTxResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.tx !== void 0) {
          tx_1.Tx.encode(message.tx, writer.uint32(10).fork()).ldelim();
        }
        if (message.txResponse !== void 0) {
          abci_1.TxResponse.encode(message.txResponse, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetTxResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.tx = tx_1.Tx.decode(reader, reader.uint32());
              break;
            case 2:
              message.txResponse = abci_1.TxResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGetTxResponse();
        if ((0, helpers_1.isSet)(object.tx))
          obj.tx = tx_1.Tx.fromJSON(object.tx);
        if ((0, helpers_1.isSet)(object.txResponse))
          obj.txResponse = abci_1.TxResponse.fromJSON(object.txResponse);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.tx !== void 0 && (obj.tx = message.tx ? tx_1.Tx.toJSON(message.tx) : void 0);
        message.txResponse !== void 0 && (obj.txResponse = message.txResponse ? abci_1.TxResponse.toJSON(message.txResponse) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGetTxResponse();
        if (object.tx !== void 0 && object.tx !== null) {
          message.tx = tx_1.Tx.fromPartial(object.tx);
        }
        if (object.txResponse !== void 0 && object.txResponse !== null) {
          message.txResponse = abci_1.TxResponse.fromPartial(object.txResponse);
        }
        return message;
      }
    };
    function createBaseGetBlockWithTxsRequest() {
      return {
        height: BigInt(0),
        pagination: void 0
      };
    }
    exports.GetBlockWithTxsRequest = {
      typeUrl: "/cosmos.tx.v1beta1.GetBlockWithTxsRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.height !== BigInt(0)) {
          writer.uint32(8).int64(message.height);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetBlockWithTxsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.height = reader.int64();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGetBlockWithTxsRequest();
        if ((0, helpers_1.isSet)(object.height))
          obj.height = BigInt(object.height.toString());
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.height !== void 0 && (obj.height = (message.height || BigInt(0)).toString());
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGetBlockWithTxsRequest();
        if (object.height !== void 0 && object.height !== null) {
          message.height = BigInt(object.height.toString());
        }
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseGetBlockWithTxsResponse() {
      return {
        txs: [],
        blockId: void 0,
        block: void 0,
        pagination: void 0
      };
    }
    exports.GetBlockWithTxsResponse = {
      typeUrl: "/cosmos.tx.v1beta1.GetBlockWithTxsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.txs) {
          tx_1.Tx.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.blockId !== void 0) {
          types_1.BlockID.encode(message.blockId, writer.uint32(18).fork()).ldelim();
        }
        if (message.block !== void 0) {
          block_1.Block.encode(message.block, writer.uint32(26).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGetBlockWithTxsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txs.push(tx_1.Tx.decode(reader, reader.uint32()));
              break;
            case 2:
              message.blockId = types_1.BlockID.decode(reader, reader.uint32());
              break;
            case 3:
              message.block = block_1.Block.decode(reader, reader.uint32());
              break;
            case 4:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseGetBlockWithTxsResponse();
        if (Array.isArray(object?.txs))
          obj.txs = object.txs.map((e) => tx_1.Tx.fromJSON(e));
        if ((0, helpers_1.isSet)(object.blockId))
          obj.blockId = types_1.BlockID.fromJSON(object.blockId);
        if ((0, helpers_1.isSet)(object.block))
          obj.block = block_1.Block.fromJSON(object.block);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.txs) {
          obj.txs = message.txs.map((e) => e ? tx_1.Tx.toJSON(e) : void 0);
        } else {
          obj.txs = [];
        }
        message.blockId !== void 0 && (obj.blockId = message.blockId ? types_1.BlockID.toJSON(message.blockId) : void 0);
        message.block !== void 0 && (obj.block = message.block ? block_1.Block.toJSON(message.block) : void 0);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseGetBlockWithTxsResponse();
        message.txs = object.txs?.map((e) => tx_1.Tx.fromPartial(e)) || [];
        if (object.blockId !== void 0 && object.blockId !== null) {
          message.blockId = types_1.BlockID.fromPartial(object.blockId);
        }
        if (object.block !== void 0 && object.block !== null) {
          message.block = block_1.Block.fromPartial(object.block);
        }
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseTxDecodeRequest() {
      return {
        txBytes: new Uint8Array()
      };
    }
    exports.TxDecodeRequest = {
      typeUrl: "/cosmos.tx.v1beta1.TxDecodeRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.txBytes.length !== 0) {
          writer.uint32(10).bytes(message.txBytes);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxDecodeRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txBytes = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxDecodeRequest();
        if ((0, helpers_1.isSet)(object.txBytes))
          obj.txBytes = (0, helpers_1.bytesFromBase64)(object.txBytes);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.txBytes !== void 0 && (obj.txBytes = (0, helpers_1.base64FromBytes)(message.txBytes !== void 0 ? message.txBytes : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxDecodeRequest();
        message.txBytes = object.txBytes ?? new Uint8Array();
        return message;
      }
    };
    function createBaseTxDecodeResponse() {
      return {
        tx: void 0
      };
    }
    exports.TxDecodeResponse = {
      typeUrl: "/cosmos.tx.v1beta1.TxDecodeResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.tx !== void 0) {
          tx_1.Tx.encode(message.tx, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxDecodeResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.tx = tx_1.Tx.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxDecodeResponse();
        if ((0, helpers_1.isSet)(object.tx))
          obj.tx = tx_1.Tx.fromJSON(object.tx);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.tx !== void 0 && (obj.tx = message.tx ? tx_1.Tx.toJSON(message.tx) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxDecodeResponse();
        if (object.tx !== void 0 && object.tx !== null) {
          message.tx = tx_1.Tx.fromPartial(object.tx);
        }
        return message;
      }
    };
    function createBaseTxEncodeRequest() {
      return {
        tx: void 0
      };
    }
    exports.TxEncodeRequest = {
      typeUrl: "/cosmos.tx.v1beta1.TxEncodeRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.tx !== void 0) {
          tx_1.Tx.encode(message.tx, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxEncodeRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.tx = tx_1.Tx.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxEncodeRequest();
        if ((0, helpers_1.isSet)(object.tx))
          obj.tx = tx_1.Tx.fromJSON(object.tx);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.tx !== void 0 && (obj.tx = message.tx ? tx_1.Tx.toJSON(message.tx) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxEncodeRequest();
        if (object.tx !== void 0 && object.tx !== null) {
          message.tx = tx_1.Tx.fromPartial(object.tx);
        }
        return message;
      }
    };
    function createBaseTxEncodeResponse() {
      return {
        txBytes: new Uint8Array()
      };
    }
    exports.TxEncodeResponse = {
      typeUrl: "/cosmos.tx.v1beta1.TxEncodeResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.txBytes.length !== 0) {
          writer.uint32(10).bytes(message.txBytes);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxEncodeResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.txBytes = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxEncodeResponse();
        if ((0, helpers_1.isSet)(object.txBytes))
          obj.txBytes = (0, helpers_1.bytesFromBase64)(object.txBytes);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.txBytes !== void 0 && (obj.txBytes = (0, helpers_1.base64FromBytes)(message.txBytes !== void 0 ? message.txBytes : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxEncodeResponse();
        message.txBytes = object.txBytes ?? new Uint8Array();
        return message;
      }
    };
    function createBaseTxEncodeAminoRequest() {
      return {
        aminoJson: ""
      };
    }
    exports.TxEncodeAminoRequest = {
      typeUrl: "/cosmos.tx.v1beta1.TxEncodeAminoRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.aminoJson !== "") {
          writer.uint32(10).string(message.aminoJson);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxEncodeAminoRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.aminoJson = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxEncodeAminoRequest();
        if ((0, helpers_1.isSet)(object.aminoJson))
          obj.aminoJson = String(object.aminoJson);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.aminoJson !== void 0 && (obj.aminoJson = message.aminoJson);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxEncodeAminoRequest();
        message.aminoJson = object.aminoJson ?? "";
        return message;
      }
    };
    function createBaseTxEncodeAminoResponse() {
      return {
        aminoBinary: new Uint8Array()
      };
    }
    exports.TxEncodeAminoResponse = {
      typeUrl: "/cosmos.tx.v1beta1.TxEncodeAminoResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.aminoBinary.length !== 0) {
          writer.uint32(10).bytes(message.aminoBinary);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxEncodeAminoResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.aminoBinary = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxEncodeAminoResponse();
        if ((0, helpers_1.isSet)(object.aminoBinary))
          obj.aminoBinary = (0, helpers_1.bytesFromBase64)(object.aminoBinary);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.aminoBinary !== void 0 && (obj.aminoBinary = (0, helpers_1.base64FromBytes)(message.aminoBinary !== void 0 ? message.aminoBinary : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxEncodeAminoResponse();
        message.aminoBinary = object.aminoBinary ?? new Uint8Array();
        return message;
      }
    };
    function createBaseTxDecodeAminoRequest() {
      return {
        aminoBinary: new Uint8Array()
      };
    }
    exports.TxDecodeAminoRequest = {
      typeUrl: "/cosmos.tx.v1beta1.TxDecodeAminoRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.aminoBinary.length !== 0) {
          writer.uint32(10).bytes(message.aminoBinary);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxDecodeAminoRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.aminoBinary = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxDecodeAminoRequest();
        if ((0, helpers_1.isSet)(object.aminoBinary))
          obj.aminoBinary = (0, helpers_1.bytesFromBase64)(object.aminoBinary);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.aminoBinary !== void 0 && (obj.aminoBinary = (0, helpers_1.base64FromBytes)(message.aminoBinary !== void 0 ? message.aminoBinary : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxDecodeAminoRequest();
        message.aminoBinary = object.aminoBinary ?? new Uint8Array();
        return message;
      }
    };
    function createBaseTxDecodeAminoResponse() {
      return {
        aminoJson: ""
      };
    }
    exports.TxDecodeAminoResponse = {
      typeUrl: "/cosmos.tx.v1beta1.TxDecodeAminoResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.aminoJson !== "") {
          writer.uint32(10).string(message.aminoJson);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTxDecodeAminoResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.aminoJson = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseTxDecodeAminoResponse();
        if ((0, helpers_1.isSet)(object.aminoJson))
          obj.aminoJson = String(object.aminoJson);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.aminoJson !== void 0 && (obj.aminoJson = message.aminoJson);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseTxDecodeAminoResponse();
        message.aminoJson = object.aminoJson ?? "";
        return message;
      }
    };
    var ServiceClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.Simulate = this.Simulate.bind(this);
        this.GetTx = this.GetTx.bind(this);
        this.BroadcastTx = this.BroadcastTx.bind(this);
        this.GetTxsEvent = this.GetTxsEvent.bind(this);
        this.GetBlockWithTxs = this.GetBlockWithTxs.bind(this);
        this.TxDecode = this.TxDecode.bind(this);
        this.TxEncode = this.TxEncode.bind(this);
        this.TxEncodeAmino = this.TxEncodeAmino.bind(this);
        this.TxDecodeAmino = this.TxDecodeAmino.bind(this);
      }
      Simulate(request) {
        const data2 = exports.SimulateRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "Simulate", data2);
        return promise.then((data3) => exports.SimulateResponse.decode(new binary_1.BinaryReader(data3)));
      }
      GetTx(request) {
        const data2 = exports.GetTxRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "GetTx", data2);
        return promise.then((data3) => exports.GetTxResponse.decode(new binary_1.BinaryReader(data3)));
      }
      BroadcastTx(request) {
        const data2 = exports.BroadcastTxRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "BroadcastTx", data2);
        return promise.then((data3) => exports.BroadcastTxResponse.decode(new binary_1.BinaryReader(data3)));
      }
      GetTxsEvent(request) {
        const data2 = exports.GetTxsEventRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "GetTxsEvent", data2);
        return promise.then((data3) => exports.GetTxsEventResponse.decode(new binary_1.BinaryReader(data3)));
      }
      GetBlockWithTxs(request) {
        const data2 = exports.GetBlockWithTxsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "GetBlockWithTxs", data2);
        return promise.then((data3) => exports.GetBlockWithTxsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      TxDecode(request) {
        const data2 = exports.TxDecodeRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "TxDecode", data2);
        return promise.then((data3) => exports.TxDecodeResponse.decode(new binary_1.BinaryReader(data3)));
      }
      TxEncode(request) {
        const data2 = exports.TxEncodeRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "TxEncode", data2);
        return promise.then((data3) => exports.TxEncodeResponse.decode(new binary_1.BinaryReader(data3)));
      }
      TxEncodeAmino(request) {
        const data2 = exports.TxEncodeAminoRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "TxEncodeAmino", data2);
        return promise.then((data3) => exports.TxEncodeAminoResponse.decode(new binary_1.BinaryReader(data3)));
      }
      TxDecodeAmino(request) {
        const data2 = exports.TxDecodeAminoRequest.encode(request).finish();
        const promise = this.rpc.request("cosmos.tx.v1beta1.Service", "TxDecodeAmino", data2);
        return promise.then((data3) => exports.TxDecodeAminoResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.ServiceClientImpl = ServiceClientImpl;
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/tx/queries.js
var require_queries11 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/tx/queries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupTxExtension = setupTxExtension;
    var proto_signing_1 = require_build6();
    var signing_1 = require_signing();
    var service_1 = require_service();
    var tx_1 = require_tx();
    var queryclient_1 = require_queryclient2();
    function setupTxExtension(base) {
      const rpc = (0, queryclient_1.createProtobufRpcClient)(base);
      const queryService = new service_1.ServiceClientImpl(rpc);
      return {
        tx: {
          getTx: async (txId) => {
            const request = {
              hash: txId
            };
            const response = await queryService.GetTx(request);
            return response;
          },
          simulate: async (messages, memo, signer, sequence) => {
            const tx = tx_1.Tx.fromPartial({
              authInfo: tx_1.AuthInfo.fromPartial({
                fee: tx_1.Fee.fromPartial({}),
                signerInfos: [
                  {
                    publicKey: (0, proto_signing_1.encodePubkey)(signer),
                    sequence: BigInt(sequence),
                    modeInfo: { single: { mode: signing_1.SignMode.SIGN_MODE_UNSPECIFIED } }
                  }
                ]
              }),
              body: tx_1.TxBody.fromPartial({
                messages: Array.from(messages),
                memo
              }),
              signatures: [new Uint8Array()]
            });
            const request = service_1.SimulateRequest.fromPartial({
              txBytes: tx_1.Tx.encode(tx).finish()
            });
            const response = await queryService.Simulate(request);
            return response;
          }
        }
      };
    }
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/vesting/aminomessages.js
var require_aminomessages12 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/vesting/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAminoMsgCreateVestingAccount = isAminoMsgCreateVestingAccount;
    exports.createVestingAminoConverters = createVestingAminoConverters;
    function isAminoMsgCreateVestingAccount(msg) {
      return msg.type === "cosmos-sdk/MsgCreateVestingAccount";
    }
    function createVestingAminoConverters() {
      return {
        "/cosmos.vesting.v1beta1.MsgCreateVestingAccount": {
          aminoType: "cosmos-sdk/MsgCreateVestingAccount",
          toAmino: ({ fromAddress, toAddress, amount, endTime, delayed }) => ({
            from_address: fromAddress,
            to_address: toAddress,
            amount: [...amount],
            end_time: endTime.toString(),
            delayed
          }),
          fromAmino: ({ from_address, to_address, amount, end_time, delayed }) => ({
            fromAddress: from_address,
            toAddress: to_address,
            amount: [...amount],
            endTime: BigInt(end_time),
            delayed
          })
        }
      };
    }
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/vesting/v1beta1/tx.js
var require_tx14 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmos/vesting/v1beta1/tx.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MsgClientImpl = exports.MsgCreatePeriodicVestingAccountResponse = exports.MsgCreatePeriodicVestingAccount = exports.MsgCreatePermanentLockedAccountResponse = exports.MsgCreatePermanentLockedAccount = exports.MsgCreateVestingAccountResponse = exports.MsgCreateVestingAccount = exports.protobufPackage = void 0;
    var coin_1 = require_coin();
    var vesting_1 = require_vesting();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmos.vesting.v1beta1";
    function createBaseMsgCreateVestingAccount() {
      return {
        fromAddress: "",
        toAddress: "",
        amount: [],
        endTime: BigInt(0),
        delayed: false
      };
    }
    exports.MsgCreateVestingAccount = {
      typeUrl: "/cosmos.vesting.v1beta1.MsgCreateVestingAccount",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.fromAddress !== "") {
          writer.uint32(10).string(message.fromAddress);
        }
        if (message.toAddress !== "") {
          writer.uint32(18).string(message.toAddress);
        }
        for (const v9 of message.amount) {
          coin_1.Coin.encode(v9, writer.uint32(26).fork()).ldelim();
        }
        if (message.endTime !== BigInt(0)) {
          writer.uint32(32).int64(message.endTime);
        }
        if (message.delayed === true) {
          writer.uint32(40).bool(message.delayed);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateVestingAccount();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.fromAddress = reader.string();
              break;
            case 2:
              message.toAddress = reader.string();
              break;
            case 3:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 4:
              message.endTime = reader.int64();
              break;
            case 5:
              message.delayed = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCreateVestingAccount();
        if ((0, helpers_1.isSet)(object.fromAddress))
          obj.fromAddress = String(object.fromAddress);
        if ((0, helpers_1.isSet)(object.toAddress))
          obj.toAddress = String(object.toAddress);
        if (Array.isArray(object?.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.endTime))
          obj.endTime = BigInt(object.endTime.toString());
        if ((0, helpers_1.isSet)(object.delayed))
          obj.delayed = Boolean(object.delayed);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.fromAddress !== void 0 && (obj.fromAddress = message.fromAddress);
        message.toAddress !== void 0 && (obj.toAddress = message.toAddress);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        message.endTime !== void 0 && (obj.endTime = (message.endTime || BigInt(0)).toString());
        message.delayed !== void 0 && (obj.delayed = message.delayed);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgCreateVestingAccount();
        message.fromAddress = object.fromAddress ?? "";
        message.toAddress = object.toAddress ?? "";
        message.amount = object.amount?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        if (object.endTime !== void 0 && object.endTime !== null) {
          message.endTime = BigInt(object.endTime.toString());
        }
        message.delayed = object.delayed ?? false;
        return message;
      }
    };
    function createBaseMsgCreateVestingAccountResponse() {
      return {};
    }
    exports.MsgCreateVestingAccountResponse = {
      typeUrl: "/cosmos.vesting.v1beta1.MsgCreateVestingAccountResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateVestingAccountResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgCreateVestingAccountResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgCreateVestingAccountResponse();
        return message;
      }
    };
    function createBaseMsgCreatePermanentLockedAccount() {
      return {
        fromAddress: "",
        toAddress: "",
        amount: []
      };
    }
    exports.MsgCreatePermanentLockedAccount = {
      typeUrl: "/cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccount",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.fromAddress !== "") {
          writer.uint32(10).string(message.fromAddress);
        }
        if (message.toAddress !== "") {
          writer.uint32(18).string(message.toAddress);
        }
        for (const v9 of message.amount) {
          coin_1.Coin.encode(v9, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreatePermanentLockedAccount();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.fromAddress = reader.string();
              break;
            case 2:
              message.toAddress = reader.string();
              break;
            case 3:
              message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCreatePermanentLockedAccount();
        if ((0, helpers_1.isSet)(object.fromAddress))
          obj.fromAddress = String(object.fromAddress);
        if ((0, helpers_1.isSet)(object.toAddress))
          obj.toAddress = String(object.toAddress);
        if (Array.isArray(object?.amount))
          obj.amount = object.amount.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.fromAddress !== void 0 && (obj.fromAddress = message.fromAddress);
        message.toAddress !== void 0 && (obj.toAddress = message.toAddress);
        if (message.amount) {
          obj.amount = message.amount.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.amount = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgCreatePermanentLockedAccount();
        message.fromAddress = object.fromAddress ?? "";
        message.toAddress = object.toAddress ?? "";
        message.amount = object.amount?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseMsgCreatePermanentLockedAccountResponse() {
      return {};
    }
    exports.MsgCreatePermanentLockedAccountResponse = {
      typeUrl: "/cosmos.vesting.v1beta1.MsgCreatePermanentLockedAccountResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreatePermanentLockedAccountResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgCreatePermanentLockedAccountResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgCreatePermanentLockedAccountResponse();
        return message;
      }
    };
    function createBaseMsgCreatePeriodicVestingAccount() {
      return {
        fromAddress: "",
        toAddress: "",
        startTime: BigInt(0),
        vestingPeriods: []
      };
    }
    exports.MsgCreatePeriodicVestingAccount = {
      typeUrl: "/cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccount",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.fromAddress !== "") {
          writer.uint32(10).string(message.fromAddress);
        }
        if (message.toAddress !== "") {
          writer.uint32(18).string(message.toAddress);
        }
        if (message.startTime !== BigInt(0)) {
          writer.uint32(24).int64(message.startTime);
        }
        for (const v9 of message.vestingPeriods) {
          vesting_1.Period.encode(v9, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreatePeriodicVestingAccount();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.fromAddress = reader.string();
              break;
            case 2:
              message.toAddress = reader.string();
              break;
            case 3:
              message.startTime = reader.int64();
              break;
            case 4:
              message.vestingPeriods.push(vesting_1.Period.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgCreatePeriodicVestingAccount();
        if ((0, helpers_1.isSet)(object.fromAddress))
          obj.fromAddress = String(object.fromAddress);
        if ((0, helpers_1.isSet)(object.toAddress))
          obj.toAddress = String(object.toAddress);
        if ((0, helpers_1.isSet)(object.startTime))
          obj.startTime = BigInt(object.startTime.toString());
        if (Array.isArray(object?.vestingPeriods))
          obj.vestingPeriods = object.vestingPeriods.map((e) => vesting_1.Period.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.fromAddress !== void 0 && (obj.fromAddress = message.fromAddress);
        message.toAddress !== void 0 && (obj.toAddress = message.toAddress);
        message.startTime !== void 0 && (obj.startTime = (message.startTime || BigInt(0)).toString());
        if (message.vestingPeriods) {
          obj.vestingPeriods = message.vestingPeriods.map((e) => e ? vesting_1.Period.toJSON(e) : void 0);
        } else {
          obj.vestingPeriods = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgCreatePeriodicVestingAccount();
        message.fromAddress = object.fromAddress ?? "";
        message.toAddress = object.toAddress ?? "";
        if (object.startTime !== void 0 && object.startTime !== null) {
          message.startTime = BigInt(object.startTime.toString());
        }
        message.vestingPeriods = object.vestingPeriods?.map((e) => vesting_1.Period.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseMsgCreatePeriodicVestingAccountResponse() {
      return {};
    }
    exports.MsgCreatePeriodicVestingAccountResponse = {
      typeUrl: "/cosmos.vesting.v1beta1.MsgCreatePeriodicVestingAccountResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgCreatePeriodicVestingAccountResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgCreatePeriodicVestingAccountResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgCreatePeriodicVestingAccountResponse();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.CreateVestingAccount = this.CreateVestingAccount.bind(this);
        this.CreatePermanentLockedAccount = this.CreatePermanentLockedAccount.bind(this);
        this.CreatePeriodicVestingAccount = this.CreatePeriodicVestingAccount.bind(this);
      }
      CreateVestingAccount(request) {
        const data2 = exports.MsgCreateVestingAccount.encode(request).finish();
        const promise = this.rpc.request("cosmos.vesting.v1beta1.Msg", "CreateVestingAccount", data2);
        return promise.then((data3) => exports.MsgCreateVestingAccountResponse.decode(new binary_1.BinaryReader(data3)));
      }
      CreatePermanentLockedAccount(request) {
        const data2 = exports.MsgCreatePermanentLockedAccount.encode(request).finish();
        const promise = this.rpc.request("cosmos.vesting.v1beta1.Msg", "CreatePermanentLockedAccount", data2);
        return promise.then((data3) => exports.MsgCreatePermanentLockedAccountResponse.decode(new binary_1.BinaryReader(data3)));
      }
      CreatePeriodicVestingAccount(request) {
        const data2 = exports.MsgCreatePeriodicVestingAccount.encode(request).finish();
        const promise = this.rpc.request("cosmos.vesting.v1beta1.Msg", "CreatePeriodicVestingAccount", data2);
        return promise.then((data3) => exports.MsgCreatePeriodicVestingAccountResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.MsgClientImpl = MsgClientImpl;
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/vesting/messages.js
var require_messages9 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/vesting/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.vestingTypes = void 0;
    var tx_1 = require_tx14();
    exports.vestingTypes = [
      ["/cosmos.vesting.v1beta1.MsgCreateVestingAccount", tx_1.MsgCreateVestingAccount]
    ];
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/index.js
var require_modules = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/modules/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAminoMsgCreateValidator = exports.isAminoMsgBeginRedelegate = exports.createStakingAminoConverters = exports.setupSlashingExtension = exports.isAminoMsgUnjail = exports.createSlashingAminoConverters = exports.setupMintExtension = exports.setupIbcExtension = exports.isMsgTransferEncodeObject = exports.ibcTypes = exports.isAminoMsgTransfer = exports.createIbcAminoConverters = exports.groupTypes = exports.createGroupAminoConverters = exports.setupGovExtension = exports.isMsgVoteWeightedEncodeObject = exports.isMsgVoteEncodeObject = exports.isMsgSubmitProposalEncodeObject = exports.isMsgDepositEncodeObject = exports.govTypes = exports.isAminoMsgVoteWeighted = exports.isAminoMsgVote = exports.isAminoMsgSubmitProposal = exports.isAminoMsgDeposit = exports.createGovAminoConverters = exports.setupFeegrantExtension = exports.feegrantTypes = exports.createFeegrantAminoConverters = exports.isAminoMsgSubmitEvidence = exports.createEvidenceAminoConverters = exports.setupDistributionExtension = exports.isMsgWithdrawDelegatorRewardEncodeObject = exports.distributionTypes = exports.isAminoMsgWithdrawValidatorCommission = exports.isAminoMsgWithdrawDelegatorReward = exports.isAminoMsgSetWithdrawAddress = exports.isAminoMsgFundCommunityPool = exports.createDistributionAminoConverters = exports.isAminoMsgVerifyInvariant = exports.createCrysisAminoConverters = exports.setupBankExtension = exports.isMsgSendEncodeObject = exports.bankTypes = exports.isAminoMsgSend = exports.isAminoMsgMultiSend = exports.createBankAminoConverters = exports.setupAuthzExtension = exports.authzTypes = exports.createAuthzAminoConverters = exports.setupAuthExtension = void 0;
    exports.vestingTypes = exports.isAminoMsgCreateVestingAccount = exports.createVestingAminoConverters = exports.setupTxExtension = exports.setupStakingExtension = exports.stakingTypes = exports.isMsgUndelegateEncodeObject = exports.isMsgEditValidatorEncodeObject = exports.isMsgDelegateEncodeObject = exports.isMsgCreateValidatorEncodeObject = exports.isMsgCancelUnbondingDelegationEncodeObject = exports.isMsgBeginRedelegateEncodeObject = exports.isAminoMsgUndelegate = exports.isAminoMsgEditValidator = exports.isAminoMsgDelegate = void 0;
    var queries_1 = require_queries();
    Object.defineProperty(exports, "setupAuthExtension", { enumerable: true, get: function() {
      return queries_1.setupAuthExtension;
    } });
    var aminomessages_1 = require_aminomessages();
    Object.defineProperty(exports, "createAuthzAminoConverters", { enumerable: true, get: function() {
      return aminomessages_1.createAuthzAminoConverters;
    } });
    var messages_1 = require_messages();
    Object.defineProperty(exports, "authzTypes", { enumerable: true, get: function() {
      return messages_1.authzTypes;
    } });
    var queries_2 = require_queries2();
    Object.defineProperty(exports, "setupAuthzExtension", { enumerable: true, get: function() {
      return queries_2.setupAuthzExtension;
    } });
    var aminomessages_2 = require_aminomessages2();
    Object.defineProperty(exports, "createBankAminoConverters", { enumerable: true, get: function() {
      return aminomessages_2.createBankAminoConverters;
    } });
    Object.defineProperty(exports, "isAminoMsgMultiSend", { enumerable: true, get: function() {
      return aminomessages_2.isAminoMsgMultiSend;
    } });
    Object.defineProperty(exports, "isAminoMsgSend", { enumerable: true, get: function() {
      return aminomessages_2.isAminoMsgSend;
    } });
    var messages_2 = require_messages2();
    Object.defineProperty(exports, "bankTypes", { enumerable: true, get: function() {
      return messages_2.bankTypes;
    } });
    Object.defineProperty(exports, "isMsgSendEncodeObject", { enumerable: true, get: function() {
      return messages_2.isMsgSendEncodeObject;
    } });
    var queries_3 = require_queries3();
    Object.defineProperty(exports, "setupBankExtension", { enumerable: true, get: function() {
      return queries_3.setupBankExtension;
    } });
    var aminomessages_3 = require_aminomessages3();
    Object.defineProperty(exports, "createCrysisAminoConverters", { enumerable: true, get: function() {
      return aminomessages_3.createCrysisAminoConverters;
    } });
    Object.defineProperty(exports, "isAminoMsgVerifyInvariant", { enumerable: true, get: function() {
      return aminomessages_3.isAminoMsgVerifyInvariant;
    } });
    var aminomessages_4 = require_aminomessages4();
    Object.defineProperty(exports, "createDistributionAminoConverters", { enumerable: true, get: function() {
      return aminomessages_4.createDistributionAminoConverters;
    } });
    Object.defineProperty(exports, "isAminoMsgFundCommunityPool", { enumerable: true, get: function() {
      return aminomessages_4.isAminoMsgFundCommunityPool;
    } });
    Object.defineProperty(exports, "isAminoMsgSetWithdrawAddress", { enumerable: true, get: function() {
      return aminomessages_4.isAminoMsgSetWithdrawAddress;
    } });
    Object.defineProperty(exports, "isAminoMsgWithdrawDelegatorReward", { enumerable: true, get: function() {
      return aminomessages_4.isAminoMsgWithdrawDelegatorReward;
    } });
    Object.defineProperty(exports, "isAminoMsgWithdrawValidatorCommission", { enumerable: true, get: function() {
      return aminomessages_4.isAminoMsgWithdrawValidatorCommission;
    } });
    var messages_3 = require_messages3();
    Object.defineProperty(exports, "distributionTypes", { enumerable: true, get: function() {
      return messages_3.distributionTypes;
    } });
    Object.defineProperty(exports, "isMsgWithdrawDelegatorRewardEncodeObject", { enumerable: true, get: function() {
      return messages_3.isMsgWithdrawDelegatorRewardEncodeObject;
    } });
    var queries_4 = require_queries4();
    Object.defineProperty(exports, "setupDistributionExtension", { enumerable: true, get: function() {
      return queries_4.setupDistributionExtension;
    } });
    var aminomessages_5 = require_aminomessages5();
    Object.defineProperty(exports, "createEvidenceAminoConverters", { enumerable: true, get: function() {
      return aminomessages_5.createEvidenceAminoConverters;
    } });
    Object.defineProperty(exports, "isAminoMsgSubmitEvidence", { enumerable: true, get: function() {
      return aminomessages_5.isAminoMsgSubmitEvidence;
    } });
    var aminomessages_6 = require_aminomessages6();
    Object.defineProperty(exports, "createFeegrantAminoConverters", { enumerable: true, get: function() {
      return aminomessages_6.createFeegrantAminoConverters;
    } });
    var messages_4 = require_messages4();
    Object.defineProperty(exports, "feegrantTypes", { enumerable: true, get: function() {
      return messages_4.feegrantTypes;
    } });
    var queries_5 = require_queries5();
    Object.defineProperty(exports, "setupFeegrantExtension", { enumerable: true, get: function() {
      return queries_5.setupFeegrantExtension;
    } });
    var aminomessages_7 = require_aminomessages7();
    Object.defineProperty(exports, "createGovAminoConverters", { enumerable: true, get: function() {
      return aminomessages_7.createGovAminoConverters;
    } });
    Object.defineProperty(exports, "isAminoMsgDeposit", { enumerable: true, get: function() {
      return aminomessages_7.isAminoMsgDeposit;
    } });
    Object.defineProperty(exports, "isAminoMsgSubmitProposal", { enumerable: true, get: function() {
      return aminomessages_7.isAminoMsgSubmitProposal;
    } });
    Object.defineProperty(exports, "isAminoMsgVote", { enumerable: true, get: function() {
      return aminomessages_7.isAminoMsgVote;
    } });
    Object.defineProperty(exports, "isAminoMsgVoteWeighted", { enumerable: true, get: function() {
      return aminomessages_7.isAminoMsgVoteWeighted;
    } });
    var messages_5 = require_messages5();
    Object.defineProperty(exports, "govTypes", { enumerable: true, get: function() {
      return messages_5.govTypes;
    } });
    Object.defineProperty(exports, "isMsgDepositEncodeObject", { enumerable: true, get: function() {
      return messages_5.isMsgDepositEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgSubmitProposalEncodeObject", { enumerable: true, get: function() {
      return messages_5.isMsgSubmitProposalEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgVoteEncodeObject", { enumerable: true, get: function() {
      return messages_5.isMsgVoteEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgVoteWeightedEncodeObject", { enumerable: true, get: function() {
      return messages_5.isMsgVoteWeightedEncodeObject;
    } });
    var queries_6 = require_queries6();
    Object.defineProperty(exports, "setupGovExtension", { enumerable: true, get: function() {
      return queries_6.setupGovExtension;
    } });
    var aminomessages_8 = require_aminomessages8();
    Object.defineProperty(exports, "createGroupAminoConverters", { enumerable: true, get: function() {
      return aminomessages_8.createGroupAminoConverters;
    } });
    var messages_6 = require_messages6();
    Object.defineProperty(exports, "groupTypes", { enumerable: true, get: function() {
      return messages_6.groupTypes;
    } });
    var aminomessages_9 = require_aminomessages9();
    Object.defineProperty(exports, "createIbcAminoConverters", { enumerable: true, get: function() {
      return aminomessages_9.createIbcAminoConverters;
    } });
    Object.defineProperty(exports, "isAminoMsgTransfer", { enumerable: true, get: function() {
      return aminomessages_9.isAminoMsgTransfer;
    } });
    var messages_7 = require_messages7();
    Object.defineProperty(exports, "ibcTypes", { enumerable: true, get: function() {
      return messages_7.ibcTypes;
    } });
    Object.defineProperty(exports, "isMsgTransferEncodeObject", { enumerable: true, get: function() {
      return messages_7.isMsgTransferEncodeObject;
    } });
    var queries_7 = require_queries7();
    Object.defineProperty(exports, "setupIbcExtension", { enumerable: true, get: function() {
      return queries_7.setupIbcExtension;
    } });
    var queries_8 = require_queries8();
    Object.defineProperty(exports, "setupMintExtension", { enumerable: true, get: function() {
      return queries_8.setupMintExtension;
    } });
    var aminomessages_10 = require_aminomessages10();
    Object.defineProperty(exports, "createSlashingAminoConverters", { enumerable: true, get: function() {
      return aminomessages_10.createSlashingAminoConverters;
    } });
    Object.defineProperty(exports, "isAminoMsgUnjail", { enumerable: true, get: function() {
      return aminomessages_10.isAminoMsgUnjail;
    } });
    var queries_9 = require_queries9();
    Object.defineProperty(exports, "setupSlashingExtension", { enumerable: true, get: function() {
      return queries_9.setupSlashingExtension;
    } });
    var aminomessages_11 = require_aminomessages11();
    Object.defineProperty(exports, "createStakingAminoConverters", { enumerable: true, get: function() {
      return aminomessages_11.createStakingAminoConverters;
    } });
    Object.defineProperty(exports, "isAminoMsgBeginRedelegate", { enumerable: true, get: function() {
      return aminomessages_11.isAminoMsgBeginRedelegate;
    } });
    Object.defineProperty(exports, "isAminoMsgCreateValidator", { enumerable: true, get: function() {
      return aminomessages_11.isAminoMsgCreateValidator;
    } });
    Object.defineProperty(exports, "isAminoMsgDelegate", { enumerable: true, get: function() {
      return aminomessages_11.isAminoMsgDelegate;
    } });
    Object.defineProperty(exports, "isAminoMsgEditValidator", { enumerable: true, get: function() {
      return aminomessages_11.isAminoMsgEditValidator;
    } });
    Object.defineProperty(exports, "isAminoMsgUndelegate", { enumerable: true, get: function() {
      return aminomessages_11.isAminoMsgUndelegate;
    } });
    var messages_8 = require_messages8();
    Object.defineProperty(exports, "isMsgBeginRedelegateEncodeObject", { enumerable: true, get: function() {
      return messages_8.isMsgBeginRedelegateEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgCancelUnbondingDelegationEncodeObject", { enumerable: true, get: function() {
      return messages_8.isMsgCancelUnbondingDelegationEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgCreateValidatorEncodeObject", { enumerable: true, get: function() {
      return messages_8.isMsgCreateValidatorEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgDelegateEncodeObject", { enumerable: true, get: function() {
      return messages_8.isMsgDelegateEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgEditValidatorEncodeObject", { enumerable: true, get: function() {
      return messages_8.isMsgEditValidatorEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgUndelegateEncodeObject", { enumerable: true, get: function() {
      return messages_8.isMsgUndelegateEncodeObject;
    } });
    Object.defineProperty(exports, "stakingTypes", { enumerable: true, get: function() {
      return messages_8.stakingTypes;
    } });
    var queries_10 = require_queries10();
    Object.defineProperty(exports, "setupStakingExtension", { enumerable: true, get: function() {
      return queries_10.setupStakingExtension;
    } });
    var queries_11 = require_queries11();
    Object.defineProperty(exports, "setupTxExtension", { enumerable: true, get: function() {
      return queries_11.setupTxExtension;
    } });
    var aminomessages_12 = require_aminomessages12();
    Object.defineProperty(exports, "createVestingAminoConverters", { enumerable: true, get: function() {
      return aminomessages_12.createVestingAminoConverters;
    } });
    Object.defineProperty(exports, "isAminoMsgCreateVestingAccount", { enumerable: true, get: function() {
      return aminomessages_12.isAminoMsgCreateVestingAccount;
    } });
    var messages_9 = require_messages9();
    Object.defineProperty(exports, "vestingTypes", { enumerable: true, get: function() {
      return messages_9.vestingTypes;
    } });
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/multisignature.js
var require_multisignature = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/multisignature.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.makeCompactBitArray = makeCompactBitArray;
    exports.makeMultisignedTx = makeMultisignedTx;
    exports.makeMultisignedTxBytes = makeMultisignedTxBytes;
    var amino_1 = require_build5();
    var encoding_1 = require_build2();
    var proto_signing_1 = require_build6();
    var multisig_1 = require_multisig2();
    var signing_1 = require_signing();
    var tx_1 = require_tx();
    function makeCompactBitArray(bits) {
      const byteCount = Math.ceil(bits.length / 8);
      const extraBits = bits.length - Math.floor(bits.length / 8) * 8;
      const bytes2 = new Uint8Array(byteCount);
      bits.forEach((value, index) => {
        const bytePos = Math.floor(index / 8);
        const bitPos = index % 8;
        if (value)
          bytes2[bytePos] |= 1 << 8 - 1 - bitPos;
      });
      return multisig_1.CompactBitArray.fromPartial({ elems: bytes2, extraBitsStored: extraBits });
    }
    function makeMultisignedTx(multisigPubkey, sequence, fee, bodyBytes, signatures) {
      const addresses = Array.from(signatures.keys());
      const prefix = (0, encoding_1.fromBech32)(addresses[0]).prefix;
      const signers = Array(multisigPubkey.value.pubkeys.length).fill(false);
      const signaturesList = new Array();
      for (let i3 = 0; i3 < multisigPubkey.value.pubkeys.length; i3++) {
        const signerAddress = (0, amino_1.pubkeyToAddress)(multisigPubkey.value.pubkeys[i3], prefix);
        const signature = signatures.get(signerAddress);
        if (signature) {
          signers[i3] = true;
          signaturesList.push(signature);
        }
      }
      const signerInfo = {
        publicKey: (0, proto_signing_1.encodePubkey)(multisigPubkey),
        modeInfo: {
          multi: {
            bitarray: makeCompactBitArray(signers),
            modeInfos: signaturesList.map((_2) => ({ single: { mode: signing_1.SignMode.SIGN_MODE_LEGACY_AMINO_JSON } }))
          }
        },
        sequence: BigInt(sequence)
      };
      const authInfo = tx_1.AuthInfo.fromPartial({
        signerInfos: [signerInfo],
        fee: {
          amount: [...fee.amount],
          gasLimit: BigInt(fee.gas)
        }
      });
      const authInfoBytes = tx_1.AuthInfo.encode(authInfo).finish();
      const signedTx = tx_1.TxRaw.fromPartial({
        bodyBytes,
        authInfoBytes,
        signatures: [multisig_1.MultiSignature.encode(multisig_1.MultiSignature.fromPartial({ signatures: signaturesList })).finish()]
      });
      return signedTx;
    }
    function makeMultisignedTxBytes(multisigPubkey, sequence, fee, bodyBytes, signatures) {
      const signedTx = makeMultisignedTx(multisigPubkey, sequence, fee, bodyBytes, signatures);
      return Uint8Array.from(tx_1.TxRaw.encode(signedTx).finish());
    }
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/search.js
var require_search = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/search.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isSearchTxQueryArray = isSearchTxQueryArray;
    function isSearchTxQueryArray(query) {
      return Array.isArray(query);
    }
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/addresses.js
var require_addresses2 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/addresses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rawEd25519PubkeyToRawAddress = rawEd25519PubkeyToRawAddress;
    exports.rawSecp256k1PubkeyToRawAddress = rawSecp256k1PubkeyToRawAddress2;
    exports.pubkeyToRawAddress = pubkeyToRawAddress;
    exports.pubkeyToAddress = pubkeyToAddress;
    var crypto_1 = require_build4();
    var encoding_1 = require_build2();
    function rawEd25519PubkeyToRawAddress(pubkeyData) {
      if (pubkeyData.length !== 32) {
        throw new Error(`Invalid Ed25519 pubkey length: ${pubkeyData.length}`);
      }
      return (0, crypto_1.sha256)(pubkeyData).slice(0, 20);
    }
    function rawSecp256k1PubkeyToRawAddress2(pubkeyData) {
      if (pubkeyData.length !== 33) {
        throw new Error(`Invalid Secp256k1 pubkey length (compressed): ${pubkeyData.length}`);
      }
      return (0, crypto_1.ripemd160)((0, crypto_1.sha256)(pubkeyData));
    }
    function pubkeyToRawAddress(type, data2) {
      switch (type) {
        case "ed25519":
          return rawEd25519PubkeyToRawAddress(data2);
        case "secp256k1":
          return rawSecp256k1PubkeyToRawAddress2(data2);
        default:
          throw new Error(`Pubkey type ${type} not supported`);
      }
    }
    function pubkeyToAddress(type, data2) {
      return (0, encoding_1.toHex)(pubkeyToRawAddress(type, data2)).toUpperCase();
    }
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/dates.js
var require_dates = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/dates.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DateTime = void 0;
    exports.fromRfc3339WithNanoseconds = fromRfc3339WithNanoseconds;
    exports.toRfc3339WithNanoseconds = toRfc3339WithNanoseconds;
    exports.fromSeconds = fromSeconds;
    exports.toSeconds = toSeconds;
    var encoding_1 = require_build2();
    var math_1 = require_build3();
    function fromRfc3339WithNanoseconds(dateTimeString) {
      const out = (0, encoding_1.fromRfc3339)(dateTimeString);
      const nanosecondsMatch = dateTimeString.match(/\.(\d+)Z$/);
      const nanoseconds = nanosecondsMatch ? nanosecondsMatch[1].slice(3) : "";
      out.nanoseconds = parseInt(nanoseconds.padEnd(6, "0"), 10);
      return out;
    }
    function toRfc3339WithNanoseconds(dateTime) {
      const millisecondIso = dateTime.toISOString();
      const nanoseconds = dateTime.nanoseconds?.toString() ?? "";
      return `${millisecondIso.slice(0, -1)}${nanoseconds.padStart(6, "0")}Z`;
    }
    function fromSeconds(seconds, nanos = 0) {
      const checkedNanos = new math_1.Uint32(nanos).toNumber();
      if (checkedNanos > 999999999) {
        throw new Error("Nano seconds must not exceed 999999999");
      }
      const out = new Date(seconds * 1e3 + Math.floor(checkedNanos / 1e6));
      out.nanoseconds = checkedNanos % 1e6;
      return out;
    }
    function toSeconds(date) {
      return {
        seconds: Math.floor(date.getTime() / 1e3),
        nanos: date.getTime() % 1e3 * 1e6 + (date.nanoseconds ?? 0)
      };
    }
    var DateTime = class {
      /** @deprecated Use fromRfc3339WithNanoseconds instead */
      static decode(dateTimeString) {
        return fromRfc3339WithNanoseconds(dateTimeString);
      }
      /** @deprecated Use toRfc3339WithNanoseconds instead */
      static encode(dateTime) {
        return toRfc3339WithNanoseconds(dateTime);
      }
    };
    exports.DateTime = DateTime;
  }
});

// node_modules/.pnpm/@cosmjs+json-rpc@0.37.0/node_modules/@cosmjs/json-rpc/build/id.js
var require_id = __commonJS({
  "node_modules/.pnpm/@cosmjs+json-rpc@0.37.0/node_modules/@cosmjs/json-rpc/build/id.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.makeJsonRpcId = makeJsonRpcId;
    var counter = 1e4;
    function makeJsonRpcId() {
      return counter += 1;
    }
  }
});

// node_modules/.pnpm/symbol-observable@2.0.3/node_modules/symbol-observable/lib/ponyfill.js
var require_ponyfill = __commonJS({
  "node_modules/.pnpm/symbol-observable@2.0.3/node_modules/symbol-observable/lib/ponyfill.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = symbolObservablePonyfill;
    function symbolObservablePonyfill(root) {
      var result;
      var _Symbol = root.Symbol;
      if (typeof _Symbol === "function") {
        if (_Symbol.observable) {
          result = _Symbol.observable;
        } else {
          result = _Symbol["for"]("https://github.com/benlesh/symbol-observable");
          try {
            _Symbol.observable = result;
          } catch (err) {
          }
        }
      } else {
        result = "@@observable";
      }
      return result;
    }
  }
});

// node_modules/.pnpm/symbol-observable@2.0.3/node_modules/symbol-observable/ponyfill.js
var require_ponyfill2 = __commonJS({
  "node_modules/.pnpm/symbol-observable@2.0.3/node_modules/symbol-observable/ponyfill.js"(exports, module) {
    module.exports = require_ponyfill();
  }
});

// node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/isArguments.js"(exports, module) {
    "use strict";
    var toStr = Object.prototype.toString;
    module.exports = function isArguments(value) {
      var str2 = toStr.call(value);
      var isArgs = str2 === "[object Arguments]";
      if (!isArgs) {
        isArgs = str2 !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
      }
      return isArgs;
    };
  }
});

// node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/implementation.js
var require_implementation = __commonJS({
  "node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/implementation.js"(exports, module) {
    "use strict";
    var keysShim;
    if (!Object.keys) {
      has = Object.prototype.hasOwnProperty;
      toStr = Object.prototype.toString;
      isArgs = require_isArguments();
      isEnumerable = Object.prototype.propertyIsEnumerable;
      hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
      hasProtoEnumBug = isEnumerable.call(function() {
      }, "prototype");
      dontEnums = [
        "toString",
        "toLocaleString",
        "valueOf",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "constructor"
      ];
      equalsConstructorPrototype = function(o3) {
        var ctor = o3.constructor;
        return ctor && ctor.prototype === o3;
      };
      excludedKeys = {
        $applicationCache: true,
        $console: true,
        $external: true,
        $frame: true,
        $frameElement: true,
        $frames: true,
        $innerHeight: true,
        $innerWidth: true,
        $onmozfullscreenchange: true,
        $onmozfullscreenerror: true,
        $outerHeight: true,
        $outerWidth: true,
        $pageXOffset: true,
        $pageYOffset: true,
        $parent: true,
        $scrollLeft: true,
        $scrollTop: true,
        $scrollX: true,
        $scrollY: true,
        $self: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $window: true
      };
      hasAutomationEqualityBug = (function() {
        if (typeof window === "undefined") {
          return false;
        }
        for (var k5 in window) {
          try {
            if (!excludedKeys["$" + k5] && has.call(window, k5) && window[k5] !== null && typeof window[k5] === "object") {
              try {
                equalsConstructorPrototype(window[k5]);
              } catch (e) {
                return true;
              }
            }
          } catch (e) {
            return true;
          }
        }
        return false;
      })();
      equalsConstructorPrototypeIfNotBuggy = function(o3) {
        if (typeof window === "undefined" || !hasAutomationEqualityBug) {
          return equalsConstructorPrototype(o3);
        }
        try {
          return equalsConstructorPrototype(o3);
        } catch (e) {
          return false;
        }
      };
      keysShim = function keys(object) {
        var isObject = object !== null && typeof object === "object";
        var isFunction = toStr.call(object) === "[object Function]";
        var isArguments = isArgs(object);
        var isString = isObject && toStr.call(object) === "[object String]";
        var theKeys = [];
        if (!isObject && !isFunction && !isArguments) {
          throw new TypeError("Object.keys called on a non-object");
        }
        var skipProto = hasProtoEnumBug && isFunction;
        if (isString && object.length > 0 && !has.call(object, 0)) {
          for (var i3 = 0; i3 < object.length; ++i3) {
            theKeys.push(String(i3));
          }
        }
        if (isArguments && object.length > 0) {
          for (var j3 = 0; j3 < object.length; ++j3) {
            theKeys.push(String(j3));
          }
        } else {
          for (var name2 in object) {
            if (!(skipProto && name2 === "prototype") && has.call(object, name2)) {
              theKeys.push(String(name2));
            }
          }
        }
        if (hasDontEnumBug) {
          var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
          for (var k5 = 0; k5 < dontEnums.length; ++k5) {
            if (!(skipConstructor && dontEnums[k5] === "constructor") && has.call(object, dontEnums[k5])) {
              theKeys.push(dontEnums[k5]);
            }
          }
        }
        return theKeys;
      };
    }
    var has;
    var toStr;
    var isArgs;
    var isEnumerable;
    var hasDontEnumBug;
    var hasProtoEnumBug;
    var dontEnums;
    var equalsConstructorPrototype;
    var excludedKeys;
    var hasAutomationEqualityBug;
    var equalsConstructorPrototypeIfNotBuggy;
    module.exports = keysShim;
  }
});

// node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/index.js
var require_object_keys = __commonJS({
  "node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/index.js"(exports, module) {
    "use strict";
    var slice = Array.prototype.slice;
    var isArgs = require_isArguments();
    var origKeys = Object.keys;
    var keysShim = origKeys ? function keys(o3) {
      return origKeys(o3);
    } : require_implementation();
    var originalKeys = Object.keys;
    keysShim.shim = function shimObjectKeys() {
      if (Object.keys) {
        var keysWorksWithArguments = (function() {
          var args = Object.keys(arguments);
          return args && args.length === arguments.length;
        })(1, 2);
        if (!keysWorksWithArguments) {
          Object.keys = function keys(object) {
            if (isArgs(object)) {
              return originalKeys(slice.call(object));
            }
            return originalKeys(object);
          };
        }
      } else {
        Object.keys = keysShim;
      }
      return Object.keys || keysShim;
    };
    module.exports = keysShim;
  }
});

// node_modules/.pnpm/define-properties@1.2.1/node_modules/define-properties/index.js
var require_define_properties = __commonJS({
  "node_modules/.pnpm/define-properties@1.2.1/node_modules/define-properties/index.js"(exports, module) {
    "use strict";
    var keys = require_object_keys();
    var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
    var toStr = Object.prototype.toString;
    var concat2 = Array.prototype.concat;
    var defineDataProperty = require_define_data_property();
    var isFunction = function(fn3) {
      return typeof fn3 === "function" && toStr.call(fn3) === "[object Function]";
    };
    var supportsDescriptors = require_has_property_descriptors()();
    var defineProperty = function(object, name2, value, predicate) {
      if (name2 in object) {
        if (predicate === true) {
          if (object[name2] === value) {
            return;
          }
        } else if (!isFunction(predicate) || !predicate()) {
          return;
        }
      }
      if (supportsDescriptors) {
        defineDataProperty(object, name2, value, true);
      } else {
        defineDataProperty(object, name2, value);
      }
    };
    var defineProperties = function(object, map) {
      var predicates = arguments.length > 2 ? arguments[2] : {};
      var props = keys(map);
      if (hasSymbols) {
        props = concat2.call(props, Object.getOwnPropertySymbols(map));
      }
      for (var i3 = 0; i3 < props.length; i3 += 1) {
        defineProperty(object, props[i3], map[props[i3]], predicates[props[i3]]);
      }
    };
    defineProperties.supportsDescriptors = !!supportsDescriptors;
    module.exports = defineProperties;
  }
});

// node_modules/.pnpm/globalthis@1.0.4/node_modules/globalthis/implementation.browser.js
var require_implementation_browser = __commonJS({
  "node_modules/.pnpm/globalthis@1.0.4/node_modules/globalthis/implementation.browser.js"(exports, module) {
    "use strict";
    if (typeof self !== "undefined") {
      module.exports = self;
    } else if (typeof window !== "undefined") {
      module.exports = window;
    } else {
      module.exports = Function("return this")();
    }
  }
});

// node_modules/.pnpm/globalthis@1.0.4/node_modules/globalthis/polyfill.js
var require_polyfill = __commonJS({
  "node_modules/.pnpm/globalthis@1.0.4/node_modules/globalthis/polyfill.js"(exports, module) {
    "use strict";
    var implementation = require_implementation_browser();
    module.exports = function getPolyfill() {
      if (typeof global !== "object" || !global || global.Math !== Math || global.Array !== Array) {
        return implementation;
      }
      return global;
    };
  }
});

// node_modules/.pnpm/globalthis@1.0.4/node_modules/globalthis/shim.js
var require_shim = __commonJS({
  "node_modules/.pnpm/globalthis@1.0.4/node_modules/globalthis/shim.js"(exports, module) {
    "use strict";
    var define = require_define_properties();
    var gOPD = require_gopd();
    var getPolyfill = require_polyfill();
    module.exports = function shimGlobal() {
      var polyfill = getPolyfill();
      if (define.supportsDescriptors) {
        var descriptor = gOPD(polyfill, "globalThis");
        if (!descriptor || descriptor.configurable && (descriptor.enumerable || !descriptor.writable || globalThis !== polyfill)) {
          Object.defineProperty(polyfill, "globalThis", {
            configurable: true,
            enumerable: false,
            value: polyfill,
            writable: true
          });
        }
      } else if (typeof globalThis !== "object" || globalThis !== polyfill) {
        polyfill.globalThis = polyfill;
      }
      return polyfill;
    };
  }
});

// node_modules/.pnpm/globalthis@1.0.4/node_modules/globalthis/index.js
var require_globalthis = __commonJS({
  "node_modules/.pnpm/globalthis@1.0.4/node_modules/globalthis/index.js"(exports, module) {
    "use strict";
    var defineProperties = require_define_properties();
    var implementation = require_implementation_browser();
    var getPolyfill = require_polyfill();
    var shim = require_shim();
    var polyfill = getPolyfill();
    var getGlobal2 = function() {
      return polyfill;
    };
    defineProperties(getGlobal2, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = getGlobal2;
  }
});

// node_modules/.pnpm/xstream@11.14.0/node_modules/xstream/index.js
var require_xstream = __commonJS({
  "node_modules/.pnpm/xstream@11.14.0/node_modules/xstream/index.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d3, b5) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b6) {
          d4.__proto__ = b6;
        } || function(d4, b6) {
          for (var p4 in b6) if (b6.hasOwnProperty(p4)) d4[p4] = b6[p4];
        };
        return extendStatics(d3, b5);
      };
      return function(d3, b5) {
        extendStatics(d3, b5);
        function __() {
          this.constructor = d3;
        }
        d3.prototype = b5 === null ? Object.create(b5) : (__.prototype = b5.prototype, new __());
      };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NO_IL = exports.NO = exports.MemoryStream = exports.Stream = void 0;
    var ponyfill_1 = require_ponyfill2();
    var globalthis_1 = require_globalthis();
    var $$observable = ponyfill_1.default(globalthis_1.getPolyfill());
    var NO = {};
    exports.NO = NO;
    function noop() {
    }
    function cp(a2) {
      var l3 = a2.length;
      var b5 = Array(l3);
      for (var i3 = 0; i3 < l3; ++i3)
        b5[i3] = a2[i3];
      return b5;
    }
    function and2(f1, f22) {
      return function andFn(t) {
        return f1(t) && f22(t);
      };
    }
    function _try(c3, t, u4) {
      try {
        return c3.f(t);
      } catch (e) {
        u4._e(e);
        return NO;
      }
    }
    var NO_IL = {
      _n: noop,
      _e: noop,
      _c: noop
    };
    exports.NO_IL = NO_IL;
    function internalizeProducer(producer) {
      producer._start = function _start(il) {
        il.next = il._n;
        il.error = il._e;
        il.complete = il._c;
        this.start(il);
      };
      producer._stop = producer.stop;
    }
    var StreamSub = (
      /** @class */
      (function() {
        function StreamSub2(_stream, _listener) {
          this._stream = _stream;
          this._listener = _listener;
        }
        StreamSub2.prototype.unsubscribe = function() {
          this._stream._remove(this._listener);
        };
        return StreamSub2;
      })()
    );
    var Observer = (
      /** @class */
      (function() {
        function Observer2(_listener) {
          this._listener = _listener;
        }
        Observer2.prototype.next = function(value) {
          this._listener._n(value);
        };
        Observer2.prototype.error = function(err) {
          this._listener._e(err);
        };
        Observer2.prototype.complete = function() {
          this._listener._c();
        };
        return Observer2;
      })()
    );
    var FromObservable = (
      /** @class */
      (function() {
        function FromObservable2(observable) {
          this.type = "fromObservable";
          this.ins = observable;
          this.active = false;
        }
        FromObservable2.prototype._start = function(out) {
          this.out = out;
          this.active = true;
          this._sub = this.ins.subscribe(new Observer(out));
          if (!this.active)
            this._sub.unsubscribe();
        };
        FromObservable2.prototype._stop = function() {
          if (this._sub)
            this._sub.unsubscribe();
          this.active = false;
        };
        return FromObservable2;
      })()
    );
    var Merge = (
      /** @class */
      (function() {
        function Merge2(insArr) {
          this.type = "merge";
          this.insArr = insArr;
          this.out = NO;
          this.ac = 0;
        }
        Merge2.prototype._start = function(out) {
          this.out = out;
          var s2 = this.insArr;
          var L3 = s2.length;
          this.ac = L3;
          for (var i3 = 0; i3 < L3; i3++)
            s2[i3]._add(this);
        };
        Merge2.prototype._stop = function() {
          var s2 = this.insArr;
          var L3 = s2.length;
          for (var i3 = 0; i3 < L3; i3++)
            s2[i3]._remove(this);
          this.out = NO;
        };
        Merge2.prototype._n = function(t) {
          var u4 = this.out;
          if (u4 === NO)
            return;
          u4._n(t);
        };
        Merge2.prototype._e = function(err) {
          var u4 = this.out;
          if (u4 === NO)
            return;
          u4._e(err);
        };
        Merge2.prototype._c = function() {
          if (--this.ac <= 0) {
            var u4 = this.out;
            if (u4 === NO)
              return;
            u4._c();
          }
        };
        return Merge2;
      })()
    );
    var CombineListener = (
      /** @class */
      (function() {
        function CombineListener2(i3, out, p4) {
          this.i = i3;
          this.out = out;
          this.p = p4;
          p4.ils.push(this);
        }
        CombineListener2.prototype._n = function(t) {
          var p4 = this.p, out = this.out;
          if (out === NO)
            return;
          if (p4.up(t, this.i)) {
            var b5 = cp(p4.vals);
            out._n(b5);
          }
        };
        CombineListener2.prototype._e = function(err) {
          var out = this.out;
          if (out === NO)
            return;
          out._e(err);
        };
        CombineListener2.prototype._c = function() {
          var p4 = this.p;
          if (p4.out === NO)
            return;
          if (--p4.Nc === 0)
            p4.out._c();
        };
        return CombineListener2;
      })()
    );
    var Combine = (
      /** @class */
      (function() {
        function Combine2(insArr) {
          this.type = "combine";
          this.insArr = insArr;
          this.out = NO;
          this.ils = [];
          this.Nc = this.Nn = 0;
          this.vals = [];
        }
        Combine2.prototype.up = function(t, i3) {
          var v9 = this.vals[i3];
          var Nn3 = !this.Nn ? 0 : v9 === NO ? --this.Nn : this.Nn;
          this.vals[i3] = t;
          return Nn3 === 0;
        };
        Combine2.prototype._start = function(out) {
          this.out = out;
          var s2 = this.insArr;
          var n2 = this.Nc = this.Nn = s2.length;
          var vals = this.vals = new Array(n2);
          if (n2 === 0) {
            out._n([]);
            out._c();
          } else {
            for (var i3 = 0; i3 < n2; i3++) {
              vals[i3] = NO;
              s2[i3]._add(new CombineListener(i3, out, this));
            }
          }
        };
        Combine2.prototype._stop = function() {
          var s2 = this.insArr;
          var n2 = s2.length;
          var ils = this.ils;
          for (var i3 = 0; i3 < n2; i3++)
            s2[i3]._remove(ils[i3]);
          this.out = NO;
          this.ils = [];
          this.vals = [];
        };
        return Combine2;
      })()
    );
    var FromArray = (
      /** @class */
      (function() {
        function FromArray2(a2) {
          this.type = "fromArray";
          this.a = a2;
        }
        FromArray2.prototype._start = function(out) {
          var a2 = this.a;
          for (var i3 = 0, n2 = a2.length; i3 < n2; i3++)
            out._n(a2[i3]);
          out._c();
        };
        FromArray2.prototype._stop = function() {
        };
        return FromArray2;
      })()
    );
    var FromPromise = (
      /** @class */
      (function() {
        function FromPromise2(p4) {
          this.type = "fromPromise";
          this.on = false;
          this.p = p4;
        }
        FromPromise2.prototype._start = function(out) {
          var prod = this;
          this.on = true;
          this.p.then(function(v9) {
            if (prod.on) {
              out._n(v9);
              out._c();
            }
          }, function(e) {
            out._e(e);
          }).then(noop, function(err) {
            setTimeout(function() {
              throw err;
            });
          });
        };
        FromPromise2.prototype._stop = function() {
          this.on = false;
        };
        return FromPromise2;
      })()
    );
    var Periodic = (
      /** @class */
      (function() {
        function Periodic2(period) {
          this.type = "periodic";
          this.period = period;
          this.intervalID = -1;
          this.i = 0;
        }
        Periodic2.prototype._start = function(out) {
          var self2 = this;
          function intervalHandler() {
            out._n(self2.i++);
          }
          this.intervalID = setInterval(intervalHandler, this.period);
        };
        Periodic2.prototype._stop = function() {
          if (this.intervalID !== -1)
            clearInterval(this.intervalID);
          this.intervalID = -1;
          this.i = 0;
        };
        return Periodic2;
      })()
    );
    var Debug = (
      /** @class */
      (function() {
        function Debug2(ins, arg) {
          this.type = "debug";
          this.ins = ins;
          this.out = NO;
          this.s = noop;
          this.l = "";
          if (typeof arg === "string")
            this.l = arg;
          else if (typeof arg === "function")
            this.s = arg;
        }
        Debug2.prototype._start = function(out) {
          this.out = out;
          this.ins._add(this);
        };
        Debug2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
        };
        Debug2.prototype._n = function(t) {
          var u4 = this.out;
          if (u4 === NO)
            return;
          var s2 = this.s, l3 = this.l;
          if (s2 !== noop) {
            try {
              s2(t);
            } catch (e) {
              u4._e(e);
            }
          } else if (l3)
            console.log(l3 + ":", t);
          else
            console.log(t);
          u4._n(t);
        };
        Debug2.prototype._e = function(err) {
          var u4 = this.out;
          if (u4 === NO)
            return;
          u4._e(err);
        };
        Debug2.prototype._c = function() {
          var u4 = this.out;
          if (u4 === NO)
            return;
          u4._c();
        };
        return Debug2;
      })()
    );
    var Drop = (
      /** @class */
      (function() {
        function Drop2(max, ins) {
          this.type = "drop";
          this.ins = ins;
          this.out = NO;
          this.max = max;
          this.dropped = 0;
        }
        Drop2.prototype._start = function(out) {
          this.out = out;
          this.dropped = 0;
          this.ins._add(this);
        };
        Drop2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
        };
        Drop2.prototype._n = function(t) {
          var u4 = this.out;
          if (u4 === NO)
            return;
          if (this.dropped++ >= this.max)
            u4._n(t);
        };
        Drop2.prototype._e = function(err) {
          var u4 = this.out;
          if (u4 === NO)
            return;
          u4._e(err);
        };
        Drop2.prototype._c = function() {
          var u4 = this.out;
          if (u4 === NO)
            return;
          u4._c();
        };
        return Drop2;
      })()
    );
    var EndWhenListener = (
      /** @class */
      (function() {
        function EndWhenListener2(out, op) {
          this.out = out;
          this.op = op;
        }
        EndWhenListener2.prototype._n = function() {
          this.op.end();
        };
        EndWhenListener2.prototype._e = function(err) {
          this.out._e(err);
        };
        EndWhenListener2.prototype._c = function() {
          this.op.end();
        };
        return EndWhenListener2;
      })()
    );
    var EndWhen = (
      /** @class */
      (function() {
        function EndWhen2(o3, ins) {
          this.type = "endWhen";
          this.ins = ins;
          this.out = NO;
          this.o = o3;
          this.oil = NO_IL;
        }
        EndWhen2.prototype._start = function(out) {
          this.out = out;
          this.o._add(this.oil = new EndWhenListener(out, this));
          this.ins._add(this);
        };
        EndWhen2.prototype._stop = function() {
          this.ins._remove(this);
          this.o._remove(this.oil);
          this.out = NO;
          this.oil = NO_IL;
        };
        EndWhen2.prototype.end = function() {
          var u4 = this.out;
          if (u4 === NO)
            return;
          u4._c();
        };
        EndWhen2.prototype._n = function(t) {
          var u4 = this.out;
          if (u4 === NO)
            return;
          u4._n(t);
        };
        EndWhen2.prototype._e = function(err) {
          var u4 = this.out;
          if (u4 === NO)
            return;
          u4._e(err);
        };
        EndWhen2.prototype._c = function() {
          this.end();
        };
        return EndWhen2;
      })()
    );
    var Filter = (
      /** @class */
      (function() {
        function Filter2(passes, ins) {
          this.type = "filter";
          this.ins = ins;
          this.out = NO;
          this.f = passes;
        }
        Filter2.prototype._start = function(out) {
          this.out = out;
          this.ins._add(this);
        };
        Filter2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
        };
        Filter2.prototype._n = function(t) {
          var u4 = this.out;
          if (u4 === NO)
            return;
          var r2 = _try(this, t, u4);
          if (r2 === NO || !r2)
            return;
          u4._n(t);
        };
        Filter2.prototype._e = function(err) {
          var u4 = this.out;
          if (u4 === NO)
            return;
          u4._e(err);
        };
        Filter2.prototype._c = function() {
          var u4 = this.out;
          if (u4 === NO)
            return;
          u4._c();
        };
        return Filter2;
      })()
    );
    var FlattenListener = (
      /** @class */
      (function() {
        function FlattenListener2(out, op) {
          this.out = out;
          this.op = op;
        }
        FlattenListener2.prototype._n = function(t) {
          this.out._n(t);
        };
        FlattenListener2.prototype._e = function(err) {
          this.out._e(err);
        };
        FlattenListener2.prototype._c = function() {
          this.op.inner = NO;
          this.op.less();
        };
        return FlattenListener2;
      })()
    );
    var Flatten = (
      /** @class */
      (function() {
        function Flatten2(ins) {
          this.type = "flatten";
          this.ins = ins;
          this.out = NO;
          this.open = true;
          this.inner = NO;
          this.il = NO_IL;
        }
        Flatten2.prototype._start = function(out) {
          this.out = out;
          this.open = true;
          this.inner = NO;
          this.il = NO_IL;
          this.ins._add(this);
        };
        Flatten2.prototype._stop = function() {
          this.ins._remove(this);
          if (this.inner !== NO)
            this.inner._remove(this.il);
          this.out = NO;
          this.open = true;
          this.inner = NO;
          this.il = NO_IL;
        };
        Flatten2.prototype.less = function() {
          var u4 = this.out;
          if (u4 === NO)
            return;
          if (!this.open && this.inner === NO)
            u4._c();
        };
        Flatten2.prototype._n = function(s2) {
          var u4 = this.out;
          if (u4 === NO)
            return;
          var _a2 = this, inner = _a2.inner, il = _a2.il;
          if (inner !== NO && il !== NO_IL)
            inner._remove(il);
          (this.inner = s2)._add(this.il = new FlattenListener(u4, this));
        };
        Flatten2.prototype._e = function(err) {
          var u4 = this.out;
          if (u4 === NO)
            return;
          u4._e(err);
        };
        Flatten2.prototype._c = function() {
          this.open = false;
          this.less();
        };
        return Flatten2;
      })()
    );
    var Fold = (
      /** @class */
      (function() {
        function Fold2(f6, seed, ins) {
          var _this = this;
          this.type = "fold";
          this.ins = ins;
          this.out = NO;
          this.f = function(t) {
            return f6(_this.acc, t);
          };
          this.acc = this.seed = seed;
        }
        Fold2.prototype._start = function(out) {
          this.out = out;
          this.acc = this.seed;
          out._n(this.acc);
          this.ins._add(this);
        };
        Fold2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
          this.acc = this.seed;
        };
        Fold2.prototype._n = function(t) {
          var u4 = this.out;
          if (u4 === NO)
            return;
          var r2 = _try(this, t, u4);
          if (r2 === NO)
            return;
          u4._n(this.acc = r2);
        };
        Fold2.prototype._e = function(err) {
          var u4 = this.out;
          if (u4 === NO)
            return;
          u4._e(err);
        };
        Fold2.prototype._c = function() {
          var u4 = this.out;
          if (u4 === NO)
            return;
          u4._c();
        };
        return Fold2;
      })()
    );
    var Last = (
      /** @class */
      (function() {
        function Last2(ins) {
          this.type = "last";
          this.ins = ins;
          this.out = NO;
          this.has = false;
          this.val = NO;
        }
        Last2.prototype._start = function(out) {
          this.out = out;
          this.has = false;
          this.ins._add(this);
        };
        Last2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
          this.val = NO;
        };
        Last2.prototype._n = function(t) {
          this.has = true;
          this.val = t;
        };
        Last2.prototype._e = function(err) {
          var u4 = this.out;
          if (u4 === NO)
            return;
          u4._e(err);
        };
        Last2.prototype._c = function() {
          var u4 = this.out;
          if (u4 === NO)
            return;
          if (this.has) {
            u4._n(this.val);
            u4._c();
          } else
            u4._e(new Error("last() failed because input stream completed"));
        };
        return Last2;
      })()
    );
    var MapOp = (
      /** @class */
      (function() {
        function MapOp2(project, ins) {
          this.type = "map";
          this.ins = ins;
          this.out = NO;
          this.f = project;
        }
        MapOp2.prototype._start = function(out) {
          this.out = out;
          this.ins._add(this);
        };
        MapOp2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
        };
        MapOp2.prototype._n = function(t) {
          var u4 = this.out;
          if (u4 === NO)
            return;
          var r2 = _try(this, t, u4);
          if (r2 === NO)
            return;
          u4._n(r2);
        };
        MapOp2.prototype._e = function(err) {
          var u4 = this.out;
          if (u4 === NO)
            return;
          u4._e(err);
        };
        MapOp2.prototype._c = function() {
          var u4 = this.out;
          if (u4 === NO)
            return;
          u4._c();
        };
        return MapOp2;
      })()
    );
    var Remember = (
      /** @class */
      (function() {
        function Remember2(ins) {
          this.type = "remember";
          this.ins = ins;
          this.out = NO;
        }
        Remember2.prototype._start = function(out) {
          this.out = out;
          this.ins._add(out);
        };
        Remember2.prototype._stop = function() {
          this.ins._remove(this.out);
          this.out = NO;
        };
        return Remember2;
      })()
    );
    var ReplaceError = (
      /** @class */
      (function() {
        function ReplaceError2(replacer, ins) {
          this.type = "replaceError";
          this.ins = ins;
          this.out = NO;
          this.f = replacer;
        }
        ReplaceError2.prototype._start = function(out) {
          this.out = out;
          this.ins._add(this);
        };
        ReplaceError2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
        };
        ReplaceError2.prototype._n = function(t) {
          var u4 = this.out;
          if (u4 === NO)
            return;
          u4._n(t);
        };
        ReplaceError2.prototype._e = function(err) {
          var u4 = this.out;
          if (u4 === NO)
            return;
          try {
            this.ins._remove(this);
            (this.ins = this.f(err))._add(this);
          } catch (e) {
            u4._e(e);
          }
        };
        ReplaceError2.prototype._c = function() {
          var u4 = this.out;
          if (u4 === NO)
            return;
          u4._c();
        };
        return ReplaceError2;
      })()
    );
    var StartWith = (
      /** @class */
      (function() {
        function StartWith2(ins, val) {
          this.type = "startWith";
          this.ins = ins;
          this.out = NO;
          this.val = val;
        }
        StartWith2.prototype._start = function(out) {
          this.out = out;
          this.out._n(this.val);
          this.ins._add(out);
        };
        StartWith2.prototype._stop = function() {
          this.ins._remove(this.out);
          this.out = NO;
        };
        return StartWith2;
      })()
    );
    var Take = (
      /** @class */
      (function() {
        function Take2(max, ins) {
          this.type = "take";
          this.ins = ins;
          this.out = NO;
          this.max = max;
          this.taken = 0;
        }
        Take2.prototype._start = function(out) {
          this.out = out;
          this.taken = 0;
          if (this.max <= 0)
            out._c();
          else
            this.ins._add(this);
        };
        Take2.prototype._stop = function() {
          this.ins._remove(this);
          this.out = NO;
        };
        Take2.prototype._n = function(t) {
          var u4 = this.out;
          if (u4 === NO)
            return;
          var m3 = ++this.taken;
          if (m3 < this.max)
            u4._n(t);
          else if (m3 === this.max) {
            u4._n(t);
            u4._c();
          }
        };
        Take2.prototype._e = function(err) {
          var u4 = this.out;
          if (u4 === NO)
            return;
          u4._e(err);
        };
        Take2.prototype._c = function() {
          var u4 = this.out;
          if (u4 === NO)
            return;
          u4._c();
        };
        return Take2;
      })()
    );
    var Stream = (
      /** @class */
      (function() {
        function Stream2(producer) {
          this._prod = producer || NO;
          this._ils = [];
          this._stopID = NO;
          this._dl = NO;
          this._d = false;
          this._target = null;
          this._err = NO;
        }
        Stream2.prototype._n = function(t) {
          var a2 = this._ils;
          var L3 = a2.length;
          if (this._d)
            this._dl._n(t);
          if (L3 == 1)
            a2[0]._n(t);
          else if (L3 == 0)
            return;
          else {
            var b5 = cp(a2);
            for (var i3 = 0; i3 < L3; i3++)
              b5[i3]._n(t);
          }
        };
        Stream2.prototype._e = function(err) {
          if (this._err !== NO)
            return;
          this._err = err;
          var a2 = this._ils;
          var L3 = a2.length;
          this._x();
          if (this._d)
            this._dl._e(err);
          if (L3 == 1)
            a2[0]._e(err);
          else if (L3 == 0)
            return;
          else {
            var b5 = cp(a2);
            for (var i3 = 0; i3 < L3; i3++)
              b5[i3]._e(err);
          }
          if (!this._d && L3 == 0)
            throw this._err;
        };
        Stream2.prototype._c = function() {
          var a2 = this._ils;
          var L3 = a2.length;
          this._x();
          if (this._d)
            this._dl._c();
          if (L3 == 1)
            a2[0]._c();
          else if (L3 == 0)
            return;
          else {
            var b5 = cp(a2);
            for (var i3 = 0; i3 < L3; i3++)
              b5[i3]._c();
          }
        };
        Stream2.prototype._x = function() {
          if (this._ils.length === 0)
            return;
          if (this._prod !== NO)
            this._prod._stop();
          this._err = NO;
          this._ils = [];
        };
        Stream2.prototype._stopNow = function() {
          this._prod._stop();
          this._err = NO;
          this._stopID = NO;
        };
        Stream2.prototype._add = function(il) {
          var ta = this._target;
          if (ta)
            return ta._add(il);
          var a2 = this._ils;
          a2.push(il);
          if (a2.length > 1)
            return;
          if (this._stopID !== NO) {
            clearTimeout(this._stopID);
            this._stopID = NO;
          } else {
            var p4 = this._prod;
            if (p4 !== NO)
              p4._start(this);
          }
        };
        Stream2.prototype._remove = function(il) {
          var _this = this;
          var ta = this._target;
          if (ta)
            return ta._remove(il);
          var a2 = this._ils;
          var i3 = a2.indexOf(il);
          if (i3 > -1) {
            a2.splice(i3, 1);
            if (this._prod !== NO && a2.length <= 0) {
              this._err = NO;
              this._stopID = setTimeout(function() {
                return _this._stopNow();
              });
            } else if (a2.length === 1) {
              this._pruneCycles();
            }
          }
        };
        Stream2.prototype._pruneCycles = function() {
          if (this._hasNoSinks(this, []))
            this._remove(this._ils[0]);
        };
        Stream2.prototype._hasNoSinks = function(x3, trace) {
          if (trace.indexOf(x3) !== -1)
            return true;
          else if (x3.out === this)
            return true;
          else if (x3.out && x3.out !== NO)
            return this._hasNoSinks(x3.out, trace.concat(x3));
          else if (x3._ils) {
            for (var i3 = 0, N2 = x3._ils.length; i3 < N2; i3++)
              if (!this._hasNoSinks(x3._ils[i3], trace.concat(x3)))
                return false;
            return true;
          } else
            return false;
        };
        Stream2.prototype.ctor = function() {
          return this instanceof MemoryStream ? MemoryStream : Stream2;
        };
        Stream2.prototype.addListener = function(listener) {
          listener._n = listener.next || noop;
          listener._e = listener.error || noop;
          listener._c = listener.complete || noop;
          this._add(listener);
        };
        Stream2.prototype.removeListener = function(listener) {
          this._remove(listener);
        };
        Stream2.prototype.subscribe = function(listener) {
          this.addListener(listener);
          return new StreamSub(this, listener);
        };
        Stream2.prototype[$$observable] = function() {
          return this;
        };
        Stream2.create = function(producer) {
          if (producer) {
            if (typeof producer.start !== "function" || typeof producer.stop !== "function")
              throw new Error("producer requires both start and stop functions");
            internalizeProducer(producer);
          }
          return new Stream2(producer);
        };
        Stream2.createWithMemory = function(producer) {
          if (producer)
            internalizeProducer(producer);
          return new MemoryStream(producer);
        };
        Stream2.never = function() {
          return new Stream2({ _start: noop, _stop: noop });
        };
        Stream2.empty = function() {
          return new Stream2({
            _start: function(il) {
              il._c();
            },
            _stop: noop
          });
        };
        Stream2.throw = function(error) {
          return new Stream2({
            _start: function(il) {
              il._e(error);
            },
            _stop: noop
          });
        };
        Stream2.from = function(input) {
          if (typeof input[$$observable] === "function")
            return Stream2.fromObservable(input);
          else if (typeof input.then === "function")
            return Stream2.fromPromise(input);
          else if (Array.isArray(input))
            return Stream2.fromArray(input);
          throw new TypeError("Type of input to from() must be an Array, Promise, or Observable");
        };
        Stream2.of = function() {
          var items = [];
          for (var _i3 = 0; _i3 < arguments.length; _i3++) {
            items[_i3] = arguments[_i3];
          }
          return Stream2.fromArray(items);
        };
        Stream2.fromArray = function(array) {
          return new Stream2(new FromArray(array));
        };
        Stream2.fromPromise = function(promise) {
          return new Stream2(new FromPromise(promise));
        };
        Stream2.fromObservable = function(obs) {
          if (obs.endWhen !== void 0)
            return obs;
          var o3 = typeof obs[$$observable] === "function" ? obs[$$observable]() : obs;
          return new Stream2(new FromObservable(o3));
        };
        Stream2.periodic = function(period) {
          return new Stream2(new Periodic(period));
        };
        Stream2.prototype._map = function(project) {
          return new (this.ctor())(new MapOp(project, this));
        };
        Stream2.prototype.map = function(project) {
          return this._map(project);
        };
        Stream2.prototype.mapTo = function(projectedValue) {
          var s2 = this.map(function() {
            return projectedValue;
          });
          var op = s2._prod;
          op.type = "mapTo";
          return s2;
        };
        Stream2.prototype.filter = function(passes) {
          var p4 = this._prod;
          if (p4 instanceof Filter)
            return new Stream2(new Filter(and2(p4.f, passes), p4.ins));
          return new Stream2(new Filter(passes, this));
        };
        Stream2.prototype.take = function(amount) {
          return new (this.ctor())(new Take(amount, this));
        };
        Stream2.prototype.drop = function(amount) {
          return new Stream2(new Drop(amount, this));
        };
        Stream2.prototype.last = function() {
          return new Stream2(new Last(this));
        };
        Stream2.prototype.startWith = function(initial) {
          return new MemoryStream(new StartWith(this, initial));
        };
        Stream2.prototype.endWhen = function(other) {
          return new (this.ctor())(new EndWhen(other, this));
        };
        Stream2.prototype.fold = function(accumulate, seed) {
          return new MemoryStream(new Fold(accumulate, seed, this));
        };
        Stream2.prototype.replaceError = function(replace) {
          return new (this.ctor())(new ReplaceError(replace, this));
        };
        Stream2.prototype.flatten = function() {
          return new Stream2(new Flatten(this));
        };
        Stream2.prototype.compose = function(operator) {
          return operator(this);
        };
        Stream2.prototype.remember = function() {
          return new MemoryStream(new Remember(this));
        };
        Stream2.prototype.debug = function(labelOrSpy) {
          return new (this.ctor())(new Debug(this, labelOrSpy));
        };
        Stream2.prototype.imitate = function(target) {
          if (target instanceof MemoryStream)
            throw new Error("A MemoryStream was given to imitate(), but it only supports a Stream. Read more about this restriction here: https://github.com/staltz/xstream#faq");
          this._target = target;
          for (var ils = this._ils, N2 = ils.length, i3 = 0; i3 < N2; i3++)
            target._add(ils[i3]);
          this._ils = [];
        };
        Stream2.prototype.shamefullySendNext = function(value) {
          this._n(value);
        };
        Stream2.prototype.shamefullySendError = function(error) {
          this._e(error);
        };
        Stream2.prototype.shamefullySendComplete = function() {
          this._c();
        };
        Stream2.prototype.setDebugListener = function(listener) {
          if (!listener) {
            this._d = false;
            this._dl = NO;
          } else {
            this._d = true;
            listener._n = listener.next || noop;
            listener._e = listener.error || noop;
            listener._c = listener.complete || noop;
            this._dl = listener;
          }
        };
        Stream2.merge = function merge() {
          var streams = [];
          for (var _i3 = 0; _i3 < arguments.length; _i3++) {
            streams[_i3] = arguments[_i3];
          }
          return new Stream2(new Merge(streams));
        };
        Stream2.combine = function combine() {
          var streams = [];
          for (var _i3 = 0; _i3 < arguments.length; _i3++) {
            streams[_i3] = arguments[_i3];
          }
          return new Stream2(new Combine(streams));
        };
        return Stream2;
      })()
    );
    exports.Stream = Stream;
    var MemoryStream = (
      /** @class */
      (function(_super) {
        __extends(MemoryStream2, _super);
        function MemoryStream2(producer) {
          var _this = _super.call(this, producer) || this;
          _this._has = false;
          return _this;
        }
        MemoryStream2.prototype._n = function(x3) {
          this._v = x3;
          this._has = true;
          _super.prototype._n.call(this, x3);
        };
        MemoryStream2.prototype._add = function(il) {
          var ta = this._target;
          if (ta)
            return ta._add(il);
          var a2 = this._ils;
          a2.push(il);
          if (a2.length > 1) {
            if (this._has)
              il._n(this._v);
            return;
          }
          if (this._stopID !== NO) {
            if (this._has)
              il._n(this._v);
            clearTimeout(this._stopID);
            this._stopID = NO;
          } else if (this._has)
            il._n(this._v);
          else {
            var p4 = this._prod;
            if (p4 !== NO)
              p4._start(this);
          }
        };
        MemoryStream2.prototype._stopNow = function() {
          this._has = false;
          _super.prototype._stopNow.call(this);
        };
        MemoryStream2.prototype._x = function() {
          this._has = false;
          _super.prototype._x.call(this);
        };
        MemoryStream2.prototype.map = function(project) {
          return this._map(project);
        };
        MemoryStream2.prototype.mapTo = function(projectedValue) {
          return _super.prototype.mapTo.call(this, projectedValue);
        };
        MemoryStream2.prototype.take = function(amount) {
          return _super.prototype.take.call(this, amount);
        };
        MemoryStream2.prototype.endWhen = function(other) {
          return _super.prototype.endWhen.call(this, other);
        };
        MemoryStream2.prototype.replaceError = function(replace) {
          return _super.prototype.replaceError.call(this, replace);
        };
        MemoryStream2.prototype.remember = function() {
          return this;
        };
        MemoryStream2.prototype.debug = function(labelOrSpy) {
          return _super.prototype.debug.call(this, labelOrSpy);
        };
        return MemoryStream2;
      })(Stream)
    );
    exports.MemoryStream = MemoryStream;
    var xs3 = Stream;
    exports.default = xs3;
  }
});

// node_modules/.pnpm/@cosmjs+stream@0.37.0/node_modules/@cosmjs/stream/build/concat.js
var require_concat = __commonJS({
  "node_modules/.pnpm/@cosmjs+stream@0.37.0/node_modules/@cosmjs/stream/build/concat.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.concat = concat2;
    var xstream_1 = require_xstream();
    function concat2(...streams) {
      const subscriptions = new Array();
      const queues = new Array();
      const completedStreams = /* @__PURE__ */ new Set();
      let activeStreamIndex = 0;
      function reset() {
        while (subscriptions.length > 0) {
          const subscription = subscriptions.shift();
          subscription.unsubscribe();
        }
        queues.length = 0;
        completedStreams.clear();
        activeStreamIndex = 0;
      }
      const producer = {
        start: (listener) => {
          streams.forEach((_2) => queues.push([]));
          function emitAllQueuesEvents(streamIndex) {
            while (true) {
              const element = queues[streamIndex].shift();
              if (element === void 0) {
                return;
              }
              listener.next(element);
            }
          }
          function isDone() {
            return activeStreamIndex >= streams.length;
          }
          if (isDone()) {
            listener.complete();
            return;
          }
          streams.forEach((stream, index) => {
            subscriptions.push(stream.subscribe({
              next: (value) => {
                if (index === activeStreamIndex) {
                  listener.next(value);
                } else {
                  queues[index].push(value);
                }
              },
              complete: () => {
                completedStreams.add(index);
                while (completedStreams.has(activeStreamIndex)) {
                  emitAllQueuesEvents(activeStreamIndex);
                  activeStreamIndex++;
                }
                if (isDone()) {
                  listener.complete();
                } else {
                  emitAllQueuesEvents(activeStreamIndex);
                }
              },
              error: (error) => {
                listener.error(error);
                reset();
              }
            }));
          });
        },
        stop: () => {
          reset();
        }
      };
      return xstream_1.Stream.create(producer);
    }
  }
});

// node_modules/.pnpm/@cosmjs+stream@0.37.0/node_modules/@cosmjs/stream/build/defaultvalueproducer.js
var require_defaultvalueproducer = __commonJS({
  "node_modules/.pnpm/@cosmjs+stream@0.37.0/node_modules/@cosmjs/stream/build/defaultvalueproducer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DefaultValueProducer = void 0;
    var DefaultValueProducer = class {
      get value() {
        return this.internalValue;
      }
      callbacks;
      internalValue;
      listener;
      constructor(value, callbacks) {
        this.callbacks = callbacks;
        this.internalValue = value;
      }
      /**
       * Update the current value.
       *
       * If producer is active (i.e. someone is listening), this emits an event.
       * If not, just the current value is updated.
       */
      update(value) {
        this.internalValue = value;
        if (this.listener) {
          this.listener.next(value);
        }
      }
      /**
       * Produce an error
       */
      // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
      error(error) {
        if (this.listener) {
          this.listener.error(error);
        }
      }
      /**
       * Called by the stream. Do not call this directly.
       */
      start(listener) {
        this.listener = listener;
        listener.next(this.internalValue);
        if (this.callbacks) {
          this.callbacks.onStarted();
        }
      }
      /**
       * Called by the stream. Do not call this directly.
       */
      stop() {
        if (this.callbacks) {
          this.callbacks.onStop();
        }
        this.listener = void 0;
      }
    };
    exports.DefaultValueProducer = DefaultValueProducer;
  }
});

// node_modules/.pnpm/@cosmjs+stream@0.37.0/node_modules/@cosmjs/stream/build/dropduplicates.js
var require_dropduplicates = __commonJS({
  "node_modules/.pnpm/@cosmjs+stream@0.37.0/node_modules/@cosmjs/stream/build/dropduplicates.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dropDuplicates = dropDuplicates;
    function dropDuplicates(valueToKey) {
      const operand = (instream) => {
        const emittedKeys = /* @__PURE__ */ new Set();
        const deduplicatedStream = instream.filter((value) => !emittedKeys.has(valueToKey(value))).debug((value) => emittedKeys.add(valueToKey(value)));
        return deduplicatedStream;
      };
      return operand;
    }
  }
});

// node_modules/.pnpm/@cosmjs+stream@0.37.0/node_modules/@cosmjs/stream/build/promise.js
var require_promise = __commonJS({
  "node_modules/.pnpm/@cosmjs+stream@0.37.0/node_modules/@cosmjs/stream/build/promise.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromListPromise = fromListPromise;
    exports.toListPromise = toListPromise;
    exports.firstEvent = firstEvent;
    var xstream_1 = require_xstream();
    function fromListPromise(promise) {
      const producer = {
        start: (listener) => {
          promise.then((iterable) => {
            for (const element of iterable) {
              listener.next(element);
            }
            listener.complete();
          }).catch((error) => {
            listener.error(error);
          });
        },
        stop: () => {
        }
      };
      return xstream_1.Stream.create(producer);
    }
    async function toListPromise(stream, count) {
      return new Promise((resolve, reject) => {
        if (count === 0) {
          resolve([]);
          return;
        }
        const events = new Array();
        stream.take(count).subscribe({
          next: (event) => {
            events.push(event);
            if (events.length === count) {
              resolve(events);
            }
          },
          complete: () => {
            reject(new Error(`Stream completed before all events could be collected. Collected ${events.length}, expected ${count}`));
          },
          error: (error) => {
            reject(error);
          }
        });
      });
    }
    async function firstEvent(stream) {
      return (await toListPromise(stream, 1))[0];
    }
  }
});

// node_modules/.pnpm/@cosmjs+stream@0.37.0/node_modules/@cosmjs/stream/build/reducer.js
var require_reducer = __commonJS({
  "node_modules/.pnpm/@cosmjs+stream@0.37.0/node_modules/@cosmjs/stream/build/reducer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Reducer = void 0;
    exports.countStream = countStream;
    exports.asArray = asArray;
    exports.lastValue = lastValue;
    var Reducer = class {
      stream;
      reducer;
      state;
      // completed maintains state of stream, resolves/rejects
      // on complete or error
      completed;
      constructor(stream, reducer, initState) {
        this.stream = stream;
        this.reducer = reducer;
        this.state = initState;
        this.completed = new Promise((resolve, reject) => {
          const subscription = this.stream.subscribe({
            next: (evt) => {
              this.state = this.reducer(this.state, evt);
            },
            complete: () => {
              resolve();
              subscription.unsubscribe();
            },
            error: (err) => {
              reject(err);
              subscription.unsubscribe();
            }
          });
        });
      }
      // value returns current materialized state
      value() {
        return this.state;
      }
      // finished resolves on completed stream, rejects on stream error
      async finished() {
        return this.completed;
      }
    };
    exports.Reducer = Reducer;
    function increment(sum, _2) {
      return sum + 1;
    }
    function countStream(stream) {
      return new Reducer(stream, increment, 0);
    }
    function append(list, evt) {
      return [...list, evt];
    }
    function asArray(stream) {
      return new Reducer(stream, append, []);
    }
    function last(_2, event) {
      return event;
    }
    function lastValue(stream) {
      return new Reducer(stream, last, void 0);
    }
  }
});

// node_modules/.pnpm/@cosmjs+stream@0.37.0/node_modules/@cosmjs/stream/build/valueandupdates.js
var require_valueandupdates = __commonJS({
  "node_modules/.pnpm/@cosmjs+stream@0.37.0/node_modules/@cosmjs/stream/build/valueandupdates.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueAndUpdates = void 0;
    var xstream_1 = require_xstream();
    var ValueAndUpdates = class {
      updates;
      get value() {
        return this.producer.value;
      }
      producer;
      constructor(producer) {
        this.producer = producer;
        this.updates = xstream_1.MemoryStream.createWithMemory(this.producer);
      }
      /**
       * Resolves as soon as search value is found.
       *
       * @param search either a value or a function that must return true when found
       * @returns the value of the update that caused the search match
       */
      async waitFor(search) {
        const searchImplementation = typeof search === "function" ? search : (value) => value === search;
        return new Promise((resolve, reject) => {
          const subscription = this.updates.subscribe({
            next: (newValue) => {
              if (searchImplementation(newValue)) {
                resolve(newValue);
                setTimeout(() => {
                  subscription.unsubscribe();
                }, 0);
              }
            },
            complete: () => {
              subscription.unsubscribe();
              reject(new Error("Update stream completed without expected value"));
            },
            error: (error) => {
              reject(error);
            }
          });
        });
      }
    };
    exports.ValueAndUpdates = ValueAndUpdates;
  }
});

// node_modules/.pnpm/@cosmjs+stream@0.37.0/node_modules/@cosmjs/stream/build/index.js
var require_build7 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stream@0.37.0/node_modules/@cosmjs/stream/build/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o3, m3, k5, k22) {
      if (k22 === void 0) k22 = k5;
      var desc = Object.getOwnPropertyDescriptor(m3, k5);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k5];
        } };
      }
      Object.defineProperty(o3, k22, desc);
    }) : (function(o3, m3, k5, k22) {
      if (k22 === void 0) k22 = k5;
      o3[k22] = m3[k5];
    }));
    var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
      for (var p4 in m3) if (p4 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p4)) __createBinding(exports2, m3, p4);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueAndUpdates = exports.toListPromise = exports.fromListPromise = exports.firstEvent = exports.dropDuplicates = exports.DefaultValueProducer = exports.concat = void 0;
    var concat_1 = require_concat();
    Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
      return concat_1.concat;
    } });
    var defaultvalueproducer_1 = require_defaultvalueproducer();
    Object.defineProperty(exports, "DefaultValueProducer", { enumerable: true, get: function() {
      return defaultvalueproducer_1.DefaultValueProducer;
    } });
    var dropduplicates_1 = require_dropduplicates();
    Object.defineProperty(exports, "dropDuplicates", { enumerable: true, get: function() {
      return dropduplicates_1.dropDuplicates;
    } });
    var promise_1 = require_promise();
    Object.defineProperty(exports, "firstEvent", { enumerable: true, get: function() {
      return promise_1.firstEvent;
    } });
    Object.defineProperty(exports, "fromListPromise", { enumerable: true, get: function() {
      return promise_1.fromListPromise;
    } });
    Object.defineProperty(exports, "toListPromise", { enumerable: true, get: function() {
      return promise_1.toListPromise;
    } });
    __exportStar(require_reducer(), exports);
    var valueandupdates_1 = require_valueandupdates();
    Object.defineProperty(exports, "ValueAndUpdates", { enumerable: true, get: function() {
      return valueandupdates_1.ValueAndUpdates;
    } });
  }
});

// node_modules/.pnpm/@cosmjs+json-rpc@0.37.0/node_modules/@cosmjs/json-rpc/build/types.js
var require_types5 = __commonJS({
  "node_modules/.pnpm/@cosmjs+json-rpc@0.37.0/node_modules/@cosmjs/json-rpc/build/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.jsonRpcCode = void 0;
    exports.isJsonRpcErrorResponse = isJsonRpcErrorResponse;
    exports.isJsonRpcSuccessResponse = isJsonRpcSuccessResponse;
    function isJsonRpcErrorResponse(response) {
      return typeof response.error === "object";
    }
    function isJsonRpcSuccessResponse(response) {
      return !isJsonRpcErrorResponse(response);
    }
    exports.jsonRpcCode = {
      parseError: -32700,
      invalidRequest: -32600,
      methodNotFound: -32601,
      invalidParams: -32602,
      internalError: -32603,
      // server error (Reserved for implementation-defined server-errors.):
      // -32000 to -32099
      serverError: {
        default: -32e3
      }
    };
  }
});

// node_modules/.pnpm/@cosmjs+json-rpc@0.37.0/node_modules/@cosmjs/json-rpc/build/jsonrpcclient.js
var require_jsonrpcclient = __commonJS({
  "node_modules/.pnpm/@cosmjs+json-rpc@0.37.0/node_modules/@cosmjs/json-rpc/build/jsonrpcclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JsonRpcClient = void 0;
    var stream_1 = require_build7();
    var types_1 = require_types5();
    var JsonRpcClient = class {
      connection;
      constructor(connection) {
        this.connection = connection;
      }
      async run(request) {
        const filteredStream = this.connection.responseStream.filter((r2) => r2.id === request.id);
        const pendingResponses = (0, stream_1.firstEvent)(filteredStream);
        this.connection.sendRequest(request);
        const response = await pendingResponses;
        if ((0, types_1.isJsonRpcErrorResponse)(response)) {
          const error = response.error;
          throw new Error(`JSON RPC error: code=${error.code}; message='${error.message}'`);
        }
        return response;
      }
    };
    exports.JsonRpcClient = JsonRpcClient;
  }
});

// node_modules/.pnpm/@cosmjs+json-rpc@0.37.0/node_modules/@cosmjs/json-rpc/build/compatibility.js
var require_compatibility = __commonJS({
  "node_modules/.pnpm/@cosmjs+json-rpc@0.37.0/node_modules/@cosmjs/json-rpc/build/compatibility.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isJsonCompatibleValue = isJsonCompatibleValue;
    exports.isJsonCompatibleArray = isJsonCompatibleArray;
    exports.isJsonCompatibleDictionary = isJsonCompatibleDictionary;
    function isJsonCompatibleValue(value) {
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean" || value === null || // eslint-disable-next-line @typescript-eslint/no-use-before-define
      isJsonCompatibleArray(value) || // eslint-disable-next-line @typescript-eslint/no-use-before-define
      isJsonCompatibleDictionary(value)) {
        return true;
      } else {
        return false;
      }
    }
    function isJsonCompatibleArray(value) {
      if (!Array.isArray(value)) {
        return false;
      }
      for (const item of value) {
        if (!isJsonCompatibleValue(item)) {
          return false;
        }
      }
      return true;
    }
    function isJsonCompatibleDictionary(value) {
      if (typeof value !== "object" || value === null) {
        return false;
      }
      if (Object.prototype.toString.call(value) !== "[object Object]") {
        return false;
      }
      return Object.values(value).every(isJsonCompatibleValue);
    }
  }
});

// node_modules/.pnpm/@cosmjs+json-rpc@0.37.0/node_modules/@cosmjs/json-rpc/build/parse.js
var require_parse = __commonJS({
  "node_modules/.pnpm/@cosmjs+json-rpc@0.37.0/node_modules/@cosmjs/json-rpc/build/parse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseJsonRpcId = parseJsonRpcId;
    exports.parseJsonRpcRequest = parseJsonRpcRequest;
    exports.parseJsonRpcErrorResponse = parseJsonRpcErrorResponse;
    exports.parseJsonRpcSuccessResponse = parseJsonRpcSuccessResponse;
    exports.parseJsonRpcResponse = parseJsonRpcResponse;
    var compatibility_1 = require_compatibility();
    function parseJsonRpcId(data2) {
      if (!(0, compatibility_1.isJsonCompatibleDictionary)(data2)) {
        throw new Error("Data must be JSON compatible dictionary");
      }
      const id = data2.id;
      if (typeof id !== "number" && typeof id !== "string") {
        return null;
      }
      return id;
    }
    function parseJsonRpcRequest(data2) {
      if (!(0, compatibility_1.isJsonCompatibleDictionary)(data2)) {
        throw new Error("Data must be JSON compatible dictionary");
      }
      if (typeof data2.jsonrpc !== "string") {
        throw new Error(`Invalid "jsonrpc" field. Must be a string.`);
      }
      if (data2.jsonrpc !== "2.0") {
        throw new Error(`Got unexpected jsonrpc version: ${data2.jsonrpc}`);
      }
      const id = parseJsonRpcId(data2);
      if (id === null) {
        throw new Error("Invalid id field");
      }
      const method = data2.method;
      if (typeof method !== "string") {
        throw new Error(`Invalid "method" field. Must be a string.`);
      }
      if (!(0, compatibility_1.isJsonCompatibleArray)(data2.params) && !(0, compatibility_1.isJsonCompatibleDictionary)(data2.params)) {
        throw new Error("Invalid params field");
      }
      return {
        jsonrpc: "2.0",
        id,
        method,
        params: data2.params
      };
    }
    function parseError(error) {
      if (typeof error.code !== "number") {
        throw new Error("Error property 'code' is not a number");
      }
      if (typeof error.message !== "string") {
        throw new Error("Error property 'message' is not a string");
      }
      let maybeUndefinedData;
      if (error.data === void 0) {
        maybeUndefinedData = void 0;
      } else if ((0, compatibility_1.isJsonCompatibleValue)(error.data)) {
        maybeUndefinedData = error.data;
      } else {
        throw new Error("Error property 'data' is defined but not a JSON compatible value.");
      }
      return {
        code: error.code,
        message: error.message,
        ...maybeUndefinedData !== void 0 ? { data: maybeUndefinedData } : {}
      };
    }
    function parseJsonRpcErrorResponse(data2) {
      if (!(0, compatibility_1.isJsonCompatibleDictionary)(data2)) {
        throw new Error("Data must be JSON compatible dictionary");
      }
      if (data2.jsonrpc !== "2.0") {
        throw new Error(`Got unexpected jsonrpc version: ${JSON.stringify(data2)}`);
      }
      const id = data2.id;
      if (typeof id !== "number" && typeof id !== "string" && id !== null) {
        throw new Error("Invalid id field");
      }
      if (typeof data2.error === "undefined" || !(0, compatibility_1.isJsonCompatibleDictionary)(data2.error)) {
        throw new Error("Invalid error field");
      }
      return {
        jsonrpc: "2.0",
        id,
        error: parseError(data2.error)
      };
    }
    function parseJsonRpcSuccessResponse(data2) {
      if (!(0, compatibility_1.isJsonCompatibleDictionary)(data2)) {
        throw new Error("Data must be JSON compatible dictionary");
      }
      if (data2.jsonrpc !== "2.0") {
        throw new Error(`Got unexpected jsonrpc version: ${JSON.stringify(data2)}`);
      }
      const id = data2.id;
      if (typeof id !== "number" && typeof id !== "string") {
        throw new Error("Invalid id field");
      }
      if (typeof data2.result === "undefined") {
        throw new Error("Invalid result field");
      }
      const result = data2.result;
      return {
        jsonrpc: "2.0",
        id,
        result
      };
    }
    function parseJsonRpcResponse(data2) {
      let response;
      try {
        response = parseJsonRpcErrorResponse(data2);
      } catch (_2) {
        response = parseJsonRpcSuccessResponse(data2);
      }
      return response;
    }
  }
});

// node_modules/.pnpm/@cosmjs+json-rpc@0.37.0/node_modules/@cosmjs/json-rpc/build/index.js
var require_build8 = __commonJS({
  "node_modules/.pnpm/@cosmjs+json-rpc@0.37.0/node_modules/@cosmjs/json-rpc/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.jsonRpcCode = exports.isJsonRpcSuccessResponse = exports.isJsonRpcErrorResponse = exports.parseJsonRpcSuccessResponse = exports.parseJsonRpcResponse = exports.parseJsonRpcRequest = exports.parseJsonRpcId = exports.parseJsonRpcErrorResponse = exports.JsonRpcClient = exports.makeJsonRpcId = void 0;
    var id_1 = require_id();
    Object.defineProperty(exports, "makeJsonRpcId", { enumerable: true, get: function() {
      return id_1.makeJsonRpcId;
    } });
    var jsonrpcclient_1 = require_jsonrpcclient();
    Object.defineProperty(exports, "JsonRpcClient", { enumerable: true, get: function() {
      return jsonrpcclient_1.JsonRpcClient;
    } });
    var parse_1 = require_parse();
    Object.defineProperty(exports, "parseJsonRpcErrorResponse", { enumerable: true, get: function() {
      return parse_1.parseJsonRpcErrorResponse;
    } });
    Object.defineProperty(exports, "parseJsonRpcId", { enumerable: true, get: function() {
      return parse_1.parseJsonRpcId;
    } });
    Object.defineProperty(exports, "parseJsonRpcRequest", { enumerable: true, get: function() {
      return parse_1.parseJsonRpcRequest;
    } });
    Object.defineProperty(exports, "parseJsonRpcResponse", { enumerable: true, get: function() {
      return parse_1.parseJsonRpcResponse;
    } });
    Object.defineProperty(exports, "parseJsonRpcSuccessResponse", { enumerable: true, get: function() {
      return parse_1.parseJsonRpcSuccessResponse;
    } });
    var types_1 = require_types5();
    Object.defineProperty(exports, "isJsonRpcErrorResponse", { enumerable: true, get: function() {
      return types_1.isJsonRpcErrorResponse;
    } });
    Object.defineProperty(exports, "isJsonRpcSuccessResponse", { enumerable: true, get: function() {
      return types_1.isJsonRpcSuccessResponse;
    } });
    Object.defineProperty(exports, "jsonRpcCode", { enumerable: true, get: function() {
      return types_1.jsonRpcCode;
    } });
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/http.js
var require_http = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/http.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.http = http;
    function filterBadStatus(res) {
      if (res.status >= 400) {
        throw new Error(`Bad status on response: ${res.status}`);
      }
      return res;
    }
    async function http(method, url, headers, request, timeout) {
      const settings = {
        method,
        body: request ? JSON.stringify(request) : void 0,
        headers: {
          "Content-Type": "application/json",
          ...headers
        },
        signal: timeout ? AbortSignal.timeout(timeout) : void 0
      };
      return fetch(url, settings).then(filterBadStatus).then((res) => res.json());
    }
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/rpcclient.js
var require_rpcclient = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/rpcclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.instanceOfRpcStreamingClient = instanceOfRpcStreamingClient;
    exports.hasProtocol = hasProtocol;
    function instanceOfRpcStreamingClient(client) {
      return "listen" in client && typeof client.listen === "function";
    }
    function hasProtocol(url) {
      return url.search("://") !== -1;
    }
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/httpbatchclient.js
var require_httpbatchclient = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/httpbatchclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HttpBatchClient = void 0;
    var json_rpc_1 = require_build8();
    var http_1 = require_http();
    var rpcclient_1 = require_rpcclient();
    var defaultHttpBatchClientOptions = {
      dispatchInterval: 20,
      batchSizeLimit: 20
    };
    var HttpBatchClient = class {
      url;
      headers;
      options;
      timer;
      queue = [];
      constructor(endpoint, options = {}) {
        this.options = {
          batchSizeLimit: options.batchSizeLimit ?? defaultHttpBatchClientOptions.batchSizeLimit,
          dispatchInterval: options.dispatchInterval ?? defaultHttpBatchClientOptions.dispatchInterval,
          httpTimeout: options.httpTimeout
        };
        if (typeof endpoint === "string") {
          if (!(0, rpcclient_1.hasProtocol)(endpoint)) {
            throw new Error("Endpoint URL is missing a protocol. Expected 'https://' or 'http://'.");
          }
          this.url = endpoint;
        } else {
          this.url = endpoint.url;
          this.headers = endpoint.headers;
        }
        this.timer = setInterval(() => {
          this.tick();
        }, options.dispatchInterval);
        this.validate();
      }
      disconnect() {
        if (this.timer)
          clearInterval(this.timer);
        this.timer = void 0;
      }
      async execute(request) {
        return new Promise((resolve, reject) => {
          this.queue.push({ request, resolve, reject });
          if (this.queue.length >= this.options.batchSizeLimit) {
            this.tick();
          }
        });
      }
      validate() {
        if (!this.options.batchSizeLimit || !Number.isSafeInteger(this.options.batchSizeLimit) || this.options.batchSizeLimit < 1) {
          throw new Error("batchSizeLimit must be a safe integer >= 1");
        }
      }
      /**
       * This is called in an interval where promise rejections cannot be handled.
       * So this is not async and HTTP errors need to be handled by the queued promises.
       */
      tick() {
        const batch = this.queue.splice(0, this.options.batchSizeLimit);
        if (!batch.length)
          return;
        const requests = batch.map((s2) => s2.request);
        const requestIds = requests.map((request) => request.id);
        (0, http_1.http)("POST", this.url, this.headers, requests, this.options.httpTimeout).then((raw) => {
          const arr = Array.isArray(raw) ? raw : [raw];
          arr.forEach((el) => {
            const req = batch.find((s2) => s2.request.id === el.id);
            if (!req)
              return;
            const { reject, resolve } = req;
            const response = (0, json_rpc_1.parseJsonRpcResponse)(el);
            if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {
              reject(new Error(JSON.stringify(response.error)));
            } else {
              resolve(response);
            }
          });
        }, (error) => {
          for (const requestId of requestIds) {
            const req = batch.find((s2) => s2.request.id === requestId);
            if (!req)
              return;
            req.reject(error);
          }
        });
      }
    };
    exports.HttpBatchClient = HttpBatchClient;
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/httpclient.js
var require_httpclient = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/httpclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HttpClient = void 0;
    var json_rpc_1 = require_build8();
    var http_1 = require_http();
    var rpcclient_1 = require_rpcclient();
    var HttpClient = class {
      url;
      headers;
      timeout;
      constructor(endpoint, timeout) {
        if (typeof endpoint === "string") {
          if (!(0, rpcclient_1.hasProtocol)(endpoint)) {
            throw new Error("Endpoint URL is missing a protocol. Expected 'https://' or 'http://'.");
          }
          this.url = endpoint;
        } else {
          this.url = endpoint.url;
          this.headers = endpoint.headers;
        }
        this.timeout = timeout;
      }
      disconnect() {
      }
      async execute(request) {
        const response = (0, json_rpc_1.parseJsonRpcResponse)(await (0, http_1.http)("POST", this.url, this.headers, request, this.timeout));
        if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {
          throw new Error(JSON.stringify(response.error));
        }
        return response;
      }
    };
    exports.HttpClient = HttpClient;
  }
});

// node_modules/.pnpm/isomorphic-ws@4.0.1_ws@7.5.10_bufferutil@4.0.9_utf-8-validate@5.0.10_/node_modules/isomorphic-ws/browser.js
var require_browser = __commonJS({
  "node_modules/.pnpm/isomorphic-ws@4.0.1_ws@7.5.10_bufferutil@4.0.9_utf-8-validate@5.0.10_/node_modules/isomorphic-ws/browser.js"(exports, module) {
    var ws2 = null;
    if (typeof WebSocket !== "undefined") {
      ws2 = WebSocket;
    } else if (typeof MozWebSocket !== "undefined") {
      ws2 = MozWebSocket;
    } else if (typeof global !== "undefined") {
      ws2 = global.WebSocket || global.MozWebSocket;
    } else if (typeof window !== "undefined") {
      ws2 = window.WebSocket || window.MozWebSocket;
    } else if (typeof self !== "undefined") {
      ws2 = self.WebSocket || self.MozWebSocket;
    }
    module.exports = ws2;
  }
});

// node_modules/.pnpm/@cosmjs+socket@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/socket/build/socketwrapper.js
var require_socketwrapper = __commonJS({
  "node_modules/.pnpm/@cosmjs+socket@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/socket/build/socketwrapper.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SocketWrapper = void 0;
    var isomorphic_ws_1 = __importDefault(require_browser());
    function environmentIsNodeJs() {
      return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
    }
    var SocketWrapper = class {
      connected;
      connectedResolver;
      connectedRejecter;
      socket;
      timeoutId;
      closed = false;
      url;
      messageHandler;
      errorHandler;
      openHandler;
      closeHandler;
      timeout;
      constructor(url, messageHandler, errorHandler, openHandler, closeHandler, timeout = 1e4) {
        this.connected = new Promise((resolve, reject) => {
          this.connectedResolver = resolve;
          this.connectedRejecter = reject;
        });
        this.url = url;
        this.messageHandler = messageHandler;
        this.errorHandler = errorHandler;
        this.openHandler = openHandler;
        this.closeHandler = closeHandler;
        this.timeout = timeout;
      }
      /**
       * returns a promise that resolves when connection is open
       */
      connect() {
        const socket = new isomorphic_ws_1.default(this.url);
        socket.onerror = (error) => {
          this.clearTimeout();
          if (this.errorHandler) {
            this.errorHandler(error);
          }
        };
        socket.onmessage = (messageEvent) => {
          this.messageHandler({
            type: messageEvent.type,
            data: messageEvent.data
          });
        };
        socket.onopen = (_2) => {
          this.clearTimeout();
          this.connectedResolver();
          if (this.openHandler) {
            this.openHandler();
          }
        };
        socket.onclose = (closeEvent) => {
          this.closed = true;
          if (this.closeHandler) {
            this.closeHandler(closeEvent);
          }
        };
        const started = Date.now();
        this.timeoutId = setTimeout(() => {
          socket.onmessage = () => 0;
          socket.onerror = () => 0;
          socket.onopen = () => 0;
          socket.onclose = () => 0;
          socket.close();
          this.socket = void 0;
          const elapsed = Math.floor(Date.now() - started);
          this.connectedRejecter(new Error(`Connection attempt timed out after ${elapsed} ms`));
        }, this.timeout);
        this.socket = socket;
      }
      /**
       * Closes an established connection and aborts other connection states
       */
      disconnect() {
        if (!this.socket) {
          throw new Error("Socket undefined. This must be called after connecting.");
        }
        this.clearTimeout();
        switch (this.socket.readyState) {
          case isomorphic_ws_1.default.OPEN:
            this.socket.close(
              1e3
              /* Normal Closure */
            );
            break;
          case isomorphic_ws_1.default.CLOSED:
            break;
          case isomorphic_ws_1.default.CONNECTING:
            this.socket.onopen = () => 0;
            this.socket.onclose = () => 0;
            this.socket.onerror = () => 0;
            this.socket.onmessage = () => 0;
            this.socket = void 0;
            if (this.closeHandler) {
              this.closeHandler({ wasClean: false, code: 4001 });
            }
            break;
          case isomorphic_ws_1.default.CLOSING:
            break;
          default:
            throw new Error(`Unknown readyState: ${this.socket.readyState}`);
        }
      }
      async send(data2) {
        return new Promise((resolve, reject) => {
          if (!this.socket) {
            throw new Error("Socket undefined. This must be called after connecting.");
          }
          if (this.closed) {
            throw new Error("Socket was closed, so no data can be sent anymore.");
          }
          if (this.socket.readyState !== isomorphic_ws_1.default.OPEN) {
            throw new Error("Websocket is not open");
          }
          if (environmentIsNodeJs()) {
            this.socket.send(data2, (err) => {
              if (err)
                reject(err);
              else
                resolve();
            });
          } else {
            this.socket.send(data2);
            resolve();
          }
        });
      }
      /**
       * Clears the timeout function, such that no timeout error will be raised anymore. This should be
       * called when the connection is established, a connection error occurred or the socket is disconnected.
       *
       * This method must not be called before `connect()`.
       * This method is idempotent.
       */
      clearTimeout() {
        if (!this.timeoutId) {
          throw new Error("Timeout ID not set. This should not happen and usually means connect() was not called.");
        }
        clearTimeout(this.timeoutId);
      }
    };
    exports.SocketWrapper = SocketWrapper;
  }
});

// node_modules/.pnpm/@cosmjs+socket@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/socket/build/streamingsocket.js
var require_streamingsocket = __commonJS({
  "node_modules/.pnpm/@cosmjs+socket@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/socket/build/streamingsocket.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StreamingSocket = void 0;
    var xstream_1 = require_xstream();
    var socketwrapper_1 = require_socketwrapper();
    var StreamingSocket = class {
      connected;
      events;
      eventProducerListener;
      socket;
      constructor(url, timeout = 1e4) {
        this.socket = new socketwrapper_1.SocketWrapper(url, (event) => {
          if (this.eventProducerListener) {
            this.eventProducerListener.next(event);
          }
        }, (errorEvent) => {
          if (this.eventProducerListener) {
            this.eventProducerListener.error(errorEvent);
          }
        }, () => {
        }, (closeEvent) => {
          if (this.eventProducerListener) {
            if (closeEvent.wasClean) {
              this.eventProducerListener.complete();
            } else {
              this.eventProducerListener.error("Socket was closed unclean");
            }
          }
        }, timeout);
        this.connected = this.socket.connected;
        const eventProducer = {
          start: (listener) => this.eventProducerListener = listener,
          stop: () => this.eventProducerListener = void 0
        };
        this.events = xstream_1.Stream.create(eventProducer);
      }
      connect() {
        this.socket.connect();
      }
      disconnect() {
        this.socket.disconnect();
      }
      async send(data2) {
        return this.socket.send(data2);
      }
    };
    exports.StreamingSocket = StreamingSocket;
  }
});

// node_modules/.pnpm/@cosmjs+socket@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/socket/build/queueingstreamingsocket.js
var require_queueingstreamingsocket = __commonJS({
  "node_modules/.pnpm/@cosmjs+socket@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/socket/build/queueingstreamingsocket.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueueingStreamingSocket = exports.ConnectionStatus = void 0;
    var stream_1 = require_build7();
    var xstream_1 = require_xstream();
    var streamingsocket_1 = require_streamingsocket();
    var ConnectionStatus;
    (function(ConnectionStatus2) {
      ConnectionStatus2[ConnectionStatus2["Unconnected"] = 0] = "Unconnected";
      ConnectionStatus2[ConnectionStatus2["Connecting"] = 1] = "Connecting";
      ConnectionStatus2[ConnectionStatus2["Connected"] = 2] = "Connected";
      ConnectionStatus2[ConnectionStatus2["Disconnected"] = 3] = "Disconnected";
    })(ConnectionStatus || (exports.ConnectionStatus = ConnectionStatus = {}));
    var QueueingStreamingSocket = class {
      connectionStatus;
      events;
      url;
      timeout;
      queue = [];
      socket;
      isProcessingQueue = false;
      eventProducerListener;
      connectionStatusProducer;
      reconnectedHandler;
      constructor(url, timeout = 1e4, reconnectedHandler) {
        this.url = url;
        this.timeout = timeout;
        this.reconnectedHandler = reconnectedHandler;
        const eventProducer = {
          start: (listener) => this.eventProducerListener = listener,
          stop: () => this.eventProducerListener = void 0
        };
        this.events = xstream_1.Stream.create(eventProducer);
        this.connectionStatusProducer = new stream_1.DefaultValueProducer(ConnectionStatus.Unconnected);
        this.connectionStatus = new stream_1.ValueAndUpdates(this.connectionStatusProducer);
        this.socket = new streamingsocket_1.StreamingSocket(this.url, this.timeout);
        this.socket.events.subscribe({
          next: (event) => {
            if (!this.eventProducerListener)
              throw new Error("No event producer listener set");
            this.eventProducerListener.next(event);
          },
          error: () => {
            this.connectionStatusProducer.update(ConnectionStatus.Disconnected);
          }
        });
      }
      connect() {
        this.connectionStatusProducer.update(ConnectionStatus.Connecting);
        this.socket.connected.then(async () => {
          this.connectionStatusProducer.update(ConnectionStatus.Connected);
          return this.processQueue();
        }, () => {
          this.connectionStatusProducer.update(ConnectionStatus.Disconnected);
        });
        this.socket.connect();
      }
      disconnect() {
        this.connectionStatusProducer.update(ConnectionStatus.Disconnected);
        this.socket.disconnect();
      }
      reconnect() {
        this.socket = new streamingsocket_1.StreamingSocket(this.url, this.timeout);
        this.socket.events.subscribe({
          next: (event) => {
            if (!this.eventProducerListener)
              throw new Error("No event producer listener set");
            this.eventProducerListener.next(event);
          },
          error: () => {
            this.connectionStatusProducer.update(ConnectionStatus.Disconnected);
          }
        });
        this.socket.connected.then(() => {
          if (this.reconnectedHandler) {
            this.reconnectedHandler();
          }
        });
        this.connect();
      }
      getQueueLength() {
        return this.queue.length;
      }
      queueRequest(request) {
        this.queue.push(request);
        this.processQueue();
      }
      async processQueue() {
        if (this.isProcessingQueue || this.connectionStatus.value !== ConnectionStatus.Connected) {
          return;
        }
        this.isProcessingQueue = true;
        let request;
        while (request = this.queue.shift()) {
          try {
            await this.socket.send(request);
            this.isProcessingQueue = false;
          } catch (_error) {
            this.queue.unshift(request);
            this.isProcessingQueue = false;
            return;
          }
        }
      }
    };
    exports.QueueingStreamingSocket = QueueingStreamingSocket;
  }
});

// node_modules/.pnpm/@cosmjs+socket@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/socket/build/reconnectingsocket.js
var require_reconnectingsocket = __commonJS({
  "node_modules/.pnpm/@cosmjs+socket@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/socket/build/reconnectingsocket.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReconnectingSocket = void 0;
    var xstream_1 = require_xstream();
    var queueingstreamingsocket_1 = require_queueingstreamingsocket();
    var ReconnectingSocket = class _ReconnectingSocket {
      /** Starts with a 0.1 second timeout, then doubles every attempt with a maximum timeout of 5 seconds. */
      static calculateTimeout(index) {
        return Math.min(2 ** index * 100, 5e3);
      }
      connectionStatus;
      events;
      socket;
      eventProducerListener;
      unconnected = true;
      disconnected = false;
      timeoutIndex = 0;
      reconnectTimeout = null;
      constructor(url, timeout = 1e4, reconnectedHandler) {
        const eventProducer = {
          start: (listener) => this.eventProducerListener = listener,
          stop: () => this.eventProducerListener = void 0
        };
        this.events = xstream_1.Stream.create(eventProducer);
        this.socket = new queueingstreamingsocket_1.QueueingStreamingSocket(url, timeout, reconnectedHandler);
        this.socket.events.subscribe({
          next: (event) => {
            if (this.eventProducerListener) {
              this.eventProducerListener.next(event);
            }
          },
          error: (error) => {
            if (this.eventProducerListener) {
              this.eventProducerListener.error(error);
            }
          }
        });
        this.connectionStatus = this.socket.connectionStatus;
        this.connectionStatus.updates.subscribe({
          next: (status) => {
            if (status === queueingstreamingsocket_1.ConnectionStatus.Connected) {
              this.timeoutIndex = 0;
            }
            if (status === queueingstreamingsocket_1.ConnectionStatus.Disconnected) {
              if (this.reconnectTimeout) {
                clearTimeout(this.reconnectTimeout);
                this.reconnectTimeout = null;
              }
              this.reconnectTimeout = setTimeout(() => {
                this.socket.reconnect();
              }, _ReconnectingSocket.calculateTimeout(this.timeoutIndex++));
            }
          }
        });
      }
      connect() {
        if (!this.unconnected) {
          throw new Error("Cannot connect: socket has already connected");
        }
        this.socket.connect();
        this.unconnected = false;
      }
      disconnect() {
        if (this.unconnected) {
          throw new Error("Cannot disconnect: socket has not yet connected");
        }
        this.socket.disconnect();
        if (this.eventProducerListener) {
          this.eventProducerListener.complete();
        }
        this.disconnected = true;
      }
      queueRequest(request) {
        if (this.disconnected) {
          throw new Error("Cannot queue request: socket has disconnected");
        }
        this.socket.queueRequest(request);
      }
    };
    exports.ReconnectingSocket = ReconnectingSocket;
  }
});

// node_modules/.pnpm/@cosmjs+socket@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/socket/build/index.js
var require_build9 = __commonJS({
  "node_modules/.pnpm/@cosmjs+socket@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/socket/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StreamingSocket = exports.SocketWrapper = exports.ReconnectingSocket = exports.QueueingStreamingSocket = exports.ConnectionStatus = void 0;
    var queueingstreamingsocket_1 = require_queueingstreamingsocket();
    Object.defineProperty(exports, "ConnectionStatus", { enumerable: true, get: function() {
      return queueingstreamingsocket_1.ConnectionStatus;
    } });
    Object.defineProperty(exports, "QueueingStreamingSocket", { enumerable: true, get: function() {
      return queueingstreamingsocket_1.QueueingStreamingSocket;
    } });
    var reconnectingsocket_1 = require_reconnectingsocket();
    Object.defineProperty(exports, "ReconnectingSocket", { enumerable: true, get: function() {
      return reconnectingsocket_1.ReconnectingSocket;
    } });
    var socketwrapper_1 = require_socketwrapper();
    Object.defineProperty(exports, "SocketWrapper", { enumerable: true, get: function() {
      return socketwrapper_1.SocketWrapper;
    } });
    var streamingsocket_1 = require_streamingsocket();
    Object.defineProperty(exports, "StreamingSocket", { enumerable: true, get: function() {
      return streamingsocket_1.StreamingSocket;
    } });
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/websocketclient.js
var require_websocketclient = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/websocketclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebsocketClient = void 0;
    var json_rpc_1 = require_build8();
    var socket_1 = require_build9();
    var stream_1 = require_build7();
    var xstream_1 = require_xstream();
    var rpcclient_1 = require_rpcclient();
    function defaultErrorHandler(error) {
      throw error;
    }
    function toJsonRpcResponse(message) {
      if (message.type !== "message") {
        throw new Error(`Unexpected message type on websocket: ${message.type}`);
      }
      const jsonRpcEvent = (0, json_rpc_1.parseJsonRpcResponse)(JSON.parse(message.data));
      return jsonRpcEvent;
    }
    var RpcEventProducer = class {
      request;
      socket;
      running = false;
      subscriptions = [];
      constructor(request, socket) {
        this.request = request;
        this.socket = socket;
      }
      /**
       * Implementation of Producer.start
       */
      start(listener) {
        if (this.running) {
          throw Error("Already started. Please stop first before restarting.");
        }
        this.running = true;
        this.connectToClient(listener);
        this.socket.queueRequest(JSON.stringify(this.request));
      }
      /**
       * Implementation of Producer.stop
       *
       * Called by the stream when the stream's last listener stopped listening
       * or when the producer completed.
       */
      stop() {
        this.running = false;
        const endRequest = { ...this.request, method: "unsubscribe" };
        try {
          this.socket.queueRequest(JSON.stringify(endRequest));
        } catch (error) {
          if (error instanceof Error && error.message.match(/socket has disconnected/i)) {
          } else {
            throw error;
          }
        }
      }
      connectToClient(listener) {
        const responseStream = this.socket.events.map(toJsonRpcResponse);
        const idSubscription = responseStream.filter((response) => response.id === this.request.id).subscribe({
          next: (response) => {
            if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {
              this.closeSubscriptions();
              listener.error(JSON.stringify(response.error));
            }
            idSubscription.unsubscribe();
          }
        });
        const idEventSubscription = responseStream.filter((response) => response.id === this.request.id).subscribe({
          next: (response) => {
            if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {
              this.closeSubscriptions();
              listener.error(JSON.stringify(response.error));
            } else {
              listener.next(response.result);
            }
          }
        });
        const nonResponseSubscription = responseStream.subscribe({
          error: (error) => {
            this.closeSubscriptions();
            listener.error(error);
          },
          complete: () => {
            this.closeSubscriptions();
            listener.complete();
          }
        });
        this.subscriptions.push(idSubscription, idEventSubscription, nonResponseSubscription);
      }
      closeSubscriptions() {
        for (const subscription of this.subscriptions) {
          subscription.unsubscribe();
        }
        this.subscriptions = [];
      }
    };
    var WebsocketClient = class {
      url;
      socket;
      /** Same events as in socket.events but in the format we need */
      jsonRpcResponseStream;
      // Lazily create streams and use the same stream when listening to the same query twice.
      //
      // Creating streams is cheap since producer is not started as long as nobody listens to events. Thus this
      // map is never cleared and there is no need to do so. But unsubscribe all the subscriptions!
      subscriptionStreams = /* @__PURE__ */ new Map();
      constructor(baseUrl, onError = defaultErrorHandler) {
        if (!(0, rpcclient_1.hasProtocol)(baseUrl)) {
          throw new Error("Base URL is missing a protocol. Expected 'ws://' or 'wss://'.");
        }
        const path = baseUrl.endsWith("/") ? "websocket" : "/websocket";
        this.url = baseUrl + path;
        this.socket = new socket_1.ReconnectingSocket(this.url);
        const errorSubscription = this.socket.events.subscribe({
          error: (error) => {
            onError(error);
            errorSubscription.unsubscribe();
          }
        });
        this.jsonRpcResponseStream = this.socket.events.map(toJsonRpcResponse);
        this.socket.connect();
      }
      async execute(request) {
        const pendingResponse = this.responseForRequestId(request.id);
        this.socket.queueRequest(JSON.stringify(request));
        const response = await pendingResponse;
        if ((0, json_rpc_1.isJsonRpcErrorResponse)(response)) {
          throw new Error(JSON.stringify(response.error));
        }
        return response;
      }
      listen(request) {
        if (request.method !== "subscribe") {
          throw new Error(`Request method must be "subscribe" to start event listening`);
        }
        const query = request.params.query;
        if (typeof query !== "string") {
          throw new Error("request.params.query must be a string");
        }
        if (!this.subscriptionStreams.has(query)) {
          const producer = new RpcEventProducer(request, this.socket);
          const stream = xstream_1.Stream.create(producer);
          this.subscriptionStreams.set(query, stream);
        }
        return this.subscriptionStreams.get(query).filter((response) => response.query !== void 0);
      }
      /**
       * Resolves as soon as websocket is connected. execute() queues requests automatically,
       * so this should be required for testing purposes only.
       */
      async connected() {
        await this.socket.connectionStatus.waitFor(socket_1.ConnectionStatus.Connected);
      }
      disconnect() {
        this.socket.disconnect();
      }
      async responseForRequestId(id) {
        return (0, stream_1.firstEvent)(this.jsonRpcResponseStream.filter((r2) => r2.id === id));
      }
    };
    exports.WebsocketClient = WebsocketClient;
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/index.js
var require_rpcclients = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/rpcclients/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebsocketClient = exports.instanceOfRpcStreamingClient = exports.HttpClient = exports.HttpBatchClient = void 0;
    var httpbatchclient_1 = require_httpbatchclient();
    Object.defineProperty(exports, "HttpBatchClient", { enumerable: true, get: function() {
      return httpbatchclient_1.HttpBatchClient;
    } });
    var httpclient_1 = require_httpclient();
    Object.defineProperty(exports, "HttpClient", { enumerable: true, get: function() {
      return httpclient_1.HttpClient;
    } });
    var rpcclient_1 = require_rpcclient();
    Object.defineProperty(exports, "instanceOfRpcStreamingClient", { enumerable: true, get: function() {
      return rpcclient_1.instanceOfRpcStreamingClient;
    } });
    var websocketclient_1 = require_websocketclient();
    Object.defineProperty(exports, "WebsocketClient", { enumerable: true, get: function() {
      return websocketclient_1.WebsocketClient;
    } });
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/jsonchecks.js
var require_jsonchecks = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/jsonchecks.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.jCheckSet = jCheckSet;
    exports.jCheckBoolean = jCheckBoolean;
    exports.jCheckString = jCheckString;
    exports.jCheckNumber = jCheckNumber;
    exports.jCheckArray = jCheckArray;
    exports.jCheckObject = jCheckObject;
    exports.jCheckNonEmptyString = jCheckNonEmptyString;
    exports.jCheckNonZeroNumber = jCheckNonZeroNumber;
    function jCheckSet(value) {
      if (value === void 0) {
        throw new Error("Value must not be undefined");
      }
      if (value === null) {
        throw new Error("Value must not be null");
      }
      return value;
    }
    function jCheckBoolean(value) {
      jCheckSet(value);
      if (typeof value !== "boolean") {
        throw new Error("Value must be a boolean");
      }
      return value;
    }
    function jCheckString(value) {
      jCheckSet(value);
      if (typeof value !== "string") {
        throw new Error("Value must be a string");
      }
      return value;
    }
    function jCheckNumber(value) {
      jCheckSet(value);
      if (typeof value !== "number") {
        throw new Error("Value must be a number");
      }
      return value;
    }
    function jCheckArray(value) {
      jCheckSet(value);
      if (!Array.isArray(value)) {
        throw new Error("Value must be an array");
      }
      return value;
    }
    function jCheckObject(value) {
      jCheckSet(value);
      if (typeof value !== "object") {
        throw new Error("Value must be an object");
      }
      if (Object.prototype.toString.call(value) !== "[object Object]") {
        throw new Error("Value must be a simple object");
      }
      return value;
    }
    function jCheckNonEmptyString(value) {
      jCheckString(value);
      if (value.length === 0)
        throw new Error("Value must not be empty");
      return value;
    }
    function jCheckNonZeroNumber(value) {
      jCheckNumber(value);
      if (value === 0)
        throw new Error("Value must not be zero");
      return value;
    }
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/inthelpers.js
var require_inthelpers = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/inthelpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.apiToSmallInt = apiToSmallInt;
    exports.apiToBigInt = apiToBigInt;
    exports.smallIntToApi = smallIntToApi;
    var math_1 = require_build3();
    var jsonchecks_1 = require_jsonchecks();
    function apiToSmallInt(input) {
      const asInt = typeof input === "number" ? new math_1.Int53(input) : math_1.Int53.fromString(input);
      return asInt.toNumber();
    }
    function apiToBigInt(input) {
      (0, jsonchecks_1.jCheckString)(input);
      if (!input.match(/^-?[0-9]+$/)) {
        throw new Error("Invalid string format");
      }
      return BigInt(input);
    }
    function smallIntToApi(num) {
      return new math_1.Int53(num).toString();
    }
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/jsonrpc.js
var require_jsonrpc = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/jsonrpc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createJsonRpcRequest = createJsonRpcRequest;
    var numbersWithoutZero = "123456789";
    function randomNumericChar() {
      return numbersWithoutZero[Math.floor(Math.random() * numbersWithoutZero.length)];
    }
    function randomId() {
      return parseInt(Array.from({ length: 12 }).map(() => randomNumericChar()).join(""), 10);
    }
    function createJsonRpcRequest(method, params) {
      const paramsCopy = params ? { ...params } : {};
      return {
        jsonrpc: "2.0",
        id: randomId(),
        method,
        params: paramsCopy
      };
    }
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/comet1/encodings.js
var require_encodings = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/comet1/encodings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.may = may;
    exports.dictionaryToStringMap = dictionaryToStringMap;
    exports.encodeString = encodeString;
    exports.encodeUvarint = encodeUvarint;
    exports.encodeTime = encodeTime;
    exports.encodeBytes = encodeBytes;
    exports.encodeVersion = encodeVersion;
    exports.encodeBlockId = encodeBlockId;
    var encoding_1 = require_build2();
    function may(transform, value) {
      return value === void 0 || value === null ? void 0 : transform(value);
    }
    function dictionaryToStringMap(obj) {
      const out = /* @__PURE__ */ new Map();
      for (const key of Object.keys(obj)) {
        const value = obj[key];
        if (typeof value !== "string") {
          throw new Error("Found dictionary value of type other than string");
        }
        out.set(key, value);
      }
      return out;
    }
    function encodeString(s2) {
      const utf82 = (0, encoding_1.toUtf8)(s2);
      return Uint8Array.from([utf82.length, ...utf82]);
    }
    function encodeUvarint(n2) {
      return n2 >= 128 ? (
        // eslint-disable-next-line no-bitwise
        Uint8Array.from([n2 & 255 | 128, ...encodeUvarint(n2 >> 7)])
      ) : (
        // eslint-disable-next-line no-bitwise
        Uint8Array.from([n2 & 255])
      );
    }
    function encodeTime(time) {
      const milliseconds = time.getTime();
      const seconds = Math.floor(milliseconds / 1e3);
      const secondsArray = seconds ? [8, ...encodeUvarint(seconds)] : new Uint8Array();
      const nanoseconds = (time.nanoseconds || 0) + milliseconds % 1e3 * 1e6;
      const nanosecondsArray = nanoseconds ? [16, ...encodeUvarint(nanoseconds)] : new Uint8Array();
      return Uint8Array.from([...secondsArray, ...nanosecondsArray]);
    }
    function encodeBytes(bytes2) {
      if (bytes2.length >= 128)
        throw new Error("Not implemented for byte arrays of length 128 or more");
      return bytes2.length ? Uint8Array.from([bytes2.length, ...bytes2]) : new Uint8Array();
    }
    function encodeVersion(version) {
      const blockArray = version.block ? Uint8Array.from([8, ...encodeUvarint(version.block)]) : new Uint8Array();
      const appArray = version.app ? Uint8Array.from([16, ...encodeUvarint(version.app)]) : new Uint8Array();
      return Uint8Array.from([...blockArray, ...appArray]);
    }
    function encodeBlockId(blockId) {
      return Uint8Array.from([
        10,
        blockId.hash.length,
        ...blockId.hash,
        18,
        blockId.parts.hash.length + 4,
        8,
        blockId.parts.total,
        18,
        blockId.parts.hash.length,
        ...blockId.parts.hash
      ]);
    }
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/comet1/requests.js
var require_requests = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/comet1/requests.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SubscriptionEventType = exports.Method = void 0;
    exports.buildQuery = buildQuery;
    var Method;
    (function(Method2) {
      Method2["AbciInfo"] = "abci_info";
      Method2["AbciQuery"] = "abci_query";
      Method2["Block"] = "block";
      Method2["Blockchain"] = "blockchain";
      Method2["BlockResults"] = "block_results";
      Method2["BlockSearch"] = "block_search";
      Method2["BroadcastTxAsync"] = "broadcast_tx_async";
      Method2["BroadcastTxSync"] = "broadcast_tx_sync";
      Method2["BroadcastTxCommit"] = "broadcast_tx_commit";
      Method2["Commit"] = "commit";
      Method2["Genesis"] = "genesis";
      Method2["Health"] = "health";
      Method2["NumUnconfirmedTxs"] = "num_unconfirmed_txs";
      Method2["Status"] = "status";
      Method2["Subscribe"] = "subscribe";
      Method2["Tx"] = "tx";
      Method2["TxSearch"] = "tx_search";
      Method2["Validators"] = "validators";
      Method2["Unsubscribe"] = "unsubscribe";
    })(Method || (exports.Method = Method = {}));
    var SubscriptionEventType;
    (function(SubscriptionEventType2) {
      SubscriptionEventType2["NewBlock"] = "NewBlock";
      SubscriptionEventType2["NewBlockHeader"] = "NewBlockHeader";
      SubscriptionEventType2["Tx"] = "Tx";
    })(SubscriptionEventType || (exports.SubscriptionEventType = SubscriptionEventType = {}));
    function buildQuery(components) {
      const tags = components.tags ? components.tags : [];
      const tagComponents = tags.map((tag) => `${tag.key}='${tag.value}'`);
      const rawComponents = components.raw ? [components.raw] : [];
      return [...tagComponents, ...rawComponents].join(" AND ");
    }
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/comet1/adaptor/requests.js
var require_requests2 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/comet1/adaptor/requests.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o3, m3, k5, k22) {
      if (k22 === void 0) k22 = k5;
      var desc = Object.getOwnPropertyDescriptor(m3, k5);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k5];
        } };
      }
      Object.defineProperty(o3, k22, desc);
    }) : (function(o3, m3, k5, k22) {
      if (k22 === void 0) k22 = k5;
      o3[k22] = m3[k5];
    }));
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o3, v9) {
      Object.defineProperty(o3, "default", { enumerable: true, value: v9 });
    }) : function(o3, v9) {
      o3["default"] = v9;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
      var ownKeys = function(o3) {
        ownKeys = Object.getOwnPropertyNames || function(o4) {
          var ar3 = [];
          for (var k5 in o4) if (Object.prototype.hasOwnProperty.call(o4, k5)) ar3[ar3.length] = k5;
          return ar3;
        };
        return ownKeys(o3);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k5 = ownKeys(mod), i3 = 0; i3 < k5.length; i3++) if (k5[i3] !== "default") __createBinding(result, mod, k5[i3]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Params = void 0;
    var encoding_1 = require_build2();
    var inthelpers_1 = require_inthelpers();
    var jsonrpc_1 = require_jsonrpc();
    var encodings_1 = require_encodings();
    var requests = __importStar(require_requests());
    function encodeHeightParam(param) {
      return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.height)
      };
    }
    function encodeBlockchainRequestParams(param) {
      return {
        minHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.minHeight),
        maxHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.maxHeight)
      };
    }
    function encodeBlockSearchParams(params) {
      return {
        query: params.query,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
      };
    }
    function encodeAbciQueryParams(params) {
      return {
        path: params.path,
        data: (0, encoding_1.toHex)(params.data),
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        prove: params.prove
      };
    }
    function encodeBroadcastTxParams(params) {
      return {
        tx: (0, encoding_1.toBase64)(params.tx)
      };
    }
    function encodeTxParams(params) {
      return {
        hash: (0, encoding_1.toBase64)(params.hash),
        prove: params.prove
      };
    }
    function encodeTxSearchParams(params) {
      return {
        query: params.query,
        prove: params.prove,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
      };
    }
    function encodeValidatorsParams(params) {
      return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page)
      };
    }
    var Params = class {
      static encodeAbciInfo(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeAbciQuery(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeAbciQueryParams(req.params));
      }
      static encodeBlock(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeBlockchain(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockchainRequestParams(req.params));
      }
      static encodeBlockResults(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeBlockSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockSearchParams(req.params));
      }
      static encodeBroadcastTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBroadcastTxParams(req.params));
      }
      static encodeCommit(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeGenesis(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeHealth(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeNumUnconfirmedTxs(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeStatus(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeSubscribe(req) {
        const eventTag = { key: "tm.event", value: req.query.type };
        const query = requests.buildQuery({ tags: [eventTag], raw: req.query.raw });
        return (0, jsonrpc_1.createJsonRpcRequest)("subscribe", { query });
      }
      static encodeTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxParams(req.params));
      }
      // TODO: encode params for query string???
      static encodeTxSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxSearchParams(req.params));
      }
      static encodeValidators(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeValidatorsParams(req.params));
      }
    };
    exports.Params = Params;
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/types.js
var require_types6 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BlockIdFlag = void 0;
    var BlockIdFlag;
    (function(BlockIdFlag2) {
      BlockIdFlag2[BlockIdFlag2["Unknown"] = 0] = "Unknown";
      BlockIdFlag2[BlockIdFlag2["Absent"] = 1] = "Absent";
      BlockIdFlag2[BlockIdFlag2["Commit"] = 2] = "Commit";
      BlockIdFlag2[BlockIdFlag2["Nil"] = 3] = "Nil";
      BlockIdFlag2[BlockIdFlag2["Unrecognized"] = -1] = "Unrecognized";
    })(BlockIdFlag || (exports.BlockIdFlag = BlockIdFlag = {}));
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/comet1/hasher.js
var require_hasher = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/comet1/hasher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashTx = hashTx;
    exports.hashBlock = hashBlock;
    var crypto_1 = require_build4();
    var encodings_1 = require_encodings();
    function hashTx(tx) {
      return (0, crypto_1.sha256)(tx);
    }
    function getSplitPoint(n2) {
      if (n2 < 1)
        throw new Error("Cannot split an empty tree");
      const largestPowerOf2 = 2 ** Math.floor(Math.log2(n2));
      return largestPowerOf2 < n2 ? largestPowerOf2 : largestPowerOf2 / 2;
    }
    function hashLeaf(leaf) {
      const hash2 = new crypto_1.Sha256(Uint8Array.from([0]));
      hash2.update(leaf);
      return hash2.digest();
    }
    function hashInner(left, right) {
      const hash2 = new crypto_1.Sha256(Uint8Array.from([1]));
      hash2.update(left);
      hash2.update(right);
      return hash2.digest();
    }
    function hashTree(hashes) {
      switch (hashes.length) {
        case 0:
          throw new Error("Cannot hash empty tree");
        case 1:
          return hashLeaf(hashes[0]);
        default: {
          const slicePoint = getSplitPoint(hashes.length);
          const left = hashTree(hashes.slice(0, slicePoint));
          const right = hashTree(hashes.slice(slicePoint));
          return hashInner(left, right);
        }
      }
    }
    function hashBlock(header) {
      if (!header.lastBlockId) {
        throw new Error("Hashing a block header with no last block ID (i.e. header at height 1) is not supported. If you need this, contributions are welcome. Please add documentation and test vectors for this case.");
      }
      const encodedFields = [
        (0, encodings_1.encodeVersion)(header.version),
        (0, encodings_1.encodeString)(header.chainId),
        (0, encodings_1.encodeUvarint)(header.height),
        (0, encodings_1.encodeTime)(header.time),
        (0, encodings_1.encodeBlockId)(header.lastBlockId),
        (0, encodings_1.encodeBytes)(header.lastCommitHash),
        (0, encodings_1.encodeBytes)(header.dataHash),
        (0, encodings_1.encodeBytes)(header.validatorsHash),
        (0, encodings_1.encodeBytes)(header.nextValidatorsHash),
        (0, encodings_1.encodeBytes)(header.consensusHash),
        (0, encodings_1.encodeBytes)(header.appHash),
        (0, encodings_1.encodeBytes)(header.lastResultsHash),
        (0, encodings_1.encodeBytes)(header.evidenceHash),
        (0, encodings_1.encodeBytes)(header.proposerAddress)
      ];
      return hashTree(encodedFields);
    }
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/comet1/adaptor/responses.js
var require_responses = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/comet1/adaptor/responses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Responses = void 0;
    exports.decodeEvent = decodeEvent;
    exports.decodeValidatorUpdate = decodeValidatorUpdate;
    exports.decodeBlockResults = decodeBlockResults;
    exports.decodeCommit = decodeCommit;
    exports.decodeValidatorGenesis = decodeValidatorGenesis;
    exports.decodeValidatorInfo = decodeValidatorInfo;
    var encoding_1 = require_build2();
    var utils_1 = require_build();
    var dates_1 = require_dates();
    var inthelpers_1 = require_inthelpers();
    var jsonchecks_1 = require_jsonchecks();
    var types_1 = require_types6();
    var encodings_1 = require_encodings();
    var hasher_1 = require_hasher();
    function decodeAbciInfo(data2) {
      return {
        data: data2.data,
        lastBlockHeight: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data2.last_block_height),
        lastBlockAppHash: (0, encodings_1.may)(encoding_1.fromBase64, data2.last_block_app_hash)
      };
    }
    function decodeQueryProof(data2) {
      return {
        ops: data2.ops.map((op) => ({
          type: op.type,
          key: (0, encoding_1.fromBase64)(op.key),
          data: (0, encoding_1.fromBase64)(op.data)
        }))
      };
    }
    function decodeAbciQuery(data2) {
      return {
        key: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckString)(data2.key ?? "")),
        value: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckString)(data2.value ?? "")),
        proof: (0, encodings_1.may)(decodeQueryProof, data2.proofOps),
        height: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data2.height),
        code: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data2.code),
        codespace: (0, jsonchecks_1.jCheckString)(data2.codespace ?? ""),
        index: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data2.index),
        log: data2.log,
        info: (0, jsonchecks_1.jCheckString)(data2.info ?? "")
      };
    }
    function decodeEventAttribute(attribute) {
      return {
        key: (0, jsonchecks_1.jCheckNonEmptyString)(attribute.key),
        value: attribute.value ?? ""
      };
    }
    function decodeAttributes(attributes) {
      return (0, jsonchecks_1.jCheckArray)(attributes).map(decodeEventAttribute);
    }
    function decodeEvent(event) {
      return {
        type: event.type,
        attributes: event.attributes ? decodeAttributes(event.attributes) : []
      };
    }
    function decodeEvents(events) {
      return (0, jsonchecks_1.jCheckArray)(events).map(decodeEvent);
    }
    function decodeTxData(data2) {
      return {
        code: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNumber)(data2.code ?? 0)),
        codespace: data2.codespace,
        log: data2.log,
        data: (0, encodings_1.may)(encoding_1.fromBase64, data2.data),
        events: data2.events ? decodeEvents(data2.events) : [],
        gasWanted: (0, inthelpers_1.apiToBigInt)(data2.gas_wanted ?? "0"),
        gasUsed: (0, inthelpers_1.apiToBigInt)(data2.gas_used ?? "0")
      };
    }
    function decodePubkey(data2) {
      if ("Sum" in data2) {
        const [[algorithm, value]] = Object.entries(data2.Sum.value);
        (0, utils_1.assert)(algorithm === "ed25519" || algorithm === "secp256k1", `unknown pubkey type: ${algorithm}`);
        return {
          algorithm,
          data: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(value))
        };
      } else {
        switch (data2.type) {
          // go-amino special code
          case "tendermint/PubKeyEd25519":
            return {
              algorithm: "ed25519",
              data: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data2.value))
            };
          case "tendermint/PubKeySecp256k1":
            return {
              algorithm: "secp256k1",
              data: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data2.value))
            };
          default:
            throw new Error(`unknown pubkey type: ${data2.type}`);
        }
      }
    }
    function decodeBlockParams(data2) {
      return {
        maxBytes: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.max_bytes)),
        maxGas: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.max_gas))
      };
    }
    function decodeEvidenceParams(data2) {
      return {
        maxAgeNumBlocks: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.max_age_num_blocks)),
        maxAgeDuration: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.max_age_duration))
      };
    }
    function decodeConsensusParams(data2) {
      return {
        block: data2.block ? decodeBlockParams((0, jsonchecks_1.jCheckObject)(data2.block)) : void 0,
        evidence: data2.evidence ? decodeEvidenceParams((0, jsonchecks_1.jCheckObject)(data2.evidence)) : void 0
      };
    }
    function decodeValidatorUpdate(data2) {
      return {
        pubkey: {
          bytes: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckString)(data2.pub_key_bytes)),
          type: (0, jsonchecks_1.jCheckString)(data2.pub_key_type)
        },
        votingPower: (0, inthelpers_1.apiToBigInt)(data2.power ?? "0")
      };
    }
    function decodeBlockResults(data2) {
      return {
        height: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.height)),
        results: (data2.txs_results || []).map(decodeTxData),
        validatorUpdates: (data2.validator_updates || []).map(decodeValidatorUpdate),
        consensusUpdates: (0, encodings_1.may)(decodeConsensusParams, data2.consensus_param_updates),
        finalizeBlockEvents: decodeEvents(data2.finalize_block_events || [])
      };
    }
    function decodeBlockId(data2) {
      return {
        hash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.hash)),
        parts: {
          total: (0, jsonchecks_1.jCheckNonZeroNumber)(data2.parts.total),
          hash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.parts.hash))
        }
      };
    }
    function decodeBlockVersion(data2) {
      return {
        block: (0, inthelpers_1.apiToSmallInt)(data2.block),
        app: (0, inthelpers_1.apiToSmallInt)(data2.app ?? 0)
      };
    }
    function decodeHeader(data2) {
      return {
        version: decodeBlockVersion(data2.version),
        chainId: (0, jsonchecks_1.jCheckNonEmptyString)(data2.chain_id),
        height: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.height)),
        time: (0, dates_1.fromRfc3339WithNanoseconds)((0, jsonchecks_1.jCheckNonEmptyString)(data2.time)),
        // When there is no last block ID (i.e. this block's height is 1), we get an empty structure like this:
        // { hash: '', parts: { total: 0, hash: '' } }
        lastBlockId: data2.last_block_id.hash ? decodeBlockId(data2.last_block_id) : null,
        lastCommitHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data2.last_commit_hash)),
        dataHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data2.data_hash)),
        validatorsHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data2.validators_hash)),
        nextValidatorsHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data2.next_validators_hash)),
        consensusHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data2.consensus_hash)),
        appHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data2.app_hash)),
        lastResultsHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data2.last_results_hash)),
        evidenceHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data2.evidence_hash)),
        proposerAddress: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.proposer_address))
      };
    }
    function decodeBlockMeta(data2) {
      return {
        blockId: decodeBlockId(data2.block_id),
        blockSize: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.block_size)),
        header: decodeHeader(data2.header),
        numTxs: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.num_txs))
      };
    }
    function decodeBlockchain(data2) {
      return {
        lastHeight: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.last_height)),
        blockMetas: (0, jsonchecks_1.jCheckArray)(data2.block_metas).map(decodeBlockMeta)
      };
    }
    function decodeBroadcastTxSync(data2) {
      return {
        ...decodeTxData(data2),
        hash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.hash))
      };
    }
    function decodeBroadcastTxCommit(data2) {
      const txResult = data2.tx_result ? decodeTxData(data2.tx_result) : void 0;
      return {
        height: (0, inthelpers_1.apiToSmallInt)(data2.height),
        hash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.hash)),
        checkTx: decodeTxData((0, jsonchecks_1.jCheckObject)(data2.check_tx)),
        deliverTx: txResult,
        txResult
      };
    }
    function decodeBlockIdFlag(blockIdFlag) {
      (0, utils_1.assert)(blockIdFlag in types_1.BlockIdFlag);
      return blockIdFlag;
    }
    function decodeCommitSignature(data2) {
      return {
        blockIdFlag: decodeBlockIdFlag(data2.block_id_flag),
        validatorAddress: data2.validator_address ? (0, encoding_1.fromHex)(data2.validator_address) : void 0,
        timestamp: data2.timestamp ? (0, dates_1.fromRfc3339WithNanoseconds)(data2.timestamp) : void 0,
        signature: data2.signature ? (0, encoding_1.fromBase64)(data2.signature) : void 0
      };
    }
    function decodeCommit(data2) {
      return {
        blockId: decodeBlockId((0, jsonchecks_1.jCheckObject)(data2.block_id)),
        height: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.height)),
        round: (0, inthelpers_1.apiToSmallInt)(data2.round),
        signatures: data2.signatures ? (0, jsonchecks_1.jCheckArray)(data2.signatures).map(decodeCommitSignature) : []
      };
    }
    function decodeCommitResponse(data2) {
      return {
        canonical: (0, jsonchecks_1.jCheckBoolean)(data2.canonical),
        header: decodeHeader(data2.signed_header.header),
        commit: decodeCommit(data2.signed_header.commit)
      };
    }
    function decodeValidatorGenesis(data2) {
      return {
        address: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.address)),
        pubkey: decodePubkey((0, jsonchecks_1.jCheckObject)(data2.pub_key)),
        power: (0, inthelpers_1.apiToBigInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.power)),
        name: data2.name
      };
    }
    function decodeGenesis(data2) {
      return {
        genesisTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, jsonchecks_1.jCheckNonEmptyString)(data2.genesis_time)),
        chainId: (0, jsonchecks_1.jCheckNonEmptyString)(data2.chain_id),
        consensusParams: decodeConsensusParams(data2.consensus_params),
        validators: data2.validators ? (0, jsonchecks_1.jCheckArray)(data2.validators).map(decodeValidatorGenesis) : [],
        appHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data2.app_hash)),
        // empty string in kvstore app
        appState: data2.app_state
      };
    }
    function decodeValidatorInfo(data2) {
      return {
        pubkey: decodePubkey((0, jsonchecks_1.jCheckObject)(data2.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.voting_power)),
        address: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.address)),
        proposerPriority: data2.proposer_priority ? (0, inthelpers_1.apiToSmallInt)(data2.proposer_priority) : void 0
      };
    }
    function decodeNodeInfo(data2) {
      return {
        id: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.id)),
        listenAddr: (0, jsonchecks_1.jCheckNonEmptyString)(data2.listen_addr),
        network: (0, jsonchecks_1.jCheckNonEmptyString)(data2.network),
        version: (0, jsonchecks_1.jCheckString)(data2.version),
        // Can be empty (https://github.com/cosmos/cosmos-sdk/issues/7963)
        channels: (0, jsonchecks_1.jCheckString)(data2.channels),
        // can be empty
        moniker: (0, jsonchecks_1.jCheckNonEmptyString)(data2.moniker),
        other: (0, encodings_1.dictionaryToStringMap)(data2.other),
        protocolVersion: {
          app: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.protocol_version.app)),
          block: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.protocol_version.block)),
          p2p: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.protocol_version.p2p))
        }
      };
    }
    function decodeSyncInfo(data2) {
      const earliestBlockHeight = data2.earliest_block_height ? (0, inthelpers_1.apiToSmallInt)(data2.earliest_block_height) : void 0;
      const earliestBlockTime = data2.earliest_block_time ? (0, dates_1.fromRfc3339WithNanoseconds)(data2.earliest_block_time) : void 0;
      return {
        earliestAppHash: data2.earliest_app_hash ? (0, encoding_1.fromHex)(data2.earliest_app_hash) : void 0,
        earliestBlockHash: data2.earliest_block_hash ? (0, encoding_1.fromHex)(data2.earliest_block_hash) : void 0,
        earliestBlockHeight: earliestBlockHeight || void 0,
        earliestBlockTime: earliestBlockTime?.getTime() ? earliestBlockTime : void 0,
        latestBlockHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.latest_block_hash)),
        latestAppHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.latest_app_hash)),
        latestBlockTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, jsonchecks_1.jCheckNonEmptyString)(data2.latest_block_time)),
        latestBlockHeight: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.latest_block_height)),
        catchingUp: (0, jsonchecks_1.jCheckBoolean)(data2.catching_up)
      };
    }
    function decodeStatus(data2) {
      return {
        nodeInfo: decodeNodeInfo(data2.node_info),
        syncInfo: decodeSyncInfo(data2.sync_info),
        validatorInfo: decodeValidatorInfo(data2.validator_info)
      };
    }
    function decodeTxProof(data2) {
      return {
        data: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data2.data)),
        rootHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.root_hash)),
        proof: {
          total: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.proof.total)),
          index: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.proof.index)),
          leafHash: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data2.proof.leaf_hash)),
          aunts: (0, jsonchecks_1.jCheckArray)(data2.proof.aunts).map(encoding_1.fromBase64)
        }
      };
    }
    function decodeTxResponse(data2) {
      return {
        tx: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data2.tx)),
        result: decodeTxData((0, jsonchecks_1.jCheckObject)(data2.tx_result)),
        height: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.height)),
        index: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNumber)(data2.index)),
        hash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.hash)),
        proof: (0, encodings_1.may)(decodeTxProof, data2.proof)
      };
    }
    function decodeTxSearch(data2) {
      return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.total_count)),
        txs: (0, jsonchecks_1.jCheckArray)(data2.txs).map(decodeTxResponse)
      };
    }
    function decodeTxEvent(data2) {
      const tx = (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data2.tx));
      return {
        tx,
        hash: (0, hasher_1.hashTx)(tx),
        result: decodeTxData(data2.result),
        height: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.height))
      };
    }
    function decodeValidators(data2) {
      return {
        blockHeight: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.block_height)),
        validators: (0, jsonchecks_1.jCheckArray)(data2.validators).map(decodeValidatorInfo),
        count: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.count)),
        total: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.total))
      };
    }
    function decodeBlock(data2) {
      return {
        header: decodeHeader((0, jsonchecks_1.jCheckObject)(data2.header)),
        // For the block at height 1, last commit is not set. This is represented in an empty object like this:
        // { height: '0', round: 0, block_id: { hash: '', parts: [Object] }, signatures: [] }
        lastCommit: data2.last_commit.block_id.hash ? decodeCommit((0, jsonchecks_1.jCheckObject)(data2.last_commit)) : null,
        txs: data2.data.txs ? (0, jsonchecks_1.jCheckArray)(data2.data.txs).map(encoding_1.fromBase64) : [],
        // Lift up .evidence.evidence to just .evidence
        // See https://github.com/tendermint/tendermint/issues/7697
        evidence: data2.evidence?.evidence ?? []
      };
    }
    function decodeBlockResponse(data2) {
      return {
        blockId: decodeBlockId(data2.block_id),
        block: decodeBlock(data2.block)
      };
    }
    function decodeBlockSearch(data2) {
      return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.total_count)),
        blocks: (0, jsonchecks_1.jCheckArray)(data2.blocks).map(decodeBlockResponse)
      };
    }
    function decodeNumUnconfirmedTxs(data2) {
      return {
        total: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.total)),
        totalBytes: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.total_bytes))
      };
    }
    var Responses = class _Responses {
      static decodeAbciInfo(response) {
        return decodeAbciInfo((0, jsonchecks_1.jCheckObject)(response.result.response));
      }
      static decodeAbciQuery(response) {
        return decodeAbciQuery((0, jsonchecks_1.jCheckObject)(response.result.response));
      }
      static decodeBlock(response) {
        return decodeBlockResponse(response.result);
      }
      static decodeBlockResults(response) {
        return decodeBlockResults(response.result);
      }
      static decodeBlockSearch(response) {
        return decodeBlockSearch(response.result);
      }
      static decodeBlockchain(response) {
        return decodeBlockchain(response.result);
      }
      static decodeBroadcastTxSync(response) {
        return decodeBroadcastTxSync(response.result);
      }
      static decodeBroadcastTxAsync(response) {
        return _Responses.decodeBroadcastTxSync(response);
      }
      static decodeBroadcastTxCommit(response) {
        return decodeBroadcastTxCommit(response.result);
      }
      static decodeCommit(response) {
        return decodeCommitResponse(response.result);
      }
      static decodeGenesis(response) {
        return decodeGenesis((0, jsonchecks_1.jCheckObject)(response.result.genesis));
      }
      static decodeHealth() {
        return null;
      }
      static decodeNumUnconfirmedTxs(response) {
        return decodeNumUnconfirmedTxs(response.result);
      }
      static decodeStatus(response) {
        return decodeStatus(response.result);
      }
      static decodeNewBlockEvent(event) {
        return decodeBlock(event.data.value.block);
      }
      static decodeNewBlockHeaderEvent(event) {
        return decodeHeader(event.data.value.header);
      }
      static decodeTxEvent(event) {
        return decodeTxEvent(event.data.value.TxResult);
      }
      static decodeTx(response) {
        return decodeTxResponse(response.result);
      }
      static decodeTxSearch(response) {
        return decodeTxSearch(response.result);
      }
      static decodeValidators(response) {
        return decodeValidators(response.result);
      }
    };
    exports.Responses = Responses;
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/comet1/adaptor/index.js
var require_adaptor = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/comet1/adaptor/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Responses = exports.Params = void 0;
    var requests_1 = require_requests2();
    Object.defineProperty(exports, "Params", { enumerable: true, get: function() {
      return requests_1.Params;
    } });
    var responses_1 = require_responses();
    Object.defineProperty(exports, "Responses", { enumerable: true, get: function() {
      return responses_1.Responses;
    } });
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/comet1/comet1client.js
var require_comet1client = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/comet1/comet1client.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o3, m3, k5, k22) {
      if (k22 === void 0) k22 = k5;
      var desc = Object.getOwnPropertyDescriptor(m3, k5);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k5];
        } };
      }
      Object.defineProperty(o3, k22, desc);
    }) : (function(o3, m3, k5, k22) {
      if (k22 === void 0) k22 = k5;
      o3[k22] = m3[k5];
    }));
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o3, v9) {
      Object.defineProperty(o3, "default", { enumerable: true, value: v9 });
    }) : function(o3, v9) {
      o3["default"] = v9;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
      var ownKeys = function(o3) {
        ownKeys = Object.getOwnPropertyNames || function(o4) {
          var ar3 = [];
          for (var k5 in o4) if (Object.prototype.hasOwnProperty.call(o4, k5)) ar3[ar3.length] = k5;
          return ar3;
        };
        return ownKeys(o3);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k5 = ownKeys(mod), i3 = 0; i3 < k5.length; i3++) if (k5[i3] !== "default") __createBinding(result, mod, k5[i3]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Comet1Client = void 0;
    var rpcclients_1 = require_rpcclients();
    var adaptor_1 = require_adaptor();
    var requests = __importStar(require_requests());
    var Comet1Client = class _Comet1Client {
      /**
       * Creates a new Tendermint client for the given endpoint.
       *
       * Uses HTTP when the URL schema is http or https. Uses WebSockets otherwise.
       */
      static async connect(endpoint) {
        let rpcClient;
        if (typeof endpoint === "object") {
          rpcClient = new rpcclients_1.HttpClient(endpoint);
        } else {
          const useHttp = endpoint.startsWith("http://") || endpoint.startsWith("https://");
          rpcClient = useHttp ? new rpcclients_1.HttpClient(endpoint) : new rpcclients_1.WebsocketClient(endpoint);
        }
        return _Comet1Client.create(rpcClient);
      }
      /**
       * Creates a new Comet BFT client given an RPC client.
       */
      static create(rpcClient) {
        return new _Comet1Client(rpcClient);
      }
      client;
      /**
       * Use `Comet1Client.connect` or `Comet1Client.create` to create an instance.
       */
      constructor(client) {
        this.client = client;
      }
      disconnect() {
        this.client.disconnect();
      }
      async abciInfo() {
        const query = { method: requests.Method.AbciInfo };
        return this.doCall(query, adaptor_1.Params.encodeAbciInfo, adaptor_1.Responses.decodeAbciInfo);
      }
      async abciQuery(params) {
        const query = { params, method: requests.Method.AbciQuery };
        return this.doCall(query, adaptor_1.Params.encodeAbciQuery, adaptor_1.Responses.decodeAbciQuery);
      }
      async block(height) {
        const query = { method: requests.Method.Block, params: { height } };
        return this.doCall(query, adaptor_1.Params.encodeBlock, adaptor_1.Responses.decodeBlock);
      }
      async blockResults(height) {
        const query = {
          method: requests.Method.BlockResults,
          params: { height }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockResults, adaptor_1.Responses.decodeBlockResults);
      }
      /**
       * Search for events that are in a block.
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/block_search
       */
      async blockSearch(params) {
        const query = { params, method: requests.Method.BlockSearch };
        const resp = await this.doCall(query, adaptor_1.Params.encodeBlockSearch, adaptor_1.Responses.decodeBlockSearch);
        return {
          ...resp,
          // make sure we sort by height, as tendermint may be sorting by string value of the height
          blocks: [...resp.blocks].sort((a2, b5) => a2.block.header.height - b5.block.header.height)
        };
      }
      // this should paginate through all blockSearch options to ensure it returns all results.
      // starts with page 1 or whatever was provided (eg. to start on page 7)
      //
      // NOTE
      // This method will error on any node that is running a Tendermint version lower than 0.34.9.
      async blockSearchAll(params) {
        let page = params.page || 1;
        const blocks = [];
        let done = false;
        while (!done) {
          const resp = await this.blockSearch({ ...params, page });
          blocks.push(...resp.blocks);
          if (blocks.length < resp.totalCount) {
            page++;
          } else {
            done = true;
          }
        }
        blocks.sort((a2, b5) => a2.block.header.height - b5.block.header.height);
        return {
          totalCount: blocks.length,
          blocks
        };
      }
      /**
       * Queries block headers filtered by minHeight <= height <= maxHeight.
       *
       * @param minHeight The minimum height to be included in the result. Defaults to 0.
       * @param maxHeight The maximum height to be included in the result. Defaults to infinity.
       */
      async blockchain(minHeight, maxHeight) {
        const query = {
          method: requests.Method.Blockchain,
          params: {
            minHeight,
            maxHeight
          }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockchain, adaptor_1.Responses.decodeBlockchain);
      }
      /**
       * Broadcast transaction to mempool and wait for response
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_sync
       */
      async broadcastTxSync(params) {
        const query = { params, method: requests.Method.BroadcastTxSync };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxSync);
      }
      /**
       * Broadcast transaction to mempool and do not wait for result
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_async
       */
      async broadcastTxAsync(params) {
        const query = { params, method: requests.Method.BroadcastTxAsync };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxAsync);
      }
      /**
       * Broadcast transaction to mempool and wait for block
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_commit
       */
      async broadcastTxCommit(params) {
        const query = { params, method: requests.Method.BroadcastTxCommit };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxCommit);
      }
      async commit(height) {
        const query = { method: requests.Method.Commit, params: { height } };
        return this.doCall(query, adaptor_1.Params.encodeCommit, adaptor_1.Responses.decodeCommit);
      }
      async genesis() {
        const query = { method: requests.Method.Genesis };
        return this.doCall(query, adaptor_1.Params.encodeGenesis, adaptor_1.Responses.decodeGenesis);
      }
      async health() {
        const query = { method: requests.Method.Health };
        return this.doCall(query, adaptor_1.Params.encodeHealth, adaptor_1.Responses.decodeHealth);
      }
      async numUnconfirmedTxs() {
        const query = { method: requests.Method.NumUnconfirmedTxs };
        return this.doCall(query, adaptor_1.Params.encodeNumUnconfirmedTxs, adaptor_1.Responses.decodeNumUnconfirmedTxs);
      }
      async status() {
        const query = { method: requests.Method.Status };
        return this.doCall(query, adaptor_1.Params.encodeStatus, adaptor_1.Responses.decodeStatus);
      }
      subscribeNewBlock() {
        const request = {
          method: requests.Method.Subscribe,
          query: { type: requests.SubscriptionEventType.NewBlock }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockEvent);
      }
      subscribeNewBlockHeader() {
        const request = {
          method: requests.Method.Subscribe,
          query: { type: requests.SubscriptionEventType.NewBlockHeader }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockHeaderEvent);
      }
      subscribeTx(query) {
        const request = {
          method: requests.Method.Subscribe,
          query: {
            type: requests.SubscriptionEventType.Tx,
            raw: query
          }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeTxEvent);
      }
      /**
       * Get a single transaction by hash
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/tx
       */
      async tx(params) {
        const query = { params, method: requests.Method.Tx };
        return this.doCall(query, adaptor_1.Params.encodeTx, adaptor_1.Responses.decodeTx);
      }
      /**
       * Search for transactions that are in a block
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/tx_search
       */
      async txSearch(params) {
        const query = { params, method: requests.Method.TxSearch };
        return this.doCall(query, adaptor_1.Params.encodeTxSearch, adaptor_1.Responses.decodeTxSearch);
      }
      // this should paginate through all txSearch options to ensure it returns all results.
      // starts with page 1 or whatever was provided (eg. to start on page 7)
      async txSearchAll(params) {
        let page = params.page || 1;
        const txs = [];
        let done = false;
        while (!done) {
          const resp = await this.txSearch({ ...params, page });
          txs.push(...resp.txs);
          if (txs.length < resp.totalCount) {
            page++;
          } else {
            done = true;
          }
        }
        return {
          totalCount: txs.length,
          txs
        };
      }
      async validators(params) {
        const query = {
          method: requests.Method.Validators,
          params
        };
        return this.doCall(query, adaptor_1.Params.encodeValidators, adaptor_1.Responses.decodeValidators);
      }
      async validatorsAll(height) {
        const validators = [];
        let page = 1;
        let done = false;
        let blockHeight = height;
        while (!done) {
          const response = await this.validators({
            per_page: 50,
            height: blockHeight,
            page
          });
          validators.push(...response.validators);
          blockHeight = blockHeight || response.blockHeight;
          if (validators.length < response.total) {
            page++;
          } else {
            done = true;
          }
        }
        return {
          // NOTE: Default value is for type safety but this should always be set
          blockHeight: blockHeight ?? 0,
          count: validators.length,
          total: validators.length,
          validators
        };
      }
      // doCall is a helper to handle the encode/call/decode logic
      async doCall(request, encode, decode) {
        const req = encode(request);
        const result = await this.client.execute(req);
        return decode(result);
      }
      subscribe(request, decode) {
        if (!(0, rpcclients_1.instanceOfRpcStreamingClient)(this.client)) {
          throw new Error("This RPC client type cannot subscribe to events");
        }
        const req = adaptor_1.Params.encodeSubscribe(request);
        const eventStream = this.client.listen(req);
        return eventStream.map((event) => {
          return decode(event);
        });
      }
    };
    exports.Comet1Client = Comet1Client;
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/comet1/responses.js
var require_responses2 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/comet1/responses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VoteType = void 0;
    exports.broadcastTxSyncSuccess = broadcastTxSyncSuccess;
    exports.broadcastTxCommitSuccess = broadcastTxCommitSuccess;
    function broadcastTxSyncSuccess(res) {
      return res.code === 0;
    }
    function broadcastTxCommitSuccess(response) {
      return response.checkTx.code === 0 && !!response.deliverTx && response.deliverTx.code === 0;
    }
    var VoteType;
    (function(VoteType2) {
      VoteType2[VoteType2["PreVote"] = 1] = "PreVote";
      VoteType2[VoteType2["PreCommit"] = 2] = "PreCommit";
    })(VoteType || (exports.VoteType = VoteType = {}));
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/comet1/index.js
var require_comet1 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/comet1/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VoteType = exports.broadcastTxSyncSuccess = exports.broadcastTxCommitSuccess = exports.SubscriptionEventType = exports.Method = exports.Comet1Client = void 0;
    var comet1client_1 = require_comet1client();
    Object.defineProperty(exports, "Comet1Client", { enumerable: true, get: function() {
      return comet1client_1.Comet1Client;
    } });
    var requests_1 = require_requests();
    Object.defineProperty(exports, "Method", { enumerable: true, get: function() {
      return requests_1.Method;
    } });
    Object.defineProperty(exports, "SubscriptionEventType", { enumerable: true, get: function() {
      return requests_1.SubscriptionEventType;
    } });
    var responses_1 = require_responses2();
    Object.defineProperty(exports, "broadcastTxCommitSuccess", { enumerable: true, get: function() {
      return responses_1.broadcastTxCommitSuccess;
    } });
    Object.defineProperty(exports, "broadcastTxSyncSuccess", { enumerable: true, get: function() {
      return responses_1.broadcastTxSyncSuccess;
    } });
    Object.defineProperty(exports, "VoteType", { enumerable: true, get: function() {
      return responses_1.VoteType;
    } });
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/comet38/encodings.js
var require_encodings2 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/comet38/encodings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.may = may;
    exports.dictionaryToStringMap = dictionaryToStringMap;
    exports.encodeString = encodeString;
    exports.encodeUvarint = encodeUvarint;
    exports.encodeTime = encodeTime;
    exports.encodeBytes = encodeBytes;
    exports.encodeVersion = encodeVersion;
    exports.encodeBlockId = encodeBlockId;
    var encoding_1 = require_build2();
    function may(transform, value) {
      return value === void 0 || value === null ? void 0 : transform(value);
    }
    function dictionaryToStringMap(obj) {
      const out = /* @__PURE__ */ new Map();
      for (const key of Object.keys(obj)) {
        const value = obj[key];
        if (typeof value !== "string") {
          throw new Error("Found dictionary value of type other than string");
        }
        out.set(key, value);
      }
      return out;
    }
    function encodeString(s2) {
      const utf82 = (0, encoding_1.toUtf8)(s2);
      return Uint8Array.from([utf82.length, ...utf82]);
    }
    function encodeUvarint(n2) {
      return n2 >= 128 ? (
        // eslint-disable-next-line no-bitwise
        Uint8Array.from([n2 & 255 | 128, ...encodeUvarint(n2 >> 7)])
      ) : (
        // eslint-disable-next-line no-bitwise
        Uint8Array.from([n2 & 255])
      );
    }
    function encodeTime(time) {
      const milliseconds = time.getTime();
      const seconds = Math.floor(milliseconds / 1e3);
      const secondsArray = seconds ? [8, ...encodeUvarint(seconds)] : new Uint8Array();
      const nanoseconds = (time.nanoseconds || 0) + milliseconds % 1e3 * 1e6;
      const nanosecondsArray = nanoseconds ? [16, ...encodeUvarint(nanoseconds)] : new Uint8Array();
      return Uint8Array.from([...secondsArray, ...nanosecondsArray]);
    }
    function encodeBytes(bytes2) {
      if (bytes2.length >= 128)
        throw new Error("Not implemented for byte arrays of length 128 or more");
      return bytes2.length ? Uint8Array.from([bytes2.length, ...bytes2]) : new Uint8Array();
    }
    function encodeVersion(version) {
      const blockArray = version.block ? Uint8Array.from([8, ...encodeUvarint(version.block)]) : new Uint8Array();
      const appArray = version.app ? Uint8Array.from([16, ...encodeUvarint(version.app)]) : new Uint8Array();
      return Uint8Array.from([...blockArray, ...appArray]);
    }
    function encodeBlockId(blockId) {
      return Uint8Array.from([
        10,
        blockId.hash.length,
        ...blockId.hash,
        18,
        blockId.parts.hash.length + 4,
        8,
        blockId.parts.total,
        18,
        blockId.parts.hash.length,
        ...blockId.parts.hash
      ]);
    }
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/comet38/requests.js
var require_requests3 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/comet38/requests.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SubscriptionEventType = exports.Method = void 0;
    exports.buildQuery = buildQuery;
    var Method;
    (function(Method2) {
      Method2["AbciInfo"] = "abci_info";
      Method2["AbciQuery"] = "abci_query";
      Method2["Block"] = "block";
      Method2["Blockchain"] = "blockchain";
      Method2["BlockResults"] = "block_results";
      Method2["BlockSearch"] = "block_search";
      Method2["BroadcastTxAsync"] = "broadcast_tx_async";
      Method2["BroadcastTxSync"] = "broadcast_tx_sync";
      Method2["BroadcastTxCommit"] = "broadcast_tx_commit";
      Method2["Commit"] = "commit";
      Method2["Genesis"] = "genesis";
      Method2["Health"] = "health";
      Method2["NumUnconfirmedTxs"] = "num_unconfirmed_txs";
      Method2["Status"] = "status";
      Method2["Subscribe"] = "subscribe";
      Method2["Tx"] = "tx";
      Method2["TxSearch"] = "tx_search";
      Method2["Validators"] = "validators";
      Method2["Unsubscribe"] = "unsubscribe";
    })(Method || (exports.Method = Method = {}));
    var SubscriptionEventType;
    (function(SubscriptionEventType2) {
      SubscriptionEventType2["NewBlock"] = "NewBlock";
      SubscriptionEventType2["NewBlockHeader"] = "NewBlockHeader";
      SubscriptionEventType2["Tx"] = "Tx";
    })(SubscriptionEventType || (exports.SubscriptionEventType = SubscriptionEventType = {}));
    function buildQuery(components) {
      const tags = components.tags ? components.tags : [];
      const tagComponents = tags.map((tag) => `${tag.key}='${tag.value}'`);
      const rawComponents = components.raw ? [components.raw] : [];
      return [...tagComponents, ...rawComponents].join(" AND ");
    }
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/comet38/adaptor/requests.js
var require_requests4 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/comet38/adaptor/requests.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o3, m3, k5, k22) {
      if (k22 === void 0) k22 = k5;
      var desc = Object.getOwnPropertyDescriptor(m3, k5);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k5];
        } };
      }
      Object.defineProperty(o3, k22, desc);
    }) : (function(o3, m3, k5, k22) {
      if (k22 === void 0) k22 = k5;
      o3[k22] = m3[k5];
    }));
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o3, v9) {
      Object.defineProperty(o3, "default", { enumerable: true, value: v9 });
    }) : function(o3, v9) {
      o3["default"] = v9;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
      var ownKeys = function(o3) {
        ownKeys = Object.getOwnPropertyNames || function(o4) {
          var ar3 = [];
          for (var k5 in o4) if (Object.prototype.hasOwnProperty.call(o4, k5)) ar3[ar3.length] = k5;
          return ar3;
        };
        return ownKeys(o3);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k5 = ownKeys(mod), i3 = 0; i3 < k5.length; i3++) if (k5[i3] !== "default") __createBinding(result, mod, k5[i3]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Params = void 0;
    var encoding_1 = require_build2();
    var inthelpers_1 = require_inthelpers();
    var jsonchecks_1 = require_jsonchecks();
    var jsonrpc_1 = require_jsonrpc();
    var encodings_1 = require_encodings2();
    var requests = __importStar(require_requests3());
    function encodeHeightParam(param) {
      return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.height)
      };
    }
    function encodeBlockchainRequestParams(param) {
      return {
        minHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.minHeight),
        maxHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.maxHeight)
      };
    }
    function encodeBlockSearchParams(params) {
      return {
        query: params.query,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
      };
    }
    function encodeAbciQueryParams(params) {
      return {
        path: (0, jsonchecks_1.jCheckNonEmptyString)(params.path),
        data: (0, encoding_1.toHex)(params.data),
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        prove: params.prove
      };
    }
    function encodeBroadcastTxParams(params) {
      return {
        tx: (0, encoding_1.toBase64)(params.tx)
      };
    }
    function encodeTxParams(params) {
      return {
        hash: (0, encoding_1.toBase64)(params.hash),
        prove: params.prove
      };
    }
    function encodeTxSearchParams(params) {
      return {
        query: params.query,
        prove: params.prove,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
      };
    }
    function encodeValidatorsParams(params) {
      return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page)
      };
    }
    var Params = class {
      static encodeAbciInfo(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeAbciQuery(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeAbciQueryParams(req.params));
      }
      static encodeBlock(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeBlockchain(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockchainRequestParams(req.params));
      }
      static encodeBlockResults(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeBlockSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockSearchParams(req.params));
      }
      static encodeBroadcastTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBroadcastTxParams(req.params));
      }
      static encodeCommit(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeGenesis(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeHealth(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeNumUnconfirmedTxs(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeStatus(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeSubscribe(req) {
        const eventTag = { key: "tm.event", value: req.query.type };
        const query = requests.buildQuery({ tags: [eventTag], raw: req.query.raw });
        return (0, jsonrpc_1.createJsonRpcRequest)("subscribe", { query });
      }
      static encodeTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxParams(req.params));
      }
      // TODO: encode params for query string???
      static encodeTxSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxSearchParams(req.params));
      }
      static encodeValidators(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeValidatorsParams(req.params));
      }
    };
    exports.Params = Params;
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/comet38/hasher.js
var require_hasher2 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/comet38/hasher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashTx = hashTx;
    exports.hashBlock = hashBlock;
    var crypto_1 = require_build4();
    var encodings_1 = require_encodings2();
    function hashTx(tx) {
      return (0, crypto_1.sha256)(tx);
    }
    function getSplitPoint(n2) {
      if (n2 < 1)
        throw new Error("Cannot split an empty tree");
      const largestPowerOf2 = 2 ** Math.floor(Math.log2(n2));
      return largestPowerOf2 < n2 ? largestPowerOf2 : largestPowerOf2 / 2;
    }
    function hashLeaf(leaf) {
      const hash2 = new crypto_1.Sha256(Uint8Array.from([0]));
      hash2.update(leaf);
      return hash2.digest();
    }
    function hashInner(left, right) {
      const hash2 = new crypto_1.Sha256(Uint8Array.from([1]));
      hash2.update(left);
      hash2.update(right);
      return hash2.digest();
    }
    function hashTree(hashes) {
      switch (hashes.length) {
        case 0:
          throw new Error("Cannot hash empty tree");
        case 1:
          return hashLeaf(hashes[0]);
        default: {
          const slicePoint = getSplitPoint(hashes.length);
          const left = hashTree(hashes.slice(0, slicePoint));
          const right = hashTree(hashes.slice(slicePoint));
          return hashInner(left, right);
        }
      }
    }
    function hashBlock(header) {
      if (!header.lastBlockId) {
        throw new Error("Hashing a block header with no last block ID (i.e. header at height 1) is not supported. If you need this, contributions are welcome. Please add documentation and test vectors for this case.");
      }
      const encodedFields = [
        (0, encodings_1.encodeVersion)(header.version),
        (0, encodings_1.encodeString)(header.chainId),
        (0, encodings_1.encodeUvarint)(header.height),
        (0, encodings_1.encodeTime)(header.time),
        (0, encodings_1.encodeBlockId)(header.lastBlockId),
        (0, encodings_1.encodeBytes)(header.lastCommitHash),
        (0, encodings_1.encodeBytes)(header.dataHash),
        (0, encodings_1.encodeBytes)(header.validatorsHash),
        (0, encodings_1.encodeBytes)(header.nextValidatorsHash),
        (0, encodings_1.encodeBytes)(header.consensusHash),
        (0, encodings_1.encodeBytes)(header.appHash),
        (0, encodings_1.encodeBytes)(header.lastResultsHash),
        (0, encodings_1.encodeBytes)(header.evidenceHash),
        (0, encodings_1.encodeBytes)(header.proposerAddress)
      ];
      return hashTree(encodedFields);
    }
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/comet38/adaptor/responses.js
var require_responses3 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/comet38/adaptor/responses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Responses = void 0;
    exports.decodeEvent = decodeEvent;
    exports.decodeValidatorUpdate = decodeValidatorUpdate;
    exports.decodeCommit = decodeCommit;
    exports.decodeValidatorGenesis = decodeValidatorGenesis;
    exports.decodeValidatorInfo = decodeValidatorInfo;
    var encoding_1 = require_build2();
    var utils_1 = require_build();
    var dates_1 = require_dates();
    var inthelpers_1 = require_inthelpers();
    var jsonchecks_1 = require_jsonchecks();
    var types_1 = require_types6();
    var encodings_1 = require_encodings2();
    var hasher_1 = require_hasher2();
    function decodeAbciInfo(data2) {
      return {
        data: data2.data,
        lastBlockHeight: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data2.last_block_height),
        lastBlockAppHash: (0, encodings_1.may)(encoding_1.fromBase64, data2.last_block_app_hash)
      };
    }
    function decodeQueryProof(data2) {
      return {
        ops: data2.ops.map((op) => ({
          type: op.type,
          key: (0, encoding_1.fromBase64)(op.key),
          data: (0, encoding_1.fromBase64)(op.data)
        }))
      };
    }
    function decodeAbciQuery(data2) {
      return {
        key: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckString)(data2.key ?? "")),
        value: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckString)(data2.value ?? "")),
        proof: (0, encodings_1.may)(decodeQueryProof, data2.proofOps),
        height: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data2.height),
        code: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data2.code),
        codespace: (0, jsonchecks_1.jCheckString)(data2.codespace ?? ""),
        index: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data2.index),
        log: data2.log,
        info: (0, jsonchecks_1.jCheckString)(data2.info ?? "")
      };
    }
    function decodeEventAttribute(attribute) {
      return {
        key: (0, jsonchecks_1.jCheckNonEmptyString)(attribute.key),
        value: attribute.value ?? ""
      };
    }
    function decodeAttributes(attributes) {
      return (0, jsonchecks_1.jCheckArray)(attributes).map(decodeEventAttribute);
    }
    function decodeEvent(event) {
      return {
        type: event.type,
        attributes: event.attributes ? decodeAttributes(event.attributes) : []
      };
    }
    function decodeEvents(events) {
      return (0, jsonchecks_1.jCheckArray)(events).map(decodeEvent);
    }
    function decodeTxData(data2) {
      return {
        code: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNumber)(data2.code ?? 0)),
        codespace: data2.codespace,
        log: data2.log,
        data: (0, encodings_1.may)(encoding_1.fromBase64, data2.data),
        events: data2.events ? decodeEvents(data2.events) : [],
        gasWanted: (0, inthelpers_1.apiToBigInt)(data2.gas_wanted ?? "0"),
        gasUsed: (0, inthelpers_1.apiToBigInt)(data2.gas_used ?? "0")
      };
    }
    function decodePubkey(data2) {
      if ("Sum" in data2) {
        const [[algorithm, value]] = Object.entries(data2.Sum.value);
        (0, utils_1.assert)(algorithm === "ed25519" || algorithm === "secp256k1", `unknown pubkey type: ${algorithm}`);
        return {
          algorithm,
          data: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(value))
        };
      } else {
        switch (data2.type) {
          // go-amino special code
          case "tendermint/PubKeyEd25519":
            return {
              algorithm: "ed25519",
              data: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data2.value))
            };
          case "tendermint/PubKeySecp256k1":
            return {
              algorithm: "secp256k1",
              data: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data2.value))
            };
          default:
            throw new Error(`unknown pubkey type: ${data2.type}`);
        }
      }
    }
    function decodeBlockParams(data2) {
      return {
        maxBytes: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.max_bytes)),
        maxGas: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.max_gas))
      };
    }
    function decodeEvidenceParams(data2) {
      return {
        maxAgeNumBlocks: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.max_age_num_blocks)),
        maxAgeDuration: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.max_age_duration))
      };
    }
    function decodeConsensusParams(data2) {
      return {
        block: data2.block ? decodeBlockParams((0, jsonchecks_1.jCheckObject)(data2.block)) : void 0,
        evidence: data2.evidence ? decodeEvidenceParams((0, jsonchecks_1.jCheckObject)(data2.evidence)) : void 0
      };
    }
    function decodeValidatorUpdate(data2) {
      return {
        pubkey: decodePubkey((0, jsonchecks_1.jCheckObject)(data2.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)(data2.power ?? "0")
      };
    }
    function decodeBlockResults(data2) {
      return {
        height: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.height)),
        results: (data2.txs_results || []).map(decodeTxData),
        validatorUpdates: (data2.validator_updates || []).map(decodeValidatorUpdate),
        consensusUpdates: (0, encodings_1.may)(decodeConsensusParams, data2.consensus_param_updates),
        finalizeBlockEvents: decodeEvents(data2.finalize_block_events || [])
      };
    }
    function decodeBlockId(data2) {
      return {
        hash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.hash)),
        parts: {
          total: (0, jsonchecks_1.jCheckNonZeroNumber)(data2.parts.total),
          hash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.parts.hash))
        }
      };
    }
    function decodeBlockVersion(data2) {
      return {
        block: (0, inthelpers_1.apiToSmallInt)(data2.block),
        app: (0, inthelpers_1.apiToSmallInt)(data2.app ?? 0)
      };
    }
    function decodeHeader(data2) {
      return {
        version: decodeBlockVersion(data2.version),
        chainId: (0, jsonchecks_1.jCheckNonEmptyString)(data2.chain_id),
        height: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.height)),
        time: (0, dates_1.fromRfc3339WithNanoseconds)((0, jsonchecks_1.jCheckNonEmptyString)(data2.time)),
        // When there is no last block ID (i.e. this block's height is 1), we get an empty structure like this:
        // { hash: '', parts: { total: 0, hash: '' } }
        lastBlockId: data2.last_block_id.hash ? decodeBlockId(data2.last_block_id) : null,
        lastCommitHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data2.last_commit_hash)),
        dataHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data2.data_hash)),
        validatorsHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data2.validators_hash)),
        nextValidatorsHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data2.next_validators_hash)),
        consensusHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data2.consensus_hash)),
        appHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data2.app_hash)),
        lastResultsHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data2.last_results_hash)),
        evidenceHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data2.evidence_hash)),
        proposerAddress: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.proposer_address))
      };
    }
    function decodeBlockMeta(data2) {
      return {
        blockId: decodeBlockId(data2.block_id),
        blockSize: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.block_size)),
        header: decodeHeader(data2.header),
        numTxs: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.num_txs))
      };
    }
    function decodeBlockchain(data2) {
      return {
        lastHeight: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.last_height)),
        blockMetas: (0, jsonchecks_1.jCheckArray)(data2.block_metas).map(decodeBlockMeta)
      };
    }
    function decodeBroadcastTxSync(data2) {
      return {
        ...decodeTxData(data2),
        hash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.hash))
      };
    }
    function decodeBroadcastTxCommit(data2) {
      const txResult = data2.tx_result ? decodeTxData(data2.tx_result) : void 0;
      return {
        height: (0, inthelpers_1.apiToSmallInt)(data2.height),
        hash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.hash)),
        checkTx: decodeTxData((0, jsonchecks_1.jCheckObject)(data2.check_tx)),
        deliverTx: txResult,
        txResult
      };
    }
    function decodeBlockIdFlag(blockIdFlag) {
      (0, utils_1.assert)(blockIdFlag in types_1.BlockIdFlag);
      return blockIdFlag;
    }
    function decodeCommitSignature(data2) {
      return {
        blockIdFlag: decodeBlockIdFlag(data2.block_id_flag),
        validatorAddress: data2.validator_address ? (0, encoding_1.fromHex)(data2.validator_address) : void 0,
        timestamp: data2.timestamp ? (0, dates_1.fromRfc3339WithNanoseconds)(data2.timestamp) : void 0,
        signature: data2.signature ? (0, encoding_1.fromBase64)(data2.signature) : void 0
      };
    }
    function decodeCommit(data2) {
      return {
        blockId: decodeBlockId((0, jsonchecks_1.jCheckObject)(data2.block_id)),
        height: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.height)),
        round: (0, inthelpers_1.apiToSmallInt)(data2.round),
        signatures: data2.signatures ? (0, jsonchecks_1.jCheckArray)(data2.signatures).map(decodeCommitSignature) : []
      };
    }
    function decodeCommitResponse(data2) {
      return {
        canonical: (0, jsonchecks_1.jCheckBoolean)(data2.canonical),
        header: decodeHeader(data2.signed_header.header),
        commit: decodeCommit(data2.signed_header.commit)
      };
    }
    function decodeValidatorGenesis(data2) {
      return {
        address: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.address)),
        pubkey: decodePubkey((0, jsonchecks_1.jCheckObject)(data2.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.power))
        // Field `name` is omitted because return type `responses.Validator` doesn't have it. Fixed
        // in comet1 adapter. We could backport this change but want to avoid unnecessary breakage.
      };
    }
    function decodeGenesis(data2) {
      return {
        genesisTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, jsonchecks_1.jCheckNonEmptyString)(data2.genesis_time)),
        chainId: (0, jsonchecks_1.jCheckNonEmptyString)(data2.chain_id),
        consensusParams: decodeConsensusParams(data2.consensus_params),
        validators: data2.validators ? (0, jsonchecks_1.jCheckArray)(data2.validators).map(decodeValidatorGenesis) : [],
        appHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data2.app_hash)),
        // empty string in kvstore app
        appState: data2.app_state
      };
    }
    function decodeValidatorInfo(data2) {
      return {
        pubkey: decodePubkey((0, jsonchecks_1.jCheckObject)(data2.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.voting_power)),
        address: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.address)),
        proposerPriority: data2.proposer_priority ? (0, inthelpers_1.apiToSmallInt)(data2.proposer_priority) : void 0
      };
    }
    function decodeNodeInfo(data2) {
      return {
        id: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.id)),
        listenAddr: (0, jsonchecks_1.jCheckNonEmptyString)(data2.listen_addr),
        network: (0, jsonchecks_1.jCheckNonEmptyString)(data2.network),
        version: (0, jsonchecks_1.jCheckString)(data2.version),
        // Can be empty (https://github.com/cosmos/cosmos-sdk/issues/7963)
        channels: (0, jsonchecks_1.jCheckString)(data2.channels),
        // can be empty
        moniker: (0, jsonchecks_1.jCheckNonEmptyString)(data2.moniker),
        other: (0, encodings_1.dictionaryToStringMap)(data2.other),
        protocolVersion: {
          app: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.protocol_version.app)),
          block: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.protocol_version.block)),
          p2p: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.protocol_version.p2p))
        }
      };
    }
    function decodeSyncInfo(data2) {
      const earliestBlockHeight = data2.earliest_block_height ? (0, inthelpers_1.apiToSmallInt)(data2.earliest_block_height) : void 0;
      const earliestBlockTime = data2.earliest_block_time ? (0, dates_1.fromRfc3339WithNanoseconds)(data2.earliest_block_time) : void 0;
      return {
        earliestAppHash: data2.earliest_app_hash ? (0, encoding_1.fromHex)(data2.earliest_app_hash) : void 0,
        earliestBlockHash: data2.earliest_block_hash ? (0, encoding_1.fromHex)(data2.earliest_block_hash) : void 0,
        earliestBlockHeight: earliestBlockHeight || void 0,
        earliestBlockTime: earliestBlockTime?.getTime() ? earliestBlockTime : void 0,
        latestBlockHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.latest_block_hash)),
        latestAppHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.latest_app_hash)),
        latestBlockTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, jsonchecks_1.jCheckNonEmptyString)(data2.latest_block_time)),
        latestBlockHeight: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.latest_block_height)),
        catchingUp: (0, jsonchecks_1.jCheckBoolean)(data2.catching_up)
      };
    }
    function decodeStatus(data2) {
      return {
        nodeInfo: decodeNodeInfo(data2.node_info),
        syncInfo: decodeSyncInfo(data2.sync_info),
        validatorInfo: decodeValidatorInfo(data2.validator_info)
      };
    }
    function decodeTxProof(data2) {
      return {
        data: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data2.data)),
        rootHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.root_hash)),
        proof: {
          total: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.proof.total)),
          index: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.proof.index)),
          leafHash: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data2.proof.leaf_hash)),
          aunts: (0, jsonchecks_1.jCheckArray)(data2.proof.aunts).map(encoding_1.fromBase64)
        }
      };
    }
    function decodeTxResponse(data2) {
      return {
        tx: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data2.tx)),
        result: decodeTxData((0, jsonchecks_1.jCheckObject)(data2.tx_result)),
        height: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.height)),
        index: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNumber)(data2.index)),
        hash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.hash)),
        proof: (0, encodings_1.may)(decodeTxProof, data2.proof)
      };
    }
    function decodeTxSearch(data2) {
      return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.total_count)),
        txs: (0, jsonchecks_1.jCheckArray)(data2.txs).map(decodeTxResponse)
      };
    }
    function decodeTxEvent(data2) {
      const tx = (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data2.tx));
      return {
        tx,
        hash: (0, hasher_1.hashTx)(tx),
        result: decodeTxData(data2.result),
        height: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.height))
      };
    }
    function decodeValidators(data2) {
      return {
        blockHeight: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.block_height)),
        validators: (0, jsonchecks_1.jCheckArray)(data2.validators).map(decodeValidatorInfo),
        count: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.count)),
        total: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.total))
      };
    }
    function decodeBlock(data2) {
      return {
        header: decodeHeader((0, jsonchecks_1.jCheckObject)(data2.header)),
        // For the block at height 1, last commit is not set. This is represented in an empty object like this:
        // { height: '0', round: 0, block_id: { hash: '', parts: [Object] }, signatures: [] }
        lastCommit: data2.last_commit.block_id.hash ? decodeCommit((0, jsonchecks_1.jCheckObject)(data2.last_commit)) : null,
        txs: data2.data.txs ? (0, jsonchecks_1.jCheckArray)(data2.data.txs).map(encoding_1.fromBase64) : [],
        // Lift up .evidence.evidence to just .evidence
        // See https://github.com/tendermint/tendermint/issues/7697
        evidence: data2.evidence?.evidence ?? []
      };
    }
    function decodeBlockResponse(data2) {
      return {
        blockId: decodeBlockId(data2.block_id),
        block: decodeBlock(data2.block)
      };
    }
    function decodeBlockSearch(data2) {
      return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.total_count)),
        blocks: (0, jsonchecks_1.jCheckArray)(data2.blocks).map(decodeBlockResponse)
      };
    }
    function decodeNumUnconfirmedTxs(data2) {
      return {
        total: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.total)),
        totalBytes: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.total_bytes))
      };
    }
    var Responses = class _Responses {
      static decodeAbciInfo(response) {
        return decodeAbciInfo((0, jsonchecks_1.jCheckObject)(response.result.response));
      }
      static decodeAbciQuery(response) {
        return decodeAbciQuery((0, jsonchecks_1.jCheckObject)(response.result.response));
      }
      static decodeBlock(response) {
        return decodeBlockResponse(response.result);
      }
      static decodeBlockResults(response) {
        return decodeBlockResults(response.result);
      }
      static decodeBlockSearch(response) {
        return decodeBlockSearch(response.result);
      }
      static decodeBlockchain(response) {
        return decodeBlockchain(response.result);
      }
      static decodeBroadcastTxSync(response) {
        return decodeBroadcastTxSync(response.result);
      }
      static decodeBroadcastTxAsync(response) {
        return _Responses.decodeBroadcastTxSync(response);
      }
      static decodeBroadcastTxCommit(response) {
        return decodeBroadcastTxCommit(response.result);
      }
      static decodeCommit(response) {
        return decodeCommitResponse(response.result);
      }
      static decodeGenesis(response) {
        return decodeGenesis((0, jsonchecks_1.jCheckObject)(response.result.genesis));
      }
      static decodeHealth() {
        return null;
      }
      static decodeNumUnconfirmedTxs(response) {
        return decodeNumUnconfirmedTxs(response.result);
      }
      static decodeStatus(response) {
        return decodeStatus(response.result);
      }
      static decodeNewBlockEvent(event) {
        return decodeBlock(event.data.value.block);
      }
      static decodeNewBlockHeaderEvent(event) {
        return decodeHeader(event.data.value.header);
      }
      static decodeTxEvent(event) {
        return decodeTxEvent(event.data.value.TxResult);
      }
      static decodeTx(response) {
        return decodeTxResponse(response.result);
      }
      static decodeTxSearch(response) {
        return decodeTxSearch(response.result);
      }
      static decodeValidators(response) {
        return decodeValidators(response.result);
      }
    };
    exports.Responses = Responses;
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/comet38/adaptor/index.js
var require_adaptor2 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/comet38/adaptor/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Responses = exports.Params = void 0;
    var requests_1 = require_requests4();
    Object.defineProperty(exports, "Params", { enumerable: true, get: function() {
      return requests_1.Params;
    } });
    var responses_1 = require_responses3();
    Object.defineProperty(exports, "Responses", { enumerable: true, get: function() {
      return responses_1.Responses;
    } });
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/comet38/comet38client.js
var require_comet38client = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/comet38/comet38client.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o3, m3, k5, k22) {
      if (k22 === void 0) k22 = k5;
      var desc = Object.getOwnPropertyDescriptor(m3, k5);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k5];
        } };
      }
      Object.defineProperty(o3, k22, desc);
    }) : (function(o3, m3, k5, k22) {
      if (k22 === void 0) k22 = k5;
      o3[k22] = m3[k5];
    }));
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o3, v9) {
      Object.defineProperty(o3, "default", { enumerable: true, value: v9 });
    }) : function(o3, v9) {
      o3["default"] = v9;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
      var ownKeys = function(o3) {
        ownKeys = Object.getOwnPropertyNames || function(o4) {
          var ar3 = [];
          for (var k5 in o4) if (Object.prototype.hasOwnProperty.call(o4, k5)) ar3[ar3.length] = k5;
          return ar3;
        };
        return ownKeys(o3);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k5 = ownKeys(mod), i3 = 0; i3 < k5.length; i3++) if (k5[i3] !== "default") __createBinding(result, mod, k5[i3]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Comet38Client = void 0;
    var rpcclients_1 = require_rpcclients();
    var adaptor_1 = require_adaptor2();
    var requests = __importStar(require_requests3());
    var Comet38Client = class _Comet38Client {
      /**
       * Creates a new Tendermint client for the given endpoint.
       *
       * Uses HTTP when the URL schema is http or https. Uses WebSockets otherwise.
       */
      static async connect(endpoint) {
        let rpcClient;
        if (typeof endpoint === "object") {
          rpcClient = new rpcclients_1.HttpClient(endpoint);
        } else {
          const useHttp = endpoint.startsWith("http://") || endpoint.startsWith("https://");
          rpcClient = useHttp ? new rpcclients_1.HttpClient(endpoint) : new rpcclients_1.WebsocketClient(endpoint);
        }
        return _Comet38Client.create(rpcClient);
      }
      /**
       * Creates a new Tendermint client given an RPC client.
       */
      static create(rpcClient) {
        return new _Comet38Client(rpcClient);
      }
      client;
      /**
       * Use `Tendermint37Client.connect` or `Tendermint37Client.create` to create an instance.
       */
      constructor(client) {
        this.client = client;
      }
      disconnect() {
        this.client.disconnect();
      }
      async abciInfo() {
        const query = { method: requests.Method.AbciInfo };
        return this.doCall(query, adaptor_1.Params.encodeAbciInfo, adaptor_1.Responses.decodeAbciInfo);
      }
      async abciQuery(params) {
        const query = { params, method: requests.Method.AbciQuery };
        return this.doCall(query, adaptor_1.Params.encodeAbciQuery, adaptor_1.Responses.decodeAbciQuery);
      }
      async block(height) {
        const query = { method: requests.Method.Block, params: { height } };
        return this.doCall(query, adaptor_1.Params.encodeBlock, adaptor_1.Responses.decodeBlock);
      }
      async blockResults(height) {
        const query = {
          method: requests.Method.BlockResults,
          params: { height }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockResults, adaptor_1.Responses.decodeBlockResults);
      }
      /**
       * Search for events that are in a block.
       *
       * NOTE
       * This method will error on any node that is running a Tendermint version lower than 0.34.9.
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/block_search
       */
      async blockSearch(params) {
        const query = { params, method: requests.Method.BlockSearch };
        const resp = await this.doCall(query, adaptor_1.Params.encodeBlockSearch, adaptor_1.Responses.decodeBlockSearch);
        return {
          ...resp,
          // make sure we sort by height, as tendermint may be sorting by string value of the height
          blocks: [...resp.blocks].sort((a2, b5) => a2.block.header.height - b5.block.header.height)
        };
      }
      // this should paginate through all blockSearch options to ensure it returns all results.
      // starts with page 1 or whatever was provided (eg. to start on page 7)
      //
      // NOTE
      // This method will error on any node that is running a Tendermint version lower than 0.34.9.
      async blockSearchAll(params) {
        let page = params.page || 1;
        const blocks = [];
        let done = false;
        while (!done) {
          const resp = await this.blockSearch({ ...params, page });
          blocks.push(...resp.blocks);
          if (blocks.length < resp.totalCount) {
            page++;
          } else {
            done = true;
          }
        }
        blocks.sort((a2, b5) => a2.block.header.height - b5.block.header.height);
        return {
          totalCount: blocks.length,
          blocks
        };
      }
      /**
       * Queries block headers filtered by minHeight <= height <= maxHeight.
       *
       * @param minHeight The minimum height to be included in the result. Defaults to 0.
       * @param maxHeight The maximum height to be included in the result. Defaults to infinity.
       */
      async blockchain(minHeight, maxHeight) {
        const query = {
          method: requests.Method.Blockchain,
          params: {
            minHeight,
            maxHeight
          }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockchain, adaptor_1.Responses.decodeBlockchain);
      }
      /**
       * Broadcast transaction to mempool and wait for response
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_sync
       */
      async broadcastTxSync(params) {
        const query = { params, method: requests.Method.BroadcastTxSync };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxSync);
      }
      /**
       * Broadcast transaction to mempool and do not wait for result
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_async
       */
      async broadcastTxAsync(params) {
        const query = { params, method: requests.Method.BroadcastTxAsync };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxAsync);
      }
      /**
       * Broadcast transaction to mempool and wait for block
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_commit
       */
      async broadcastTxCommit(params) {
        const query = { params, method: requests.Method.BroadcastTxCommit };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxCommit);
      }
      async commit(height) {
        const query = { method: requests.Method.Commit, params: { height } };
        return this.doCall(query, adaptor_1.Params.encodeCommit, adaptor_1.Responses.decodeCommit);
      }
      async genesis() {
        const query = { method: requests.Method.Genesis };
        return this.doCall(query, adaptor_1.Params.encodeGenesis, adaptor_1.Responses.decodeGenesis);
      }
      async health() {
        const query = { method: requests.Method.Health };
        return this.doCall(query, adaptor_1.Params.encodeHealth, adaptor_1.Responses.decodeHealth);
      }
      async numUnconfirmedTxs() {
        const query = { method: requests.Method.NumUnconfirmedTxs };
        return this.doCall(query, adaptor_1.Params.encodeNumUnconfirmedTxs, adaptor_1.Responses.decodeNumUnconfirmedTxs);
      }
      async status() {
        const query = { method: requests.Method.Status };
        return this.doCall(query, adaptor_1.Params.encodeStatus, adaptor_1.Responses.decodeStatus);
      }
      subscribeNewBlock() {
        const request = {
          method: requests.Method.Subscribe,
          query: { type: requests.SubscriptionEventType.NewBlock }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockEvent);
      }
      subscribeNewBlockHeader() {
        const request = {
          method: requests.Method.Subscribe,
          query: { type: requests.SubscriptionEventType.NewBlockHeader }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockHeaderEvent);
      }
      subscribeTx(query) {
        const request = {
          method: requests.Method.Subscribe,
          query: {
            type: requests.SubscriptionEventType.Tx,
            raw: query
          }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeTxEvent);
      }
      /**
       * Get a single transaction by hash
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/tx
       */
      async tx(params) {
        const query = { params, method: requests.Method.Tx };
        return this.doCall(query, adaptor_1.Params.encodeTx, adaptor_1.Responses.decodeTx);
      }
      /**
       * Search for transactions that are in a block
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/tx_search
       */
      async txSearch(params) {
        const query = { params, method: requests.Method.TxSearch };
        return this.doCall(query, adaptor_1.Params.encodeTxSearch, adaptor_1.Responses.decodeTxSearch);
      }
      // this should paginate through all txSearch options to ensure it returns all results.
      // starts with page 1 or whatever was provided (eg. to start on page 7)
      async txSearchAll(params) {
        let page = params.page || 1;
        const txs = [];
        let done = false;
        while (!done) {
          const resp = await this.txSearch({ ...params, page });
          txs.push(...resp.txs);
          if (txs.length < resp.totalCount) {
            page++;
          } else {
            done = true;
          }
        }
        return {
          totalCount: txs.length,
          txs
        };
      }
      async validators(params) {
        const query = {
          method: requests.Method.Validators,
          params
        };
        return this.doCall(query, adaptor_1.Params.encodeValidators, adaptor_1.Responses.decodeValidators);
      }
      async validatorsAll(height) {
        const validators = [];
        let page = 1;
        let done = false;
        let blockHeight = height;
        while (!done) {
          const response = await this.validators({
            per_page: 50,
            height: blockHeight,
            page
          });
          validators.push(...response.validators);
          blockHeight = blockHeight || response.blockHeight;
          if (validators.length < response.total) {
            page++;
          } else {
            done = true;
          }
        }
        return {
          // NOTE: Default value is for type safety but this should always be set
          blockHeight: blockHeight ?? 0,
          count: validators.length,
          total: validators.length,
          validators
        };
      }
      // doCall is a helper to handle the encode/call/decode logic
      async doCall(request, encode, decode) {
        const req = encode(request);
        const result = await this.client.execute(req);
        return decode(result);
      }
      subscribe(request, decode) {
        if (!(0, rpcclients_1.instanceOfRpcStreamingClient)(this.client)) {
          throw new Error("This RPC client type cannot subscribe to events");
        }
        const req = adaptor_1.Params.encodeSubscribe(request);
        const eventStream = this.client.listen(req);
        return eventStream.map((event) => {
          return decode(event);
        });
      }
    };
    exports.Comet38Client = Comet38Client;
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/comet38/responses.js
var require_responses4 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/comet38/responses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VoteType = void 0;
    exports.broadcastTxSyncSuccess = broadcastTxSyncSuccess;
    exports.broadcastTxCommitSuccess = broadcastTxCommitSuccess;
    function broadcastTxSyncSuccess(res) {
      return res.code === 0;
    }
    function broadcastTxCommitSuccess(response) {
      return response.checkTx.code === 0 && !!response.deliverTx && response.deliverTx.code === 0;
    }
    var VoteType;
    (function(VoteType2) {
      VoteType2[VoteType2["PreVote"] = 1] = "PreVote";
      VoteType2[VoteType2["PreCommit"] = 2] = "PreCommit";
    })(VoteType || (exports.VoteType = VoteType = {}));
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/comet38/index.js
var require_comet38 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/comet38/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VoteType = exports.broadcastTxSyncSuccess = exports.broadcastTxCommitSuccess = exports.SubscriptionEventType = exports.Method = exports.Comet38Client = void 0;
    var comet38client_1 = require_comet38client();
    Object.defineProperty(exports, "Comet38Client", { enumerable: true, get: function() {
      return comet38client_1.Comet38Client;
    } });
    var requests_1 = require_requests3();
    Object.defineProperty(exports, "Method", { enumerable: true, get: function() {
      return requests_1.Method;
    } });
    Object.defineProperty(exports, "SubscriptionEventType", { enumerable: true, get: function() {
      return requests_1.SubscriptionEventType;
    } });
    var responses_1 = require_responses4();
    Object.defineProperty(exports, "broadcastTxCommitSuccess", { enumerable: true, get: function() {
      return responses_1.broadcastTxCommitSuccess;
    } });
    Object.defineProperty(exports, "broadcastTxSyncSuccess", { enumerable: true, get: function() {
      return responses_1.broadcastTxSyncSuccess;
    } });
    Object.defineProperty(exports, "VoteType", { enumerable: true, get: function() {
      return responses_1.VoteType;
    } });
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/requests.js
var require_requests5 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/requests.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SubscriptionEventType = exports.Method = void 0;
    exports.buildQuery = buildQuery;
    var Method;
    (function(Method2) {
      Method2["AbciInfo"] = "abci_info";
      Method2["AbciQuery"] = "abci_query";
      Method2["Block"] = "block";
      Method2["Blockchain"] = "blockchain";
      Method2["BlockResults"] = "block_results";
      Method2["BlockSearch"] = "block_search";
      Method2["BroadcastTxAsync"] = "broadcast_tx_async";
      Method2["BroadcastTxSync"] = "broadcast_tx_sync";
      Method2["BroadcastTxCommit"] = "broadcast_tx_commit";
      Method2["Commit"] = "commit";
      Method2["Genesis"] = "genesis";
      Method2["Health"] = "health";
      Method2["NumUnconfirmedTxs"] = "num_unconfirmed_txs";
      Method2["Status"] = "status";
      Method2["Subscribe"] = "subscribe";
      Method2["Tx"] = "tx";
      Method2["TxSearch"] = "tx_search";
      Method2["Validators"] = "validators";
      Method2["Unsubscribe"] = "unsubscribe";
    })(Method || (exports.Method = Method = {}));
    var SubscriptionEventType;
    (function(SubscriptionEventType2) {
      SubscriptionEventType2["NewBlock"] = "NewBlock";
      SubscriptionEventType2["NewBlockHeader"] = "NewBlockHeader";
      SubscriptionEventType2["Tx"] = "Tx";
    })(SubscriptionEventType || (exports.SubscriptionEventType = SubscriptionEventType = {}));
    function buildQuery(components) {
      const tags = components.tags ? components.tags : [];
      const tagComponents = tags.map((tag) => `${tag.key}='${tag.value}'`);
      const rawComponents = components.raw ? [components.raw] : [];
      return [...tagComponents, ...rawComponents].join(" AND ");
    }
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/responses.js
var require_responses5 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/responses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VoteType = void 0;
    exports.broadcastTxSyncSuccess = broadcastTxSyncSuccess;
    exports.broadcastTxCommitSuccess = broadcastTxCommitSuccess;
    function broadcastTxSyncSuccess(res) {
      return res.code === 0;
    }
    function broadcastTxCommitSuccess(response) {
      return response.checkTx.code === 0 && !!response.deliverTx && response.deliverTx.code === 0;
    }
    var VoteType;
    (function(VoteType2) {
      VoteType2[VoteType2["PreVote"] = 1] = "PreVote";
      VoteType2[VoteType2["PreCommit"] = 2] = "PreCommit";
    })(VoteType || (exports.VoteType = VoteType = {}));
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/encodings.js
var require_encodings3 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/encodings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.may = may;
    exports.dictionaryToStringMap = dictionaryToStringMap;
    exports.encodeString = encodeString;
    exports.encodeUvarint = encodeUvarint;
    exports.encodeTime = encodeTime;
    exports.encodeBytes = encodeBytes;
    exports.encodeVersion = encodeVersion;
    exports.encodeBlockId = encodeBlockId;
    var encoding_1 = require_build2();
    function may(transform, value) {
      return value === void 0 || value === null ? void 0 : transform(value);
    }
    function dictionaryToStringMap(obj) {
      const out = /* @__PURE__ */ new Map();
      for (const key of Object.keys(obj)) {
        const value = obj[key];
        if (typeof value !== "string") {
          throw new Error("Found dictionary value of type other than string");
        }
        out.set(key, value);
      }
      return out;
    }
    function encodeString(s2) {
      const utf82 = (0, encoding_1.toUtf8)(s2);
      return Uint8Array.from([utf82.length, ...utf82]);
    }
    function encodeUvarint(n2) {
      return n2 >= 128 ? (
        // eslint-disable-next-line no-bitwise
        Uint8Array.from([n2 & 255 | 128, ...encodeUvarint(n2 >> 7)])
      ) : (
        // eslint-disable-next-line no-bitwise
        Uint8Array.from([n2 & 255])
      );
    }
    function encodeTime(time) {
      const milliseconds = time.getTime();
      const seconds = Math.floor(milliseconds / 1e3);
      const secondsArray = seconds ? [8, ...encodeUvarint(seconds)] : new Uint8Array();
      const nanoseconds = (time.nanoseconds || 0) + milliseconds % 1e3 * 1e6;
      const nanosecondsArray = nanoseconds ? [16, ...encodeUvarint(nanoseconds)] : new Uint8Array();
      return Uint8Array.from([...secondsArray, ...nanosecondsArray]);
    }
    function encodeBytes(bytes2) {
      if (bytes2.length >= 128)
        throw new Error("Not implemented for byte arrays of length 128 or more");
      return bytes2.length ? Uint8Array.from([bytes2.length, ...bytes2]) : new Uint8Array();
    }
    function encodeVersion(version) {
      const blockArray = version.block ? Uint8Array.from([8, ...encodeUvarint(version.block)]) : new Uint8Array();
      const appArray = version.app ? Uint8Array.from([16, ...encodeUvarint(version.app)]) : new Uint8Array();
      return Uint8Array.from([...blockArray, ...appArray]);
    }
    function encodeBlockId(blockId) {
      return Uint8Array.from([
        10,
        blockId.hash.length,
        ...blockId.hash,
        18,
        blockId.parts.hash.length + 4,
        8,
        blockId.parts.total,
        18,
        blockId.parts.hash.length,
        ...blockId.parts.hash
      ]);
    }
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/requests.js
var require_requests6 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/requests.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o3, m3, k5, k22) {
      if (k22 === void 0) k22 = k5;
      var desc = Object.getOwnPropertyDescriptor(m3, k5);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k5];
        } };
      }
      Object.defineProperty(o3, k22, desc);
    }) : (function(o3, m3, k5, k22) {
      if (k22 === void 0) k22 = k5;
      o3[k22] = m3[k5];
    }));
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o3, v9) {
      Object.defineProperty(o3, "default", { enumerable: true, value: v9 });
    }) : function(o3, v9) {
      o3["default"] = v9;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
      var ownKeys = function(o3) {
        ownKeys = Object.getOwnPropertyNames || function(o4) {
          var ar3 = [];
          for (var k5 in o4) if (Object.prototype.hasOwnProperty.call(o4, k5)) ar3[ar3.length] = k5;
          return ar3;
        };
        return ownKeys(o3);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k5 = ownKeys(mod), i3 = 0; i3 < k5.length; i3++) if (k5[i3] !== "default") __createBinding(result, mod, k5[i3]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Params = void 0;
    var encoding_1 = require_build2();
    var inthelpers_1 = require_inthelpers();
    var jsonrpc_1 = require_jsonrpc();
    var encodings_1 = require_encodings3();
    var requests = __importStar(require_requests5());
    function encodeHeightParam(param) {
      return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.height)
      };
    }
    function encodeBlockchainRequestParams(param) {
      return {
        minHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.minHeight),
        maxHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.maxHeight)
      };
    }
    function encodeBlockSearchParams(params) {
      return {
        query: params.query,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
      };
    }
    function encodeAbciQueryParams(params) {
      return {
        path: params.path,
        data: (0, encoding_1.toHex)(params.data),
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        prove: params.prove
      };
    }
    function encodeBroadcastTxParams(params) {
      return {
        tx: (0, encoding_1.toBase64)(params.tx)
      };
    }
    function encodeTxParams(params) {
      return {
        hash: (0, encoding_1.toBase64)(params.hash),
        prove: params.prove
      };
    }
    function encodeTxSearchParams(params) {
      return {
        query: params.query,
        prove: params.prove,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
      };
    }
    function encodeValidatorsParams(params) {
      return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page)
      };
    }
    var Params = class {
      static encodeAbciInfo(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeAbciQuery(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeAbciQueryParams(req.params));
      }
      static encodeBlock(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeBlockchain(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockchainRequestParams(req.params));
      }
      static encodeBlockResults(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeBlockSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockSearchParams(req.params));
      }
      static encodeBroadcastTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBroadcastTxParams(req.params));
      }
      static encodeCommit(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeGenesis(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeHealth(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeNumUnconfirmedTxs(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeStatus(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeSubscribe(req) {
        const eventTag = { key: "tm.event", value: req.query.type };
        const query = requests.buildQuery({ tags: [eventTag], raw: req.query.raw });
        return (0, jsonrpc_1.createJsonRpcRequest)("subscribe", { query });
      }
      static encodeTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxParams(req.params));
      }
      // TODO: encode params for query string???
      static encodeTxSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxSearchParams(req.params));
      }
      static encodeValidators(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeValidatorsParams(req.params));
      }
    };
    exports.Params = Params;
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/hasher.js
var require_hasher3 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/hasher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashTx = hashTx;
    exports.hashBlock = hashBlock;
    var crypto_1 = require_build4();
    var encodings_1 = require_encodings3();
    function hashTx(tx) {
      return (0, crypto_1.sha256)(tx);
    }
    function getSplitPoint(n2) {
      if (n2 < 1)
        throw new Error("Cannot split an empty tree");
      const largestPowerOf2 = 2 ** Math.floor(Math.log2(n2));
      return largestPowerOf2 < n2 ? largestPowerOf2 : largestPowerOf2 / 2;
    }
    function hashLeaf(leaf) {
      const hash2 = new crypto_1.Sha256(Uint8Array.from([0]));
      hash2.update(leaf);
      return hash2.digest();
    }
    function hashInner(left, right) {
      const hash2 = new crypto_1.Sha256(Uint8Array.from([1]));
      hash2.update(left);
      hash2.update(right);
      return hash2.digest();
    }
    function hashTree(hashes) {
      switch (hashes.length) {
        case 0:
          throw new Error("Cannot hash empty tree");
        case 1:
          return hashLeaf(hashes[0]);
        default: {
          const slicePoint = getSplitPoint(hashes.length);
          const left = hashTree(hashes.slice(0, slicePoint));
          const right = hashTree(hashes.slice(slicePoint));
          return hashInner(left, right);
        }
      }
    }
    function hashBlock(header) {
      if (!header.lastBlockId) {
        throw new Error("Hashing a block header with no last block ID (i.e. header at height 1) is not supported. If you need this, contributions are welcome. Please add documentation and test vectors for this case.");
      }
      const encodedFields = [
        (0, encodings_1.encodeVersion)(header.version),
        (0, encodings_1.encodeString)(header.chainId),
        (0, encodings_1.encodeUvarint)(header.height),
        (0, encodings_1.encodeTime)(header.time),
        (0, encodings_1.encodeBlockId)(header.lastBlockId),
        (0, encodings_1.encodeBytes)(header.lastCommitHash),
        (0, encodings_1.encodeBytes)(header.dataHash),
        (0, encodings_1.encodeBytes)(header.validatorsHash),
        (0, encodings_1.encodeBytes)(header.nextValidatorsHash),
        (0, encodings_1.encodeBytes)(header.consensusHash),
        (0, encodings_1.encodeBytes)(header.appHash),
        (0, encodings_1.encodeBytes)(header.lastResultsHash),
        (0, encodings_1.encodeBytes)(header.evidenceHash),
        (0, encodings_1.encodeBytes)(header.proposerAddress)
      ];
      return hashTree(encodedFields);
    }
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/responses.js
var require_responses6 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/responses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Responses = void 0;
    exports.decodeEvent = decodeEvent;
    exports.decodeValidatorUpdate = decodeValidatorUpdate;
    exports.decodeValidatorGenesis = decodeValidatorGenesis;
    exports.decodeValidatorInfo = decodeValidatorInfo;
    var encoding_1 = require_build2();
    var utils_1 = require_build();
    var dates_1 = require_dates();
    var inthelpers_1 = require_inthelpers();
    var jsonchecks_1 = require_jsonchecks();
    var types_1 = require_types6();
    var encodings_1 = require_encodings3();
    var hasher_1 = require_hasher3();
    function decodeAbciInfo(data2) {
      return {
        data: data2.data,
        lastBlockHeight: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data2.last_block_height),
        lastBlockAppHash: (0, encodings_1.may)(encoding_1.fromBase64, data2.last_block_app_hash)
      };
    }
    function decodeQueryProof(data2) {
      return {
        ops: data2.ops.map((op) => ({
          type: op.type,
          key: (0, encoding_1.fromBase64)(op.key),
          data: (0, encoding_1.fromBase64)(op.data)
        }))
      };
    }
    function decodeAbciQuery(data2) {
      return {
        key: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckString)(data2.key ?? "")),
        value: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckString)(data2.value ?? "")),
        proof: (0, encodings_1.may)(decodeQueryProof, data2.proofOps),
        height: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data2.height),
        code: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data2.code),
        codespace: (0, jsonchecks_1.jCheckString)(data2.codespace ?? ""),
        index: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data2.index),
        log: data2.log,
        info: (0, jsonchecks_1.jCheckString)(data2.info ?? "")
      };
    }
    function decodeAttribute(attribute) {
      return {
        key: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(attribute.key)),
        value: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckString)(attribute.value ?? ""))
      };
    }
    function decodeAttributes(attributes) {
      return (0, jsonchecks_1.jCheckArray)(attributes).map(decodeAttribute);
    }
    function decodeEvent(event) {
      return {
        type: event.type,
        attributes: event.attributes ? decodeAttributes(event.attributes) : []
      };
    }
    function decodeEvents(events) {
      return (0, jsonchecks_1.jCheckArray)(events).map(decodeEvent);
    }
    function decodeTxData(data2) {
      return {
        code: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNumber)(data2.code ?? 0)),
        codespace: data2.codespace,
        log: data2.log,
        data: (0, encodings_1.may)(encoding_1.fromBase64, data2.data),
        events: data2.events ? decodeEvents(data2.events) : [],
        gasWanted: (0, inthelpers_1.apiToBigInt)(data2.gas_wanted ?? "0"),
        gasUsed: (0, inthelpers_1.apiToBigInt)(data2.gas_used ?? "0")
      };
    }
    function decodePubkey(data2) {
      if ("Sum" in data2) {
        const [[algorithm, value]] = Object.entries(data2.Sum.value);
        (0, utils_1.assert)(algorithm === "ed25519" || algorithm === "secp256k1", `unknown pubkey type: ${algorithm}`);
        return {
          algorithm,
          data: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(value))
        };
      } else {
        switch (data2.type) {
          // go-amino special code
          case "tendermint/PubKeyEd25519":
            return {
              algorithm: "ed25519",
              data: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data2.value))
            };
          case "tendermint/PubKeySecp256k1":
            return {
              algorithm: "secp256k1",
              data: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data2.value))
            };
          default:
            throw new Error(`unknown pubkey type: ${data2.type}`);
        }
      }
    }
    function decodeBlockParams(data2) {
      return {
        maxBytes: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.max_bytes)),
        maxGas: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.max_gas))
      };
    }
    function decodeEvidenceParams(data2) {
      return {
        maxAgeNumBlocks: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.max_age_num_blocks)),
        maxAgeDuration: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.max_age_duration))
      };
    }
    function decodeConsensusParams(data2) {
      return {
        block: data2.block ? decodeBlockParams((0, jsonchecks_1.jCheckObject)(data2.block)) : void 0,
        evidence: data2.evidence ? decodeEvidenceParams((0, jsonchecks_1.jCheckObject)(data2.evidence)) : void 0
      };
    }
    function decodeValidatorUpdate(data2) {
      return {
        pubkey: decodePubkey((0, jsonchecks_1.jCheckObject)(data2.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)(data2.power ?? "0")
      };
    }
    function decodeBlockResults(data2) {
      return {
        height: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.height)),
        results: (data2.txs_results || []).map(decodeTxData),
        validatorUpdates: (data2.validator_updates || []).map(decodeValidatorUpdate),
        consensusUpdates: (0, encodings_1.may)(decodeConsensusParams, data2.consensus_param_updates),
        beginBlockEvents: decodeEvents(data2.begin_block_events || []),
        endBlockEvents: decodeEvents(data2.end_block_events || [])
      };
    }
    function decodeBlockId(data2) {
      return {
        hash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.hash)),
        parts: {
          total: (0, jsonchecks_1.jCheckNonZeroNumber)(data2.parts.total),
          hash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.parts.hash))
        }
      };
    }
    function decodeBlockVersion(data2) {
      return {
        block: (0, inthelpers_1.apiToSmallInt)(data2.block),
        app: (0, inthelpers_1.apiToSmallInt)(data2.app ?? 0)
      };
    }
    function decodeHeader(data2) {
      return {
        version: decodeBlockVersion(data2.version),
        chainId: (0, jsonchecks_1.jCheckNonEmptyString)(data2.chain_id),
        height: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.height)),
        time: (0, dates_1.fromRfc3339WithNanoseconds)((0, jsonchecks_1.jCheckNonEmptyString)(data2.time)),
        // When there is no last block ID (i.e. this block's height is 1), we get an empty structure like this:
        // { hash: '', parts: { total: 0, hash: '' } }
        lastBlockId: data2.last_block_id.hash ? decodeBlockId(data2.last_block_id) : null,
        lastCommitHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data2.last_commit_hash)),
        dataHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data2.data_hash)),
        validatorsHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data2.validators_hash)),
        nextValidatorsHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data2.next_validators_hash)),
        consensusHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data2.consensus_hash)),
        appHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data2.app_hash)),
        lastResultsHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data2.last_results_hash)),
        evidenceHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data2.evidence_hash)),
        proposerAddress: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.proposer_address))
      };
    }
    function decodeBlockMeta(data2) {
      return {
        blockId: decodeBlockId(data2.block_id),
        blockSize: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.block_size)),
        header: decodeHeader(data2.header),
        numTxs: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.num_txs))
      };
    }
    function decodeBlockchain(data2) {
      return {
        lastHeight: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.last_height)),
        blockMetas: (0, jsonchecks_1.jCheckArray)(data2.block_metas).map(decodeBlockMeta)
      };
    }
    function decodeBroadcastTxSync(data2) {
      return {
        ...decodeTxData(data2),
        hash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.hash))
      };
    }
    function decodeBroadcastTxCommit(data2) {
      return {
        height: (0, inthelpers_1.apiToSmallInt)(data2.height),
        hash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.hash)),
        checkTx: decodeTxData((0, jsonchecks_1.jCheckObject)(data2.check_tx)),
        deliverTx: (0, encodings_1.may)(decodeTxData, data2.deliver_tx)
      };
    }
    function decodeBlockIdFlag(blockIdFlag) {
      (0, utils_1.assert)(blockIdFlag in types_1.BlockIdFlag);
      return blockIdFlag;
    }
    function decodeCommitSignature(data2) {
      return {
        blockIdFlag: decodeBlockIdFlag(data2.block_id_flag),
        validatorAddress: data2.validator_address ? (0, encoding_1.fromHex)(data2.validator_address) : void 0,
        timestamp: data2.timestamp ? (0, dates_1.fromRfc3339WithNanoseconds)(data2.timestamp) : void 0,
        signature: data2.signature ? (0, encoding_1.fromBase64)(data2.signature) : void 0
      };
    }
    function decodeCommit(data2) {
      return {
        blockId: decodeBlockId((0, jsonchecks_1.jCheckObject)(data2.block_id)),
        height: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.height)),
        round: (0, inthelpers_1.apiToSmallInt)(data2.round),
        signatures: (0, jsonchecks_1.jCheckArray)(data2.signatures).map(decodeCommitSignature)
      };
    }
    function decodeCommitResponse(data2) {
      return {
        canonical: (0, jsonchecks_1.jCheckBoolean)(data2.canonical),
        header: decodeHeader(data2.signed_header.header),
        commit: decodeCommit(data2.signed_header.commit)
      };
    }
    function decodeValidatorGenesis(data2) {
      return {
        address: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.address)),
        pubkey: decodePubkey((0, jsonchecks_1.jCheckObject)(data2.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.power))
        // Field `name` is omitted because return type `responses.Validator` doesn't have it. Fixed
        // in comet1 adapter. We could backport this change but want to avoid unnecessary breakage.
      };
    }
    function decodeGenesis(data2) {
      return {
        genesisTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, jsonchecks_1.jCheckNonEmptyString)(data2.genesis_time)),
        chainId: (0, jsonchecks_1.jCheckNonEmptyString)(data2.chain_id),
        consensusParams: decodeConsensusParams(data2.consensus_params),
        validators: data2.validators ? (0, jsonchecks_1.jCheckArray)(data2.validators).map(decodeValidatorGenesis) : [],
        appHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data2.app_hash)),
        // empty string in kvstore app
        appState: data2.app_state
      };
    }
    function decodeValidatorInfo(data2) {
      return {
        pubkey: decodePubkey((0, jsonchecks_1.jCheckObject)(data2.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.voting_power)),
        address: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.address)),
        proposerPriority: data2.proposer_priority ? (0, inthelpers_1.apiToSmallInt)(data2.proposer_priority) : void 0
      };
    }
    function decodeNodeInfo(data2) {
      return {
        id: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.id)),
        listenAddr: (0, jsonchecks_1.jCheckNonEmptyString)(data2.listen_addr),
        network: (0, jsonchecks_1.jCheckNonEmptyString)(data2.network),
        version: (0, jsonchecks_1.jCheckString)(data2.version),
        // Can be empty (https://github.com/cosmos/cosmos-sdk/issues/7963)
        channels: (0, jsonchecks_1.jCheckNonEmptyString)(data2.channels),
        moniker: (0, jsonchecks_1.jCheckNonEmptyString)(data2.moniker),
        other: (0, encodings_1.dictionaryToStringMap)(data2.other),
        protocolVersion: {
          app: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.protocol_version.app)),
          block: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.protocol_version.block)),
          p2p: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.protocol_version.p2p))
        }
      };
    }
    function decodeSyncInfo(data2) {
      const earliestBlockHeight = data2.earliest_block_height ? (0, inthelpers_1.apiToSmallInt)(data2.earliest_block_height) : void 0;
      const earliestBlockTime = data2.earliest_block_time ? (0, dates_1.fromRfc3339WithNanoseconds)(data2.earliest_block_time) : void 0;
      return {
        earliestAppHash: data2.earliest_app_hash ? (0, encoding_1.fromHex)(data2.earliest_app_hash) : void 0,
        earliestBlockHash: data2.earliest_block_hash ? (0, encoding_1.fromHex)(data2.earliest_block_hash) : void 0,
        earliestBlockHeight: earliestBlockHeight || void 0,
        earliestBlockTime: earliestBlockTime?.getTime() ? earliestBlockTime : void 0,
        latestBlockHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.latest_block_hash)),
        latestAppHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.latest_app_hash)),
        latestBlockTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, jsonchecks_1.jCheckNonEmptyString)(data2.latest_block_time)),
        latestBlockHeight: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.latest_block_height)),
        catchingUp: (0, jsonchecks_1.jCheckBoolean)(data2.catching_up)
      };
    }
    function decodeStatus(data2) {
      return {
        nodeInfo: decodeNodeInfo(data2.node_info),
        syncInfo: decodeSyncInfo(data2.sync_info),
        validatorInfo: decodeValidatorInfo(data2.validator_info)
      };
    }
    function decodeTxProof(data2) {
      return {
        data: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data2.data)),
        rootHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.root_hash)),
        proof: {
          total: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.proof.total)),
          index: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.proof.index)),
          leafHash: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data2.proof.leaf_hash)),
          aunts: (0, jsonchecks_1.jCheckArray)(data2.proof.aunts).map(encoding_1.fromBase64)
        }
      };
    }
    function decodeTxResponse(data2) {
      return {
        tx: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data2.tx)),
        result: decodeTxData((0, jsonchecks_1.jCheckObject)(data2.tx_result)),
        height: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.height)),
        index: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNumber)(data2.index)),
        hash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.hash)),
        proof: (0, encodings_1.may)(decodeTxProof, data2.proof)
      };
    }
    function decodeTxSearch(data2) {
      return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.total_count)),
        txs: (0, jsonchecks_1.jCheckArray)(data2.txs).map(decodeTxResponse)
      };
    }
    function decodeTxEvent(data2) {
      const tx = (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data2.tx));
      return {
        tx,
        hash: (0, hasher_1.hashTx)(tx),
        result: decodeTxData(data2.result),
        height: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.height))
      };
    }
    function decodeValidators(data2) {
      return {
        blockHeight: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.block_height)),
        validators: (0, jsonchecks_1.jCheckArray)(data2.validators).map(decodeValidatorInfo),
        count: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.count)),
        total: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.total))
      };
    }
    function decodeBlock(data2) {
      return {
        header: decodeHeader((0, jsonchecks_1.jCheckObject)(data2.header)),
        // For the block at height 1, last commit is not set. This is represented in an empty object like this:
        // { height: '0', round: 0, block_id: { hash: '', parts: [Object] }, signatures: [] }
        lastCommit: data2.last_commit.block_id.hash ? decodeCommit((0, jsonchecks_1.jCheckObject)(data2.last_commit)) : null,
        txs: data2.data.txs ? (0, jsonchecks_1.jCheckArray)(data2.data.txs).map(encoding_1.fromBase64) : [],
        // Lift up .evidence.evidence to just .evidence
        // See https://github.com/tendermint/tendermint/issues/7697
        evidence: data2.evidence?.evidence ?? []
      };
    }
    function decodeBlockResponse(data2) {
      return {
        blockId: decodeBlockId(data2.block_id),
        block: decodeBlock(data2.block)
      };
    }
    function decodeBlockSearch(data2) {
      return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.total_count)),
        blocks: (0, jsonchecks_1.jCheckArray)(data2.blocks).map(decodeBlockResponse)
      };
    }
    function decodeNumUnconfirmedTxs(data2) {
      return {
        total: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.total)),
        totalBytes: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.total_bytes))
      };
    }
    var Responses = class _Responses {
      static decodeAbciInfo(response) {
        return decodeAbciInfo((0, jsonchecks_1.jCheckObject)(response.result.response));
      }
      static decodeAbciQuery(response) {
        return decodeAbciQuery((0, jsonchecks_1.jCheckObject)(response.result.response));
      }
      static decodeBlock(response) {
        return decodeBlockResponse(response.result);
      }
      static decodeBlockResults(response) {
        return decodeBlockResults(response.result);
      }
      static decodeBlockSearch(response) {
        return decodeBlockSearch(response.result);
      }
      static decodeBlockchain(response) {
        return decodeBlockchain(response.result);
      }
      static decodeBroadcastTxSync(response) {
        return decodeBroadcastTxSync(response.result);
      }
      static decodeBroadcastTxAsync(response) {
        return _Responses.decodeBroadcastTxSync(response);
      }
      static decodeBroadcastTxCommit(response) {
        return decodeBroadcastTxCommit(response.result);
      }
      static decodeCommit(response) {
        return decodeCommitResponse(response.result);
      }
      static decodeGenesis(response) {
        return decodeGenesis((0, jsonchecks_1.jCheckObject)(response.result.genesis));
      }
      static decodeHealth() {
        return null;
      }
      static decodeNumUnconfirmedTxs(response) {
        return decodeNumUnconfirmedTxs(response.result);
      }
      static decodeStatus(response) {
        return decodeStatus(response.result);
      }
      static decodeNewBlockEvent(event) {
        return decodeBlock(event.data.value.block);
      }
      static decodeNewBlockHeaderEvent(event) {
        return decodeHeader(event.data.value.header);
      }
      static decodeTxEvent(event) {
        return decodeTxEvent(event.data.value.TxResult);
      }
      static decodeTx(response) {
        return decodeTxResponse(response.result);
      }
      static decodeTxSearch(response) {
        return decodeTxSearch(response.result);
      }
      static decodeValidators(response) {
        return decodeValidators(response.result);
      }
    };
    exports.Responses = Responses;
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/index.js
var require_adaptor3 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/adaptor/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Responses = exports.Params = void 0;
    var requests_1 = require_requests6();
    Object.defineProperty(exports, "Params", { enumerable: true, get: function() {
      return requests_1.Params;
    } });
    var responses_1 = require_responses6();
    Object.defineProperty(exports, "Responses", { enumerable: true, get: function() {
      return responses_1.Responses;
    } });
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/tendermint34client.js
var require_tendermint34client = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/tendermint34client.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o3, m3, k5, k22) {
      if (k22 === void 0) k22 = k5;
      var desc = Object.getOwnPropertyDescriptor(m3, k5);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k5];
        } };
      }
      Object.defineProperty(o3, k22, desc);
    }) : (function(o3, m3, k5, k22) {
      if (k22 === void 0) k22 = k5;
      o3[k22] = m3[k5];
    }));
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o3, v9) {
      Object.defineProperty(o3, "default", { enumerable: true, value: v9 });
    }) : function(o3, v9) {
      o3["default"] = v9;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
      var ownKeys = function(o3) {
        ownKeys = Object.getOwnPropertyNames || function(o4) {
          var ar3 = [];
          for (var k5 in o4) if (Object.prototype.hasOwnProperty.call(o4, k5)) ar3[ar3.length] = k5;
          return ar3;
        };
        return ownKeys(o3);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k5 = ownKeys(mod), i3 = 0; i3 < k5.length; i3++) if (k5[i3] !== "default") __createBinding(result, mod, k5[i3]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tendermint34Client = void 0;
    var rpcclients_1 = require_rpcclients();
    var adaptor_1 = require_adaptor3();
    var requests = __importStar(require_requests5());
    var Tendermint34Client = class _Tendermint34Client {
      /**
       * Creates a new Tendermint client for the given endpoint.
       *
       * Uses HTTP when the URL schema is http or https. Uses WebSockets otherwise.
       */
      static async connect(endpoint) {
        let rpcClient;
        if (typeof endpoint === "object") {
          rpcClient = new rpcclients_1.HttpClient(endpoint);
        } else {
          const useHttp = endpoint.startsWith("http://") || endpoint.startsWith("https://");
          rpcClient = useHttp ? new rpcclients_1.HttpClient(endpoint) : new rpcclients_1.WebsocketClient(endpoint);
        }
        return _Tendermint34Client.create(rpcClient);
      }
      /**
       * Creates a new Tendermint client given an RPC client.
       */
      static create(rpcClient) {
        return new _Tendermint34Client(rpcClient);
      }
      client;
      /**
       * Use `Tendermint34Client.connect` or `Tendermint34Client.create` to create an instance.
       */
      constructor(client) {
        this.client = client;
      }
      disconnect() {
        this.client.disconnect();
      }
      async abciInfo() {
        const query = { method: requests.Method.AbciInfo };
        return this.doCall(query, adaptor_1.Params.encodeAbciInfo, adaptor_1.Responses.decodeAbciInfo);
      }
      async abciQuery(params) {
        const query = { params, method: requests.Method.AbciQuery };
        return this.doCall(query, adaptor_1.Params.encodeAbciQuery, adaptor_1.Responses.decodeAbciQuery);
      }
      async block(height) {
        const query = { method: requests.Method.Block, params: { height } };
        return this.doCall(query, adaptor_1.Params.encodeBlock, adaptor_1.Responses.decodeBlock);
      }
      async blockResults(height) {
        const query = {
          method: requests.Method.BlockResults,
          params: { height }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockResults, adaptor_1.Responses.decodeBlockResults);
      }
      /**
       * Search for events that are in a block.
       *
       * NOTE
       * This method will error on any node that is running a Tendermint version lower than 0.34.9.
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/block_search
       */
      async blockSearch(params) {
        const query = { params, method: requests.Method.BlockSearch };
        const resp = await this.doCall(query, adaptor_1.Params.encodeBlockSearch, adaptor_1.Responses.decodeBlockSearch);
        return {
          ...resp,
          // make sure we sort by height, as tendermint may be sorting by string value of the height
          blocks: [...resp.blocks].sort((a2, b5) => a2.block.header.height - b5.block.header.height)
        };
      }
      // this should paginate through all blockSearch options to ensure it returns all results.
      // starts with page 1 or whatever was provided (eg. to start on page 7)
      //
      // NOTE
      // This method will error on any node that is running a Tendermint version lower than 0.34.9.
      async blockSearchAll(params) {
        let page = params.page || 1;
        const blocks = [];
        let done = false;
        while (!done) {
          const resp = await this.blockSearch({ ...params, page });
          blocks.push(...resp.blocks);
          if (blocks.length < resp.totalCount) {
            page++;
          } else {
            done = true;
          }
        }
        blocks.sort((a2, b5) => a2.block.header.height - b5.block.header.height);
        return {
          totalCount: blocks.length,
          blocks
        };
      }
      /**
       * Queries block headers filtered by minHeight <= height <= maxHeight.
       *
       * @param minHeight The minimum height to be included in the result. Defaults to 0.
       * @param maxHeight The maximum height to be included in the result. Defaults to infinity.
       */
      async blockchain(minHeight, maxHeight) {
        const query = {
          method: requests.Method.Blockchain,
          params: {
            minHeight,
            maxHeight
          }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockchain, adaptor_1.Responses.decodeBlockchain);
      }
      /**
       * Broadcast transaction to mempool and wait for response
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_sync
       */
      async broadcastTxSync(params) {
        const query = { params, method: requests.Method.BroadcastTxSync };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxSync);
      }
      /**
       * Broadcast transaction to mempool and do not wait for result
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_async
       */
      async broadcastTxAsync(params) {
        const query = { params, method: requests.Method.BroadcastTxAsync };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxAsync);
      }
      /**
       * Broadcast transaction to mempool and wait for block
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_commit
       */
      async broadcastTxCommit(params) {
        const query = { params, method: requests.Method.BroadcastTxCommit };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxCommit);
      }
      async commit(height) {
        const query = { method: requests.Method.Commit, params: { height } };
        return this.doCall(query, adaptor_1.Params.encodeCommit, adaptor_1.Responses.decodeCommit);
      }
      async genesis() {
        const query = { method: requests.Method.Genesis };
        return this.doCall(query, adaptor_1.Params.encodeGenesis, adaptor_1.Responses.decodeGenesis);
      }
      async health() {
        const query = { method: requests.Method.Health };
        return this.doCall(query, adaptor_1.Params.encodeHealth, adaptor_1.Responses.decodeHealth);
      }
      async numUnconfirmedTxs() {
        const query = { method: requests.Method.NumUnconfirmedTxs };
        return this.doCall(query, adaptor_1.Params.encodeNumUnconfirmedTxs, adaptor_1.Responses.decodeNumUnconfirmedTxs);
      }
      async status() {
        const query = { method: requests.Method.Status };
        return this.doCall(query, adaptor_1.Params.encodeStatus, adaptor_1.Responses.decodeStatus);
      }
      subscribeNewBlock() {
        const request = {
          method: requests.Method.Subscribe,
          query: { type: requests.SubscriptionEventType.NewBlock }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockEvent);
      }
      subscribeNewBlockHeader() {
        const request = {
          method: requests.Method.Subscribe,
          query: { type: requests.SubscriptionEventType.NewBlockHeader }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockHeaderEvent);
      }
      subscribeTx(query) {
        const request = {
          method: requests.Method.Subscribe,
          query: {
            type: requests.SubscriptionEventType.Tx,
            raw: query
          }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeTxEvent);
      }
      /**
       * Get a single transaction by hash
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/tx
       */
      async tx(params) {
        const query = { params, method: requests.Method.Tx };
        return this.doCall(query, adaptor_1.Params.encodeTx, adaptor_1.Responses.decodeTx);
      }
      /**
       * Search for transactions that are in a block
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/tx_search
       */
      async txSearch(params) {
        const query = { params, method: requests.Method.TxSearch };
        return this.doCall(query, adaptor_1.Params.encodeTxSearch, adaptor_1.Responses.decodeTxSearch);
      }
      // this should paginate through all txSearch options to ensure it returns all results.
      // starts with page 1 or whatever was provided (eg. to start on page 7)
      async txSearchAll(params) {
        let page = params.page || 1;
        const txs = [];
        let done = false;
        while (!done) {
          const resp = await this.txSearch({ ...params, page });
          txs.push(...resp.txs);
          if (txs.length < resp.totalCount) {
            page++;
          } else {
            done = true;
          }
        }
        return {
          totalCount: txs.length,
          txs
        };
      }
      async validators(params) {
        const query = {
          method: requests.Method.Validators,
          params
        };
        return this.doCall(query, adaptor_1.Params.encodeValidators, adaptor_1.Responses.decodeValidators);
      }
      async validatorsAll(height) {
        const validators = [];
        let page = 1;
        let done = false;
        let blockHeight = height;
        while (!done) {
          const response = await this.validators({
            per_page: 50,
            height: blockHeight,
            page
          });
          validators.push(...response.validators);
          blockHeight = blockHeight || response.blockHeight;
          if (validators.length < response.total) {
            page++;
          } else {
            done = true;
          }
        }
        return {
          // NOTE: Default value is for type safety but this should always be set
          blockHeight: blockHeight ?? 0,
          count: validators.length,
          total: validators.length,
          validators
        };
      }
      // doCall is a helper to handle the encode/call/decode logic
      async doCall(request, encode, decode) {
        const req = encode(request);
        const result = await this.client.execute(req);
        return decode(result);
      }
      subscribe(request, decode) {
        if (!(0, rpcclients_1.instanceOfRpcStreamingClient)(this.client)) {
          throw new Error("This RPC client type cannot subscribe to events");
        }
        const req = adaptor_1.Params.encodeSubscribe(request);
        const eventStream = this.client.listen(req);
        return eventStream.map((event) => {
          return decode(event);
        });
      }
    };
    exports.Tendermint34Client = Tendermint34Client;
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/index.js
var require_tendermint34 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/tendermint34/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tendermint34Client = exports.VoteType = exports.broadcastTxSyncSuccess = exports.broadcastTxCommitSuccess = exports.SubscriptionEventType = exports.Method = void 0;
    var requests_1 = require_requests5();
    Object.defineProperty(exports, "Method", { enumerable: true, get: function() {
      return requests_1.Method;
    } });
    Object.defineProperty(exports, "SubscriptionEventType", { enumerable: true, get: function() {
      return requests_1.SubscriptionEventType;
    } });
    var responses_1 = require_responses5();
    Object.defineProperty(exports, "broadcastTxCommitSuccess", { enumerable: true, get: function() {
      return responses_1.broadcastTxCommitSuccess;
    } });
    Object.defineProperty(exports, "broadcastTxSyncSuccess", { enumerable: true, get: function() {
      return responses_1.broadcastTxSyncSuccess;
    } });
    Object.defineProperty(exports, "VoteType", { enumerable: true, get: function() {
      return responses_1.VoteType;
    } });
    var tendermint34client_1 = require_tendermint34client();
    Object.defineProperty(exports, "Tendermint34Client", { enumerable: true, get: function() {
      return tendermint34client_1.Tendermint34Client;
    } });
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/requests.js
var require_requests7 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/requests.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SubscriptionEventType = exports.Method = void 0;
    exports.buildQuery = buildQuery;
    var Method;
    (function(Method2) {
      Method2["AbciInfo"] = "abci_info";
      Method2["AbciQuery"] = "abci_query";
      Method2["Block"] = "block";
      Method2["Blockchain"] = "blockchain";
      Method2["BlockResults"] = "block_results";
      Method2["BlockSearch"] = "block_search";
      Method2["BroadcastTxAsync"] = "broadcast_tx_async";
      Method2["BroadcastTxSync"] = "broadcast_tx_sync";
      Method2["BroadcastTxCommit"] = "broadcast_tx_commit";
      Method2["Commit"] = "commit";
      Method2["Genesis"] = "genesis";
      Method2["Health"] = "health";
      Method2["NumUnconfirmedTxs"] = "num_unconfirmed_txs";
      Method2["Status"] = "status";
      Method2["Subscribe"] = "subscribe";
      Method2["Tx"] = "tx";
      Method2["TxSearch"] = "tx_search";
      Method2["Validators"] = "validators";
      Method2["Unsubscribe"] = "unsubscribe";
    })(Method || (exports.Method = Method = {}));
    var SubscriptionEventType;
    (function(SubscriptionEventType2) {
      SubscriptionEventType2["NewBlock"] = "NewBlock";
      SubscriptionEventType2["NewBlockHeader"] = "NewBlockHeader";
      SubscriptionEventType2["Tx"] = "Tx";
    })(SubscriptionEventType || (exports.SubscriptionEventType = SubscriptionEventType = {}));
    function buildQuery(components) {
      const tags = components.tags ? components.tags : [];
      const tagComponents = tags.map((tag) => `${tag.key}='${tag.value}'`);
      const rawComponents = components.raw ? [components.raw] : [];
      return [...tagComponents, ...rawComponents].join(" AND ");
    }
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/responses.js
var require_responses7 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/responses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VoteType = void 0;
    exports.broadcastTxSyncSuccess = broadcastTxSyncSuccess;
    exports.broadcastTxCommitSuccess = broadcastTxCommitSuccess;
    function broadcastTxSyncSuccess(res) {
      return res.code === 0;
    }
    function broadcastTxCommitSuccess(response) {
      return response.checkTx.code === 0 && !!response.deliverTx && response.deliverTx.code === 0;
    }
    var VoteType;
    (function(VoteType2) {
      VoteType2[VoteType2["PreVote"] = 1] = "PreVote";
      VoteType2[VoteType2["PreCommit"] = 2] = "PreCommit";
    })(VoteType || (exports.VoteType = VoteType = {}));
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/encodings.js
var require_encodings4 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/encodings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.may = may;
    exports.dictionaryToStringMap = dictionaryToStringMap;
    exports.encodeString = encodeString;
    exports.encodeUvarint = encodeUvarint;
    exports.encodeTime = encodeTime;
    exports.encodeBytes = encodeBytes;
    exports.encodeVersion = encodeVersion;
    exports.encodeBlockId = encodeBlockId;
    var encoding_1 = require_build2();
    function may(transform, value) {
      return value === void 0 || value === null ? void 0 : transform(value);
    }
    function dictionaryToStringMap(obj) {
      const out = /* @__PURE__ */ new Map();
      for (const key of Object.keys(obj)) {
        const value = obj[key];
        if (typeof value !== "string") {
          throw new Error("Found dictionary value of type other than string");
        }
        out.set(key, value);
      }
      return out;
    }
    function encodeString(s2) {
      const utf82 = (0, encoding_1.toUtf8)(s2);
      return Uint8Array.from([utf82.length, ...utf82]);
    }
    function encodeUvarint(n2) {
      return n2 >= 128 ? (
        // eslint-disable-next-line no-bitwise
        Uint8Array.from([n2 & 255 | 128, ...encodeUvarint(n2 >> 7)])
      ) : (
        // eslint-disable-next-line no-bitwise
        Uint8Array.from([n2 & 255])
      );
    }
    function encodeTime(time) {
      const milliseconds = time.getTime();
      const seconds = Math.floor(milliseconds / 1e3);
      const secondsArray = seconds ? [8, ...encodeUvarint(seconds)] : new Uint8Array();
      const nanoseconds = (time.nanoseconds || 0) + milliseconds % 1e3 * 1e6;
      const nanosecondsArray = nanoseconds ? [16, ...encodeUvarint(nanoseconds)] : new Uint8Array();
      return Uint8Array.from([...secondsArray, ...nanosecondsArray]);
    }
    function encodeBytes(bytes2) {
      if (bytes2.length >= 128)
        throw new Error("Not implemented for byte arrays of length 128 or more");
      return bytes2.length ? Uint8Array.from([bytes2.length, ...bytes2]) : new Uint8Array();
    }
    function encodeVersion(version) {
      const blockArray = version.block ? Uint8Array.from([8, ...encodeUvarint(version.block)]) : new Uint8Array();
      const appArray = version.app ? Uint8Array.from([16, ...encodeUvarint(version.app)]) : new Uint8Array();
      return Uint8Array.from([...blockArray, ...appArray]);
    }
    function encodeBlockId(blockId) {
      return Uint8Array.from([
        10,
        blockId.hash.length,
        ...blockId.hash,
        18,
        blockId.parts.hash.length + 4,
        8,
        blockId.parts.total,
        18,
        blockId.parts.hash.length,
        ...blockId.parts.hash
      ]);
    }
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/adaptor/requests.js
var require_requests8 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/adaptor/requests.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o3, m3, k5, k22) {
      if (k22 === void 0) k22 = k5;
      var desc = Object.getOwnPropertyDescriptor(m3, k5);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k5];
        } };
      }
      Object.defineProperty(o3, k22, desc);
    }) : (function(o3, m3, k5, k22) {
      if (k22 === void 0) k22 = k5;
      o3[k22] = m3[k5];
    }));
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o3, v9) {
      Object.defineProperty(o3, "default", { enumerable: true, value: v9 });
    }) : function(o3, v9) {
      o3["default"] = v9;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
      var ownKeys = function(o3) {
        ownKeys = Object.getOwnPropertyNames || function(o4) {
          var ar3 = [];
          for (var k5 in o4) if (Object.prototype.hasOwnProperty.call(o4, k5)) ar3[ar3.length] = k5;
          return ar3;
        };
        return ownKeys(o3);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k5 = ownKeys(mod), i3 = 0; i3 < k5.length; i3++) if (k5[i3] !== "default") __createBinding(result, mod, k5[i3]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Params = void 0;
    var encoding_1 = require_build2();
    var inthelpers_1 = require_inthelpers();
    var jsonrpc_1 = require_jsonrpc();
    var encodings_1 = require_encodings4();
    var requests = __importStar(require_requests7());
    function encodeHeightParam(param) {
      return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.height)
      };
    }
    function encodeBlockchainRequestParams(param) {
      return {
        minHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.minHeight),
        maxHeight: (0, encodings_1.may)(inthelpers_1.smallIntToApi, param.maxHeight)
      };
    }
    function encodeBlockSearchParams(params) {
      return {
        query: params.query,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
      };
    }
    function encodeAbciQueryParams(params) {
      return {
        path: params.path,
        data: (0, encoding_1.toHex)(params.data),
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        prove: params.prove
      };
    }
    function encodeBroadcastTxParams(params) {
      return {
        tx: (0, encoding_1.toBase64)(params.tx)
      };
    }
    function encodeTxParams(params) {
      return {
        hash: (0, encoding_1.toBase64)(params.hash),
        prove: params.prove
      };
    }
    function encodeTxSearchParams(params) {
      return {
        query: params.query,
        prove: params.prove,
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page),
        order_by: params.order_by
      };
    }
    function encodeValidatorsParams(params) {
      return {
        height: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.height),
        page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.page),
        per_page: (0, encodings_1.may)(inthelpers_1.smallIntToApi, params.per_page)
      };
    }
    var Params = class {
      static encodeAbciInfo(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeAbciQuery(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeAbciQueryParams(req.params));
      }
      static encodeBlock(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeBlockchain(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockchainRequestParams(req.params));
      }
      static encodeBlockResults(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeBlockSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBlockSearchParams(req.params));
      }
      static encodeBroadcastTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeBroadcastTxParams(req.params));
      }
      static encodeCommit(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeHeightParam(req.params));
      }
      static encodeGenesis(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeHealth(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeNumUnconfirmedTxs(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeStatus(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method);
      }
      static encodeSubscribe(req) {
        const eventTag = { key: "tm.event", value: req.query.type };
        const query = requests.buildQuery({ tags: [eventTag], raw: req.query.raw });
        return (0, jsonrpc_1.createJsonRpcRequest)("subscribe", { query });
      }
      static encodeTx(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxParams(req.params));
      }
      // TODO: encode params for query string???
      static encodeTxSearch(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeTxSearchParams(req.params));
      }
      static encodeValidators(req) {
        return (0, jsonrpc_1.createJsonRpcRequest)(req.method, encodeValidatorsParams(req.params));
      }
    };
    exports.Params = Params;
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/hasher.js
var require_hasher4 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/hasher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hashTx = hashTx;
    exports.hashBlock = hashBlock;
    var crypto_1 = require_build4();
    var encodings_1 = require_encodings4();
    function hashTx(tx) {
      return (0, crypto_1.sha256)(tx);
    }
    function getSplitPoint(n2) {
      if (n2 < 1)
        throw new Error("Cannot split an empty tree");
      const largestPowerOf2 = 2 ** Math.floor(Math.log2(n2));
      return largestPowerOf2 < n2 ? largestPowerOf2 : largestPowerOf2 / 2;
    }
    function hashLeaf(leaf) {
      const hash2 = new crypto_1.Sha256(Uint8Array.from([0]));
      hash2.update(leaf);
      return hash2.digest();
    }
    function hashInner(left, right) {
      const hash2 = new crypto_1.Sha256(Uint8Array.from([1]));
      hash2.update(left);
      hash2.update(right);
      return hash2.digest();
    }
    function hashTree(hashes) {
      switch (hashes.length) {
        case 0:
          throw new Error("Cannot hash empty tree");
        case 1:
          return hashLeaf(hashes[0]);
        default: {
          const slicePoint = getSplitPoint(hashes.length);
          const left = hashTree(hashes.slice(0, slicePoint));
          const right = hashTree(hashes.slice(slicePoint));
          return hashInner(left, right);
        }
      }
    }
    function hashBlock(header) {
      if (!header.lastBlockId) {
        throw new Error("Hashing a block header with no last block ID (i.e. header at height 1) is not supported. If you need this, contributions are welcome. Please add documentation and test vectors for this case.");
      }
      const encodedFields = [
        (0, encodings_1.encodeVersion)(header.version),
        (0, encodings_1.encodeString)(header.chainId),
        (0, encodings_1.encodeUvarint)(header.height),
        (0, encodings_1.encodeTime)(header.time),
        (0, encodings_1.encodeBlockId)(header.lastBlockId),
        (0, encodings_1.encodeBytes)(header.lastCommitHash),
        (0, encodings_1.encodeBytes)(header.dataHash),
        (0, encodings_1.encodeBytes)(header.validatorsHash),
        (0, encodings_1.encodeBytes)(header.nextValidatorsHash),
        (0, encodings_1.encodeBytes)(header.consensusHash),
        (0, encodings_1.encodeBytes)(header.appHash),
        (0, encodings_1.encodeBytes)(header.lastResultsHash),
        (0, encodings_1.encodeBytes)(header.evidenceHash),
        (0, encodings_1.encodeBytes)(header.proposerAddress)
      ];
      return hashTree(encodedFields);
    }
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/adaptor/responses.js
var require_responses8 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/adaptor/responses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Responses = void 0;
    exports.decodeEvent = decodeEvent;
    exports.decodeValidatorUpdate = decodeValidatorUpdate;
    exports.decodeValidatorGenesis = decodeValidatorGenesis;
    exports.decodeValidatorInfo = decodeValidatorInfo;
    var encoding_1 = require_build2();
    var utils_1 = require_build();
    var dates_1 = require_dates();
    var inthelpers_1 = require_inthelpers();
    var jsonchecks_1 = require_jsonchecks();
    var types_1 = require_types6();
    var encodings_1 = require_encodings4();
    var hasher_1 = require_hasher4();
    function decodeAbciInfo(data2) {
      return {
        data: data2.data,
        lastBlockHeight: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data2.last_block_height),
        lastBlockAppHash: (0, encodings_1.may)(encoding_1.fromBase64, data2.last_block_app_hash)
      };
    }
    function decodeQueryProof(data2) {
      return {
        ops: data2.ops.map((op) => ({
          type: op.type,
          key: (0, encoding_1.fromBase64)(op.key),
          data: (0, encoding_1.fromBase64)(op.data)
        }))
      };
    }
    function decodeAbciQuery(data2) {
      return {
        key: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckString)(data2.key ?? "")),
        value: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckString)(data2.value ?? "")),
        proof: (0, encodings_1.may)(decodeQueryProof, data2.proofOps),
        height: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data2.height),
        code: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data2.code),
        codespace: (0, jsonchecks_1.jCheckString)(data2.codespace ?? ""),
        index: (0, encodings_1.may)(inthelpers_1.apiToSmallInt, data2.index),
        log: data2.log,
        info: (0, jsonchecks_1.jCheckString)(data2.info ?? "")
      };
    }
    function decodeEventAttribute(attribute) {
      return {
        key: (0, jsonchecks_1.jCheckNonEmptyString)(attribute.key),
        value: attribute.value ?? ""
      };
    }
    function decodeAttributes(attributes) {
      return (0, jsonchecks_1.jCheckArray)(attributes).map(decodeEventAttribute);
    }
    function decodeEvent(event) {
      return {
        type: event.type,
        attributes: event.attributes ? decodeAttributes(event.attributes) : []
      };
    }
    function decodeEvents(events) {
      return (0, jsonchecks_1.jCheckArray)(events).map(decodeEvent);
    }
    function decodeTxData(data2) {
      return {
        code: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNumber)(data2.code ?? 0)),
        codespace: data2.codespace,
        log: data2.log,
        data: (0, encodings_1.may)(encoding_1.fromBase64, data2.data),
        events: data2.events ? decodeEvents(data2.events) : [],
        gasWanted: (0, inthelpers_1.apiToBigInt)(data2.gas_wanted ?? "0"),
        gasUsed: (0, inthelpers_1.apiToBigInt)(data2.gas_used ?? "0")
      };
    }
    function decodePubkey(data2) {
      if ("Sum" in data2) {
        const [[algorithm, value]] = Object.entries(data2.Sum.value);
        (0, utils_1.assert)(algorithm === "ed25519" || algorithm === "secp256k1", `unknown pubkey type: ${algorithm}`);
        return {
          algorithm,
          data: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(value))
        };
      } else {
        switch (data2.type) {
          // go-amino special code
          case "tendermint/PubKeyEd25519":
            return {
              algorithm: "ed25519",
              data: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data2.value))
            };
          case "tendermint/PubKeySecp256k1":
            return {
              algorithm: "secp256k1",
              data: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data2.value))
            };
          default:
            throw new Error(`unknown pubkey type: ${data2.type}`);
        }
      }
    }
    function decodeBlockParams(data2) {
      return {
        maxBytes: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.max_bytes)),
        maxGas: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.max_gas))
      };
    }
    function decodeEvidenceParams(data2) {
      return {
        maxAgeNumBlocks: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.max_age_num_blocks)),
        maxAgeDuration: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.max_age_duration))
      };
    }
    function decodeConsensusParams(data2) {
      return {
        block: data2.block ? decodeBlockParams((0, jsonchecks_1.jCheckObject)(data2.block)) : void 0,
        evidence: data2.evidence ? decodeEvidenceParams((0, jsonchecks_1.jCheckObject)(data2.evidence)) : void 0
      };
    }
    function decodeValidatorUpdate(data2) {
      return {
        pubkey: decodePubkey((0, jsonchecks_1.jCheckObject)(data2.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)(data2.power ?? "0")
      };
    }
    function decodeBlockResults(data2) {
      return {
        height: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.height)),
        results: (data2.txs_results || []).map(decodeTxData),
        validatorUpdates: (data2.validator_updates || []).map(decodeValidatorUpdate),
        consensusUpdates: (0, encodings_1.may)(decodeConsensusParams, data2.consensus_param_updates),
        beginBlockEvents: decodeEvents(data2.begin_block_events || []),
        endBlockEvents: decodeEvents(data2.end_block_events || [])
      };
    }
    function decodeBlockId(data2) {
      return {
        hash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.hash)),
        parts: {
          total: (0, jsonchecks_1.jCheckNonZeroNumber)(data2.parts.total),
          hash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.parts.hash))
        }
      };
    }
    function decodeBlockVersion(data2) {
      return {
        block: (0, inthelpers_1.apiToSmallInt)(data2.block),
        app: (0, inthelpers_1.apiToSmallInt)(data2.app ?? 0)
      };
    }
    function decodeHeader(data2) {
      return {
        version: decodeBlockVersion(data2.version),
        chainId: (0, jsonchecks_1.jCheckNonEmptyString)(data2.chain_id),
        height: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.height)),
        time: (0, dates_1.fromRfc3339WithNanoseconds)((0, jsonchecks_1.jCheckNonEmptyString)(data2.time)),
        // When there is no last block ID (i.e. this block's height is 1), we get an empty structure like this:
        // { hash: '', parts: { total: 0, hash: '' } }
        lastBlockId: data2.last_block_id.hash ? decodeBlockId(data2.last_block_id) : null,
        lastCommitHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data2.last_commit_hash)),
        dataHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data2.data_hash)),
        validatorsHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data2.validators_hash)),
        nextValidatorsHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data2.next_validators_hash)),
        consensusHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data2.consensus_hash)),
        appHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data2.app_hash)),
        lastResultsHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data2.last_results_hash)),
        evidenceHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data2.evidence_hash)),
        proposerAddress: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.proposer_address))
      };
    }
    function decodeBlockMeta(data2) {
      return {
        blockId: decodeBlockId(data2.block_id),
        blockSize: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.block_size)),
        header: decodeHeader(data2.header),
        numTxs: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.num_txs))
      };
    }
    function decodeBlockchain(data2) {
      return {
        lastHeight: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.last_height)),
        blockMetas: (0, jsonchecks_1.jCheckArray)(data2.block_metas).map(decodeBlockMeta)
      };
    }
    function decodeBroadcastTxSync(data2) {
      return {
        ...decodeTxData(data2),
        hash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.hash))
      };
    }
    function decodeBroadcastTxCommit(data2) {
      return {
        height: (0, inthelpers_1.apiToSmallInt)(data2.height),
        hash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.hash)),
        checkTx: decodeTxData((0, jsonchecks_1.jCheckObject)(data2.check_tx)),
        deliverTx: (0, encodings_1.may)(decodeTxData, data2.deliver_tx)
      };
    }
    function decodeBlockIdFlag(blockIdFlag) {
      (0, utils_1.assert)(blockIdFlag in types_1.BlockIdFlag);
      return blockIdFlag;
    }
    function decodeCommitSignature(data2) {
      return {
        blockIdFlag: decodeBlockIdFlag(data2.block_id_flag),
        validatorAddress: data2.validator_address ? (0, encoding_1.fromHex)(data2.validator_address) : void 0,
        timestamp: data2.timestamp ? (0, dates_1.fromRfc3339WithNanoseconds)(data2.timestamp) : void 0,
        signature: data2.signature ? (0, encoding_1.fromBase64)(data2.signature) : void 0
      };
    }
    function decodeCommit(data2) {
      return {
        blockId: decodeBlockId((0, jsonchecks_1.jCheckObject)(data2.block_id)),
        height: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.height)),
        round: (0, inthelpers_1.apiToSmallInt)(data2.round),
        signatures: (0, jsonchecks_1.jCheckArray)(data2.signatures).map(decodeCommitSignature)
      };
    }
    function decodeCommitResponse(data2) {
      return {
        canonical: (0, jsonchecks_1.jCheckBoolean)(data2.canonical),
        header: decodeHeader(data2.signed_header.header),
        commit: decodeCommit(data2.signed_header.commit)
      };
    }
    function decodeValidatorGenesis(data2) {
      return {
        address: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.address)),
        pubkey: decodePubkey((0, jsonchecks_1.jCheckObject)(data2.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.power))
        // Field `name` is omitted because return type `responses.Validator` doesn't have it. Fixed
        // in comet1 adapter. We could backport this change but want to avoid unnecessary breakage.
      };
    }
    function decodeGenesis(data2) {
      return {
        genesisTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, jsonchecks_1.jCheckNonEmptyString)(data2.genesis_time)),
        chainId: (0, jsonchecks_1.jCheckNonEmptyString)(data2.chain_id),
        consensusParams: decodeConsensusParams(data2.consensus_params),
        validators: data2.validators ? (0, jsonchecks_1.jCheckArray)(data2.validators).map(decodeValidatorGenesis) : [],
        appHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckSet)(data2.app_hash)),
        // empty string in kvstore app
        appState: data2.app_state
      };
    }
    function decodeValidatorInfo(data2) {
      return {
        pubkey: decodePubkey((0, jsonchecks_1.jCheckObject)(data2.pub_key)),
        votingPower: (0, inthelpers_1.apiToBigInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.voting_power)),
        address: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.address)),
        proposerPriority: data2.proposer_priority ? (0, inthelpers_1.apiToSmallInt)(data2.proposer_priority) : void 0
      };
    }
    function decodeNodeInfo(data2) {
      return {
        id: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.id)),
        listenAddr: (0, jsonchecks_1.jCheckNonEmptyString)(data2.listen_addr),
        network: (0, jsonchecks_1.jCheckNonEmptyString)(data2.network),
        version: (0, jsonchecks_1.jCheckString)(data2.version),
        // Can be empty (https://github.com/cosmos/cosmos-sdk/issues/7963)
        channels: (0, jsonchecks_1.jCheckString)(data2.channels),
        // can be empty
        moniker: (0, jsonchecks_1.jCheckNonEmptyString)(data2.moniker),
        other: (0, encodings_1.dictionaryToStringMap)(data2.other),
        protocolVersion: {
          app: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.protocol_version.app)),
          block: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.protocol_version.block)),
          p2p: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.protocol_version.p2p))
        }
      };
    }
    function decodeSyncInfo(data2) {
      const earliestBlockHeight = data2.earliest_block_height ? (0, inthelpers_1.apiToSmallInt)(data2.earliest_block_height) : void 0;
      const earliestBlockTime = data2.earliest_block_time ? (0, dates_1.fromRfc3339WithNanoseconds)(data2.earliest_block_time) : void 0;
      return {
        earliestAppHash: data2.earliest_app_hash ? (0, encoding_1.fromHex)(data2.earliest_app_hash) : void 0,
        earliestBlockHash: data2.earliest_block_hash ? (0, encoding_1.fromHex)(data2.earliest_block_hash) : void 0,
        earliestBlockHeight: earliestBlockHeight || void 0,
        earliestBlockTime: earliestBlockTime?.getTime() ? earliestBlockTime : void 0,
        latestBlockHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.latest_block_hash)),
        latestAppHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.latest_app_hash)),
        latestBlockTime: (0, dates_1.fromRfc3339WithNanoseconds)((0, jsonchecks_1.jCheckNonEmptyString)(data2.latest_block_time)),
        latestBlockHeight: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.latest_block_height)),
        catchingUp: (0, jsonchecks_1.jCheckBoolean)(data2.catching_up)
      };
    }
    function decodeStatus(data2) {
      return {
        nodeInfo: decodeNodeInfo(data2.node_info),
        syncInfo: decodeSyncInfo(data2.sync_info),
        validatorInfo: decodeValidatorInfo(data2.validator_info)
      };
    }
    function decodeTxProof(data2) {
      return {
        data: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data2.data)),
        rootHash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.root_hash)),
        proof: {
          total: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.proof.total)),
          index: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.proof.index)),
          leafHash: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data2.proof.leaf_hash)),
          aunts: (0, jsonchecks_1.jCheckArray)(data2.proof.aunts).map(encoding_1.fromBase64)
        }
      };
    }
    function decodeTxResponse(data2) {
      return {
        tx: (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data2.tx)),
        result: decodeTxData((0, jsonchecks_1.jCheckObject)(data2.tx_result)),
        height: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.height)),
        index: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNumber)(data2.index)),
        hash: (0, encoding_1.fromHex)((0, jsonchecks_1.jCheckNonEmptyString)(data2.hash)),
        proof: (0, encodings_1.may)(decodeTxProof, data2.proof)
      };
    }
    function decodeTxSearch(data2) {
      return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.total_count)),
        txs: (0, jsonchecks_1.jCheckArray)(data2.txs).map(decodeTxResponse)
      };
    }
    function decodeTxEvent(data2) {
      const tx = (0, encoding_1.fromBase64)((0, jsonchecks_1.jCheckNonEmptyString)(data2.tx));
      return {
        tx,
        hash: (0, hasher_1.hashTx)(tx),
        result: decodeTxData(data2.result),
        height: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.height))
      };
    }
    function decodeValidators(data2) {
      return {
        blockHeight: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.block_height)),
        validators: (0, jsonchecks_1.jCheckArray)(data2.validators).map(decodeValidatorInfo),
        count: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.count)),
        total: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.total))
      };
    }
    function decodeBlock(data2) {
      return {
        header: decodeHeader((0, jsonchecks_1.jCheckObject)(data2.header)),
        // For the block at height 1, last commit is not set. This is represented in an empty object like this:
        // { height: '0', round: 0, block_id: { hash: '', parts: [Object] }, signatures: [] }
        lastCommit: data2.last_commit.block_id.hash ? decodeCommit((0, jsonchecks_1.jCheckObject)(data2.last_commit)) : null,
        txs: data2.data.txs ? (0, jsonchecks_1.jCheckArray)(data2.data.txs).map(encoding_1.fromBase64) : [],
        // Lift up .evidence.evidence to just .evidence
        // See https://github.com/tendermint/tendermint/issues/7697
        evidence: data2.evidence?.evidence ?? []
      };
    }
    function decodeBlockResponse(data2) {
      return {
        blockId: decodeBlockId(data2.block_id),
        block: decodeBlock(data2.block)
      };
    }
    function decodeBlockSearch(data2) {
      return {
        totalCount: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.total_count)),
        blocks: (0, jsonchecks_1.jCheckArray)(data2.blocks).map(decodeBlockResponse)
      };
    }
    function decodeNumUnconfirmedTxs(data2) {
      return {
        total: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.total)),
        totalBytes: (0, inthelpers_1.apiToSmallInt)((0, jsonchecks_1.jCheckNonEmptyString)(data2.total_bytes))
      };
    }
    var Responses = class _Responses {
      static decodeAbciInfo(response) {
        return decodeAbciInfo((0, jsonchecks_1.jCheckObject)(response.result.response));
      }
      static decodeAbciQuery(response) {
        return decodeAbciQuery((0, jsonchecks_1.jCheckObject)(response.result.response));
      }
      static decodeBlock(response) {
        return decodeBlockResponse(response.result);
      }
      static decodeBlockResults(response) {
        return decodeBlockResults(response.result);
      }
      static decodeBlockSearch(response) {
        return decodeBlockSearch(response.result);
      }
      static decodeBlockchain(response) {
        return decodeBlockchain(response.result);
      }
      static decodeBroadcastTxSync(response) {
        return decodeBroadcastTxSync(response.result);
      }
      static decodeBroadcastTxAsync(response) {
        return _Responses.decodeBroadcastTxSync(response);
      }
      static decodeBroadcastTxCommit(response) {
        return decodeBroadcastTxCommit(response.result);
      }
      static decodeCommit(response) {
        return decodeCommitResponse(response.result);
      }
      static decodeGenesis(response) {
        return decodeGenesis((0, jsonchecks_1.jCheckObject)(response.result.genesis));
      }
      static decodeHealth() {
        return null;
      }
      static decodeNumUnconfirmedTxs(response) {
        return decodeNumUnconfirmedTxs(response.result);
      }
      static decodeStatus(response) {
        return decodeStatus(response.result);
      }
      static decodeNewBlockEvent(event) {
        return decodeBlock(event.data.value.block);
      }
      static decodeNewBlockHeaderEvent(event) {
        return decodeHeader(event.data.value.header);
      }
      static decodeTxEvent(event) {
        return decodeTxEvent(event.data.value.TxResult);
      }
      static decodeTx(response) {
        return decodeTxResponse(response.result);
      }
      static decodeTxSearch(response) {
        return decodeTxSearch(response.result);
      }
      static decodeValidators(response) {
        return decodeValidators(response.result);
      }
    };
    exports.Responses = Responses;
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/adaptor/index.js
var require_adaptor4 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/adaptor/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Responses = exports.Params = void 0;
    var requests_1 = require_requests8();
    Object.defineProperty(exports, "Params", { enumerable: true, get: function() {
      return requests_1.Params;
    } });
    var responses_1 = require_responses8();
    Object.defineProperty(exports, "Responses", { enumerable: true, get: function() {
      return responses_1.Responses;
    } });
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/tendermint37client.js
var require_tendermint37client = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/tendermint37client.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o3, m3, k5, k22) {
      if (k22 === void 0) k22 = k5;
      var desc = Object.getOwnPropertyDescriptor(m3, k5);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k5];
        } };
      }
      Object.defineProperty(o3, k22, desc);
    }) : (function(o3, m3, k5, k22) {
      if (k22 === void 0) k22 = k5;
      o3[k22] = m3[k5];
    }));
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o3, v9) {
      Object.defineProperty(o3, "default", { enumerable: true, value: v9 });
    }) : function(o3, v9) {
      o3["default"] = v9;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
      var ownKeys = function(o3) {
        ownKeys = Object.getOwnPropertyNames || function(o4) {
          var ar3 = [];
          for (var k5 in o4) if (Object.prototype.hasOwnProperty.call(o4, k5)) ar3[ar3.length] = k5;
          return ar3;
        };
        return ownKeys(o3);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k5 = ownKeys(mod), i3 = 0; i3 < k5.length; i3++) if (k5[i3] !== "default") __createBinding(result, mod, k5[i3]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tendermint37Client = void 0;
    var rpcclients_1 = require_rpcclients();
    var adaptor_1 = require_adaptor4();
    var requests = __importStar(require_requests7());
    var Tendermint37Client = class _Tendermint37Client {
      /**
       * Creates a new Tendermint client for the given endpoint.
       *
       * Uses HTTP when the URL schema is http or https. Uses WebSockets otherwise.
       */
      static async connect(endpoint) {
        let rpcClient;
        if (typeof endpoint === "object") {
          rpcClient = new rpcclients_1.HttpClient(endpoint);
        } else {
          const useHttp = endpoint.startsWith("http://") || endpoint.startsWith("https://");
          rpcClient = useHttp ? new rpcclients_1.HttpClient(endpoint) : new rpcclients_1.WebsocketClient(endpoint);
        }
        return _Tendermint37Client.create(rpcClient);
      }
      /**
       * Creates a new Tendermint client given an RPC client.
       */
      static create(rpcClient) {
        return new _Tendermint37Client(rpcClient);
      }
      client;
      /**
       * Use `Tendermint37Client.connect` or `Tendermint37Client.create` to create an instance.
       */
      constructor(client) {
        this.client = client;
      }
      disconnect() {
        this.client.disconnect();
      }
      async abciInfo() {
        const query = { method: requests.Method.AbciInfo };
        return this.doCall(query, adaptor_1.Params.encodeAbciInfo, adaptor_1.Responses.decodeAbciInfo);
      }
      async abciQuery(params) {
        const query = { params, method: requests.Method.AbciQuery };
        return this.doCall(query, adaptor_1.Params.encodeAbciQuery, adaptor_1.Responses.decodeAbciQuery);
      }
      async block(height) {
        const query = { method: requests.Method.Block, params: { height } };
        return this.doCall(query, adaptor_1.Params.encodeBlock, adaptor_1.Responses.decodeBlock);
      }
      async blockResults(height) {
        const query = {
          method: requests.Method.BlockResults,
          params: { height }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockResults, adaptor_1.Responses.decodeBlockResults);
      }
      /**
       * Search for events that are in a block.
       *
       * NOTE
       * This method will error on any node that is running a Tendermint version lower than 0.34.9.
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/block_search
       */
      async blockSearch(params) {
        const query = { params, method: requests.Method.BlockSearch };
        const resp = await this.doCall(query, adaptor_1.Params.encodeBlockSearch, adaptor_1.Responses.decodeBlockSearch);
        return {
          ...resp,
          // make sure we sort by height, as tendermint may be sorting by string value of the height
          blocks: [...resp.blocks].sort((a2, b5) => a2.block.header.height - b5.block.header.height)
        };
      }
      // this should paginate through all blockSearch options to ensure it returns all results.
      // starts with page 1 or whatever was provided (eg. to start on page 7)
      //
      // NOTE
      // This method will error on any node that is running a Tendermint version lower than 0.34.9.
      async blockSearchAll(params) {
        let page = params.page || 1;
        const blocks = [];
        let done = false;
        while (!done) {
          const resp = await this.blockSearch({ ...params, page });
          blocks.push(...resp.blocks);
          if (blocks.length < resp.totalCount) {
            page++;
          } else {
            done = true;
          }
        }
        blocks.sort((a2, b5) => a2.block.header.height - b5.block.header.height);
        return {
          totalCount: blocks.length,
          blocks
        };
      }
      /**
       * Queries block headers filtered by minHeight <= height <= maxHeight.
       *
       * @param minHeight The minimum height to be included in the result. Defaults to 0.
       * @param maxHeight The maximum height to be included in the result. Defaults to infinity.
       */
      async blockchain(minHeight, maxHeight) {
        const query = {
          method: requests.Method.Blockchain,
          params: {
            minHeight,
            maxHeight
          }
        };
        return this.doCall(query, adaptor_1.Params.encodeBlockchain, adaptor_1.Responses.decodeBlockchain);
      }
      /**
       * Broadcast transaction to mempool and wait for response
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_sync
       */
      async broadcastTxSync(params) {
        const query = { params, method: requests.Method.BroadcastTxSync };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxSync);
      }
      /**
       * Broadcast transaction to mempool and do not wait for result
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_async
       */
      async broadcastTxAsync(params) {
        const query = { params, method: requests.Method.BroadcastTxAsync };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxAsync);
      }
      /**
       * Broadcast transaction to mempool and wait for block
       *
       * @see https://docs.tendermint.com/master/rpc/#/Tx/broadcast_tx_commit
       */
      async broadcastTxCommit(params) {
        const query = { params, method: requests.Method.BroadcastTxCommit };
        return this.doCall(query, adaptor_1.Params.encodeBroadcastTx, adaptor_1.Responses.decodeBroadcastTxCommit);
      }
      async commit(height) {
        const query = { method: requests.Method.Commit, params: { height } };
        return this.doCall(query, adaptor_1.Params.encodeCommit, adaptor_1.Responses.decodeCommit);
      }
      async genesis() {
        const query = { method: requests.Method.Genesis };
        return this.doCall(query, adaptor_1.Params.encodeGenesis, adaptor_1.Responses.decodeGenesis);
      }
      async health() {
        const query = { method: requests.Method.Health };
        return this.doCall(query, adaptor_1.Params.encodeHealth, adaptor_1.Responses.decodeHealth);
      }
      async numUnconfirmedTxs() {
        const query = { method: requests.Method.NumUnconfirmedTxs };
        return this.doCall(query, adaptor_1.Params.encodeNumUnconfirmedTxs, adaptor_1.Responses.decodeNumUnconfirmedTxs);
      }
      async status() {
        const query = { method: requests.Method.Status };
        return this.doCall(query, adaptor_1.Params.encodeStatus, adaptor_1.Responses.decodeStatus);
      }
      subscribeNewBlock() {
        const request = {
          method: requests.Method.Subscribe,
          query: { type: requests.SubscriptionEventType.NewBlock }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockEvent);
      }
      subscribeNewBlockHeader() {
        const request = {
          method: requests.Method.Subscribe,
          query: { type: requests.SubscriptionEventType.NewBlockHeader }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeNewBlockHeaderEvent);
      }
      subscribeTx(query) {
        const request = {
          method: requests.Method.Subscribe,
          query: {
            type: requests.SubscriptionEventType.Tx,
            raw: query
          }
        };
        return this.subscribe(request, adaptor_1.Responses.decodeTxEvent);
      }
      /**
       * Get a single transaction by hash
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/tx
       */
      async tx(params) {
        const query = { params, method: requests.Method.Tx };
        return this.doCall(query, adaptor_1.Params.encodeTx, adaptor_1.Responses.decodeTx);
      }
      /**
       * Search for transactions that are in a block
       *
       * @see https://docs.tendermint.com/master/rpc/#/Info/tx_search
       */
      async txSearch(params) {
        const query = { params, method: requests.Method.TxSearch };
        return this.doCall(query, adaptor_1.Params.encodeTxSearch, adaptor_1.Responses.decodeTxSearch);
      }
      // this should paginate through all txSearch options to ensure it returns all results.
      // starts with page 1 or whatever was provided (eg. to start on page 7)
      async txSearchAll(params) {
        let page = params.page || 1;
        const txs = [];
        let done = false;
        while (!done) {
          const resp = await this.txSearch({ ...params, page });
          txs.push(...resp.txs);
          if (txs.length < resp.totalCount) {
            page++;
          } else {
            done = true;
          }
        }
        return {
          totalCount: txs.length,
          txs
        };
      }
      async validators(params) {
        const query = {
          method: requests.Method.Validators,
          params
        };
        return this.doCall(query, adaptor_1.Params.encodeValidators, adaptor_1.Responses.decodeValidators);
      }
      async validatorsAll(height) {
        const validators = [];
        let page = 1;
        let done = false;
        let blockHeight = height;
        while (!done) {
          const response = await this.validators({
            per_page: 50,
            height: blockHeight,
            page
          });
          validators.push(...response.validators);
          blockHeight = blockHeight || response.blockHeight;
          if (validators.length < response.total) {
            page++;
          } else {
            done = true;
          }
        }
        return {
          // NOTE: Default value is for type safety but this should always be set
          blockHeight: blockHeight ?? 0,
          count: validators.length,
          total: validators.length,
          validators
        };
      }
      // doCall is a helper to handle the encode/call/decode logic
      async doCall(request, encode, decode) {
        const req = encode(request);
        const result = await this.client.execute(req);
        return decode(result);
      }
      subscribe(request, decode) {
        if (!(0, rpcclients_1.instanceOfRpcStreamingClient)(this.client)) {
          throw new Error("This RPC client type cannot subscribe to events");
        }
        const req = adaptor_1.Params.encodeSubscribe(request);
        const eventStream = this.client.listen(req);
        return eventStream.map((event) => {
          return decode(event);
        });
      }
    };
    exports.Tendermint37Client = Tendermint37Client;
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/index.js
var require_tendermint37 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/tendermint37/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tendermint37Client = exports.VoteType = exports.broadcastTxSyncSuccess = exports.broadcastTxCommitSuccess = exports.SubscriptionEventType = exports.Method = void 0;
    var requests_1 = require_requests7();
    Object.defineProperty(exports, "Method", { enumerable: true, get: function() {
      return requests_1.Method;
    } });
    Object.defineProperty(exports, "SubscriptionEventType", { enumerable: true, get: function() {
      return requests_1.SubscriptionEventType;
    } });
    var responses_1 = require_responses7();
    Object.defineProperty(exports, "broadcastTxCommitSuccess", { enumerable: true, get: function() {
      return responses_1.broadcastTxCommitSuccess;
    } });
    Object.defineProperty(exports, "broadcastTxSyncSuccess", { enumerable: true, get: function() {
      return responses_1.broadcastTxSyncSuccess;
    } });
    Object.defineProperty(exports, "VoteType", { enumerable: true, get: function() {
      return responses_1.VoteType;
    } });
    var tendermint37client_1 = require_tendermint37client();
    Object.defineProperty(exports, "Tendermint37Client", { enumerable: true, get: function() {
      return tendermint37client_1.Tendermint37Client;
    } });
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/tendermintclient.js
var require_tendermintclient = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/tendermintclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isTendermint34Client = isTendermint34Client;
    exports.isTendermint37Client = isTendermint37Client;
    exports.isComet38Client = isComet38Client;
    exports.isComet1Client = isComet1Client;
    exports.connectComet = connectComet;
    var comet1_1 = require_comet1();
    var comet38_1 = require_comet38();
    var tendermint34_1 = require_tendermint34();
    var tendermint37_1 = require_tendermint37();
    function isTendermint34Client(client) {
      return client instanceof tendermint34_1.Tendermint34Client;
    }
    function isTendermint37Client(client) {
      return client instanceof tendermint37_1.Tendermint37Client;
    }
    function isComet38Client(client) {
      return client instanceof comet38_1.Comet38Client;
    }
    function isComet1Client(client) {
      return client instanceof comet1_1.Comet1Client;
    }
    async function connectComet(endpoint) {
      let out;
      const tm37Client = await tendermint37_1.Tendermint37Client.connect(endpoint);
      const version = (await tm37Client.status()).nodeInfo.version;
      if (version.startsWith("0.37.")) {
        out = tm37Client;
      } else if (version.startsWith("0.38.")) {
        tm37Client.disconnect();
        out = await comet38_1.Comet38Client.connect(endpoint);
      } else if (version.startsWith("1.")) {
        tm37Client.disconnect();
        out = await comet1_1.Comet1Client.connect(endpoint);
      } else {
        tm37Client.disconnect();
        out = await tendermint34_1.Tendermint34Client.connect(endpoint);
      }
      return out;
    }
  }
});

// node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/index.js
var require_build10 = __commonJS({
  "node_modules/.pnpm/@cosmjs+tendermint-rpc@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/tendermint-rpc/build/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o3, m3, k5, k22) {
      if (k22 === void 0) k22 = k5;
      var desc = Object.getOwnPropertyDescriptor(m3, k5);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k5];
        } };
      }
      Object.defineProperty(o3, k22, desc);
    }) : (function(o3, m3, k5, k22) {
      if (k22 === void 0) k22 = k5;
      o3[k22] = m3[k5];
    }));
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o3, v9) {
      Object.defineProperty(o3, "default", { enumerable: true, value: v9 });
    }) : function(o3, v9) {
      o3["default"] = v9;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
      var ownKeys = function(o3) {
        ownKeys = Object.getOwnPropertyNames || function(o4) {
          var ar3 = [];
          for (var k5 in o4) if (Object.prototype.hasOwnProperty.call(o4, k5)) ar3[ar3.length] = k5;
          return ar3;
        };
        return ownKeys(o3);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k5 = ownKeys(mod), i3 = 0; i3 < k5.length; i3++) if (k5[i3] !== "default") __createBinding(result, mod, k5[i3]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BlockIdFlag = exports.isTendermint37Client = exports.isTendermint34Client = exports.isComet38Client = exports.isComet1Client = exports.connectComet = exports.Tendermint37Client = exports.tendermint37 = exports.Tendermint34Client = exports.tendermint34 = exports.VoteType = exports.SubscriptionEventType = exports.Method = exports.broadcastTxSyncSuccess = exports.broadcastTxCommitSuccess = exports.WebsocketClient = exports.HttpClient = exports.HttpBatchClient = exports.Comet38Client = exports.comet38 = exports.Comet1Client = exports.comet1 = exports.toSeconds = exports.toRfc3339WithNanoseconds = exports.fromSeconds = exports.fromRfc3339WithNanoseconds = exports.DateTime = exports.rawSecp256k1PubkeyToRawAddress = exports.rawEd25519PubkeyToRawAddress = exports.pubkeyToRawAddress = exports.pubkeyToAddress = void 0;
    var addresses_1 = require_addresses2();
    Object.defineProperty(exports, "pubkeyToAddress", { enumerable: true, get: function() {
      return addresses_1.pubkeyToAddress;
    } });
    Object.defineProperty(exports, "pubkeyToRawAddress", { enumerable: true, get: function() {
      return addresses_1.pubkeyToRawAddress;
    } });
    Object.defineProperty(exports, "rawEd25519PubkeyToRawAddress", { enumerable: true, get: function() {
      return addresses_1.rawEd25519PubkeyToRawAddress;
    } });
    Object.defineProperty(exports, "rawSecp256k1PubkeyToRawAddress", { enumerable: true, get: function() {
      return addresses_1.rawSecp256k1PubkeyToRawAddress;
    } });
    var dates_1 = require_dates();
    Object.defineProperty(exports, "DateTime", { enumerable: true, get: function() {
      return dates_1.DateTime;
    } });
    Object.defineProperty(exports, "fromRfc3339WithNanoseconds", { enumerable: true, get: function() {
      return dates_1.fromRfc3339WithNanoseconds;
    } });
    Object.defineProperty(exports, "fromSeconds", { enumerable: true, get: function() {
      return dates_1.fromSeconds;
    } });
    Object.defineProperty(exports, "toRfc3339WithNanoseconds", { enumerable: true, get: function() {
      return dates_1.toRfc3339WithNanoseconds;
    } });
    Object.defineProperty(exports, "toSeconds", { enumerable: true, get: function() {
      return dates_1.toSeconds;
    } });
    exports.comet1 = __importStar(require_comet1());
    var comet1_1 = require_comet1();
    Object.defineProperty(exports, "Comet1Client", { enumerable: true, get: function() {
      return comet1_1.Comet1Client;
    } });
    exports.comet38 = __importStar(require_comet38());
    var comet38_1 = require_comet38();
    Object.defineProperty(exports, "Comet38Client", { enumerable: true, get: function() {
      return comet38_1.Comet38Client;
    } });
    var rpcclients_1 = require_rpcclients();
    Object.defineProperty(exports, "HttpBatchClient", { enumerable: true, get: function() {
      return rpcclients_1.HttpBatchClient;
    } });
    Object.defineProperty(exports, "HttpClient", { enumerable: true, get: function() {
      return rpcclients_1.HttpClient;
    } });
    Object.defineProperty(exports, "WebsocketClient", { enumerable: true, get: function() {
      return rpcclients_1.WebsocketClient;
    } });
    var tendermint34_1 = require_tendermint34();
    Object.defineProperty(exports, "broadcastTxCommitSuccess", { enumerable: true, get: function() {
      return tendermint34_1.broadcastTxCommitSuccess;
    } });
    Object.defineProperty(exports, "broadcastTxSyncSuccess", { enumerable: true, get: function() {
      return tendermint34_1.broadcastTxSyncSuccess;
    } });
    Object.defineProperty(exports, "Method", { enumerable: true, get: function() {
      return tendermint34_1.Method;
    } });
    Object.defineProperty(exports, "SubscriptionEventType", { enumerable: true, get: function() {
      return tendermint34_1.SubscriptionEventType;
    } });
    Object.defineProperty(exports, "VoteType", { enumerable: true, get: function() {
      return tendermint34_1.VoteType;
    } });
    exports.tendermint34 = __importStar(require_tendermint34());
    var tendermint34_2 = require_tendermint34();
    Object.defineProperty(exports, "Tendermint34Client", { enumerable: true, get: function() {
      return tendermint34_2.Tendermint34Client;
    } });
    exports.tendermint37 = __importStar(require_tendermint37());
    var tendermint37_1 = require_tendermint37();
    Object.defineProperty(exports, "Tendermint37Client", { enumerable: true, get: function() {
      return tendermint37_1.Tendermint37Client;
    } });
    var tendermintclient_1 = require_tendermintclient();
    Object.defineProperty(exports, "connectComet", { enumerable: true, get: function() {
      return tendermintclient_1.connectComet;
    } });
    Object.defineProperty(exports, "isComet1Client", { enumerable: true, get: function() {
      return tendermintclient_1.isComet1Client;
    } });
    Object.defineProperty(exports, "isComet38Client", { enumerable: true, get: function() {
      return tendermintclient_1.isComet38Client;
    } });
    Object.defineProperty(exports, "isTendermint34Client", { enumerable: true, get: function() {
      return tendermintclient_1.isTendermint34Client;
    } });
    Object.defineProperty(exports, "isTendermint37Client", { enumerable: true, get: function() {
      return tendermintclient_1.isTendermint37Client;
    } });
    var types_1 = require_types6();
    Object.defineProperty(exports, "BlockIdFlag", { enumerable: true, get: function() {
      return types_1.BlockIdFlag;
    } });
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/stargateclient.js
var require_stargateclient = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/stargateclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StargateClient = exports.BroadcastTxError = exports.TimeoutError = void 0;
    exports.isDeliverTxFailure = isDeliverTxFailure;
    exports.isDeliverTxSuccess = isDeliverTxSuccess;
    exports.assertIsDeliverTxSuccess = assertIsDeliverTxSuccess;
    exports.assertIsDeliverTxFailure = assertIsDeliverTxFailure;
    var amino_1 = require_build5();
    var encoding_1 = require_build2();
    var math_1 = require_build3();
    var tendermint_rpc_1 = require_build10();
    var utils_1 = require_build();
    var abci_1 = require_abci();
    var accounts_1 = require_accounts();
    var events_1 = require_events2();
    var modules_1 = require_modules();
    var queryclient_1 = require_queryclient2();
    var search_1 = require_search();
    var TimeoutError = class extends Error {
      txId;
      constructor(message, txId) {
        super(message);
        this.name = this.constructor.name;
        this.txId = txId;
      }
    };
    exports.TimeoutError = TimeoutError;
    function isDeliverTxFailure(result) {
      return !!result.code;
    }
    function isDeliverTxSuccess(result) {
      return !isDeliverTxFailure(result);
    }
    function assertIsDeliverTxSuccess(result) {
      if (isDeliverTxFailure(result)) {
        throw new Error(`Error when broadcasting tx ${result.transactionHash} at height ${result.height}. Code: ${result.code}; Raw log: ${result.rawLog}`);
      }
    }
    function assertIsDeliverTxFailure(result) {
      if (isDeliverTxSuccess(result)) {
        throw new Error(`Transaction ${result.transactionHash} did not fail at height ${result.height}. Code: ${result.code}; Raw log: ${result.rawLog}`);
      }
    }
    var BroadcastTxError = class extends Error {
      code;
      codespace;
      log;
      constructor(code, codespace, log) {
        super(`Broadcasting transaction failed with code ${code} (codespace: ${codespace}). Log: ${log}`);
        this.name = this.constructor.name;
        this.code = code;
        this.codespace = codespace;
        this.log = log;
      }
    };
    exports.BroadcastTxError = BroadcastTxError;
    var StargateClient2 = class _StargateClient {
      cometClient;
      queryClient;
      chainId;
      accountParser;
      /**
       * Creates an instance by connecting to the given CometBFT RPC endpoint.
       *
       * This uses auto-detection to decide between a CometBFT 0.38, Tendermint 0.37 and 0.34 client.
       * To set the Comet client explicitly, use `create`.
       */
      static async connect(endpoint, options = {}) {
        const cometClient = await (0, tendermint_rpc_1.connectComet)(endpoint);
        return _StargateClient.create(cometClient, options);
      }
      /**
       * Creates an instance from a manually created Comet client.
       * Use this to use `Comet38Client` or `Tendermint37Client` instead of `Tendermint34Client`.
       */
      static create(cometClient, options = {}) {
        return new _StargateClient(cometClient, options);
      }
      constructor(cometClient, options) {
        if (cometClient) {
          this.cometClient = cometClient;
          this.queryClient = queryclient_1.QueryClient.withExtensions(cometClient, modules_1.setupAuthExtension, modules_1.setupBankExtension, modules_1.setupStakingExtension, modules_1.setupTxExtension);
        }
        const { accountParser = accounts_1.accountFromAny } = options;
        this.accountParser = accountParser;
      }
      getCometClient() {
        return this.cometClient;
      }
      forceGetCometClient() {
        if (!this.cometClient) {
          throw new Error("Comet client not available. You cannot use online functionality in offline mode.");
        }
        return this.cometClient;
      }
      getQueryClient() {
        return this.queryClient;
      }
      forceGetQueryClient() {
        if (!this.queryClient) {
          throw new Error("Query client not available. You cannot use online functionality in offline mode.");
        }
        return this.queryClient;
      }
      async getChainId() {
        if (!this.chainId) {
          const response = await this.forceGetCometClient().status();
          const chainId = response.nodeInfo.network;
          if (!chainId)
            throw new Error("Chain ID must not be empty");
          this.chainId = chainId;
        }
        return this.chainId;
      }
      async getHeight() {
        const status = await this.forceGetCometClient().status();
        return status.syncInfo.latestBlockHeight;
      }
      async getAccount(searchAddress) {
        try {
          const account = await this.forceGetQueryClient().auth.account(searchAddress);
          return account ? this.accountParser(account) : null;
        } catch (error) {
          (0, utils_1.assert)(error instanceof Error);
          if (/rpc error: code = NotFound/i.test(error.toString())) {
            return null;
          }
          throw error;
        }
      }
      async getSequence(address) {
        const account = await this.getAccount(address);
        if (!account) {
          throw new Error(`Account '${address}' does not exist on chain. Send some tokens there before trying to query sequence.`);
        }
        return {
          accountNumber: account.accountNumber,
          sequence: account.sequence
        };
      }
      async getBlock(height) {
        const response = await this.forceGetCometClient().block(height);
        return {
          id: (0, encoding_1.toHex)(response.blockId.hash).toUpperCase(),
          header: {
            version: {
              block: new math_1.Uint53(response.block.header.version.block).toString(),
              app: new math_1.Uint53(response.block.header.version.app).toString()
            },
            height: response.block.header.height,
            chainId: response.block.header.chainId,
            time: (0, tendermint_rpc_1.toRfc3339WithNanoseconds)(response.block.header.time)
          },
          txs: response.block.txs
        };
      }
      async getBalance(address, searchDenom) {
        return this.forceGetQueryClient().bank.balance(address, searchDenom);
      }
      /**
       * Queries all balances for all denoms that belong to this address.
       *
       * Uses the grpc queries (which iterates over the store internally), and we cannot get
       * proofs from such a method.
       */
      async getAllBalances(address) {
        return this.forceGetQueryClient().bank.allBalances(address);
      }
      async getBalanceStaked(address) {
        const allDelegations = [];
        let startAtKey = void 0;
        do {
          const { delegationResponses, pagination } = await this.forceGetQueryClient().staking.delegatorDelegations(address, startAtKey);
          const loadedDelegations = delegationResponses || [];
          allDelegations.push(...loadedDelegations);
          startAtKey = pagination?.nextKey;
        } while (startAtKey !== void 0 && startAtKey.length !== 0);
        const sumValues = allDelegations.reduce((previousValue, currentValue) => {
          (0, utils_1.assert)(currentValue.balance);
          return previousValue !== null ? (0, amino_1.addCoins)(previousValue, currentValue.balance) : currentValue.balance;
        }, null);
        return sumValues;
      }
      async getDelegation(delegatorAddress, validatorAddress) {
        let delegatedAmount;
        try {
          delegatedAmount = (await this.forceGetQueryClient().staking.delegation(delegatorAddress, validatorAddress)).delegationResponse?.balance;
        } catch (e) {
          (0, utils_1.assert)(e instanceof Error);
          if (e.toString().includes("key not found")) {
          } else {
            throw e;
          }
        }
        return delegatedAmount || null;
      }
      async getTx(id) {
        const results = await this.txsQuery(`tx.hash='${id}'`);
        return results[0] ?? null;
      }
      async searchTx(query) {
        let rawQuery;
        if (typeof query === "string") {
          rawQuery = query;
        } else if ((0, search_1.isSearchTxQueryArray)(query)) {
          rawQuery = query.map((t) => {
            if (typeof t.value === "string")
              return `${t.key}='${t.value}'`;
            else
              return `${t.key}=${t.value}`;
          }).join(" AND ");
        } else {
          throw new Error("Got unsupported query type. See CosmJS 0.31 CHANGELOG for API breaking changes here.");
        }
        return this.txsQuery(rawQuery);
      }
      disconnect() {
        if (this.cometClient)
          this.cometClient.disconnect();
      }
      /**
       * Broadcasts a signed transaction to the network and monitors its inclusion in a block.
       *
       * If broadcasting is rejected by the node for some reason (e.g. because of a CheckTx failure),
       * an error is thrown.
       *
       * If the transaction is not included in a block before the provided timeout, this errors with a `TimeoutError`.
       *
       * If the transaction is included in a block, a `DeliverTxResponse` is returned. The caller then
       * usually needs to check for execution success or failure.
       */
      async broadcastTx(tx, timeoutMs = 6e4, pollIntervalMs = 3e3) {
        let timedOut = false;
        const txPollTimeout = setTimeout(() => {
          timedOut = true;
        }, timeoutMs);
        const pollForTx = async (txId) => {
          if (timedOut) {
            throw new TimeoutError(`Transaction with ID ${txId} was submitted but was not yet found on the chain. You might want to check later. There was a wait of ${timeoutMs / 1e3} seconds.`, txId);
          }
          await (0, utils_1.sleep)(pollIntervalMs);
          const result = await this.getTx(txId);
          return result ? {
            code: result.code,
            height: result.height,
            txIndex: result.txIndex,
            events: result.events,
            rawLog: result.rawLog,
            transactionHash: txId,
            msgResponses: result.msgResponses,
            gasUsed: result.gasUsed,
            gasWanted: result.gasWanted
          } : pollForTx(txId);
        };
        const transactionId = await this.broadcastTxSync(tx);
        return new Promise((resolve, reject) => pollForTx(transactionId).then((value) => {
          clearTimeout(txPollTimeout);
          resolve(value);
        }, (error) => {
          clearTimeout(txPollTimeout);
          reject(error);
        }));
      }
      /**
       * Broadcasts a signed transaction to the network without monitoring it.
       *
       * If broadcasting is rejected by the node for some reason (e.g. because of a CheckTx failure),
       * an error is thrown.
       *
       * If the transaction is broadcasted, a `string` containing the hash of the transaction is returned. The caller then
       * usually needs to check if the transaction was included in a block and was successful.
       *
       * @returns Returns the hash of the transaction
       */
      async broadcastTxSync(tx) {
        const broadcasted = await this.forceGetCometClient().broadcastTxSync({ tx });
        if (broadcasted.code) {
          return Promise.reject(new BroadcastTxError(broadcasted.code, broadcasted.codespace ?? "", broadcasted.log));
        }
        const transactionId = (0, encoding_1.toHex)(broadcasted.hash).toUpperCase();
        return transactionId;
      }
      async txsQuery(query) {
        const results = await this.forceGetCometClient().txSearchAll({ query });
        return results.txs.map((tx) => {
          const txMsgData = abci_1.TxMsgData.decode(tx.result.data ?? new Uint8Array());
          return {
            height: tx.height,
            txIndex: tx.index,
            hash: (0, encoding_1.toHex)(tx.hash).toUpperCase(),
            code: tx.result.code,
            events: tx.result.events.map(events_1.fromTendermintEvent),
            rawLog: tx.result.log || "",
            tx: tx.tx,
            msgResponses: txMsgData.msgResponses,
            gasUsed: tx.result.gasUsed,
            gasWanted: tx.result.gasWanted
          };
        });
      }
    };
    exports.StargateClient = StargateClient2;
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/signingstargateclient.js
var require_signingstargateclient = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/signingstargateclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SigningStargateClient = exports.defaultRegistryTypes = void 0;
    exports.createDefaultAminoConverters = createDefaultAminoConverters;
    var amino_1 = require_build5();
    var encoding_1 = require_build2();
    var math_1 = require_build3();
    var proto_signing_1 = require_build6();
    var tendermint_rpc_1 = require_build10();
    var utils_1 = require_build();
    var coin_1 = require_coin();
    var tx_1 = require_tx4();
    var tx_2 = require_tx13();
    var signing_1 = require_signing();
    var tx_3 = require_tx();
    var tx_4 = require_tx9();
    var aminotypes_1 = require_aminotypes();
    var fee_1 = require_fee();
    var modules_1 = require_modules();
    var stargateclient_1 = require_stargateclient();
    exports.defaultRegistryTypes = [
      ["/cosmos.base.v1beta1.Coin", coin_1.Coin],
      ...modules_1.authzTypes,
      ...modules_1.bankTypes,
      ...modules_1.distributionTypes,
      ...modules_1.feegrantTypes,
      ...modules_1.govTypes,
      ...modules_1.groupTypes,
      ...modules_1.stakingTypes,
      ...modules_1.ibcTypes,
      ...modules_1.vestingTypes
    ];
    function createDefaultAminoConverters() {
      return {
        ...(0, modules_1.createAuthzAminoConverters)(),
        ...(0, modules_1.createBankAminoConverters)(),
        ...(0, modules_1.createDistributionAminoConverters)(),
        ...(0, modules_1.createGovAminoConverters)(),
        ...(0, modules_1.createStakingAminoConverters)(),
        ...(0, modules_1.createIbcAminoConverters)(),
        ...(0, modules_1.createFeegrantAminoConverters)(),
        ...(0, modules_1.createVestingAminoConverters)()
      };
    }
    var SigningStargateClient = class _SigningStargateClient extends stargateclient_1.StargateClient {
      registry;
      broadcastTimeoutMs;
      broadcastPollIntervalMs;
      signer;
      aminoTypes;
      gasPrice;
      // Starting with Cosmos SDK 0.47, we see many cases in which 1.3 is not enough anymore
      // E.g. https://github.com/cosmos/cosmos-sdk/issues/16020
      defaultGasMultiplier = 1.4;
      /**
       * Creates an instance by connecting to the given CometBFT RPC endpoint.
       *
       * This uses auto-detection to decide between a CometBFT 0.38, Tendermint 0.37 and 0.34 client.
       * To set the Comet client explicitly, use `createWithSigner`.
       */
      static async connectWithSigner(endpoint, signer, options = {}) {
        const cometClient = await (0, tendermint_rpc_1.connectComet)(endpoint);
        return _SigningStargateClient.createWithSigner(cometClient, signer, options);
      }
      /**
       * Creates an instance from a manually created Comet client.
       * Use this to use `Comet38Client` or `Tendermint37Client` instead of `Tendermint34Client`.
       */
      static createWithSigner(cometClient, signer, options = {}) {
        return new _SigningStargateClient(cometClient, signer, options);
      }
      /**
       * Creates a client in offline mode.
       *
       * This should only be used in niche cases where you know exactly what you're doing,
       * e.g. when building an offline signing application.
       *
       * When you try to use online functionality with such a signer, an
       * exception will be raised.
       */
      static async offline(signer, options = {}) {
        return new _SigningStargateClient(void 0, signer, options);
      }
      constructor(cometClient, signer, options) {
        super(cometClient, options);
        const { registry = new proto_signing_1.Registry(exports.defaultRegistryTypes), aminoTypes = new aminotypes_1.AminoTypes(createDefaultAminoConverters()) } = options;
        this.registry = registry;
        this.aminoTypes = aminoTypes;
        this.signer = signer;
        this.broadcastTimeoutMs = options.broadcastTimeoutMs;
        this.broadcastPollIntervalMs = options.broadcastPollIntervalMs;
        this.gasPrice = options.gasPrice;
      }
      async simulate(signerAddress, messages, memo) {
        const anyMsgs = messages.map((m3) => this.registry.encodeAsAny(m3));
        const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);
        if (!accountFromSigner) {
          throw new Error("Failed to retrieve account from signer");
        }
        const pubkey = (0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey);
        const { sequence } = await this.getSequence(signerAddress);
        const { gasInfo } = await this.forceGetQueryClient().tx.simulate(anyMsgs, memo, pubkey, sequence);
        (0, utils_1.assertDefined)(gasInfo);
        return math_1.Uint53.fromString(gasInfo.gasUsed.toString()).toNumber();
      }
      async sendTokens(senderAddress, recipientAddress, amount, fee, memo = "") {
        const sendMsg = {
          typeUrl: "/cosmos.bank.v1beta1.MsgSend",
          value: {
            fromAddress: senderAddress,
            toAddress: recipientAddress,
            amount: [...amount]
          }
        };
        return this.signAndBroadcast(senderAddress, [sendMsg], fee, memo);
      }
      async delegateTokens(delegatorAddress, validatorAddress, amount, fee, memo = "") {
        const delegateMsg = {
          typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
          value: tx_2.MsgDelegate.fromPartial({
            delegatorAddress,
            validatorAddress,
            amount
          })
        };
        return this.signAndBroadcast(delegatorAddress, [delegateMsg], fee, memo);
      }
      async undelegateTokens(delegatorAddress, validatorAddress, amount, fee, memo = "") {
        const undelegateMsg = {
          typeUrl: "/cosmos.staking.v1beta1.MsgUndelegate",
          value: tx_2.MsgUndelegate.fromPartial({
            delegatorAddress,
            validatorAddress,
            amount
          })
        };
        return this.signAndBroadcast(delegatorAddress, [undelegateMsg], fee, memo);
      }
      async withdrawRewards(delegatorAddress, validatorAddress, fee, memo = "") {
        const withdrawMsg = {
          typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
          value: tx_1.MsgWithdrawDelegatorReward.fromPartial({
            delegatorAddress,
            validatorAddress
          })
        };
        return this.signAndBroadcast(delegatorAddress, [withdrawMsg], fee, memo);
      }
      /**
       * @deprecated This API does not support setting the memo field of `MsgTransfer` (only the transaction memo).
       * We'll remove this method at some point because trying to wrap the various message types is a losing strategy.
       * Please migrate to `signAndBroadcast` with an `MsgTransferEncodeObject` created in the caller code instead.
       * @see https://github.com/cosmos/cosmjs/issues/1493
       */
      async sendIbcTokens(senderAddress, recipientAddress, transferAmount, sourcePort, sourceChannel, timeoutHeight, timeoutTimestamp, fee, memo = "") {
        const timeoutTimestampNanoseconds = timeoutTimestamp ? BigInt(timeoutTimestamp) * BigInt(1e9) : void 0;
        const transferMsg = {
          typeUrl: "/ibc.applications.transfer.v1.MsgTransfer",
          value: tx_4.MsgTransfer.fromPartial({
            sourcePort,
            sourceChannel,
            sender: senderAddress,
            receiver: recipientAddress,
            token: transferAmount,
            timeoutHeight,
            timeoutTimestamp: timeoutTimestampNanoseconds
          })
        };
        return this.signAndBroadcast(senderAddress, [transferMsg], fee, memo);
      }
      async signAndBroadcast(signerAddress, messages, fee, memo = "", timeoutHeight) {
        let usedFee;
        if (fee == "auto" || typeof fee === "number") {
          (0, utils_1.assertDefined)(this.gasPrice, "Gas price must be set in the client options when auto gas is used.");
          const gasEstimation = await this.simulate(signerAddress, messages, memo);
          const multiplier = typeof fee === "number" ? fee : this.defaultGasMultiplier;
          usedFee = (0, fee_1.calculateFee)(Math.round(gasEstimation * multiplier), this.gasPrice);
        } else {
          usedFee = fee;
        }
        const txRaw = await this.sign(signerAddress, messages, usedFee, memo, void 0, timeoutHeight);
        const txBytes = tx_3.TxRaw.encode(txRaw).finish();
        return this.broadcastTx(txBytes, this.broadcastTimeoutMs, this.broadcastPollIntervalMs);
      }
      /**
       * This method is useful if you want to send a transaction in broadcast,
       * without waiting for it to be placed inside a block, because for example
       * I would like to receive the hash to later track the transaction with another tool.
       * @returns Returns the hash of the transaction
       */
      async signAndBroadcastSync(signerAddress, messages, fee, memo = "", timeoutHeight) {
        let usedFee;
        if (fee == "auto" || typeof fee === "number") {
          (0, utils_1.assertDefined)(this.gasPrice, "Gas price must be set in the client options when auto gas is used.");
          const gasEstimation = await this.simulate(signerAddress, messages, memo);
          const multiplier = typeof fee === "number" ? fee : this.defaultGasMultiplier;
          usedFee = (0, fee_1.calculateFee)(Math.round(gasEstimation * multiplier), this.gasPrice);
        } else {
          usedFee = fee;
        }
        const txRaw = await this.sign(signerAddress, messages, usedFee, memo, void 0, timeoutHeight);
        const txBytes = tx_3.TxRaw.encode(txRaw).finish();
        return this.broadcastTxSync(txBytes);
      }
      /**
       * Gets account number and sequence from the API, creates a sign doc,
       * creates a single signature and assembles the signed transaction.
       *
       * The sign mode (SIGN_MODE_DIRECT or SIGN_MODE_LEGACY_AMINO_JSON) is determined by this client's signer.
       *
       * You can pass signer data (account number, sequence and chain ID) explicitly instead of querying them
       * from the chain. This is needed when signing for a multisig account, but it also allows for offline signing
       * (See the SigningStargateClient.offline constructor).
       */
      async sign(signerAddress, messages, fee, memo, explicitSignerData, timeoutHeight) {
        let signerData;
        if (explicitSignerData) {
          signerData = explicitSignerData;
        } else {
          const { accountNumber, sequence } = await this.getSequence(signerAddress);
          const chainId = await this.getChainId();
          signerData = {
            accountNumber,
            sequence,
            chainId
          };
        }
        return (0, proto_signing_1.isOfflineDirectSigner)(this.signer) ? this.signDirect(signerAddress, messages, fee, memo, signerData, timeoutHeight) : this.signAmino(signerAddress, messages, fee, memo, signerData, timeoutHeight);
      }
      async signAmino(signerAddress, messages, fee, memo, { accountNumber, sequence, chainId }, timeoutHeight) {
        (0, utils_1.assert)(!(0, proto_signing_1.isOfflineDirectSigner)(this.signer));
        const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);
        if (!accountFromSigner) {
          throw new Error("Failed to retrieve account from signer");
        }
        const pubkey = (0, proto_signing_1.encodePubkey)((0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey));
        const signMode = signing_1.SignMode.SIGN_MODE_LEGACY_AMINO_JSON;
        const msgs = messages.map((msg) => this.aminoTypes.toAmino(msg));
        const signDoc = (0, amino_1.makeSignDoc)(msgs, fee, chainId, memo, accountNumber, sequence, timeoutHeight);
        const { signature, signed } = await this.signer.signAmino(signerAddress, signDoc);
        const signedTxBody = {
          messages: signed.msgs.map((msg) => this.aminoTypes.fromAmino(msg)),
          memo: signed.memo,
          timeoutHeight
        };
        const signedTxBodyEncodeObject = {
          typeUrl: "/cosmos.tx.v1beta1.TxBody",
          value: signedTxBody
        };
        const signedTxBodyBytes = this.registry.encode(signedTxBodyEncodeObject);
        const signedGasLimit = math_1.Int53.fromString(signed.fee.gas).toNumber();
        const signedSequence = math_1.Int53.fromString(signed.sequence).toNumber();
        const signedAuthInfoBytes = (0, proto_signing_1.makeAuthInfoBytes)([{ pubkey, sequence: signedSequence }], signed.fee.amount, signedGasLimit, signed.fee.granter, signed.fee.payer, signMode);
        return tx_3.TxRaw.fromPartial({
          bodyBytes: signedTxBodyBytes,
          authInfoBytes: signedAuthInfoBytes,
          signatures: [(0, encoding_1.fromBase64)(signature.signature)]
        });
      }
      async signDirect(signerAddress, messages, fee, memo, { accountNumber, sequence, chainId }, timeoutHeight) {
        (0, utils_1.assert)((0, proto_signing_1.isOfflineDirectSigner)(this.signer));
        const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);
        if (!accountFromSigner) {
          throw new Error("Failed to retrieve account from signer");
        }
        const pubkey = (0, proto_signing_1.encodePubkey)((0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey));
        const txBodyEncodeObject = {
          typeUrl: "/cosmos.tx.v1beta1.TxBody",
          value: {
            messages,
            memo,
            timeoutHeight
          }
        };
        const txBodyBytes = this.registry.encode(txBodyEncodeObject);
        const gasLimit = math_1.Int53.fromString(fee.gas).toNumber();
        const authInfoBytes = (0, proto_signing_1.makeAuthInfoBytes)([{ pubkey, sequence }], fee.amount, gasLimit, fee.granter, fee.payer);
        const signDoc = (0, proto_signing_1.makeSignDoc)(txBodyBytes, authInfoBytes, chainId, accountNumber);
        const { signature, signed } = await this.signer.signDirect(signerAddress, signDoc);
        return tx_3.TxRaw.fromPartial({
          bodyBytes: signed.bodyBytes,
          authInfoBytes: signed.authInfoBytes,
          signatures: [(0, encoding_1.fromBase64)(signature.signature)]
        });
      }
    };
    exports.SigningStargateClient = SigningStargateClient;
  }
});

// node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/index.js
var require_build11 = __commonJS({
  "node_modules/.pnpm/@cosmjs+stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/stargate/build/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o3, m3, k5, k22) {
      if (k22 === void 0) k22 = k5;
      var desc = Object.getOwnPropertyDescriptor(m3, k5);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k5];
        } };
      }
      Object.defineProperty(o3, k22, desc);
    }) : (function(o3, m3, k5, k22) {
      if (k22 === void 0) k22 = k5;
      o3[k22] = m3[k5];
    }));
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o3, v9) {
      Object.defineProperty(o3, "default", { enumerable: true, value: v9 });
    }) : function(o3, v9) {
      o3["default"] = v9;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
      var ownKeys = function(o3) {
        ownKeys = Object.getOwnPropertyNames || function(o4) {
          var ar3 = [];
          for (var k5 in o4) if (Object.prototype.hasOwnProperty.call(o4, k5)) ar3[ar3.length] = k5;
          return ar3;
        };
        return ownKeys(o3);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k5 = ownKeys(mod), i3 = 0; i3 < k5.length; i3++) if (k5[i3] !== "default") __createBinding(result, mod, k5[i3]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isMsgVoteWeightedEncodeObject = exports.isMsgVoteEncodeObject = exports.isMsgUndelegateEncodeObject = exports.isMsgTransferEncodeObject = exports.isMsgSubmitProposalEncodeObject = exports.isMsgSendEncodeObject = exports.isMsgEditValidatorEncodeObject = exports.isMsgDepositEncodeObject = exports.isMsgDelegateEncodeObject = exports.isMsgCreateValidatorEncodeObject = exports.isMsgCancelUnbondingDelegationEncodeObject = exports.isMsgBeginRedelegateEncodeObject = exports.isAminoMsgWithdrawValidatorCommission = exports.isAminoMsgWithdrawDelegatorReward = exports.isAminoMsgVoteWeighted = exports.isAminoMsgVote = exports.isAminoMsgVerifyInvariant = exports.isAminoMsgUnjail = exports.isAminoMsgUndelegate = exports.isAminoMsgTransfer = exports.isAminoMsgSubmitProposal = exports.isAminoMsgSubmitEvidence = exports.isAminoMsgSetWithdrawAddress = exports.isAminoMsgSend = exports.isAminoMsgMultiSend = exports.isAminoMsgFundCommunityPool = exports.isAminoMsgEditValidator = exports.isAminoMsgDeposit = exports.isAminoMsgDelegate = exports.isAminoMsgCreateVestingAccount = exports.isAminoMsgCreateValidator = exports.isAminoMsgBeginRedelegate = exports.createVestingAminoConverters = exports.createStakingAminoConverters = exports.createSlashingAminoConverters = exports.createIbcAminoConverters = exports.createGroupAminoConverters = exports.createGovAminoConverters = exports.createFeegrantAminoConverters = exports.createEvidenceAminoConverters = exports.createDistributionAminoConverters = exports.createCrysisAminoConverters = exports.createBankAminoConverters = exports.createAuthzAminoConverters = exports.logs = exports.GasPrice = exports.calculateFee = exports.fromTendermintEvent = exports.AminoTypes = exports.accountFromAny = void 0;
    exports.parseCoins = exports.makeCosmoshubPath = exports.coins = exports.coin = exports.TimeoutError = exports.StargateClient = exports.isDeliverTxSuccess = exports.isDeliverTxFailure = exports.BroadcastTxError = exports.assertIsDeliverTxSuccess = exports.assertIsDeliverTxFailure = exports.SigningStargateClient = exports.defaultRegistryTypes = exports.createDefaultAminoConverters = exports.isSearchTxQueryArray = exports.QueryClient = exports.decodeCosmosSdkDecFromProto = exports.createProtobufRpcClient = exports.createPagination = exports.makeMultisignedTxBytes = exports.makeMultisignedTx = exports.setupTxExtension = exports.setupStakingExtension = exports.setupSlashingExtension = exports.setupMintExtension = exports.setupIbcExtension = exports.setupGovExtension = exports.setupFeegrantExtension = exports.setupDistributionExtension = exports.setupBankExtension = exports.setupAuthzExtension = exports.setupAuthExtension = exports.isMsgWithdrawDelegatorRewardEncodeObject = void 0;
    var accounts_1 = require_accounts();
    Object.defineProperty(exports, "accountFromAny", { enumerable: true, get: function() {
      return accounts_1.accountFromAny;
    } });
    var aminotypes_1 = require_aminotypes();
    Object.defineProperty(exports, "AminoTypes", { enumerable: true, get: function() {
      return aminotypes_1.AminoTypes;
    } });
    var events_1 = require_events2();
    Object.defineProperty(exports, "fromTendermintEvent", { enumerable: true, get: function() {
      return events_1.fromTendermintEvent;
    } });
    var fee_1 = require_fee();
    Object.defineProperty(exports, "calculateFee", { enumerable: true, get: function() {
      return fee_1.calculateFee;
    } });
    Object.defineProperty(exports, "GasPrice", { enumerable: true, get: function() {
      return fee_1.GasPrice;
    } });
    exports.logs = __importStar(require_logs());
    var modules_1 = require_modules();
    Object.defineProperty(exports, "createAuthzAminoConverters", { enumerable: true, get: function() {
      return modules_1.createAuthzAminoConverters;
    } });
    Object.defineProperty(exports, "createBankAminoConverters", { enumerable: true, get: function() {
      return modules_1.createBankAminoConverters;
    } });
    Object.defineProperty(exports, "createCrysisAminoConverters", { enumerable: true, get: function() {
      return modules_1.createCrysisAminoConverters;
    } });
    Object.defineProperty(exports, "createDistributionAminoConverters", { enumerable: true, get: function() {
      return modules_1.createDistributionAminoConverters;
    } });
    Object.defineProperty(exports, "createEvidenceAminoConverters", { enumerable: true, get: function() {
      return modules_1.createEvidenceAminoConverters;
    } });
    Object.defineProperty(exports, "createFeegrantAminoConverters", { enumerable: true, get: function() {
      return modules_1.createFeegrantAminoConverters;
    } });
    Object.defineProperty(exports, "createGovAminoConverters", { enumerable: true, get: function() {
      return modules_1.createGovAminoConverters;
    } });
    Object.defineProperty(exports, "createGroupAminoConverters", { enumerable: true, get: function() {
      return modules_1.createGroupAminoConverters;
    } });
    Object.defineProperty(exports, "createIbcAminoConverters", { enumerable: true, get: function() {
      return modules_1.createIbcAminoConverters;
    } });
    Object.defineProperty(exports, "createSlashingAminoConverters", { enumerable: true, get: function() {
      return modules_1.createSlashingAminoConverters;
    } });
    Object.defineProperty(exports, "createStakingAminoConverters", { enumerable: true, get: function() {
      return modules_1.createStakingAminoConverters;
    } });
    Object.defineProperty(exports, "createVestingAminoConverters", { enumerable: true, get: function() {
      return modules_1.createVestingAminoConverters;
    } });
    Object.defineProperty(exports, "isAminoMsgBeginRedelegate", { enumerable: true, get: function() {
      return modules_1.isAminoMsgBeginRedelegate;
    } });
    Object.defineProperty(exports, "isAminoMsgCreateValidator", { enumerable: true, get: function() {
      return modules_1.isAminoMsgCreateValidator;
    } });
    Object.defineProperty(exports, "isAminoMsgCreateVestingAccount", { enumerable: true, get: function() {
      return modules_1.isAminoMsgCreateVestingAccount;
    } });
    Object.defineProperty(exports, "isAminoMsgDelegate", { enumerable: true, get: function() {
      return modules_1.isAminoMsgDelegate;
    } });
    Object.defineProperty(exports, "isAminoMsgDeposit", { enumerable: true, get: function() {
      return modules_1.isAminoMsgDeposit;
    } });
    Object.defineProperty(exports, "isAminoMsgEditValidator", { enumerable: true, get: function() {
      return modules_1.isAminoMsgEditValidator;
    } });
    Object.defineProperty(exports, "isAminoMsgFundCommunityPool", { enumerable: true, get: function() {
      return modules_1.isAminoMsgFundCommunityPool;
    } });
    Object.defineProperty(exports, "isAminoMsgMultiSend", { enumerable: true, get: function() {
      return modules_1.isAminoMsgMultiSend;
    } });
    Object.defineProperty(exports, "isAminoMsgSend", { enumerable: true, get: function() {
      return modules_1.isAminoMsgSend;
    } });
    Object.defineProperty(exports, "isAminoMsgSetWithdrawAddress", { enumerable: true, get: function() {
      return modules_1.isAminoMsgSetWithdrawAddress;
    } });
    Object.defineProperty(exports, "isAminoMsgSubmitEvidence", { enumerable: true, get: function() {
      return modules_1.isAminoMsgSubmitEvidence;
    } });
    Object.defineProperty(exports, "isAminoMsgSubmitProposal", { enumerable: true, get: function() {
      return modules_1.isAminoMsgSubmitProposal;
    } });
    Object.defineProperty(exports, "isAminoMsgTransfer", { enumerable: true, get: function() {
      return modules_1.isAminoMsgTransfer;
    } });
    Object.defineProperty(exports, "isAminoMsgUndelegate", { enumerable: true, get: function() {
      return modules_1.isAminoMsgUndelegate;
    } });
    Object.defineProperty(exports, "isAminoMsgUnjail", { enumerable: true, get: function() {
      return modules_1.isAminoMsgUnjail;
    } });
    Object.defineProperty(exports, "isAminoMsgVerifyInvariant", { enumerable: true, get: function() {
      return modules_1.isAminoMsgVerifyInvariant;
    } });
    Object.defineProperty(exports, "isAminoMsgVote", { enumerable: true, get: function() {
      return modules_1.isAminoMsgVote;
    } });
    Object.defineProperty(exports, "isAminoMsgVoteWeighted", { enumerable: true, get: function() {
      return modules_1.isAminoMsgVoteWeighted;
    } });
    Object.defineProperty(exports, "isAminoMsgWithdrawDelegatorReward", { enumerable: true, get: function() {
      return modules_1.isAminoMsgWithdrawDelegatorReward;
    } });
    Object.defineProperty(exports, "isAminoMsgWithdrawValidatorCommission", { enumerable: true, get: function() {
      return modules_1.isAminoMsgWithdrawValidatorCommission;
    } });
    Object.defineProperty(exports, "isMsgBeginRedelegateEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgBeginRedelegateEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgCancelUnbondingDelegationEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgCancelUnbondingDelegationEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgCreateValidatorEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgCreateValidatorEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgDelegateEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgDelegateEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgDepositEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgDepositEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgEditValidatorEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgEditValidatorEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgSendEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgSendEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgSubmitProposalEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgSubmitProposalEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgTransferEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgTransferEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgUndelegateEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgUndelegateEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgVoteEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgVoteEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgVoteWeightedEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgVoteWeightedEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgWithdrawDelegatorRewardEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgWithdrawDelegatorRewardEncodeObject;
    } });
    Object.defineProperty(exports, "setupAuthExtension", { enumerable: true, get: function() {
      return modules_1.setupAuthExtension;
    } });
    Object.defineProperty(exports, "setupAuthzExtension", { enumerable: true, get: function() {
      return modules_1.setupAuthzExtension;
    } });
    Object.defineProperty(exports, "setupBankExtension", { enumerable: true, get: function() {
      return modules_1.setupBankExtension;
    } });
    Object.defineProperty(exports, "setupDistributionExtension", { enumerable: true, get: function() {
      return modules_1.setupDistributionExtension;
    } });
    Object.defineProperty(exports, "setupFeegrantExtension", { enumerable: true, get: function() {
      return modules_1.setupFeegrantExtension;
    } });
    Object.defineProperty(exports, "setupGovExtension", { enumerable: true, get: function() {
      return modules_1.setupGovExtension;
    } });
    Object.defineProperty(exports, "setupIbcExtension", { enumerable: true, get: function() {
      return modules_1.setupIbcExtension;
    } });
    Object.defineProperty(exports, "setupMintExtension", { enumerable: true, get: function() {
      return modules_1.setupMintExtension;
    } });
    Object.defineProperty(exports, "setupSlashingExtension", { enumerable: true, get: function() {
      return modules_1.setupSlashingExtension;
    } });
    Object.defineProperty(exports, "setupStakingExtension", { enumerable: true, get: function() {
      return modules_1.setupStakingExtension;
    } });
    Object.defineProperty(exports, "setupTxExtension", { enumerable: true, get: function() {
      return modules_1.setupTxExtension;
    } });
    var multisignature_1 = require_multisignature();
    Object.defineProperty(exports, "makeMultisignedTx", { enumerable: true, get: function() {
      return multisignature_1.makeMultisignedTx;
    } });
    Object.defineProperty(exports, "makeMultisignedTxBytes", { enumerable: true, get: function() {
      return multisignature_1.makeMultisignedTxBytes;
    } });
    var queryclient_1 = require_queryclient2();
    Object.defineProperty(exports, "createPagination", { enumerable: true, get: function() {
      return queryclient_1.createPagination;
    } });
    Object.defineProperty(exports, "createProtobufRpcClient", { enumerable: true, get: function() {
      return queryclient_1.createProtobufRpcClient;
    } });
    Object.defineProperty(exports, "decodeCosmosSdkDecFromProto", { enumerable: true, get: function() {
      return queryclient_1.decodeCosmosSdkDecFromProto;
    } });
    Object.defineProperty(exports, "QueryClient", { enumerable: true, get: function() {
      return queryclient_1.QueryClient;
    } });
    var search_1 = require_search();
    Object.defineProperty(exports, "isSearchTxQueryArray", { enumerable: true, get: function() {
      return search_1.isSearchTxQueryArray;
    } });
    var signingstargateclient_1 = require_signingstargateclient();
    Object.defineProperty(exports, "createDefaultAminoConverters", { enumerable: true, get: function() {
      return signingstargateclient_1.createDefaultAminoConverters;
    } });
    Object.defineProperty(exports, "defaultRegistryTypes", { enumerable: true, get: function() {
      return signingstargateclient_1.defaultRegistryTypes;
    } });
    Object.defineProperty(exports, "SigningStargateClient", { enumerable: true, get: function() {
      return signingstargateclient_1.SigningStargateClient;
    } });
    var stargateclient_1 = require_stargateclient();
    Object.defineProperty(exports, "assertIsDeliverTxFailure", { enumerable: true, get: function() {
      return stargateclient_1.assertIsDeliverTxFailure;
    } });
    Object.defineProperty(exports, "assertIsDeliverTxSuccess", { enumerable: true, get: function() {
      return stargateclient_1.assertIsDeliverTxSuccess;
    } });
    Object.defineProperty(exports, "BroadcastTxError", { enumerable: true, get: function() {
      return stargateclient_1.BroadcastTxError;
    } });
    Object.defineProperty(exports, "isDeliverTxFailure", { enumerable: true, get: function() {
      return stargateclient_1.isDeliverTxFailure;
    } });
    Object.defineProperty(exports, "isDeliverTxSuccess", { enumerable: true, get: function() {
      return stargateclient_1.isDeliverTxSuccess;
    } });
    Object.defineProperty(exports, "StargateClient", { enumerable: true, get: function() {
      return stargateclient_1.StargateClient;
    } });
    Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: function() {
      return stargateclient_1.TimeoutError;
    } });
    var proto_signing_1 = require_build6();
    Object.defineProperty(exports, "coin", { enumerable: true, get: function() {
      return proto_signing_1.coin;
    } });
    Object.defineProperty(exports, "coins", { enumerable: true, get: function() {
      return proto_signing_1.coins;
    } });
    Object.defineProperty(exports, "makeCosmoshubPath", { enumerable: true, get: function() {
      return proto_signing_1.makeCosmoshubPath;
    } });
    Object.defineProperty(exports, "parseCoins", { enumerable: true, get: function() {
      return proto_signing_1.parseCoins;
    } });
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmwasm/wasm/v1/types.js
var require_types7 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmwasm/wasm/v1/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Model = exports.AbsoluteTxPosition = exports.ContractCodeHistoryEntry = exports.ContractInfo = exports.CodeInfo = exports.Params = exports.AccessConfig = exports.AccessTypeParam = exports.contractCodeHistoryOperationTypeToJSON = exports.contractCodeHistoryOperationTypeFromJSON = exports.ContractCodeHistoryOperationType = exports.accessTypeToJSON = exports.accessTypeFromJSON = exports.AccessType = exports.protobufPackage = void 0;
    var any_1 = require_any();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmwasm.wasm.v1";
    var AccessType;
    (function(AccessType2) {
      AccessType2[AccessType2["ACCESS_TYPE_UNSPECIFIED"] = 0] = "ACCESS_TYPE_UNSPECIFIED";
      AccessType2[AccessType2["ACCESS_TYPE_NOBODY"] = 1] = "ACCESS_TYPE_NOBODY";
      AccessType2[AccessType2["ACCESS_TYPE_EVERYBODY"] = 3] = "ACCESS_TYPE_EVERYBODY";
      AccessType2[AccessType2["ACCESS_TYPE_ANY_OF_ADDRESSES"] = 4] = "ACCESS_TYPE_ANY_OF_ADDRESSES";
      AccessType2[AccessType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(AccessType || (exports.AccessType = AccessType = {}));
    function accessTypeFromJSON(object) {
      switch (object) {
        case 0:
        case "ACCESS_TYPE_UNSPECIFIED":
          return AccessType.ACCESS_TYPE_UNSPECIFIED;
        case 1:
        case "ACCESS_TYPE_NOBODY":
          return AccessType.ACCESS_TYPE_NOBODY;
        case 3:
        case "ACCESS_TYPE_EVERYBODY":
          return AccessType.ACCESS_TYPE_EVERYBODY;
        case 4:
        case "ACCESS_TYPE_ANY_OF_ADDRESSES":
          return AccessType.ACCESS_TYPE_ANY_OF_ADDRESSES;
        case -1:
        case "UNRECOGNIZED":
        default:
          return AccessType.UNRECOGNIZED;
      }
    }
    exports.accessTypeFromJSON = accessTypeFromJSON;
    function accessTypeToJSON(object) {
      switch (object) {
        case AccessType.ACCESS_TYPE_UNSPECIFIED:
          return "ACCESS_TYPE_UNSPECIFIED";
        case AccessType.ACCESS_TYPE_NOBODY:
          return "ACCESS_TYPE_NOBODY";
        case AccessType.ACCESS_TYPE_EVERYBODY:
          return "ACCESS_TYPE_EVERYBODY";
        case AccessType.ACCESS_TYPE_ANY_OF_ADDRESSES:
          return "ACCESS_TYPE_ANY_OF_ADDRESSES";
        case AccessType.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.accessTypeToJSON = accessTypeToJSON;
    var ContractCodeHistoryOperationType;
    (function(ContractCodeHistoryOperationType2) {
      ContractCodeHistoryOperationType2[ContractCodeHistoryOperationType2["CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED"] = 0] = "CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED";
      ContractCodeHistoryOperationType2[ContractCodeHistoryOperationType2["CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT"] = 1] = "CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT";
      ContractCodeHistoryOperationType2[ContractCodeHistoryOperationType2["CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE"] = 2] = "CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE";
      ContractCodeHistoryOperationType2[ContractCodeHistoryOperationType2["CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS"] = 3] = "CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS";
      ContractCodeHistoryOperationType2[ContractCodeHistoryOperationType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ContractCodeHistoryOperationType || (exports.ContractCodeHistoryOperationType = ContractCodeHistoryOperationType = {}));
    function contractCodeHistoryOperationTypeFromJSON(object) {
      switch (object) {
        case 0:
        case "CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED":
          return ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED;
        case 1:
        case "CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT":
          return ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT;
        case 2:
        case "CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE":
          return ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE;
        case 3:
        case "CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS":
          return ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS;
        case -1:
        case "UNRECOGNIZED":
        default:
          return ContractCodeHistoryOperationType.UNRECOGNIZED;
      }
    }
    exports.contractCodeHistoryOperationTypeFromJSON = contractCodeHistoryOperationTypeFromJSON;
    function contractCodeHistoryOperationTypeToJSON(object) {
      switch (object) {
        case ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED:
          return "CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED";
        case ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT:
          return "CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT";
        case ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE:
          return "CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE";
        case ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS:
          return "CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS";
        case ContractCodeHistoryOperationType.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    exports.contractCodeHistoryOperationTypeToJSON = contractCodeHistoryOperationTypeToJSON;
    function createBaseAccessTypeParam() {
      return {
        value: 0
      };
    }
    exports.AccessTypeParam = {
      typeUrl: "/cosmwasm.wasm.v1.AccessTypeParam",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.value !== 0) {
          writer.uint32(8).int32(message.value);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAccessTypeParam();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.value = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseAccessTypeParam();
        if ((0, helpers_1.isSet)(object.value))
          obj.value = accessTypeFromJSON(object.value);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.value !== void 0 && (obj.value = accessTypeToJSON(message.value));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseAccessTypeParam();
        message.value = object.value ?? 0;
        return message;
      }
    };
    function createBaseAccessConfig() {
      return {
        permission: 0,
        addresses: []
      };
    }
    exports.AccessConfig = {
      typeUrl: "/cosmwasm.wasm.v1.AccessConfig",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.permission !== 0) {
          writer.uint32(8).int32(message.permission);
        }
        for (const v9 of message.addresses) {
          writer.uint32(26).string(v9);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAccessConfig();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.permission = reader.int32();
              break;
            case 3:
              message.addresses.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseAccessConfig();
        if ((0, helpers_1.isSet)(object.permission))
          obj.permission = accessTypeFromJSON(object.permission);
        if (Array.isArray(object?.addresses))
          obj.addresses = object.addresses.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.permission !== void 0 && (obj.permission = accessTypeToJSON(message.permission));
        if (message.addresses) {
          obj.addresses = message.addresses.map((e) => e);
        } else {
          obj.addresses = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseAccessConfig();
        message.permission = object.permission ?? 0;
        message.addresses = object.addresses?.map((e) => e) || [];
        return message;
      }
    };
    function createBaseParams() {
      return {
        codeUploadAccess: exports.AccessConfig.fromPartial({}),
        instantiateDefaultPermission: 0
      };
    }
    exports.Params = {
      typeUrl: "/cosmwasm.wasm.v1.Params",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.codeUploadAccess !== void 0) {
          exports.AccessConfig.encode(message.codeUploadAccess, writer.uint32(10).fork()).ldelim();
        }
        if (message.instantiateDefaultPermission !== 0) {
          writer.uint32(16).int32(message.instantiateDefaultPermission);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.codeUploadAccess = exports.AccessConfig.decode(reader, reader.uint32());
              break;
            case 2:
              message.instantiateDefaultPermission = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseParams();
        if ((0, helpers_1.isSet)(object.codeUploadAccess))
          obj.codeUploadAccess = exports.AccessConfig.fromJSON(object.codeUploadAccess);
        if ((0, helpers_1.isSet)(object.instantiateDefaultPermission))
          obj.instantiateDefaultPermission = accessTypeFromJSON(object.instantiateDefaultPermission);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.codeUploadAccess !== void 0 && (obj.codeUploadAccess = message.codeUploadAccess ? exports.AccessConfig.toJSON(message.codeUploadAccess) : void 0);
        message.instantiateDefaultPermission !== void 0 && (obj.instantiateDefaultPermission = accessTypeToJSON(message.instantiateDefaultPermission));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseParams();
        if (object.codeUploadAccess !== void 0 && object.codeUploadAccess !== null) {
          message.codeUploadAccess = exports.AccessConfig.fromPartial(object.codeUploadAccess);
        }
        message.instantiateDefaultPermission = object.instantiateDefaultPermission ?? 0;
        return message;
      }
    };
    function createBaseCodeInfo() {
      return {
        codeHash: new Uint8Array(),
        creator: "",
        instantiateConfig: exports.AccessConfig.fromPartial({})
      };
    }
    exports.CodeInfo = {
      typeUrl: "/cosmwasm.wasm.v1.CodeInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.codeHash.length !== 0) {
          writer.uint32(10).bytes(message.codeHash);
        }
        if (message.creator !== "") {
          writer.uint32(18).string(message.creator);
        }
        if (message.instantiateConfig !== void 0) {
          exports.AccessConfig.encode(message.instantiateConfig, writer.uint32(42).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCodeInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.codeHash = reader.bytes();
              break;
            case 2:
              message.creator = reader.string();
              break;
            case 5:
              message.instantiateConfig = exports.AccessConfig.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCodeInfo();
        if ((0, helpers_1.isSet)(object.codeHash))
          obj.codeHash = (0, helpers_1.bytesFromBase64)(object.codeHash);
        if ((0, helpers_1.isSet)(object.creator))
          obj.creator = String(object.creator);
        if ((0, helpers_1.isSet)(object.instantiateConfig))
          obj.instantiateConfig = exports.AccessConfig.fromJSON(object.instantiateConfig);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.codeHash !== void 0 && (obj.codeHash = (0, helpers_1.base64FromBytes)(message.codeHash !== void 0 ? message.codeHash : new Uint8Array()));
        message.creator !== void 0 && (obj.creator = message.creator);
        message.instantiateConfig !== void 0 && (obj.instantiateConfig = message.instantiateConfig ? exports.AccessConfig.toJSON(message.instantiateConfig) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCodeInfo();
        message.codeHash = object.codeHash ?? new Uint8Array();
        message.creator = object.creator ?? "";
        if (object.instantiateConfig !== void 0 && object.instantiateConfig !== null) {
          message.instantiateConfig = exports.AccessConfig.fromPartial(object.instantiateConfig);
        }
        return message;
      }
    };
    function createBaseContractInfo() {
      return {
        codeId: BigInt(0),
        creator: "",
        admin: "",
        label: "",
        created: void 0,
        ibcPortId: "",
        extension: void 0
      };
    }
    exports.ContractInfo = {
      typeUrl: "/cosmwasm.wasm.v1.ContractInfo",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.codeId !== BigInt(0)) {
          writer.uint32(8).uint64(message.codeId);
        }
        if (message.creator !== "") {
          writer.uint32(18).string(message.creator);
        }
        if (message.admin !== "") {
          writer.uint32(26).string(message.admin);
        }
        if (message.label !== "") {
          writer.uint32(34).string(message.label);
        }
        if (message.created !== void 0) {
          exports.AbsoluteTxPosition.encode(message.created, writer.uint32(42).fork()).ldelim();
        }
        if (message.ibcPortId !== "") {
          writer.uint32(50).string(message.ibcPortId);
        }
        if (message.extension !== void 0) {
          any_1.Any.encode(message.extension, writer.uint32(58).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseContractInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.codeId = reader.uint64();
              break;
            case 2:
              message.creator = reader.string();
              break;
            case 3:
              message.admin = reader.string();
              break;
            case 4:
              message.label = reader.string();
              break;
            case 5:
              message.created = exports.AbsoluteTxPosition.decode(reader, reader.uint32());
              break;
            case 6:
              message.ibcPortId = reader.string();
              break;
            case 7:
              message.extension = any_1.Any.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseContractInfo();
        if ((0, helpers_1.isSet)(object.codeId))
          obj.codeId = BigInt(object.codeId.toString());
        if ((0, helpers_1.isSet)(object.creator))
          obj.creator = String(object.creator);
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.label))
          obj.label = String(object.label);
        if ((0, helpers_1.isSet)(object.created))
          obj.created = exports.AbsoluteTxPosition.fromJSON(object.created);
        if ((0, helpers_1.isSet)(object.ibcPortId))
          obj.ibcPortId = String(object.ibcPortId);
        if ((0, helpers_1.isSet)(object.extension))
          obj.extension = any_1.Any.fromJSON(object.extension);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.codeId !== void 0 && (obj.codeId = (message.codeId || BigInt(0)).toString());
        message.creator !== void 0 && (obj.creator = message.creator);
        message.admin !== void 0 && (obj.admin = message.admin);
        message.label !== void 0 && (obj.label = message.label);
        message.created !== void 0 && (obj.created = message.created ? exports.AbsoluteTxPosition.toJSON(message.created) : void 0);
        message.ibcPortId !== void 0 && (obj.ibcPortId = message.ibcPortId);
        message.extension !== void 0 && (obj.extension = message.extension ? any_1.Any.toJSON(message.extension) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseContractInfo();
        if (object.codeId !== void 0 && object.codeId !== null) {
          message.codeId = BigInt(object.codeId.toString());
        }
        message.creator = object.creator ?? "";
        message.admin = object.admin ?? "";
        message.label = object.label ?? "";
        if (object.created !== void 0 && object.created !== null) {
          message.created = exports.AbsoluteTxPosition.fromPartial(object.created);
        }
        message.ibcPortId = object.ibcPortId ?? "";
        if (object.extension !== void 0 && object.extension !== null) {
          message.extension = any_1.Any.fromPartial(object.extension);
        }
        return message;
      }
    };
    function createBaseContractCodeHistoryEntry() {
      return {
        operation: 0,
        codeId: BigInt(0),
        updated: void 0,
        msg: new Uint8Array()
      };
    }
    exports.ContractCodeHistoryEntry = {
      typeUrl: "/cosmwasm.wasm.v1.ContractCodeHistoryEntry",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.operation !== 0) {
          writer.uint32(8).int32(message.operation);
        }
        if (message.codeId !== BigInt(0)) {
          writer.uint32(16).uint64(message.codeId);
        }
        if (message.updated !== void 0) {
          exports.AbsoluteTxPosition.encode(message.updated, writer.uint32(26).fork()).ldelim();
        }
        if (message.msg.length !== 0) {
          writer.uint32(34).bytes(message.msg);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseContractCodeHistoryEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.operation = reader.int32();
              break;
            case 2:
              message.codeId = reader.uint64();
              break;
            case 3:
              message.updated = exports.AbsoluteTxPosition.decode(reader, reader.uint32());
              break;
            case 4:
              message.msg = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseContractCodeHistoryEntry();
        if ((0, helpers_1.isSet)(object.operation))
          obj.operation = contractCodeHistoryOperationTypeFromJSON(object.operation);
        if ((0, helpers_1.isSet)(object.codeId))
          obj.codeId = BigInt(object.codeId.toString());
        if ((0, helpers_1.isSet)(object.updated))
          obj.updated = exports.AbsoluteTxPosition.fromJSON(object.updated);
        if ((0, helpers_1.isSet)(object.msg))
          obj.msg = (0, helpers_1.bytesFromBase64)(object.msg);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.operation !== void 0 && (obj.operation = contractCodeHistoryOperationTypeToJSON(message.operation));
        message.codeId !== void 0 && (obj.codeId = (message.codeId || BigInt(0)).toString());
        message.updated !== void 0 && (obj.updated = message.updated ? exports.AbsoluteTxPosition.toJSON(message.updated) : void 0);
        message.msg !== void 0 && (obj.msg = (0, helpers_1.base64FromBytes)(message.msg !== void 0 ? message.msg : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseContractCodeHistoryEntry();
        message.operation = object.operation ?? 0;
        if (object.codeId !== void 0 && object.codeId !== null) {
          message.codeId = BigInt(object.codeId.toString());
        }
        if (object.updated !== void 0 && object.updated !== null) {
          message.updated = exports.AbsoluteTxPosition.fromPartial(object.updated);
        }
        message.msg = object.msg ?? new Uint8Array();
        return message;
      }
    };
    function createBaseAbsoluteTxPosition() {
      return {
        blockHeight: BigInt(0),
        txIndex: BigInt(0)
      };
    }
    exports.AbsoluteTxPosition = {
      typeUrl: "/cosmwasm.wasm.v1.AbsoluteTxPosition",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.blockHeight !== BigInt(0)) {
          writer.uint32(8).uint64(message.blockHeight);
        }
        if (message.txIndex !== BigInt(0)) {
          writer.uint32(16).uint64(message.txIndex);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAbsoluteTxPosition();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.blockHeight = reader.uint64();
              break;
            case 2:
              message.txIndex = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseAbsoluteTxPosition();
        if ((0, helpers_1.isSet)(object.blockHeight))
          obj.blockHeight = BigInt(object.blockHeight.toString());
        if ((0, helpers_1.isSet)(object.txIndex))
          obj.txIndex = BigInt(object.txIndex.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.blockHeight !== void 0 && (obj.blockHeight = (message.blockHeight || BigInt(0)).toString());
        message.txIndex !== void 0 && (obj.txIndex = (message.txIndex || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseAbsoluteTxPosition();
        if (object.blockHeight !== void 0 && object.blockHeight !== null) {
          message.blockHeight = BigInt(object.blockHeight.toString());
        }
        if (object.txIndex !== void 0 && object.txIndex !== null) {
          message.txIndex = BigInt(object.txIndex.toString());
        }
        return message;
      }
    };
    function createBaseModel() {
      return {
        key: new Uint8Array(),
        value: new Uint8Array()
      };
    }
    exports.Model = {
      typeUrl: "/cosmwasm.wasm.v1.Model",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.key.length !== 0) {
          writer.uint32(10).bytes(message.key);
        }
        if (message.value.length !== 0) {
          writer.uint32(18).bytes(message.value);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseModel();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.key = reader.bytes();
              break;
            case 2:
              message.value = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseModel();
        if ((0, helpers_1.isSet)(object.key))
          obj.key = (0, helpers_1.bytesFromBase64)(object.key);
        if ((0, helpers_1.isSet)(object.value))
          obj.value = (0, helpers_1.bytesFromBase64)(object.value);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.key !== void 0 && (obj.key = (0, helpers_1.base64FromBytes)(message.key !== void 0 ? message.key : new Uint8Array()));
        message.value !== void 0 && (obj.value = (0, helpers_1.base64FromBytes)(message.value !== void 0 ? message.value : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseModel();
        message.key = object.key ?? new Uint8Array();
        message.value = object.value ?? new Uint8Array();
        return message;
      }
    };
  }
});

// node_modules/.pnpm/@cosmjs+cosmwasm-stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/cosmwasm-stargate/build/modules/wasm/aminomessages.js
var require_aminomessages13 = __commonJS({
  "node_modules/.pnpm/@cosmjs+cosmwasm-stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/cosmwasm-stargate/build/modules/wasm/aminomessages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.accessTypeFromString = accessTypeFromString;
    exports.accessTypeToString = accessTypeToString;
    exports.createWasmAminoConverters = createWasmAminoConverters;
    var amino_1 = require_build5();
    var encoding_1 = require_build2();
    var types_1 = require_types7();
    function accessTypeFromString(str2) {
      switch (str2) {
        case "Unspecified":
          return types_1.AccessType.ACCESS_TYPE_UNSPECIFIED;
        case "Nobody":
          return types_1.AccessType.ACCESS_TYPE_NOBODY;
        case "Everybody":
          return types_1.AccessType.ACCESS_TYPE_EVERYBODY;
        case "AnyOfAddresses":
          return types_1.AccessType.ACCESS_TYPE_ANY_OF_ADDRESSES;
        default:
          return types_1.AccessType.UNRECOGNIZED;
      }
    }
    function accessTypeToString(object) {
      switch (object) {
        case types_1.AccessType.ACCESS_TYPE_UNSPECIFIED:
          return "Unspecified";
        case types_1.AccessType.ACCESS_TYPE_NOBODY:
          return "Nobody";
        case types_1.AccessType.ACCESS_TYPE_EVERYBODY:
          return "Everybody";
        case types_1.AccessType.ACCESS_TYPE_ANY_OF_ADDRESSES:
          return "AnyOfAddresses";
        case types_1.AccessType.UNRECOGNIZED:
        default:
          return "UNRECOGNIZED";
      }
    }
    function createWasmAminoConverters() {
      return {
        "/cosmwasm.wasm.v1.MsgStoreCode": {
          aminoType: "wasm/MsgStoreCode",
          toAmino: ({ sender, wasmByteCode, instantiatePermission }) => ({
            sender,
            wasm_byte_code: (0, encoding_1.toBase64)(wasmByteCode),
            instantiate_permission: instantiatePermission ? {
              permission: accessTypeToString(instantiatePermission.permission),
              addresses: instantiatePermission.addresses.length !== 0 ? instantiatePermission.addresses : void 0
            } : void 0
          }),
          fromAmino: ({ sender, wasm_byte_code, instantiate_permission }) => ({
            sender,
            wasmByteCode: (0, encoding_1.fromBase64)(wasm_byte_code),
            instantiatePermission: instantiate_permission ? types_1.AccessConfig.fromPartial({
              permission: accessTypeFromString(instantiate_permission.permission),
              addresses: instantiate_permission.addresses ?? []
            }) : void 0
          })
        },
        "/cosmwasm.wasm.v1.MsgInstantiateContract": {
          aminoType: "wasm/MsgInstantiateContract",
          toAmino: ({ sender, codeId, label, msg, funds, admin }) => ({
            sender,
            code_id: codeId.toString(),
            label,
            msg: JSON.parse((0, encoding_1.fromUtf8)(msg)),
            funds,
            admin: (0, amino_1.omitDefault)(admin)
          }),
          fromAmino: ({ sender, code_id, label, msg, funds, admin }) => ({
            sender,
            codeId: BigInt(code_id),
            label,
            msg: (0, encoding_1.toUtf8)(JSON.stringify(msg)),
            funds: [...funds],
            admin: admin ?? ""
          })
        },
        "/cosmwasm.wasm.v1.MsgInstantiateContract2": {
          aminoType: "wasm/MsgInstantiateContract2",
          toAmino: ({ sender, codeId, label, msg, funds, admin, salt, fixMsg }) => ({
            sender,
            code_id: codeId.toString(),
            label,
            msg: JSON.parse((0, encoding_1.fromUtf8)(msg)),
            funds,
            admin: (0, amino_1.omitDefault)(admin),
            salt: (0, encoding_1.toBase64)(salt),
            fix_msg: (0, amino_1.omitDefault)(fixMsg)
          }),
          fromAmino: ({ sender, code_id, label, msg, funds, admin, salt, fix_msg }) => ({
            sender,
            codeId: BigInt(code_id),
            label,
            msg: (0, encoding_1.toUtf8)(JSON.stringify(msg)),
            funds: [...funds],
            admin: admin ?? "",
            salt: (0, encoding_1.fromBase64)(salt),
            fixMsg: fix_msg ?? false
          })
        },
        "/cosmwasm.wasm.v1.MsgUpdateAdmin": {
          aminoType: "wasm/MsgUpdateAdmin",
          toAmino: ({ sender, newAdmin, contract }) => ({
            sender,
            new_admin: newAdmin,
            contract
          }),
          fromAmino: ({ sender, new_admin, contract }) => ({
            sender,
            newAdmin: new_admin,
            contract
          })
        },
        "/cosmwasm.wasm.v1.MsgClearAdmin": {
          aminoType: "wasm/MsgClearAdmin",
          toAmino: ({ sender, contract }) => ({
            sender,
            contract
          }),
          fromAmino: ({ sender, contract }) => ({
            sender,
            contract
          })
        },
        "/cosmwasm.wasm.v1.MsgExecuteContract": {
          aminoType: "wasm/MsgExecuteContract",
          toAmino: ({ sender, contract, msg, funds }) => ({
            sender,
            contract,
            msg: JSON.parse((0, encoding_1.fromUtf8)(msg)),
            funds
          }),
          fromAmino: ({ sender, contract, msg, funds }) => ({
            sender,
            contract,
            msg: (0, encoding_1.toUtf8)(JSON.stringify(msg)),
            funds: [...funds]
          })
        },
        "/cosmwasm.wasm.v1.MsgMigrateContract": {
          aminoType: "wasm/MsgMigrateContract",
          toAmino: ({ sender, contract, codeId, msg }) => ({
            sender,
            contract,
            code_id: codeId.toString(),
            msg: JSON.parse((0, encoding_1.fromUtf8)(msg))
          }),
          fromAmino: ({ sender, contract, code_id, msg }) => ({
            sender,
            contract,
            codeId: BigInt(code_id),
            msg: (0, encoding_1.toUtf8)(JSON.stringify(msg))
          })
        }
      };
    }
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmwasm/wasm/v1/tx.js
var require_tx15 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmwasm/wasm/v1/tx.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MsgClientImpl = exports.MsgUpdateContractLabelResponse = exports.MsgUpdateContractLabel = exports.MsgStoreAndMigrateContractResponse = exports.MsgStoreAndMigrateContract = exports.MsgRemoveCodeUploadParamsAddressesResponse = exports.MsgRemoveCodeUploadParamsAddresses = exports.MsgAddCodeUploadParamsAddressesResponse = exports.MsgAddCodeUploadParamsAddresses = exports.MsgStoreAndInstantiateContractResponse = exports.MsgStoreAndInstantiateContract = exports.MsgUnpinCodesResponse = exports.MsgUnpinCodes = exports.MsgPinCodesResponse = exports.MsgPinCodes = exports.MsgSudoContractResponse = exports.MsgSudoContract = exports.MsgUpdateParamsResponse = exports.MsgUpdateParams = exports.MsgUpdateInstantiateConfigResponse = exports.MsgUpdateInstantiateConfig = exports.MsgClearAdminResponse = exports.MsgClearAdmin = exports.MsgUpdateAdminResponse = exports.MsgUpdateAdmin = exports.MsgMigrateContractResponse = exports.MsgMigrateContract = exports.MsgExecuteContractResponse = exports.MsgExecuteContract = exports.MsgInstantiateContract2Response = exports.MsgInstantiateContract2 = exports.MsgInstantiateContractResponse = exports.MsgInstantiateContract = exports.MsgStoreCodeResponse = exports.MsgStoreCode = exports.protobufPackage = void 0;
    var types_1 = require_types7();
    var coin_1 = require_coin();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmwasm.wasm.v1";
    function createBaseMsgStoreCode() {
      return {
        sender: "",
        wasmByteCode: new Uint8Array(),
        instantiatePermission: void 0
      };
    }
    exports.MsgStoreCode = {
      typeUrl: "/cosmwasm.wasm.v1.MsgStoreCode",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.sender !== "") {
          writer.uint32(10).string(message.sender);
        }
        if (message.wasmByteCode.length !== 0) {
          writer.uint32(18).bytes(message.wasmByteCode);
        }
        if (message.instantiatePermission !== void 0) {
          types_1.AccessConfig.encode(message.instantiatePermission, writer.uint32(42).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgStoreCode();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.wasmByteCode = reader.bytes();
              break;
            case 5:
              message.instantiatePermission = types_1.AccessConfig.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgStoreCode();
        if ((0, helpers_1.isSet)(object.sender))
          obj.sender = String(object.sender);
        if ((0, helpers_1.isSet)(object.wasmByteCode))
          obj.wasmByteCode = (0, helpers_1.bytesFromBase64)(object.wasmByteCode);
        if ((0, helpers_1.isSet)(object.instantiatePermission))
          obj.instantiatePermission = types_1.AccessConfig.fromJSON(object.instantiatePermission);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.sender !== void 0 && (obj.sender = message.sender);
        message.wasmByteCode !== void 0 && (obj.wasmByteCode = (0, helpers_1.base64FromBytes)(message.wasmByteCode !== void 0 ? message.wasmByteCode : new Uint8Array()));
        message.instantiatePermission !== void 0 && (obj.instantiatePermission = message.instantiatePermission ? types_1.AccessConfig.toJSON(message.instantiatePermission) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgStoreCode();
        message.sender = object.sender ?? "";
        message.wasmByteCode = object.wasmByteCode ?? new Uint8Array();
        if (object.instantiatePermission !== void 0 && object.instantiatePermission !== null) {
          message.instantiatePermission = types_1.AccessConfig.fromPartial(object.instantiatePermission);
        }
        return message;
      }
    };
    function createBaseMsgStoreCodeResponse() {
      return {
        codeId: BigInt(0),
        checksum: new Uint8Array()
      };
    }
    exports.MsgStoreCodeResponse = {
      typeUrl: "/cosmwasm.wasm.v1.MsgStoreCodeResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.codeId !== BigInt(0)) {
          writer.uint32(8).uint64(message.codeId);
        }
        if (message.checksum.length !== 0) {
          writer.uint32(18).bytes(message.checksum);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgStoreCodeResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.codeId = reader.uint64();
              break;
            case 2:
              message.checksum = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgStoreCodeResponse();
        if ((0, helpers_1.isSet)(object.codeId))
          obj.codeId = BigInt(object.codeId.toString());
        if ((0, helpers_1.isSet)(object.checksum))
          obj.checksum = (0, helpers_1.bytesFromBase64)(object.checksum);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.codeId !== void 0 && (obj.codeId = (message.codeId || BigInt(0)).toString());
        message.checksum !== void 0 && (obj.checksum = (0, helpers_1.base64FromBytes)(message.checksum !== void 0 ? message.checksum : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgStoreCodeResponse();
        if (object.codeId !== void 0 && object.codeId !== null) {
          message.codeId = BigInt(object.codeId.toString());
        }
        message.checksum = object.checksum ?? new Uint8Array();
        return message;
      }
    };
    function createBaseMsgInstantiateContract() {
      return {
        sender: "",
        admin: "",
        codeId: BigInt(0),
        label: "",
        msg: new Uint8Array(),
        funds: []
      };
    }
    exports.MsgInstantiateContract = {
      typeUrl: "/cosmwasm.wasm.v1.MsgInstantiateContract",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.sender !== "") {
          writer.uint32(10).string(message.sender);
        }
        if (message.admin !== "") {
          writer.uint32(18).string(message.admin);
        }
        if (message.codeId !== BigInt(0)) {
          writer.uint32(24).uint64(message.codeId);
        }
        if (message.label !== "") {
          writer.uint32(34).string(message.label);
        }
        if (message.msg.length !== 0) {
          writer.uint32(42).bytes(message.msg);
        }
        for (const v9 of message.funds) {
          coin_1.Coin.encode(v9, writer.uint32(50).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgInstantiateContract();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.admin = reader.string();
              break;
            case 3:
              message.codeId = reader.uint64();
              break;
            case 4:
              message.label = reader.string();
              break;
            case 5:
              message.msg = reader.bytes();
              break;
            case 6:
              message.funds.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgInstantiateContract();
        if ((0, helpers_1.isSet)(object.sender))
          obj.sender = String(object.sender);
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.codeId))
          obj.codeId = BigInt(object.codeId.toString());
        if ((0, helpers_1.isSet)(object.label))
          obj.label = String(object.label);
        if ((0, helpers_1.isSet)(object.msg))
          obj.msg = (0, helpers_1.bytesFromBase64)(object.msg);
        if (Array.isArray(object?.funds))
          obj.funds = object.funds.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.sender !== void 0 && (obj.sender = message.sender);
        message.admin !== void 0 && (obj.admin = message.admin);
        message.codeId !== void 0 && (obj.codeId = (message.codeId || BigInt(0)).toString());
        message.label !== void 0 && (obj.label = message.label);
        message.msg !== void 0 && (obj.msg = (0, helpers_1.base64FromBytes)(message.msg !== void 0 ? message.msg : new Uint8Array()));
        if (message.funds) {
          obj.funds = message.funds.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.funds = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgInstantiateContract();
        message.sender = object.sender ?? "";
        message.admin = object.admin ?? "";
        if (object.codeId !== void 0 && object.codeId !== null) {
          message.codeId = BigInt(object.codeId.toString());
        }
        message.label = object.label ?? "";
        message.msg = object.msg ?? new Uint8Array();
        message.funds = object.funds?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseMsgInstantiateContractResponse() {
      return {
        address: "",
        data: new Uint8Array()
      };
    }
    exports.MsgInstantiateContractResponse = {
      typeUrl: "/cosmwasm.wasm.v1.MsgInstantiateContractResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.data.length !== 0) {
          writer.uint32(18).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgInstantiateContractResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgInstantiateContractResponse();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.data))
          obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgInstantiateContractResponse();
        message.address = object.address ?? "";
        message.data = object.data ?? new Uint8Array();
        return message;
      }
    };
    function createBaseMsgInstantiateContract2() {
      return {
        sender: "",
        admin: "",
        codeId: BigInt(0),
        label: "",
        msg: new Uint8Array(),
        funds: [],
        salt: new Uint8Array(),
        fixMsg: false
      };
    }
    exports.MsgInstantiateContract2 = {
      typeUrl: "/cosmwasm.wasm.v1.MsgInstantiateContract2",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.sender !== "") {
          writer.uint32(10).string(message.sender);
        }
        if (message.admin !== "") {
          writer.uint32(18).string(message.admin);
        }
        if (message.codeId !== BigInt(0)) {
          writer.uint32(24).uint64(message.codeId);
        }
        if (message.label !== "") {
          writer.uint32(34).string(message.label);
        }
        if (message.msg.length !== 0) {
          writer.uint32(42).bytes(message.msg);
        }
        for (const v9 of message.funds) {
          coin_1.Coin.encode(v9, writer.uint32(50).fork()).ldelim();
        }
        if (message.salt.length !== 0) {
          writer.uint32(58).bytes(message.salt);
        }
        if (message.fixMsg === true) {
          writer.uint32(64).bool(message.fixMsg);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgInstantiateContract2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.admin = reader.string();
              break;
            case 3:
              message.codeId = reader.uint64();
              break;
            case 4:
              message.label = reader.string();
              break;
            case 5:
              message.msg = reader.bytes();
              break;
            case 6:
              message.funds.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 7:
              message.salt = reader.bytes();
              break;
            case 8:
              message.fixMsg = reader.bool();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgInstantiateContract2();
        if ((0, helpers_1.isSet)(object.sender))
          obj.sender = String(object.sender);
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.codeId))
          obj.codeId = BigInt(object.codeId.toString());
        if ((0, helpers_1.isSet)(object.label))
          obj.label = String(object.label);
        if ((0, helpers_1.isSet)(object.msg))
          obj.msg = (0, helpers_1.bytesFromBase64)(object.msg);
        if (Array.isArray(object?.funds))
          obj.funds = object.funds.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.salt))
          obj.salt = (0, helpers_1.bytesFromBase64)(object.salt);
        if ((0, helpers_1.isSet)(object.fixMsg))
          obj.fixMsg = Boolean(object.fixMsg);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.sender !== void 0 && (obj.sender = message.sender);
        message.admin !== void 0 && (obj.admin = message.admin);
        message.codeId !== void 0 && (obj.codeId = (message.codeId || BigInt(0)).toString());
        message.label !== void 0 && (obj.label = message.label);
        message.msg !== void 0 && (obj.msg = (0, helpers_1.base64FromBytes)(message.msg !== void 0 ? message.msg : new Uint8Array()));
        if (message.funds) {
          obj.funds = message.funds.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.funds = [];
        }
        message.salt !== void 0 && (obj.salt = (0, helpers_1.base64FromBytes)(message.salt !== void 0 ? message.salt : new Uint8Array()));
        message.fixMsg !== void 0 && (obj.fixMsg = message.fixMsg);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgInstantiateContract2();
        message.sender = object.sender ?? "";
        message.admin = object.admin ?? "";
        if (object.codeId !== void 0 && object.codeId !== null) {
          message.codeId = BigInt(object.codeId.toString());
        }
        message.label = object.label ?? "";
        message.msg = object.msg ?? new Uint8Array();
        message.funds = object.funds?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        message.salt = object.salt ?? new Uint8Array();
        message.fixMsg = object.fixMsg ?? false;
        return message;
      }
    };
    function createBaseMsgInstantiateContract2Response() {
      return {
        address: "",
        data: new Uint8Array()
      };
    }
    exports.MsgInstantiateContract2Response = {
      typeUrl: "/cosmwasm.wasm.v1.MsgInstantiateContract2Response",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.data.length !== 0) {
          writer.uint32(18).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgInstantiateContract2Response();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgInstantiateContract2Response();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.data))
          obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgInstantiateContract2Response();
        message.address = object.address ?? "";
        message.data = object.data ?? new Uint8Array();
        return message;
      }
    };
    function createBaseMsgExecuteContract() {
      return {
        sender: "",
        contract: "",
        msg: new Uint8Array(),
        funds: []
      };
    }
    exports.MsgExecuteContract = {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.sender !== "") {
          writer.uint32(10).string(message.sender);
        }
        if (message.contract !== "") {
          writer.uint32(18).string(message.contract);
        }
        if (message.msg.length !== 0) {
          writer.uint32(26).bytes(message.msg);
        }
        for (const v9 of message.funds) {
          coin_1.Coin.encode(v9, writer.uint32(42).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgExecuteContract();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.contract = reader.string();
              break;
            case 3:
              message.msg = reader.bytes();
              break;
            case 5:
              message.funds.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgExecuteContract();
        if ((0, helpers_1.isSet)(object.sender))
          obj.sender = String(object.sender);
        if ((0, helpers_1.isSet)(object.contract))
          obj.contract = String(object.contract);
        if ((0, helpers_1.isSet)(object.msg))
          obj.msg = (0, helpers_1.bytesFromBase64)(object.msg);
        if (Array.isArray(object?.funds))
          obj.funds = object.funds.map((e) => coin_1.Coin.fromJSON(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.sender !== void 0 && (obj.sender = message.sender);
        message.contract !== void 0 && (obj.contract = message.contract);
        message.msg !== void 0 && (obj.msg = (0, helpers_1.base64FromBytes)(message.msg !== void 0 ? message.msg : new Uint8Array()));
        if (message.funds) {
          obj.funds = message.funds.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.funds = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgExecuteContract();
        message.sender = object.sender ?? "";
        message.contract = object.contract ?? "";
        message.msg = object.msg ?? new Uint8Array();
        message.funds = object.funds?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        return message;
      }
    };
    function createBaseMsgExecuteContractResponse() {
      return {
        data: new Uint8Array()
      };
    }
    exports.MsgExecuteContractResponse = {
      typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContractResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.data.length !== 0) {
          writer.uint32(10).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgExecuteContractResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgExecuteContractResponse();
        if ((0, helpers_1.isSet)(object.data))
          obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgExecuteContractResponse();
        message.data = object.data ?? new Uint8Array();
        return message;
      }
    };
    function createBaseMsgMigrateContract() {
      return {
        sender: "",
        contract: "",
        codeId: BigInt(0),
        msg: new Uint8Array()
      };
    }
    exports.MsgMigrateContract = {
      typeUrl: "/cosmwasm.wasm.v1.MsgMigrateContract",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.sender !== "") {
          writer.uint32(10).string(message.sender);
        }
        if (message.contract !== "") {
          writer.uint32(18).string(message.contract);
        }
        if (message.codeId !== BigInt(0)) {
          writer.uint32(24).uint64(message.codeId);
        }
        if (message.msg.length !== 0) {
          writer.uint32(34).bytes(message.msg);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgMigrateContract();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.contract = reader.string();
              break;
            case 3:
              message.codeId = reader.uint64();
              break;
            case 4:
              message.msg = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgMigrateContract();
        if ((0, helpers_1.isSet)(object.sender))
          obj.sender = String(object.sender);
        if ((0, helpers_1.isSet)(object.contract))
          obj.contract = String(object.contract);
        if ((0, helpers_1.isSet)(object.codeId))
          obj.codeId = BigInt(object.codeId.toString());
        if ((0, helpers_1.isSet)(object.msg))
          obj.msg = (0, helpers_1.bytesFromBase64)(object.msg);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.sender !== void 0 && (obj.sender = message.sender);
        message.contract !== void 0 && (obj.contract = message.contract);
        message.codeId !== void 0 && (obj.codeId = (message.codeId || BigInt(0)).toString());
        message.msg !== void 0 && (obj.msg = (0, helpers_1.base64FromBytes)(message.msg !== void 0 ? message.msg : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgMigrateContract();
        message.sender = object.sender ?? "";
        message.contract = object.contract ?? "";
        if (object.codeId !== void 0 && object.codeId !== null) {
          message.codeId = BigInt(object.codeId.toString());
        }
        message.msg = object.msg ?? new Uint8Array();
        return message;
      }
    };
    function createBaseMsgMigrateContractResponse() {
      return {
        data: new Uint8Array()
      };
    }
    exports.MsgMigrateContractResponse = {
      typeUrl: "/cosmwasm.wasm.v1.MsgMigrateContractResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.data.length !== 0) {
          writer.uint32(10).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgMigrateContractResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgMigrateContractResponse();
        if ((0, helpers_1.isSet)(object.data))
          obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgMigrateContractResponse();
        message.data = object.data ?? new Uint8Array();
        return message;
      }
    };
    function createBaseMsgUpdateAdmin() {
      return {
        sender: "",
        newAdmin: "",
        contract: ""
      };
    }
    exports.MsgUpdateAdmin = {
      typeUrl: "/cosmwasm.wasm.v1.MsgUpdateAdmin",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.sender !== "") {
          writer.uint32(10).string(message.sender);
        }
        if (message.newAdmin !== "") {
          writer.uint32(18).string(message.newAdmin);
        }
        if (message.contract !== "") {
          writer.uint32(26).string(message.contract);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateAdmin();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.newAdmin = reader.string();
              break;
            case 3:
              message.contract = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateAdmin();
        if ((0, helpers_1.isSet)(object.sender))
          obj.sender = String(object.sender);
        if ((0, helpers_1.isSet)(object.newAdmin))
          obj.newAdmin = String(object.newAdmin);
        if ((0, helpers_1.isSet)(object.contract))
          obj.contract = String(object.contract);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.sender !== void 0 && (obj.sender = message.sender);
        message.newAdmin !== void 0 && (obj.newAdmin = message.newAdmin);
        message.contract !== void 0 && (obj.contract = message.contract);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateAdmin();
        message.sender = object.sender ?? "";
        message.newAdmin = object.newAdmin ?? "";
        message.contract = object.contract ?? "";
        return message;
      }
    };
    function createBaseMsgUpdateAdminResponse() {
      return {};
    }
    exports.MsgUpdateAdminResponse = {
      typeUrl: "/cosmwasm.wasm.v1.MsgUpdateAdminResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateAdminResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgUpdateAdminResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgUpdateAdminResponse();
        return message;
      }
    };
    function createBaseMsgClearAdmin() {
      return {
        sender: "",
        contract: ""
      };
    }
    exports.MsgClearAdmin = {
      typeUrl: "/cosmwasm.wasm.v1.MsgClearAdmin",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.sender !== "") {
          writer.uint32(10).string(message.sender);
        }
        if (message.contract !== "") {
          writer.uint32(26).string(message.contract);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgClearAdmin();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 3:
              message.contract = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgClearAdmin();
        if ((0, helpers_1.isSet)(object.sender))
          obj.sender = String(object.sender);
        if ((0, helpers_1.isSet)(object.contract))
          obj.contract = String(object.contract);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.sender !== void 0 && (obj.sender = message.sender);
        message.contract !== void 0 && (obj.contract = message.contract);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgClearAdmin();
        message.sender = object.sender ?? "";
        message.contract = object.contract ?? "";
        return message;
      }
    };
    function createBaseMsgClearAdminResponse() {
      return {};
    }
    exports.MsgClearAdminResponse = {
      typeUrl: "/cosmwasm.wasm.v1.MsgClearAdminResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgClearAdminResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgClearAdminResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgClearAdminResponse();
        return message;
      }
    };
    function createBaseMsgUpdateInstantiateConfig() {
      return {
        sender: "",
        codeId: BigInt(0),
        newInstantiatePermission: void 0
      };
    }
    exports.MsgUpdateInstantiateConfig = {
      typeUrl: "/cosmwasm.wasm.v1.MsgUpdateInstantiateConfig",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.sender !== "") {
          writer.uint32(10).string(message.sender);
        }
        if (message.codeId !== BigInt(0)) {
          writer.uint32(16).uint64(message.codeId);
        }
        if (message.newInstantiatePermission !== void 0) {
          types_1.AccessConfig.encode(message.newInstantiatePermission, writer.uint32(26).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateInstantiateConfig();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.codeId = reader.uint64();
              break;
            case 3:
              message.newInstantiatePermission = types_1.AccessConfig.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateInstantiateConfig();
        if ((0, helpers_1.isSet)(object.sender))
          obj.sender = String(object.sender);
        if ((0, helpers_1.isSet)(object.codeId))
          obj.codeId = BigInt(object.codeId.toString());
        if ((0, helpers_1.isSet)(object.newInstantiatePermission))
          obj.newInstantiatePermission = types_1.AccessConfig.fromJSON(object.newInstantiatePermission);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.sender !== void 0 && (obj.sender = message.sender);
        message.codeId !== void 0 && (obj.codeId = (message.codeId || BigInt(0)).toString());
        message.newInstantiatePermission !== void 0 && (obj.newInstantiatePermission = message.newInstantiatePermission ? types_1.AccessConfig.toJSON(message.newInstantiatePermission) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateInstantiateConfig();
        message.sender = object.sender ?? "";
        if (object.codeId !== void 0 && object.codeId !== null) {
          message.codeId = BigInt(object.codeId.toString());
        }
        if (object.newInstantiatePermission !== void 0 && object.newInstantiatePermission !== null) {
          message.newInstantiatePermission = types_1.AccessConfig.fromPartial(object.newInstantiatePermission);
        }
        return message;
      }
    };
    function createBaseMsgUpdateInstantiateConfigResponse() {
      return {};
    }
    exports.MsgUpdateInstantiateConfigResponse = {
      typeUrl: "/cosmwasm.wasm.v1.MsgUpdateInstantiateConfigResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateInstantiateConfigResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgUpdateInstantiateConfigResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgUpdateInstantiateConfigResponse();
        return message;
      }
    };
    function createBaseMsgUpdateParams() {
      return {
        authority: "",
        params: types_1.Params.fromPartial({})
      };
    }
    exports.MsgUpdateParams = {
      typeUrl: "/cosmwasm.wasm.v1.MsgUpdateParams",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.authority !== "") {
          writer.uint32(10).string(message.authority);
        }
        if (message.params !== void 0) {
          types_1.Params.encode(message.params, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParams();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.authority = reader.string();
              break;
            case 2:
              message.params = types_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateParams();
        if ((0, helpers_1.isSet)(object.authority))
          obj.authority = String(object.authority);
        if ((0, helpers_1.isSet)(object.params))
          obj.params = types_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.authority !== void 0 && (obj.authority = message.authority);
        message.params !== void 0 && (obj.params = message.params ? types_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateParams();
        message.authority = object.authority ?? "";
        if (object.params !== void 0 && object.params !== null) {
          message.params = types_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseMsgUpdateParamsResponse() {
      return {};
    }
    exports.MsgUpdateParamsResponse = {
      typeUrl: "/cosmwasm.wasm.v1.MsgUpdateParamsResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgUpdateParamsResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgUpdateParamsResponse();
        return message;
      }
    };
    function createBaseMsgSudoContract() {
      return {
        authority: "",
        contract: "",
        msg: new Uint8Array()
      };
    }
    exports.MsgSudoContract = {
      typeUrl: "/cosmwasm.wasm.v1.MsgSudoContract",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.authority !== "") {
          writer.uint32(10).string(message.authority);
        }
        if (message.contract !== "") {
          writer.uint32(18).string(message.contract);
        }
        if (message.msg.length !== 0) {
          writer.uint32(26).bytes(message.msg);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSudoContract();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.authority = reader.string();
              break;
            case 2:
              message.contract = reader.string();
              break;
            case 3:
              message.msg = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgSudoContract();
        if ((0, helpers_1.isSet)(object.authority))
          obj.authority = String(object.authority);
        if ((0, helpers_1.isSet)(object.contract))
          obj.contract = String(object.contract);
        if ((0, helpers_1.isSet)(object.msg))
          obj.msg = (0, helpers_1.bytesFromBase64)(object.msg);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.authority !== void 0 && (obj.authority = message.authority);
        message.contract !== void 0 && (obj.contract = message.contract);
        message.msg !== void 0 && (obj.msg = (0, helpers_1.base64FromBytes)(message.msg !== void 0 ? message.msg : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgSudoContract();
        message.authority = object.authority ?? "";
        message.contract = object.contract ?? "";
        message.msg = object.msg ?? new Uint8Array();
        return message;
      }
    };
    function createBaseMsgSudoContractResponse() {
      return {
        data: new Uint8Array()
      };
    }
    exports.MsgSudoContractResponse = {
      typeUrl: "/cosmwasm.wasm.v1.MsgSudoContractResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.data.length !== 0) {
          writer.uint32(10).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgSudoContractResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgSudoContractResponse();
        if ((0, helpers_1.isSet)(object.data))
          obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgSudoContractResponse();
        message.data = object.data ?? new Uint8Array();
        return message;
      }
    };
    function createBaseMsgPinCodes() {
      return {
        authority: "",
        codeIds: []
      };
    }
    exports.MsgPinCodes = {
      typeUrl: "/cosmwasm.wasm.v1.MsgPinCodes",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.authority !== "") {
          writer.uint32(10).string(message.authority);
        }
        writer.uint32(18).fork();
        for (const v9 of message.codeIds) {
          writer.uint64(v9);
        }
        writer.ldelim();
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgPinCodes();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.authority = reader.string();
              break;
            case 2:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.codeIds.push(reader.uint64());
                }
              } else {
                message.codeIds.push(reader.uint64());
              }
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgPinCodes();
        if ((0, helpers_1.isSet)(object.authority))
          obj.authority = String(object.authority);
        if (Array.isArray(object?.codeIds))
          obj.codeIds = object.codeIds.map((e) => BigInt(e.toString()));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.authority !== void 0 && (obj.authority = message.authority);
        if (message.codeIds) {
          obj.codeIds = message.codeIds.map((e) => (e || BigInt(0)).toString());
        } else {
          obj.codeIds = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgPinCodes();
        message.authority = object.authority ?? "";
        message.codeIds = object.codeIds?.map((e) => BigInt(e.toString())) || [];
        return message;
      }
    };
    function createBaseMsgPinCodesResponse() {
      return {};
    }
    exports.MsgPinCodesResponse = {
      typeUrl: "/cosmwasm.wasm.v1.MsgPinCodesResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgPinCodesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgPinCodesResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgPinCodesResponse();
        return message;
      }
    };
    function createBaseMsgUnpinCodes() {
      return {
        authority: "",
        codeIds: []
      };
    }
    exports.MsgUnpinCodes = {
      typeUrl: "/cosmwasm.wasm.v1.MsgUnpinCodes",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.authority !== "") {
          writer.uint32(10).string(message.authority);
        }
        writer.uint32(18).fork();
        for (const v9 of message.codeIds) {
          writer.uint64(v9);
        }
        writer.ldelim();
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUnpinCodes();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.authority = reader.string();
              break;
            case 2:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.codeIds.push(reader.uint64());
                }
              } else {
                message.codeIds.push(reader.uint64());
              }
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUnpinCodes();
        if ((0, helpers_1.isSet)(object.authority))
          obj.authority = String(object.authority);
        if (Array.isArray(object?.codeIds))
          obj.codeIds = object.codeIds.map((e) => BigInt(e.toString()));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.authority !== void 0 && (obj.authority = message.authority);
        if (message.codeIds) {
          obj.codeIds = message.codeIds.map((e) => (e || BigInt(0)).toString());
        } else {
          obj.codeIds = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUnpinCodes();
        message.authority = object.authority ?? "";
        message.codeIds = object.codeIds?.map((e) => BigInt(e.toString())) || [];
        return message;
      }
    };
    function createBaseMsgUnpinCodesResponse() {
      return {};
    }
    exports.MsgUnpinCodesResponse = {
      typeUrl: "/cosmwasm.wasm.v1.MsgUnpinCodesResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUnpinCodesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgUnpinCodesResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgUnpinCodesResponse();
        return message;
      }
    };
    function createBaseMsgStoreAndInstantiateContract() {
      return {
        authority: "",
        wasmByteCode: new Uint8Array(),
        instantiatePermission: void 0,
        unpinCode: false,
        admin: "",
        label: "",
        msg: new Uint8Array(),
        funds: [],
        source: "",
        builder: "",
        codeHash: new Uint8Array()
      };
    }
    exports.MsgStoreAndInstantiateContract = {
      typeUrl: "/cosmwasm.wasm.v1.MsgStoreAndInstantiateContract",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.authority !== "") {
          writer.uint32(10).string(message.authority);
        }
        if (message.wasmByteCode.length !== 0) {
          writer.uint32(26).bytes(message.wasmByteCode);
        }
        if (message.instantiatePermission !== void 0) {
          types_1.AccessConfig.encode(message.instantiatePermission, writer.uint32(34).fork()).ldelim();
        }
        if (message.unpinCode === true) {
          writer.uint32(40).bool(message.unpinCode);
        }
        if (message.admin !== "") {
          writer.uint32(50).string(message.admin);
        }
        if (message.label !== "") {
          writer.uint32(58).string(message.label);
        }
        if (message.msg.length !== 0) {
          writer.uint32(66).bytes(message.msg);
        }
        for (const v9 of message.funds) {
          coin_1.Coin.encode(v9, writer.uint32(74).fork()).ldelim();
        }
        if (message.source !== "") {
          writer.uint32(82).string(message.source);
        }
        if (message.builder !== "") {
          writer.uint32(90).string(message.builder);
        }
        if (message.codeHash.length !== 0) {
          writer.uint32(98).bytes(message.codeHash);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgStoreAndInstantiateContract();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.authority = reader.string();
              break;
            case 3:
              message.wasmByteCode = reader.bytes();
              break;
            case 4:
              message.instantiatePermission = types_1.AccessConfig.decode(reader, reader.uint32());
              break;
            case 5:
              message.unpinCode = reader.bool();
              break;
            case 6:
              message.admin = reader.string();
              break;
            case 7:
              message.label = reader.string();
              break;
            case 8:
              message.msg = reader.bytes();
              break;
            case 9:
              message.funds.push(coin_1.Coin.decode(reader, reader.uint32()));
              break;
            case 10:
              message.source = reader.string();
              break;
            case 11:
              message.builder = reader.string();
              break;
            case 12:
              message.codeHash = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgStoreAndInstantiateContract();
        if ((0, helpers_1.isSet)(object.authority))
          obj.authority = String(object.authority);
        if ((0, helpers_1.isSet)(object.wasmByteCode))
          obj.wasmByteCode = (0, helpers_1.bytesFromBase64)(object.wasmByteCode);
        if ((0, helpers_1.isSet)(object.instantiatePermission))
          obj.instantiatePermission = types_1.AccessConfig.fromJSON(object.instantiatePermission);
        if ((0, helpers_1.isSet)(object.unpinCode))
          obj.unpinCode = Boolean(object.unpinCode);
        if ((0, helpers_1.isSet)(object.admin))
          obj.admin = String(object.admin);
        if ((0, helpers_1.isSet)(object.label))
          obj.label = String(object.label);
        if ((0, helpers_1.isSet)(object.msg))
          obj.msg = (0, helpers_1.bytesFromBase64)(object.msg);
        if (Array.isArray(object?.funds))
          obj.funds = object.funds.map((e) => coin_1.Coin.fromJSON(e));
        if ((0, helpers_1.isSet)(object.source))
          obj.source = String(object.source);
        if ((0, helpers_1.isSet)(object.builder))
          obj.builder = String(object.builder);
        if ((0, helpers_1.isSet)(object.codeHash))
          obj.codeHash = (0, helpers_1.bytesFromBase64)(object.codeHash);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.authority !== void 0 && (obj.authority = message.authority);
        message.wasmByteCode !== void 0 && (obj.wasmByteCode = (0, helpers_1.base64FromBytes)(message.wasmByteCode !== void 0 ? message.wasmByteCode : new Uint8Array()));
        message.instantiatePermission !== void 0 && (obj.instantiatePermission = message.instantiatePermission ? types_1.AccessConfig.toJSON(message.instantiatePermission) : void 0);
        message.unpinCode !== void 0 && (obj.unpinCode = message.unpinCode);
        message.admin !== void 0 && (obj.admin = message.admin);
        message.label !== void 0 && (obj.label = message.label);
        message.msg !== void 0 && (obj.msg = (0, helpers_1.base64FromBytes)(message.msg !== void 0 ? message.msg : new Uint8Array()));
        if (message.funds) {
          obj.funds = message.funds.map((e) => e ? coin_1.Coin.toJSON(e) : void 0);
        } else {
          obj.funds = [];
        }
        message.source !== void 0 && (obj.source = message.source);
        message.builder !== void 0 && (obj.builder = message.builder);
        message.codeHash !== void 0 && (obj.codeHash = (0, helpers_1.base64FromBytes)(message.codeHash !== void 0 ? message.codeHash : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgStoreAndInstantiateContract();
        message.authority = object.authority ?? "";
        message.wasmByteCode = object.wasmByteCode ?? new Uint8Array();
        if (object.instantiatePermission !== void 0 && object.instantiatePermission !== null) {
          message.instantiatePermission = types_1.AccessConfig.fromPartial(object.instantiatePermission);
        }
        message.unpinCode = object.unpinCode ?? false;
        message.admin = object.admin ?? "";
        message.label = object.label ?? "";
        message.msg = object.msg ?? new Uint8Array();
        message.funds = object.funds?.map((e) => coin_1.Coin.fromPartial(e)) || [];
        message.source = object.source ?? "";
        message.builder = object.builder ?? "";
        message.codeHash = object.codeHash ?? new Uint8Array();
        return message;
      }
    };
    function createBaseMsgStoreAndInstantiateContractResponse() {
      return {
        address: "",
        data: new Uint8Array()
      };
    }
    exports.MsgStoreAndInstantiateContractResponse = {
      typeUrl: "/cosmwasm.wasm.v1.MsgStoreAndInstantiateContractResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.data.length !== 0) {
          writer.uint32(18).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgStoreAndInstantiateContractResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgStoreAndInstantiateContractResponse();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.data))
          obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgStoreAndInstantiateContractResponse();
        message.address = object.address ?? "";
        message.data = object.data ?? new Uint8Array();
        return message;
      }
    };
    function createBaseMsgAddCodeUploadParamsAddresses() {
      return {
        authority: "",
        addresses: []
      };
    }
    exports.MsgAddCodeUploadParamsAddresses = {
      typeUrl: "/cosmwasm.wasm.v1.MsgAddCodeUploadParamsAddresses",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.authority !== "") {
          writer.uint32(10).string(message.authority);
        }
        for (const v9 of message.addresses) {
          writer.uint32(18).string(v9);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgAddCodeUploadParamsAddresses();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.authority = reader.string();
              break;
            case 2:
              message.addresses.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgAddCodeUploadParamsAddresses();
        if ((0, helpers_1.isSet)(object.authority))
          obj.authority = String(object.authority);
        if (Array.isArray(object?.addresses))
          obj.addresses = object.addresses.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.authority !== void 0 && (obj.authority = message.authority);
        if (message.addresses) {
          obj.addresses = message.addresses.map((e) => e);
        } else {
          obj.addresses = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgAddCodeUploadParamsAddresses();
        message.authority = object.authority ?? "";
        message.addresses = object.addresses?.map((e) => e) || [];
        return message;
      }
    };
    function createBaseMsgAddCodeUploadParamsAddressesResponse() {
      return {};
    }
    exports.MsgAddCodeUploadParamsAddressesResponse = {
      typeUrl: "/cosmwasm.wasm.v1.MsgAddCodeUploadParamsAddressesResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgAddCodeUploadParamsAddressesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgAddCodeUploadParamsAddressesResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgAddCodeUploadParamsAddressesResponse();
        return message;
      }
    };
    function createBaseMsgRemoveCodeUploadParamsAddresses() {
      return {
        authority: "",
        addresses: []
      };
    }
    exports.MsgRemoveCodeUploadParamsAddresses = {
      typeUrl: "/cosmwasm.wasm.v1.MsgRemoveCodeUploadParamsAddresses",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.authority !== "") {
          writer.uint32(10).string(message.authority);
        }
        for (const v9 of message.addresses) {
          writer.uint32(18).string(v9);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRemoveCodeUploadParamsAddresses();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.authority = reader.string();
              break;
            case 2:
              message.addresses.push(reader.string());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgRemoveCodeUploadParamsAddresses();
        if ((0, helpers_1.isSet)(object.authority))
          obj.authority = String(object.authority);
        if (Array.isArray(object?.addresses))
          obj.addresses = object.addresses.map((e) => String(e));
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.authority !== void 0 && (obj.authority = message.authority);
        if (message.addresses) {
          obj.addresses = message.addresses.map((e) => e);
        } else {
          obj.addresses = [];
        }
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgRemoveCodeUploadParamsAddresses();
        message.authority = object.authority ?? "";
        message.addresses = object.addresses?.map((e) => e) || [];
        return message;
      }
    };
    function createBaseMsgRemoveCodeUploadParamsAddressesResponse() {
      return {};
    }
    exports.MsgRemoveCodeUploadParamsAddressesResponse = {
      typeUrl: "/cosmwasm.wasm.v1.MsgRemoveCodeUploadParamsAddressesResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgRemoveCodeUploadParamsAddressesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgRemoveCodeUploadParamsAddressesResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgRemoveCodeUploadParamsAddressesResponse();
        return message;
      }
    };
    function createBaseMsgStoreAndMigrateContract() {
      return {
        authority: "",
        wasmByteCode: new Uint8Array(),
        instantiatePermission: void 0,
        contract: "",
        msg: new Uint8Array()
      };
    }
    exports.MsgStoreAndMigrateContract = {
      typeUrl: "/cosmwasm.wasm.v1.MsgStoreAndMigrateContract",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.authority !== "") {
          writer.uint32(10).string(message.authority);
        }
        if (message.wasmByteCode.length !== 0) {
          writer.uint32(18).bytes(message.wasmByteCode);
        }
        if (message.instantiatePermission !== void 0) {
          types_1.AccessConfig.encode(message.instantiatePermission, writer.uint32(26).fork()).ldelim();
        }
        if (message.contract !== "") {
          writer.uint32(34).string(message.contract);
        }
        if (message.msg.length !== 0) {
          writer.uint32(42).bytes(message.msg);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgStoreAndMigrateContract();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.authority = reader.string();
              break;
            case 2:
              message.wasmByteCode = reader.bytes();
              break;
            case 3:
              message.instantiatePermission = types_1.AccessConfig.decode(reader, reader.uint32());
              break;
            case 4:
              message.contract = reader.string();
              break;
            case 5:
              message.msg = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgStoreAndMigrateContract();
        if ((0, helpers_1.isSet)(object.authority))
          obj.authority = String(object.authority);
        if ((0, helpers_1.isSet)(object.wasmByteCode))
          obj.wasmByteCode = (0, helpers_1.bytesFromBase64)(object.wasmByteCode);
        if ((0, helpers_1.isSet)(object.instantiatePermission))
          obj.instantiatePermission = types_1.AccessConfig.fromJSON(object.instantiatePermission);
        if ((0, helpers_1.isSet)(object.contract))
          obj.contract = String(object.contract);
        if ((0, helpers_1.isSet)(object.msg))
          obj.msg = (0, helpers_1.bytesFromBase64)(object.msg);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.authority !== void 0 && (obj.authority = message.authority);
        message.wasmByteCode !== void 0 && (obj.wasmByteCode = (0, helpers_1.base64FromBytes)(message.wasmByteCode !== void 0 ? message.wasmByteCode : new Uint8Array()));
        message.instantiatePermission !== void 0 && (obj.instantiatePermission = message.instantiatePermission ? types_1.AccessConfig.toJSON(message.instantiatePermission) : void 0);
        message.contract !== void 0 && (obj.contract = message.contract);
        message.msg !== void 0 && (obj.msg = (0, helpers_1.base64FromBytes)(message.msg !== void 0 ? message.msg : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgStoreAndMigrateContract();
        message.authority = object.authority ?? "";
        message.wasmByteCode = object.wasmByteCode ?? new Uint8Array();
        if (object.instantiatePermission !== void 0 && object.instantiatePermission !== null) {
          message.instantiatePermission = types_1.AccessConfig.fromPartial(object.instantiatePermission);
        }
        message.contract = object.contract ?? "";
        message.msg = object.msg ?? new Uint8Array();
        return message;
      }
    };
    function createBaseMsgStoreAndMigrateContractResponse() {
      return {
        codeId: BigInt(0),
        checksum: new Uint8Array(),
        data: new Uint8Array()
      };
    }
    exports.MsgStoreAndMigrateContractResponse = {
      typeUrl: "/cosmwasm.wasm.v1.MsgStoreAndMigrateContractResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.codeId !== BigInt(0)) {
          writer.uint32(8).uint64(message.codeId);
        }
        if (message.checksum.length !== 0) {
          writer.uint32(18).bytes(message.checksum);
        }
        if (message.data.length !== 0) {
          writer.uint32(26).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgStoreAndMigrateContractResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.codeId = reader.uint64();
              break;
            case 2:
              message.checksum = reader.bytes();
              break;
            case 3:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgStoreAndMigrateContractResponse();
        if ((0, helpers_1.isSet)(object.codeId))
          obj.codeId = BigInt(object.codeId.toString());
        if ((0, helpers_1.isSet)(object.checksum))
          obj.checksum = (0, helpers_1.bytesFromBase64)(object.checksum);
        if ((0, helpers_1.isSet)(object.data))
          obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.codeId !== void 0 && (obj.codeId = (message.codeId || BigInt(0)).toString());
        message.checksum !== void 0 && (obj.checksum = (0, helpers_1.base64FromBytes)(message.checksum !== void 0 ? message.checksum : new Uint8Array()));
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgStoreAndMigrateContractResponse();
        if (object.codeId !== void 0 && object.codeId !== null) {
          message.codeId = BigInt(object.codeId.toString());
        }
        message.checksum = object.checksum ?? new Uint8Array();
        message.data = object.data ?? new Uint8Array();
        return message;
      }
    };
    function createBaseMsgUpdateContractLabel() {
      return {
        sender: "",
        newLabel: "",
        contract: ""
      };
    }
    exports.MsgUpdateContractLabel = {
      typeUrl: "/cosmwasm.wasm.v1.MsgUpdateContractLabel",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.sender !== "") {
          writer.uint32(10).string(message.sender);
        }
        if (message.newLabel !== "") {
          writer.uint32(18).string(message.newLabel);
        }
        if (message.contract !== "") {
          writer.uint32(26).string(message.contract);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateContractLabel();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.sender = reader.string();
              break;
            case 2:
              message.newLabel = reader.string();
              break;
            case 3:
              message.contract = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseMsgUpdateContractLabel();
        if ((0, helpers_1.isSet)(object.sender))
          obj.sender = String(object.sender);
        if ((0, helpers_1.isSet)(object.newLabel))
          obj.newLabel = String(object.newLabel);
        if ((0, helpers_1.isSet)(object.contract))
          obj.contract = String(object.contract);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.sender !== void 0 && (obj.sender = message.sender);
        message.newLabel !== void 0 && (obj.newLabel = message.newLabel);
        message.contract !== void 0 && (obj.contract = message.contract);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseMsgUpdateContractLabel();
        message.sender = object.sender ?? "";
        message.newLabel = object.newLabel ?? "";
        message.contract = object.contract ?? "";
        return message;
      }
    };
    function createBaseMsgUpdateContractLabelResponse() {
      return {};
    }
    exports.MsgUpdateContractLabelResponse = {
      typeUrl: "/cosmwasm.wasm.v1.MsgUpdateContractLabelResponse",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateContractLabelResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseMsgUpdateContractLabelResponse();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseMsgUpdateContractLabelResponse();
        return message;
      }
    };
    var MsgClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.StoreCode = this.StoreCode.bind(this);
        this.InstantiateContract = this.InstantiateContract.bind(this);
        this.InstantiateContract2 = this.InstantiateContract2.bind(this);
        this.ExecuteContract = this.ExecuteContract.bind(this);
        this.MigrateContract = this.MigrateContract.bind(this);
        this.UpdateAdmin = this.UpdateAdmin.bind(this);
        this.ClearAdmin = this.ClearAdmin.bind(this);
        this.UpdateInstantiateConfig = this.UpdateInstantiateConfig.bind(this);
        this.UpdateParams = this.UpdateParams.bind(this);
        this.SudoContract = this.SudoContract.bind(this);
        this.PinCodes = this.PinCodes.bind(this);
        this.UnpinCodes = this.UnpinCodes.bind(this);
        this.StoreAndInstantiateContract = this.StoreAndInstantiateContract.bind(this);
        this.RemoveCodeUploadParamsAddresses = this.RemoveCodeUploadParamsAddresses.bind(this);
        this.AddCodeUploadParamsAddresses = this.AddCodeUploadParamsAddresses.bind(this);
        this.StoreAndMigrateContract = this.StoreAndMigrateContract.bind(this);
        this.UpdateContractLabel = this.UpdateContractLabel.bind(this);
      }
      StoreCode(request) {
        const data2 = exports.MsgStoreCode.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Msg", "StoreCode", data2);
        return promise.then((data3) => exports.MsgStoreCodeResponse.decode(new binary_1.BinaryReader(data3)));
      }
      InstantiateContract(request) {
        const data2 = exports.MsgInstantiateContract.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Msg", "InstantiateContract", data2);
        return promise.then((data3) => exports.MsgInstantiateContractResponse.decode(new binary_1.BinaryReader(data3)));
      }
      InstantiateContract2(request) {
        const data2 = exports.MsgInstantiateContract2.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Msg", "InstantiateContract2", data2);
        return promise.then((data3) => exports.MsgInstantiateContract2Response.decode(new binary_1.BinaryReader(data3)));
      }
      ExecuteContract(request) {
        const data2 = exports.MsgExecuteContract.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Msg", "ExecuteContract", data2);
        return promise.then((data3) => exports.MsgExecuteContractResponse.decode(new binary_1.BinaryReader(data3)));
      }
      MigrateContract(request) {
        const data2 = exports.MsgMigrateContract.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Msg", "MigrateContract", data2);
        return promise.then((data3) => exports.MsgMigrateContractResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateAdmin(request) {
        const data2 = exports.MsgUpdateAdmin.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Msg", "UpdateAdmin", data2);
        return promise.then((data3) => exports.MsgUpdateAdminResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ClearAdmin(request) {
        const data2 = exports.MsgClearAdmin.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Msg", "ClearAdmin", data2);
        return promise.then((data3) => exports.MsgClearAdminResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateInstantiateConfig(request) {
        const data2 = exports.MsgUpdateInstantiateConfig.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Msg", "UpdateInstantiateConfig", data2);
        return promise.then((data3) => exports.MsgUpdateInstantiateConfigResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateParams(request) {
        const data2 = exports.MsgUpdateParams.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Msg", "UpdateParams", data2);
        return promise.then((data3) => exports.MsgUpdateParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      SudoContract(request) {
        const data2 = exports.MsgSudoContract.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Msg", "SudoContract", data2);
        return promise.then((data3) => exports.MsgSudoContractResponse.decode(new binary_1.BinaryReader(data3)));
      }
      PinCodes(request) {
        const data2 = exports.MsgPinCodes.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Msg", "PinCodes", data2);
        return promise.then((data3) => exports.MsgPinCodesResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UnpinCodes(request) {
        const data2 = exports.MsgUnpinCodes.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Msg", "UnpinCodes", data2);
        return promise.then((data3) => exports.MsgUnpinCodesResponse.decode(new binary_1.BinaryReader(data3)));
      }
      StoreAndInstantiateContract(request) {
        const data2 = exports.MsgStoreAndInstantiateContract.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Msg", "StoreAndInstantiateContract", data2);
        return promise.then((data3) => exports.MsgStoreAndInstantiateContractResponse.decode(new binary_1.BinaryReader(data3)));
      }
      RemoveCodeUploadParamsAddresses(request) {
        const data2 = exports.MsgRemoveCodeUploadParamsAddresses.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Msg", "RemoveCodeUploadParamsAddresses", data2);
        return promise.then((data3) => exports.MsgRemoveCodeUploadParamsAddressesResponse.decode(new binary_1.BinaryReader(data3)));
      }
      AddCodeUploadParamsAddresses(request) {
        const data2 = exports.MsgAddCodeUploadParamsAddresses.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Msg", "AddCodeUploadParamsAddresses", data2);
        return promise.then((data3) => exports.MsgAddCodeUploadParamsAddressesResponse.decode(new binary_1.BinaryReader(data3)));
      }
      StoreAndMigrateContract(request) {
        const data2 = exports.MsgStoreAndMigrateContract.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Msg", "StoreAndMigrateContract", data2);
        return promise.then((data3) => exports.MsgStoreAndMigrateContractResponse.decode(new binary_1.BinaryReader(data3)));
      }
      UpdateContractLabel(request) {
        const data2 = exports.MsgUpdateContractLabel.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Msg", "UpdateContractLabel", data2);
        return promise.then((data3) => exports.MsgUpdateContractLabelResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.MsgClientImpl = MsgClientImpl;
  }
});

// node_modules/.pnpm/@cosmjs+cosmwasm-stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/cosmwasm-stargate/build/modules/wasm/messages.js
var require_messages10 = __commonJS({
  "node_modules/.pnpm/@cosmjs+cosmwasm-stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/cosmwasm-stargate/build/modules/wasm/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wasmTypes = void 0;
    exports.isMsgStoreCodeEncodeObject = isMsgStoreCodeEncodeObject;
    exports.isMsgInstantiateContractEncodeObject = isMsgInstantiateContractEncodeObject;
    exports.isMsgInstantiateContract2EncodeObject = isMsgInstantiateContract2EncodeObject;
    exports.isMsgUpdateAdminEncodeObject = isMsgUpdateAdminEncodeObject;
    exports.isMsgClearAdminEncodeObject = isMsgClearAdminEncodeObject;
    exports.isMsgMigrateEncodeObject = isMsgMigrateEncodeObject;
    exports.isMsgExecuteEncodeObject = isMsgExecuteEncodeObject;
    var tx_1 = require_tx15();
    exports.wasmTypes = [
      ["/cosmwasm.wasm.v1.MsgClearAdmin", tx_1.MsgClearAdmin],
      ["/cosmwasm.wasm.v1.MsgExecuteContract", tx_1.MsgExecuteContract],
      ["/cosmwasm.wasm.v1.MsgMigrateContract", tx_1.MsgMigrateContract],
      ["/cosmwasm.wasm.v1.MsgStoreCode", tx_1.MsgStoreCode],
      ["/cosmwasm.wasm.v1.MsgInstantiateContract", tx_1.MsgInstantiateContract],
      ["/cosmwasm.wasm.v1.MsgInstantiateContract2", tx_1.MsgInstantiateContract2],
      ["/cosmwasm.wasm.v1.MsgUpdateAdmin", tx_1.MsgUpdateAdmin]
    ];
    function isMsgStoreCodeEncodeObject(object) {
      return object.typeUrl === "/cosmwasm.wasm.v1.MsgStoreCode";
    }
    function isMsgInstantiateContractEncodeObject(object) {
      return object.typeUrl === "/cosmwasm.wasm.v1.MsgInstantiateContract";
    }
    function isMsgInstantiateContract2EncodeObject(object) {
      return object.typeUrl === "/cosmwasm.wasm.v1.MsgInstantiateContract2";
    }
    function isMsgUpdateAdminEncodeObject(object) {
      return object.typeUrl === "/cosmwasm.wasm.v1.MsgUpdateAdmin";
    }
    function isMsgClearAdminEncodeObject(object) {
      return object.typeUrl === "/cosmwasm.wasm.v1.MsgClearAdmin";
    }
    function isMsgMigrateEncodeObject(object) {
      return object.typeUrl === "/cosmwasm.wasm.v1.MsgMigrateContract";
    }
    function isMsgExecuteEncodeObject(object) {
      return object.typeUrl === "/cosmwasm.wasm.v1.MsgExecuteContract";
    }
  }
});

// node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmwasm/wasm/v1/query.js
var require_query14 = __commonJS({
  "node_modules/.pnpm/cosmjs-types@0.10.1/node_modules/cosmjs-types/cosmwasm/wasm/v1/query.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueryClientImpl = exports.QueryBuildAddressResponse = exports.QueryBuildAddressRequest = exports.QueryWasmLimitsConfigResponse = exports.QueryWasmLimitsConfigRequest = exports.QueryContractsByCreatorResponse = exports.QueryContractsByCreatorRequest = exports.QueryParamsResponse = exports.QueryParamsRequest = exports.QueryPinnedCodesResponse = exports.QueryPinnedCodesRequest = exports.QueryCodesResponse = exports.QueryCodesRequest = exports.QueryCodeResponse = exports.CodeInfoResponse = exports.QueryCodeInfoResponse = exports.QueryCodeInfoRequest = exports.QueryCodeRequest = exports.QuerySmartContractStateResponse = exports.QuerySmartContractStateRequest = exports.QueryRawContractStateResponse = exports.QueryRawContractStateRequest = exports.QueryAllContractStateResponse = exports.QueryAllContractStateRequest = exports.QueryContractsByCodeResponse = exports.QueryContractsByCodeRequest = exports.QueryContractHistoryResponse = exports.QueryContractHistoryRequest = exports.QueryContractInfoResponse = exports.QueryContractInfoRequest = exports.protobufPackage = void 0;
    var pagination_1 = require_pagination();
    var types_1 = require_types7();
    var binary_1 = require_binary();
    var helpers_1 = require_helpers();
    exports.protobufPackage = "cosmwasm.wasm.v1";
    function createBaseQueryContractInfoRequest() {
      return {
        address: ""
      };
    }
    exports.QueryContractInfoRequest = {
      typeUrl: "/cosmwasm.wasm.v1.QueryContractInfoRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryContractInfoRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryContractInfoRequest();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryContractInfoRequest();
        message.address = object.address ?? "";
        return message;
      }
    };
    function createBaseQueryContractInfoResponse() {
      return {
        address: "",
        contractInfo: types_1.ContractInfo.fromPartial({})
      };
    }
    exports.QueryContractInfoResponse = {
      typeUrl: "/cosmwasm.wasm.v1.QueryContractInfoResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.contractInfo !== void 0) {
          types_1.ContractInfo.encode(message.contractInfo, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryContractInfoResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.contractInfo = types_1.ContractInfo.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryContractInfoResponse();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.contractInfo))
          obj.contractInfo = types_1.ContractInfo.fromJSON(object.contractInfo);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.contractInfo !== void 0 && (obj.contractInfo = message.contractInfo ? types_1.ContractInfo.toJSON(message.contractInfo) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryContractInfoResponse();
        message.address = object.address ?? "";
        if (object.contractInfo !== void 0 && object.contractInfo !== null) {
          message.contractInfo = types_1.ContractInfo.fromPartial(object.contractInfo);
        }
        return message;
      }
    };
    function createBaseQueryContractHistoryRequest() {
      return {
        address: "",
        pagination: void 0
      };
    }
    exports.QueryContractHistoryRequest = {
      typeUrl: "/cosmwasm.wasm.v1.QueryContractHistoryRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryContractHistoryRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryContractHistoryRequest();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryContractHistoryRequest();
        message.address = object.address ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryContractHistoryResponse() {
      return {
        entries: [],
        pagination: void 0
      };
    }
    exports.QueryContractHistoryResponse = {
      typeUrl: "/cosmwasm.wasm.v1.QueryContractHistoryResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.entries) {
          types_1.ContractCodeHistoryEntry.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryContractHistoryResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.entries.push(types_1.ContractCodeHistoryEntry.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryContractHistoryResponse();
        if (Array.isArray(object?.entries))
          obj.entries = object.entries.map((e) => types_1.ContractCodeHistoryEntry.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.entries) {
          obj.entries = message.entries.map((e) => e ? types_1.ContractCodeHistoryEntry.toJSON(e) : void 0);
        } else {
          obj.entries = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryContractHistoryResponse();
        message.entries = object.entries?.map((e) => types_1.ContractCodeHistoryEntry.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryContractsByCodeRequest() {
      return {
        codeId: BigInt(0),
        pagination: void 0
      };
    }
    exports.QueryContractsByCodeRequest = {
      typeUrl: "/cosmwasm.wasm.v1.QueryContractsByCodeRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.codeId !== BigInt(0)) {
          writer.uint32(8).uint64(message.codeId);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryContractsByCodeRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.codeId = reader.uint64();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryContractsByCodeRequest();
        if ((0, helpers_1.isSet)(object.codeId))
          obj.codeId = BigInt(object.codeId.toString());
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.codeId !== void 0 && (obj.codeId = (message.codeId || BigInt(0)).toString());
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryContractsByCodeRequest();
        if (object.codeId !== void 0 && object.codeId !== null) {
          message.codeId = BigInt(object.codeId.toString());
        }
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryContractsByCodeResponse() {
      return {
        contracts: [],
        pagination: void 0
      };
    }
    exports.QueryContractsByCodeResponse = {
      typeUrl: "/cosmwasm.wasm.v1.QueryContractsByCodeResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.contracts) {
          writer.uint32(10).string(v9);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryContractsByCodeResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.contracts.push(reader.string());
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryContractsByCodeResponse();
        if (Array.isArray(object?.contracts))
          obj.contracts = object.contracts.map((e) => String(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.contracts) {
          obj.contracts = message.contracts.map((e) => e);
        } else {
          obj.contracts = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryContractsByCodeResponse();
        message.contracts = object.contracts?.map((e) => e) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryAllContractStateRequest() {
      return {
        address: "",
        pagination: void 0
      };
    }
    exports.QueryAllContractStateRequest = {
      typeUrl: "/cosmwasm.wasm.v1.QueryAllContractStateRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAllContractStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAllContractStateRequest();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAllContractStateRequest();
        message.address = object.address ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryAllContractStateResponse() {
      return {
        models: [],
        pagination: void 0
      };
    }
    exports.QueryAllContractStateResponse = {
      typeUrl: "/cosmwasm.wasm.v1.QueryAllContractStateResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.models) {
          types_1.Model.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryAllContractStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.models.push(types_1.Model.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryAllContractStateResponse();
        if (Array.isArray(object?.models))
          obj.models = object.models.map((e) => types_1.Model.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.models) {
          obj.models = message.models.map((e) => e ? types_1.Model.toJSON(e) : void 0);
        } else {
          obj.models = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryAllContractStateResponse();
        message.models = object.models?.map((e) => types_1.Model.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryRawContractStateRequest() {
      return {
        address: "",
        queryData: new Uint8Array()
      };
    }
    exports.QueryRawContractStateRequest = {
      typeUrl: "/cosmwasm.wasm.v1.QueryRawContractStateRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.queryData.length !== 0) {
          writer.uint32(18).bytes(message.queryData);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryRawContractStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.queryData = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryRawContractStateRequest();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.queryData))
          obj.queryData = (0, helpers_1.bytesFromBase64)(object.queryData);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.queryData !== void 0 && (obj.queryData = (0, helpers_1.base64FromBytes)(message.queryData !== void 0 ? message.queryData : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryRawContractStateRequest();
        message.address = object.address ?? "";
        message.queryData = object.queryData ?? new Uint8Array();
        return message;
      }
    };
    function createBaseQueryRawContractStateResponse() {
      return {
        data: new Uint8Array()
      };
    }
    exports.QueryRawContractStateResponse = {
      typeUrl: "/cosmwasm.wasm.v1.QueryRawContractStateResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.data.length !== 0) {
          writer.uint32(10).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryRawContractStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryRawContractStateResponse();
        if ((0, helpers_1.isSet)(object.data))
          obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryRawContractStateResponse();
        message.data = object.data ?? new Uint8Array();
        return message;
      }
    };
    function createBaseQuerySmartContractStateRequest() {
      return {
        address: "",
        queryData: new Uint8Array()
      };
    }
    exports.QuerySmartContractStateRequest = {
      typeUrl: "/cosmwasm.wasm.v1.QuerySmartContractStateRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        if (message.queryData.length !== 0) {
          writer.uint32(18).bytes(message.queryData);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySmartContractStateRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            case 2:
              message.queryData = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQuerySmartContractStateRequest();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        if ((0, helpers_1.isSet)(object.queryData))
          obj.queryData = (0, helpers_1.bytesFromBase64)(object.queryData);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        message.queryData !== void 0 && (obj.queryData = (0, helpers_1.base64FromBytes)(message.queryData !== void 0 ? message.queryData : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQuerySmartContractStateRequest();
        message.address = object.address ?? "";
        message.queryData = object.queryData ?? new Uint8Array();
        return message;
      }
    };
    function createBaseQuerySmartContractStateResponse() {
      return {
        data: new Uint8Array()
      };
    }
    exports.QuerySmartContractStateResponse = {
      typeUrl: "/cosmwasm.wasm.v1.QuerySmartContractStateResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.data.length !== 0) {
          writer.uint32(10).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQuerySmartContractStateResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQuerySmartContractStateResponse();
        if ((0, helpers_1.isSet)(object.data))
          obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQuerySmartContractStateResponse();
        message.data = object.data ?? new Uint8Array();
        return message;
      }
    };
    function createBaseQueryCodeRequest() {
      return {
        codeId: BigInt(0)
      };
    }
    exports.QueryCodeRequest = {
      typeUrl: "/cosmwasm.wasm.v1.QueryCodeRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.codeId !== BigInt(0)) {
          writer.uint32(8).uint64(message.codeId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryCodeRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.codeId = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryCodeRequest();
        if ((0, helpers_1.isSet)(object.codeId))
          obj.codeId = BigInt(object.codeId.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.codeId !== void 0 && (obj.codeId = (message.codeId || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryCodeRequest();
        if (object.codeId !== void 0 && object.codeId !== null) {
          message.codeId = BigInt(object.codeId.toString());
        }
        return message;
      }
    };
    function createBaseQueryCodeInfoRequest() {
      return {
        codeId: BigInt(0)
      };
    }
    exports.QueryCodeInfoRequest = {
      typeUrl: "/cosmwasm.wasm.v1.QueryCodeInfoRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.codeId !== BigInt(0)) {
          writer.uint32(8).uint64(message.codeId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryCodeInfoRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.codeId = reader.uint64();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryCodeInfoRequest();
        if ((0, helpers_1.isSet)(object.codeId))
          obj.codeId = BigInt(object.codeId.toString());
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.codeId !== void 0 && (obj.codeId = (message.codeId || BigInt(0)).toString());
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryCodeInfoRequest();
        if (object.codeId !== void 0 && object.codeId !== null) {
          message.codeId = BigInt(object.codeId.toString());
        }
        return message;
      }
    };
    function createBaseQueryCodeInfoResponse() {
      return {
        codeId: BigInt(0),
        creator: "",
        checksum: new Uint8Array(),
        instantiatePermission: types_1.AccessConfig.fromPartial({})
      };
    }
    exports.QueryCodeInfoResponse = {
      typeUrl: "/cosmwasm.wasm.v1.QueryCodeInfoResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.codeId !== BigInt(0)) {
          writer.uint32(8).uint64(message.codeId);
        }
        if (message.creator !== "") {
          writer.uint32(18).string(message.creator);
        }
        if (message.checksum.length !== 0) {
          writer.uint32(26).bytes(message.checksum);
        }
        if (message.instantiatePermission !== void 0) {
          types_1.AccessConfig.encode(message.instantiatePermission, writer.uint32(34).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryCodeInfoResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.codeId = reader.uint64();
              break;
            case 2:
              message.creator = reader.string();
              break;
            case 3:
              message.checksum = reader.bytes();
              break;
            case 4:
              message.instantiatePermission = types_1.AccessConfig.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryCodeInfoResponse();
        if ((0, helpers_1.isSet)(object.codeId))
          obj.codeId = BigInt(object.codeId.toString());
        if ((0, helpers_1.isSet)(object.creator))
          obj.creator = String(object.creator);
        if ((0, helpers_1.isSet)(object.checksum))
          obj.checksum = (0, helpers_1.bytesFromBase64)(object.checksum);
        if ((0, helpers_1.isSet)(object.instantiatePermission))
          obj.instantiatePermission = types_1.AccessConfig.fromJSON(object.instantiatePermission);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.codeId !== void 0 && (obj.codeId = (message.codeId || BigInt(0)).toString());
        message.creator !== void 0 && (obj.creator = message.creator);
        message.checksum !== void 0 && (obj.checksum = (0, helpers_1.base64FromBytes)(message.checksum !== void 0 ? message.checksum : new Uint8Array()));
        message.instantiatePermission !== void 0 && (obj.instantiatePermission = message.instantiatePermission ? types_1.AccessConfig.toJSON(message.instantiatePermission) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryCodeInfoResponse();
        if (object.codeId !== void 0 && object.codeId !== null) {
          message.codeId = BigInt(object.codeId.toString());
        }
        message.creator = object.creator ?? "";
        message.checksum = object.checksum ?? new Uint8Array();
        if (object.instantiatePermission !== void 0 && object.instantiatePermission !== null) {
          message.instantiatePermission = types_1.AccessConfig.fromPartial(object.instantiatePermission);
        }
        return message;
      }
    };
    function createBaseCodeInfoResponse() {
      return {
        codeId: BigInt(0),
        creator: "",
        dataHash: new Uint8Array(),
        instantiatePermission: types_1.AccessConfig.fromPartial({})
      };
    }
    exports.CodeInfoResponse = {
      typeUrl: "/cosmwasm.wasm.v1.CodeInfoResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.codeId !== BigInt(0)) {
          writer.uint32(8).uint64(message.codeId);
        }
        if (message.creator !== "") {
          writer.uint32(18).string(message.creator);
        }
        if (message.dataHash.length !== 0) {
          writer.uint32(26).bytes(message.dataHash);
        }
        if (message.instantiatePermission !== void 0) {
          types_1.AccessConfig.encode(message.instantiatePermission, writer.uint32(50).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCodeInfoResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.codeId = reader.uint64();
              break;
            case 2:
              message.creator = reader.string();
              break;
            case 3:
              message.dataHash = reader.bytes();
              break;
            case 6:
              message.instantiatePermission = types_1.AccessConfig.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseCodeInfoResponse();
        if ((0, helpers_1.isSet)(object.codeId))
          obj.codeId = BigInt(object.codeId.toString());
        if ((0, helpers_1.isSet)(object.creator))
          obj.creator = String(object.creator);
        if ((0, helpers_1.isSet)(object.dataHash))
          obj.dataHash = (0, helpers_1.bytesFromBase64)(object.dataHash);
        if ((0, helpers_1.isSet)(object.instantiatePermission))
          obj.instantiatePermission = types_1.AccessConfig.fromJSON(object.instantiatePermission);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.codeId !== void 0 && (obj.codeId = (message.codeId || BigInt(0)).toString());
        message.creator !== void 0 && (obj.creator = message.creator);
        message.dataHash !== void 0 && (obj.dataHash = (0, helpers_1.base64FromBytes)(message.dataHash !== void 0 ? message.dataHash : new Uint8Array()));
        message.instantiatePermission !== void 0 && (obj.instantiatePermission = message.instantiatePermission ? types_1.AccessConfig.toJSON(message.instantiatePermission) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseCodeInfoResponse();
        if (object.codeId !== void 0 && object.codeId !== null) {
          message.codeId = BigInt(object.codeId.toString());
        }
        message.creator = object.creator ?? "";
        message.dataHash = object.dataHash ?? new Uint8Array();
        if (object.instantiatePermission !== void 0 && object.instantiatePermission !== null) {
          message.instantiatePermission = types_1.AccessConfig.fromPartial(object.instantiatePermission);
        }
        return message;
      }
    };
    function createBaseQueryCodeResponse() {
      return {
        codeInfo: void 0,
        data: new Uint8Array()
      };
    }
    exports.QueryCodeResponse = {
      typeUrl: "/cosmwasm.wasm.v1.QueryCodeResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.codeInfo !== void 0) {
          exports.CodeInfoResponse.encode(message.codeInfo, writer.uint32(10).fork()).ldelim();
        }
        if (message.data.length !== 0) {
          writer.uint32(18).bytes(message.data);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryCodeResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.codeInfo = exports.CodeInfoResponse.decode(reader, reader.uint32());
              break;
            case 2:
              message.data = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryCodeResponse();
        if ((0, helpers_1.isSet)(object.codeInfo))
          obj.codeInfo = exports.CodeInfoResponse.fromJSON(object.codeInfo);
        if ((0, helpers_1.isSet)(object.data))
          obj.data = (0, helpers_1.bytesFromBase64)(object.data);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.codeInfo !== void 0 && (obj.codeInfo = message.codeInfo ? exports.CodeInfoResponse.toJSON(message.codeInfo) : void 0);
        message.data !== void 0 && (obj.data = (0, helpers_1.base64FromBytes)(message.data !== void 0 ? message.data : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryCodeResponse();
        if (object.codeInfo !== void 0 && object.codeInfo !== null) {
          message.codeInfo = exports.CodeInfoResponse.fromPartial(object.codeInfo);
        }
        message.data = object.data ?? new Uint8Array();
        return message;
      }
    };
    function createBaseQueryCodesRequest() {
      return {
        pagination: void 0
      };
    }
    exports.QueryCodesRequest = {
      typeUrl: "/cosmwasm.wasm.v1.QueryCodesRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryCodesRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryCodesRequest();
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryCodesRequest();
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryCodesResponse() {
      return {
        codeInfos: [],
        pagination: void 0
      };
    }
    exports.QueryCodesResponse = {
      typeUrl: "/cosmwasm.wasm.v1.QueryCodesResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.codeInfos) {
          exports.CodeInfoResponse.encode(v9, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryCodesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.codeInfos.push(exports.CodeInfoResponse.decode(reader, reader.uint32()));
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryCodesResponse();
        if (Array.isArray(object?.codeInfos))
          obj.codeInfos = object.codeInfos.map((e) => exports.CodeInfoResponse.fromJSON(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.codeInfos) {
          obj.codeInfos = message.codeInfos.map((e) => e ? exports.CodeInfoResponse.toJSON(e) : void 0);
        } else {
          obj.codeInfos = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryCodesResponse();
        message.codeInfos = object.codeInfos?.map((e) => exports.CodeInfoResponse.fromPartial(e)) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryPinnedCodesRequest() {
      return {
        pagination: void 0
      };
    }
    exports.QueryPinnedCodesRequest = {
      typeUrl: "/cosmwasm.wasm.v1.QueryPinnedCodesRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPinnedCodesRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryPinnedCodesRequest();
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryPinnedCodesRequest();
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryPinnedCodesResponse() {
      return {
        codeIds: [],
        pagination: void 0
      };
    }
    exports.QueryPinnedCodesResponse = {
      typeUrl: "/cosmwasm.wasm.v1.QueryPinnedCodesResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        writer.uint32(10).fork();
        for (const v9 of message.codeIds) {
          writer.uint64(v9);
        }
        writer.ldelim();
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryPinnedCodesResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if ((tag & 7) === 2) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.codeIds.push(reader.uint64());
                }
              } else {
                message.codeIds.push(reader.uint64());
              }
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryPinnedCodesResponse();
        if (Array.isArray(object?.codeIds))
          obj.codeIds = object.codeIds.map((e) => BigInt(e.toString()));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.codeIds) {
          obj.codeIds = message.codeIds.map((e) => (e || BigInt(0)).toString());
        } else {
          obj.codeIds = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryPinnedCodesResponse();
        message.codeIds = object.codeIds?.map((e) => BigInt(e.toString())) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryParamsRequest() {
      return {};
    }
    exports.QueryParamsRequest = {
      typeUrl: "/cosmwasm.wasm.v1.QueryParamsRequest",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseQueryParamsRequest();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseQueryParamsRequest();
        return message;
      }
    };
    function createBaseQueryParamsResponse() {
      return {
        params: types_1.Params.fromPartial({})
      };
    }
    exports.QueryParamsResponse = {
      typeUrl: "/cosmwasm.wasm.v1.QueryParamsResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.params !== void 0) {
          types_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.params = types_1.Params.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryParamsResponse();
        if ((0, helpers_1.isSet)(object.params))
          obj.params = types_1.Params.fromJSON(object.params);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.params !== void 0 && (obj.params = message.params ? types_1.Params.toJSON(message.params) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryParamsResponse();
        if (object.params !== void 0 && object.params !== null) {
          message.params = types_1.Params.fromPartial(object.params);
        }
        return message;
      }
    };
    function createBaseQueryContractsByCreatorRequest() {
      return {
        creatorAddress: "",
        pagination: void 0
      };
    }
    exports.QueryContractsByCreatorRequest = {
      typeUrl: "/cosmwasm.wasm.v1.QueryContractsByCreatorRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.creatorAddress !== "") {
          writer.uint32(10).string(message.creatorAddress);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryContractsByCreatorRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.creatorAddress = reader.string();
              break;
            case 2:
              message.pagination = pagination_1.PageRequest.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryContractsByCreatorRequest();
        if ((0, helpers_1.isSet)(object.creatorAddress))
          obj.creatorAddress = String(object.creatorAddress);
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageRequest.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.creatorAddress !== void 0 && (obj.creatorAddress = message.creatorAddress);
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageRequest.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryContractsByCreatorRequest();
        message.creatorAddress = object.creatorAddress ?? "";
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageRequest.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryContractsByCreatorResponse() {
      return {
        contractAddresses: [],
        pagination: void 0
      };
    }
    exports.QueryContractsByCreatorResponse = {
      typeUrl: "/cosmwasm.wasm.v1.QueryContractsByCreatorResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        for (const v9 of message.contractAddresses) {
          writer.uint32(10).string(v9);
        }
        if (message.pagination !== void 0) {
          pagination_1.PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryContractsByCreatorResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.contractAddresses.push(reader.string());
              break;
            case 2:
              message.pagination = pagination_1.PageResponse.decode(reader, reader.uint32());
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryContractsByCreatorResponse();
        if (Array.isArray(object?.contractAddresses))
          obj.contractAddresses = object.contractAddresses.map((e) => String(e));
        if ((0, helpers_1.isSet)(object.pagination))
          obj.pagination = pagination_1.PageResponse.fromJSON(object.pagination);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        if (message.contractAddresses) {
          obj.contractAddresses = message.contractAddresses.map((e) => e);
        } else {
          obj.contractAddresses = [];
        }
        message.pagination !== void 0 && (obj.pagination = message.pagination ? pagination_1.PageResponse.toJSON(message.pagination) : void 0);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryContractsByCreatorResponse();
        message.contractAddresses = object.contractAddresses?.map((e) => e) || [];
        if (object.pagination !== void 0 && object.pagination !== null) {
          message.pagination = pagination_1.PageResponse.fromPartial(object.pagination);
        }
        return message;
      }
    };
    function createBaseQueryWasmLimitsConfigRequest() {
      return {};
    }
    exports.QueryWasmLimitsConfigRequest = {
      typeUrl: "/cosmwasm.wasm.v1.QueryWasmLimitsConfigRequest",
      encode(_2, writer = binary_1.BinaryWriter.create()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryWasmLimitsConfigRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(_2) {
        const obj = createBaseQueryWasmLimitsConfigRequest();
        return obj;
      },
      toJSON(_2) {
        const obj = {};
        return obj;
      },
      fromPartial(_2) {
        const message = createBaseQueryWasmLimitsConfigRequest();
        return message;
      }
    };
    function createBaseQueryWasmLimitsConfigResponse() {
      return {
        config: ""
      };
    }
    exports.QueryWasmLimitsConfigResponse = {
      typeUrl: "/cosmwasm.wasm.v1.QueryWasmLimitsConfigResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.config !== "") {
          writer.uint32(10).string(message.config);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryWasmLimitsConfigResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.config = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryWasmLimitsConfigResponse();
        if ((0, helpers_1.isSet)(object.config))
          obj.config = String(object.config);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.config !== void 0 && (obj.config = message.config);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryWasmLimitsConfigResponse();
        message.config = object.config ?? "";
        return message;
      }
    };
    function createBaseQueryBuildAddressRequest() {
      return {
        codeHash: "",
        creatorAddress: "",
        salt: "",
        initArgs: new Uint8Array()
      };
    }
    exports.QueryBuildAddressRequest = {
      typeUrl: "/cosmwasm.wasm.v1.QueryBuildAddressRequest",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.codeHash !== "") {
          writer.uint32(10).string(message.codeHash);
        }
        if (message.creatorAddress !== "") {
          writer.uint32(18).string(message.creatorAddress);
        }
        if (message.salt !== "") {
          writer.uint32(26).string(message.salt);
        }
        if (message.initArgs.length !== 0) {
          writer.uint32(34).bytes(message.initArgs);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryBuildAddressRequest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.codeHash = reader.string();
              break;
            case 2:
              message.creatorAddress = reader.string();
              break;
            case 3:
              message.salt = reader.string();
              break;
            case 4:
              message.initArgs = reader.bytes();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryBuildAddressRequest();
        if ((0, helpers_1.isSet)(object.codeHash))
          obj.codeHash = String(object.codeHash);
        if ((0, helpers_1.isSet)(object.creatorAddress))
          obj.creatorAddress = String(object.creatorAddress);
        if ((0, helpers_1.isSet)(object.salt))
          obj.salt = String(object.salt);
        if ((0, helpers_1.isSet)(object.initArgs))
          obj.initArgs = (0, helpers_1.bytesFromBase64)(object.initArgs);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.codeHash !== void 0 && (obj.codeHash = message.codeHash);
        message.creatorAddress !== void 0 && (obj.creatorAddress = message.creatorAddress);
        message.salt !== void 0 && (obj.salt = message.salt);
        message.initArgs !== void 0 && (obj.initArgs = (0, helpers_1.base64FromBytes)(message.initArgs !== void 0 ? message.initArgs : new Uint8Array()));
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryBuildAddressRequest();
        message.codeHash = object.codeHash ?? "";
        message.creatorAddress = object.creatorAddress ?? "";
        message.salt = object.salt ?? "";
        message.initArgs = object.initArgs ?? new Uint8Array();
        return message;
      }
    };
    function createBaseQueryBuildAddressResponse() {
      return {
        address: ""
      };
    }
    exports.QueryBuildAddressResponse = {
      typeUrl: "/cosmwasm.wasm.v1.QueryBuildAddressResponse",
      encode(message, writer = binary_1.BinaryWriter.create()) {
        if (message.address !== "") {
          writer.uint32(10).string(message.address);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof binary_1.BinaryReader ? input : new binary_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseQueryBuildAddressResponse();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.address = reader.string();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      },
      fromJSON(object) {
        const obj = createBaseQueryBuildAddressResponse();
        if ((0, helpers_1.isSet)(object.address))
          obj.address = String(object.address);
        return obj;
      },
      toJSON(message) {
        const obj = {};
        message.address !== void 0 && (obj.address = message.address);
        return obj;
      },
      fromPartial(object) {
        const message = createBaseQueryBuildAddressResponse();
        message.address = object.address ?? "";
        return message;
      }
    };
    var QueryClientImpl = class {
      constructor(rpc) {
        this.rpc = rpc;
        this.ContractInfo = this.ContractInfo.bind(this);
        this.ContractHistory = this.ContractHistory.bind(this);
        this.ContractsByCode = this.ContractsByCode.bind(this);
        this.AllContractState = this.AllContractState.bind(this);
        this.RawContractState = this.RawContractState.bind(this);
        this.SmartContractState = this.SmartContractState.bind(this);
        this.Code = this.Code.bind(this);
        this.Codes = this.Codes.bind(this);
        this.CodeInfo = this.CodeInfo.bind(this);
        this.PinnedCodes = this.PinnedCodes.bind(this);
        this.Params = this.Params.bind(this);
        this.ContractsByCreator = this.ContractsByCreator.bind(this);
        this.WasmLimitsConfig = this.WasmLimitsConfig.bind(this);
        this.BuildAddress = this.BuildAddress.bind(this);
      }
      ContractInfo(request) {
        const data2 = exports.QueryContractInfoRequest.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Query", "ContractInfo", data2);
        return promise.then((data3) => exports.QueryContractInfoResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ContractHistory(request) {
        const data2 = exports.QueryContractHistoryRequest.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Query", "ContractHistory", data2);
        return promise.then((data3) => exports.QueryContractHistoryResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ContractsByCode(request) {
        const data2 = exports.QueryContractsByCodeRequest.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Query", "ContractsByCode", data2);
        return promise.then((data3) => exports.QueryContractsByCodeResponse.decode(new binary_1.BinaryReader(data3)));
      }
      AllContractState(request) {
        const data2 = exports.QueryAllContractStateRequest.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Query", "AllContractState", data2);
        return promise.then((data3) => exports.QueryAllContractStateResponse.decode(new binary_1.BinaryReader(data3)));
      }
      RawContractState(request) {
        const data2 = exports.QueryRawContractStateRequest.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Query", "RawContractState", data2);
        return promise.then((data3) => exports.QueryRawContractStateResponse.decode(new binary_1.BinaryReader(data3)));
      }
      SmartContractState(request) {
        const data2 = exports.QuerySmartContractStateRequest.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Query", "SmartContractState", data2);
        return promise.then((data3) => exports.QuerySmartContractStateResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Code(request) {
        const data2 = exports.QueryCodeRequest.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Query", "Code", data2);
        return promise.then((data3) => exports.QueryCodeResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Codes(request = {
        pagination: pagination_1.PageRequest.fromPartial({})
      }) {
        const data2 = exports.QueryCodesRequest.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Query", "Codes", data2);
        return promise.then((data3) => exports.QueryCodesResponse.decode(new binary_1.BinaryReader(data3)));
      }
      CodeInfo(request) {
        const data2 = exports.QueryCodeInfoRequest.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Query", "CodeInfo", data2);
        return promise.then((data3) => exports.QueryCodeInfoResponse.decode(new binary_1.BinaryReader(data3)));
      }
      PinnedCodes(request = {
        pagination: pagination_1.PageRequest.fromPartial({})
      }) {
        const data2 = exports.QueryPinnedCodesRequest.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Query", "PinnedCodes", data2);
        return promise.then((data3) => exports.QueryPinnedCodesResponse.decode(new binary_1.BinaryReader(data3)));
      }
      Params(request = {}) {
        const data2 = exports.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Query", "Params", data2);
        return promise.then((data3) => exports.QueryParamsResponse.decode(new binary_1.BinaryReader(data3)));
      }
      ContractsByCreator(request) {
        const data2 = exports.QueryContractsByCreatorRequest.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Query", "ContractsByCreator", data2);
        return promise.then((data3) => exports.QueryContractsByCreatorResponse.decode(new binary_1.BinaryReader(data3)));
      }
      WasmLimitsConfig(request = {}) {
        const data2 = exports.QueryWasmLimitsConfigRequest.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Query", "WasmLimitsConfig", data2);
        return promise.then((data3) => exports.QueryWasmLimitsConfigResponse.decode(new binary_1.BinaryReader(data3)));
      }
      BuildAddress(request) {
        const data2 = exports.QueryBuildAddressRequest.encode(request).finish();
        const promise = this.rpc.request("cosmwasm.wasm.v1.Query", "BuildAddress", data2);
        return promise.then((data3) => exports.QueryBuildAddressResponse.decode(new binary_1.BinaryReader(data3)));
      }
    };
    exports.QueryClientImpl = QueryClientImpl;
  }
});

// node_modules/.pnpm/@cosmjs+cosmwasm-stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/cosmwasm-stargate/build/modules/wasm/queries.js
var require_queries12 = __commonJS({
  "node_modules/.pnpm/@cosmjs+cosmwasm-stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/cosmwasm-stargate/build/modules/wasm/queries.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupWasmExtension = setupWasmExtension;
    var encoding_1 = require_build2();
    var stargate_1 = require_build11();
    var query_1 = require_query14();
    function setupWasmExtension(base) {
      const rpc = (0, stargate_1.createProtobufRpcClient)(base);
      const queryService = new query_1.QueryClientImpl(rpc);
      return {
        wasm: {
          listCodeInfo: async (paginationKey) => {
            const request = {
              pagination: (0, stargate_1.createPagination)(paginationKey)
            };
            return queryService.Codes(request);
          },
          getCode: async (id) => {
            const request = query_1.QueryCodeRequest.fromPartial({ codeId: BigInt(id) });
            return queryService.Code(request);
          },
          listContractsByCodeId: async (id, paginationKey) => {
            const request = query_1.QueryContractsByCodeRequest.fromPartial({
              codeId: BigInt(id),
              pagination: (0, stargate_1.createPagination)(paginationKey)
            });
            return queryService.ContractsByCode(request);
          },
          listContractsByCreator: async (creator, paginationKey) => {
            const request = {
              creatorAddress: creator,
              pagination: (0, stargate_1.createPagination)(paginationKey)
            };
            return queryService.ContractsByCreator(request);
          },
          getContractInfo: async (address) => {
            const request = { address };
            return queryService.ContractInfo(request);
          },
          getContractCodeHistory: async (address, paginationKey) => {
            const request = {
              address,
              pagination: (0, stargate_1.createPagination)(paginationKey)
            };
            return queryService.ContractHistory(request);
          },
          getAllContractState: async (address, paginationKey) => {
            const request = {
              address,
              pagination: (0, stargate_1.createPagination)(paginationKey)
            };
            return queryService.AllContractState(request);
          },
          queryContractRaw: async (address, key) => {
            const request = { address, queryData: key };
            return queryService.RawContractState(request);
          },
          queryContractSmart: async (address, query) => {
            const request = { address, queryData: (0, encoding_1.toUtf8)(JSON.stringify(query)) };
            const { data: data2 } = await queryService.SmartContractState(request);
            let responseText;
            try {
              responseText = (0, encoding_1.fromUtf8)(data2);
            } catch (error) {
              throw new Error(`Could not UTF-8 decode smart query response from contract: ${error}`);
            }
            try {
              return JSON.parse(responseText);
            } catch (error) {
              throw new Error(`Could not JSON parse smart query response from contract: ${error}`);
            }
          }
        }
      };
    }
  }
});

// node_modules/.pnpm/@cosmjs+cosmwasm-stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/cosmwasm-stargate/build/modules/index.js
var require_modules2 = __commonJS({
  "node_modules/.pnpm/@cosmjs+cosmwasm-stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/cosmwasm-stargate/build/modules/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setupWasmExtension = exports.wasmTypes = exports.isMsgUpdateAdminEncodeObject = exports.isMsgStoreCodeEncodeObject = exports.isMsgMigrateEncodeObject = exports.isMsgInstantiateContractEncodeObject = exports.isMsgInstantiateContract2EncodeObject = exports.isMsgExecuteEncodeObject = exports.isMsgClearAdminEncodeObject = exports.createWasmAminoConverters = void 0;
    var aminomessages_1 = require_aminomessages13();
    Object.defineProperty(exports, "createWasmAminoConverters", { enumerable: true, get: function() {
      return aminomessages_1.createWasmAminoConverters;
    } });
    var messages_1 = require_messages10();
    Object.defineProperty(exports, "isMsgClearAdminEncodeObject", { enumerable: true, get: function() {
      return messages_1.isMsgClearAdminEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgExecuteEncodeObject", { enumerable: true, get: function() {
      return messages_1.isMsgExecuteEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgInstantiateContract2EncodeObject", { enumerable: true, get: function() {
      return messages_1.isMsgInstantiateContract2EncodeObject;
    } });
    Object.defineProperty(exports, "isMsgInstantiateContractEncodeObject", { enumerable: true, get: function() {
      return messages_1.isMsgInstantiateContractEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgMigrateEncodeObject", { enumerable: true, get: function() {
      return messages_1.isMsgMigrateEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgStoreCodeEncodeObject", { enumerable: true, get: function() {
      return messages_1.isMsgStoreCodeEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgUpdateAdminEncodeObject", { enumerable: true, get: function() {
      return messages_1.isMsgUpdateAdminEncodeObject;
    } });
    Object.defineProperty(exports, "wasmTypes", { enumerable: true, get: function() {
      return messages_1.wasmTypes;
    } });
    var queries_1 = require_queries12();
    Object.defineProperty(exports, "setupWasmExtension", { enumerable: true, get: function() {
      return queries_1.setupWasmExtension;
    } });
  }
});

// node_modules/.pnpm/@cosmjs+cosmwasm-stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/cosmwasm-stargate/build/cosmwasmclient.js
var require_cosmwasmclient = __commonJS({
  "node_modules/.pnpm/@cosmjs+cosmwasm-stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/cosmwasm-stargate/build/cosmwasmclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CosmWasmClient = void 0;
    var encoding_1 = require_build2();
    var math_1 = require_build3();
    var stargate_1 = require_build11();
    var tendermint_rpc_1 = require_build10();
    var utils_1 = require_build();
    var abci_1 = require_abci();
    var types_1 = require_types7();
    var modules_1 = require_modules2();
    var CosmWasmClient = class _CosmWasmClient {
      cometClient;
      queryClient;
      codesCache = /* @__PURE__ */ new Map();
      chainId;
      /**
       * Creates an instance by connecting to the given CometBFT RPC endpoint.
       *
       * This uses auto-detection to decide between a CometBFT 0.38, Tendermint 0.37 and 0.34 client.
       * To set the Comet client explicitly, use `create`.
       */
      static async connect(endpoint) {
        const cometClient = await (0, tendermint_rpc_1.connectComet)(endpoint);
        return _CosmWasmClient.create(cometClient);
      }
      /**
       * Creates an instance from a manually created Comet client.
       * Use this to use `Comet38Client` or `Tendermint37Client` instead of `Tendermint34Client`.
       */
      static create(cometClient) {
        return new _CosmWasmClient(cometClient);
      }
      constructor(cometClient) {
        if (cometClient) {
          this.cometClient = cometClient;
          this.queryClient = stargate_1.QueryClient.withExtensions(cometClient, stargate_1.setupAuthExtension, stargate_1.setupBankExtension, modules_1.setupWasmExtension, stargate_1.setupTxExtension);
        }
      }
      getCometClient() {
        return this.cometClient;
      }
      forceGetCometClient() {
        if (!this.cometClient) {
          throw new Error("Comet client not available. You cannot use online functionality in offline mode.");
        }
        return this.cometClient;
      }
      getQueryClient() {
        return this.queryClient;
      }
      forceGetQueryClient() {
        if (!this.queryClient) {
          throw new Error("Query client not available. You cannot use online functionality in offline mode.");
        }
        return this.queryClient;
      }
      async getChainId() {
        if (!this.chainId) {
          const response = await this.forceGetCometClient().status();
          const chainId = response.nodeInfo.network;
          if (!chainId)
            throw new Error("Chain ID must not be empty");
          this.chainId = chainId;
        }
        return this.chainId;
      }
      async getHeight() {
        const status = await this.forceGetCometClient().status();
        return status.syncInfo.latestBlockHeight;
      }
      async getAccount(searchAddress) {
        try {
          const account = await this.forceGetQueryClient().auth.account(searchAddress);
          return account ? (0, stargate_1.accountFromAny)(account) : null;
        } catch (error) {
          if (/rpc error: code = NotFound/i.test(error.toString())) {
            return null;
          }
          throw error;
        }
      }
      async getSequence(address) {
        const account = await this.getAccount(address);
        if (!account) {
          throw new Error(`Account '${address}' does not exist on chain. Send some tokens there before trying to query sequence.`);
        }
        return {
          accountNumber: account.accountNumber,
          sequence: account.sequence
        };
      }
      async getBlock(height) {
        const response = await this.forceGetCometClient().block(height);
        return {
          id: (0, encoding_1.toHex)(response.blockId.hash).toUpperCase(),
          header: {
            version: {
              block: new math_1.Uint53(response.block.header.version.block).toString(),
              app: new math_1.Uint53(response.block.header.version.app).toString()
            },
            height: response.block.header.height,
            chainId: response.block.header.chainId,
            time: (0, tendermint_rpc_1.toRfc3339WithNanoseconds)(response.block.header.time)
          },
          txs: response.block.txs
        };
      }
      async getBalance(address, searchDenom) {
        return this.forceGetQueryClient().bank.balance(address, searchDenom);
      }
      async getTx(id) {
        const results = await this.txsQuery(`tx.hash='${id}'`);
        return results[0] ?? null;
      }
      async searchTx(query) {
        let rawQuery;
        if (typeof query === "string") {
          rawQuery = query;
        } else if ((0, stargate_1.isSearchTxQueryArray)(query)) {
          rawQuery = query.map((t) => {
            if (typeof t.value === "string")
              return `${t.key}='${t.value}'`;
            else
              return `${t.key}=${t.value}`;
          }).join(" AND ");
        } else {
          throw new Error("Got unsupported query type. See CosmJS 0.31 CHANGELOG for API breaking changes here.");
        }
        return this.txsQuery(rawQuery);
      }
      disconnect() {
        if (this.cometClient)
          this.cometClient.disconnect();
      }
      /**
       * Broadcasts a signed transaction to the network and monitors its inclusion in a block.
       *
       * If broadcasting is rejected by the node for some reason (e.g. because of a CheckTx failure),
       * an error is thrown.
       *
       * If the transaction is not included in a block before the provided timeout, this errors with a `TimeoutError`.
       *
       * If the transaction is included in a block, a `DeliverTxResponse` is returned. The caller then
       * usually needs to check for execution success or failure.
       */
      // NOTE: This method is tested against slow chains and timeouts in the @cosmjs/stargate package.
      // Make sure it is kept in sync!
      async broadcastTx(tx, timeoutMs = 6e4, pollIntervalMs = 3e3) {
        let timedOut = false;
        const txPollTimeout = setTimeout(() => {
          timedOut = true;
        }, timeoutMs);
        const pollForTx = async (txId) => {
          if (timedOut) {
            throw new stargate_1.TimeoutError(`Transaction with ID ${txId} was submitted but was not yet found on the chain. You might want to check later. There was a wait of ${timeoutMs / 1e3} seconds.`, txId);
          }
          await (0, utils_1.sleep)(pollIntervalMs);
          const result = await this.getTx(txId);
          return result ? {
            code: result.code,
            height: result.height,
            txIndex: result.txIndex,
            rawLog: result.rawLog,
            transactionHash: txId,
            events: result.events,
            msgResponses: result.msgResponses,
            gasUsed: result.gasUsed,
            gasWanted: result.gasWanted
          } : pollForTx(txId);
        };
        const transactionId = await this.broadcastTxSync(tx);
        return new Promise((resolve, reject) => pollForTx(transactionId).then((value) => {
          clearTimeout(txPollTimeout);
          resolve(value);
        }, (error) => {
          clearTimeout(txPollTimeout);
          reject(error);
        }));
      }
      /**
       * Broadcasts a signed transaction to the network without monitoring it.
       *
       * If broadcasting is rejected by the node for some reason (e.g. because of a CheckTx failure),
       * an error is thrown.
       *
       * If the transaction is broadcasted, a `string` containing the hash of the transaction is returned. The caller then
       * usually needs to check if the transaction was included in a block and was successful.
       *
       * @returns Returns the hash of the transaction
       */
      async broadcastTxSync(tx) {
        const broadcasted = await this.forceGetCometClient().broadcastTxSync({ tx });
        if (broadcasted.code) {
          return Promise.reject(new stargate_1.BroadcastTxError(broadcasted.code, broadcasted.codespace ?? "", broadcasted.log));
        }
        const transactionId = (0, encoding_1.toHex)(broadcasted.hash).toUpperCase();
        return transactionId;
      }
      /**
       * getCodes() returns all codes and is just looping through all pagination pages.
       *
       * This is potentially inefficient and advanced apps should consider creating
       * their own query client to handle pagination together with the app's screens.
       */
      async getCodes() {
        const allCodes = [];
        let startAtKey = void 0;
        do {
          const { codeInfos, pagination } = await this.forceGetQueryClient().wasm.listCodeInfo(startAtKey);
          const loadedCodes = codeInfos || [];
          allCodes.push(...loadedCodes);
          startAtKey = pagination?.nextKey;
        } while (startAtKey?.length !== 0);
        return allCodes.map((entry) => {
          (0, utils_1.assert)(entry.creator && entry.codeId && entry.dataHash, "entry incomplete");
          return {
            id: Number(entry.codeId),
            creator: entry.creator,
            checksum: (0, encoding_1.toHex)(entry.dataHash)
          };
        });
      }
      async getCodeDetails(codeId) {
        const cached = this.codesCache.get(codeId);
        if (cached)
          return cached;
        const { codeInfo, data: data2 } = await this.forceGetQueryClient().wasm.getCode(codeId);
        (0, utils_1.assert)(codeInfo && codeInfo.codeId && codeInfo.creator && codeInfo.dataHash && data2, "codeInfo missing or incomplete");
        const codeDetails = {
          id: Number(codeInfo.codeId),
          creator: codeInfo.creator,
          checksum: (0, encoding_1.toHex)(codeInfo.dataHash),
          data: data2
        };
        this.codesCache.set(codeId, codeDetails);
        return codeDetails;
      }
      /**
       * getContracts() returns all contract instances for one code and is just looping through all pagination pages.
       *
       * This is potentially inefficient and advanced apps should consider creating
       * their own query client to handle pagination together with the app's screens.
       */
      async getContracts(codeId) {
        const allContracts = [];
        let startAtKey = void 0;
        do {
          const { contracts, pagination } = await this.forceGetQueryClient().wasm.listContractsByCodeId(codeId, startAtKey);
          allContracts.push(...contracts);
          startAtKey = pagination?.nextKey;
        } while (startAtKey?.length !== 0 && startAtKey !== void 0);
        return allContracts;
      }
      /**
       * Returns a list of contract addresses created by the given creator.
       * This just loops through all pagination pages.
       */
      async getContractsByCreator(creator) {
        const allContracts = [];
        let startAtKey = void 0;
        do {
          const { contractAddresses, pagination } = await this.forceGetQueryClient().wasm.listContractsByCreator(creator, startAtKey);
          allContracts.push(...contractAddresses);
          startAtKey = pagination?.nextKey;
        } while (startAtKey?.length !== 0 && startAtKey !== void 0);
        return allContracts;
      }
      /**
       * Throws an error if no contract was found at the address
       */
      async getContract(address) {
        const { address: retrievedAddress, contractInfo } = await this.forceGetQueryClient().wasm.getContractInfo(address);
        if (!contractInfo)
          throw new Error(`No contract found at address "${address}"`);
        (0, utils_1.assert)(retrievedAddress, "address missing");
        (0, utils_1.assert)(contractInfo.codeId && contractInfo.creator && contractInfo.label, "contractInfo incomplete");
        return {
          address: retrievedAddress,
          codeId: Number(contractInfo.codeId),
          creator: contractInfo.creator,
          admin: contractInfo.admin || void 0,
          label: contractInfo.label,
          ibcPortId: contractInfo.ibcPortId || void 0
        };
      }
      /**
       * Throws an error if no contract was found at the address
       */
      async getContractCodeHistory(address) {
        const result = await this.forceGetQueryClient().wasm.getContractCodeHistory(address);
        if (!result)
          throw new Error(`No contract history found for address "${address}"`);
        const operations = {
          [types_1.ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT]: "Init",
          [types_1.ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS]: "Genesis",
          [types_1.ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE]: "Migrate"
        };
        return (result.entries || []).map((entry) => {
          (0, utils_1.assert)(entry.operation && entry.codeId && entry.msg);
          return {
            operation: operations[entry.operation],
            codeId: Number(entry.codeId),
            msg: JSON.parse((0, encoding_1.fromUtf8)(entry.msg))
          };
        });
      }
      /**
       * Returns the data at the key if present (raw contract dependent storage data)
       * or null if no data at this key.
       *
       * Promise is rejected when contract does not exist.
       */
      async queryContractRaw(address, key) {
        await this.getContract(address);
        const { data: data2 } = await this.forceGetQueryClient().wasm.queryContractRaw(address, key);
        return data2 ?? null;
      }
      /**
       * Makes a smart query on the contract, returns the parsed JSON document.
       *
       * Promise is rejected when contract does not exist.
       * Promise is rejected for invalid query format.
       * Promise is rejected for invalid response format.
       */
      async queryContractSmart(address, queryMsg) {
        try {
          return await this.forceGetQueryClient().wasm.queryContractSmart(address, queryMsg);
        } catch (error) {
          if (error instanceof Error) {
            if (error.message.startsWith("not found: contract")) {
              throw new Error(`No contract found at address "${address}"`);
            } else {
              throw error;
            }
          } else {
            throw error;
          }
        }
      }
      async txsQuery(query) {
        const results = await this.forceGetCometClient().txSearchAll({ query });
        return results.txs.map((tx) => {
          const txMsgData = abci_1.TxMsgData.decode(tx.result.data ?? new Uint8Array());
          return {
            height: tx.height,
            txIndex: tx.index,
            hash: (0, encoding_1.toHex)(tx.hash).toUpperCase(),
            code: tx.result.code,
            events: tx.result.events.map(stargate_1.fromTendermintEvent),
            rawLog: tx.result.log || "",
            tx: tx.tx,
            msgResponses: txMsgData.msgResponses,
            gasUsed: tx.result.gasUsed,
            gasWanted: tx.result.gasWanted
          };
        });
      }
    };
    exports.CosmWasmClient = CosmWasmClient;
  }
});

// node_modules/.pnpm/@cosmjs+cosmwasm-stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/cosmwasm-stargate/build/encoding.js
var require_encoding2 = __commonJS({
  "node_modules/.pnpm/@cosmjs+cosmwasm-stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/cosmwasm-stargate/build/encoding.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toBinary = toBinary;
    exports.fromBinary = fromBinary;
    var encoding_1 = require_build2();
    function toBinary(obj) {
      return (0, encoding_1.toBase64)((0, encoding_1.toUtf8)(JSON.stringify(obj)));
    }
    function fromBinary(base642) {
      return JSON.parse((0, encoding_1.fromUtf8)((0, encoding_1.fromBase64)(base642)));
    }
  }
});

// node_modules/.pnpm/@cosmjs+cosmwasm-stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/cosmwasm-stargate/build/instantiate2.js
var require_instantiate2 = __commonJS({
  "node_modules/.pnpm/@cosmjs+cosmwasm-stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/cosmwasm-stargate/build/instantiate2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._instantiate2AddressIntermediate = _instantiate2AddressIntermediate;
    exports.instantiate2Address = instantiate2Address;
    var crypto_1 = require_build4();
    var encoding_1 = require_build2();
    var math_1 = require_build3();
    var utils_1 = require_build();
    function hash2(type, key) {
      return new crypto_1.Sha256((0, crypto_1.sha256)((0, encoding_1.toAscii)(type))).update(key).digest();
    }
    function toUint64(int) {
      return math_1.Uint64.fromNumber(int).toBytesBigEndian();
    }
    function _instantiate2AddressIntermediate(checksum2, creator, salt, msg, prefix) {
      (0, utils_1.assert)(checksum2.length === 32);
      const creatorData = (0, encoding_1.fromBech32)(creator).data;
      const msgData = typeof msg === "string" ? (0, encoding_1.toUtf8)(msg) : new Uint8Array();
      if (salt.length < 1 || salt.length > 64)
        throw new Error("Salt must be between 1 and 64 bytes");
      const key = new Uint8Array([
        ...(0, encoding_1.toAscii)("wasm"),
        0,
        ...toUint64(checksum2.length),
        ...checksum2,
        ...toUint64(creatorData.length),
        ...creatorData,
        ...toUint64(salt.length),
        ...salt,
        ...toUint64(msgData.length),
        ...msgData
      ]);
      const addressData = hash2("module", key);
      const address = (0, encoding_1.toBech32)(prefix, addressData);
      return { key, addressData, address };
    }
    function instantiate2Address(checksum2, creator, salt, bech32Prefix) {
      const msg = null;
      return _instantiate2AddressIntermediate(checksum2, creator, salt, msg, bech32Prefix).address;
    }
  }
});

// node_modules/.pnpm/@cosmjs+cosmwasm-stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/cosmwasm-stargate/build/compression.js
var require_compression = __commonJS({
  "node_modules/.pnpm/@cosmjs+cosmwasm-stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/cosmwasm-stargate/build/compression.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.gzip = gzip;
    async function gzip(uncompressed) {
      const inputStream = new Blob([uncompressed]).stream();
      const stream = inputStream.pipeThrough(new CompressionStream("gzip"));
      const buffer = await new Response(stream).arrayBuffer();
      return new Uint8Array(buffer);
    }
  }
});

// node_modules/.pnpm/@cosmjs+cosmwasm-stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/cosmwasm-stargate/build/signingcosmwasmclient.js
var require_signingcosmwasmclient = __commonJS({
  "node_modules/.pnpm/@cosmjs+cosmwasm-stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/cosmwasm-stargate/build/signingcosmwasmclient.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SigningCosmWasmClient = void 0;
    exports.findAttribute = findAttribute;
    var amino_1 = require_build5();
    var crypto_1 = require_build4();
    var encoding_1 = require_build2();
    var math_1 = require_build3();
    var proto_signing_1 = require_build6();
    var stargate_1 = require_build11();
    var tendermint_rpc_1 = require_build10();
    var utils_1 = require_build();
    var tx_1 = require_tx4();
    var tx_2 = require_tx13();
    var signing_1 = require_signing();
    var tx_3 = require_tx();
    var tx_4 = require_tx15();
    var compression_1 = require_compression();
    var cosmwasmclient_1 = require_cosmwasmclient();
    var modules_1 = require_modules2();
    function findAttribute(events, eventType, attrKey) {
      const attributes = events.filter((event) => event.type === eventType).flatMap((e) => e.attributes);
      const out = attributes.find((attr) => attr.key === attrKey);
      if (!out) {
        throw new Error(`Could not find attribute '${attrKey}' in first event of type '${eventType}' in first log.`);
      }
      return out;
    }
    function createDeliverTxResponseErrorMessage(result) {
      return `Error when broadcasting tx ${result.transactionHash} at height ${result.height}. Code: ${result.code}; Raw log: ${result.rawLog}`;
    }
    var SigningCosmWasmClient = class _SigningCosmWasmClient extends cosmwasmclient_1.CosmWasmClient {
      registry;
      broadcastTimeoutMs;
      broadcastPollIntervalMs;
      signer;
      aminoTypes;
      gasPrice;
      // Starting with Cosmos SDK 0.47, we see many cases in which 1.3 is not enough anymore
      // E.g. https://github.com/cosmos/cosmos-sdk/issues/16020
      defaultGasMultiplier = 1.4;
      /**
       * Creates an instance by connecting to the given CometBFT RPC endpoint.
       *
       * This uses auto-detection to decide between a CometBFT 0.38, Tendermint 0.37 and 0.34 client.
       * To set the Comet client explicitly, use `createWithSigner`.
       */
      static async connectWithSigner(endpoint, signer, options = {}) {
        const cometClient = await (0, tendermint_rpc_1.connectComet)(endpoint);
        return _SigningCosmWasmClient.createWithSigner(cometClient, signer, options);
      }
      /**
       * Creates an instance from a manually created Comet client.
       * Use this to use `Comet38Client` or `Tendermint37Client` instead of `Tendermint34Client`.
       */
      static createWithSigner(cometClient, signer, options = {}) {
        return new _SigningCosmWasmClient(cometClient, signer, options);
      }
      /**
       * Creates a client in offline mode.
       *
       * This should only be used in niche cases where you know exactly what you're doing,
       * e.g. when building an offline signing application.
       *
       * When you try to use online functionality with such a signer, an
       * exception will be raised.
       */
      static async offline(signer, options = {}) {
        return new _SigningCosmWasmClient(void 0, signer, options);
      }
      constructor(cometClient, signer, options) {
        super(cometClient);
        const { registry = new proto_signing_1.Registry([...stargate_1.defaultRegistryTypes, ...modules_1.wasmTypes]), aminoTypes = new stargate_1.AminoTypes({
          ...(0, stargate_1.createDefaultAminoConverters)(),
          ...(0, modules_1.createWasmAminoConverters)()
        }) } = options;
        this.registry = registry;
        this.aminoTypes = aminoTypes;
        this.signer = signer;
        this.broadcastTimeoutMs = options.broadcastTimeoutMs;
        this.broadcastPollIntervalMs = options.broadcastPollIntervalMs;
        this.gasPrice = options.gasPrice;
      }
      async simulate(signerAddress, messages, memo) {
        const anyMsgs = messages.map((m3) => this.registry.encodeAsAny(m3));
        const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);
        if (!accountFromSigner) {
          throw new Error("Failed to retrieve account from signer");
        }
        const pubkey = (0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey);
        const { sequence } = await this.getSequence(signerAddress);
        const { gasInfo } = await this.forceGetQueryClient().tx.simulate(anyMsgs, memo, pubkey, sequence);
        (0, utils_1.assertDefined)(gasInfo);
        return math_1.Uint53.fromString(gasInfo.gasUsed.toString()).toNumber();
      }
      /** Uploads code and returns a receipt, including the code ID */
      async upload(senderAddress, wasmCode, fee, memo = "", instantiatePermission) {
        const compressed = await (0, compression_1.gzip)(wasmCode);
        const storeCodeMsg = {
          typeUrl: "/cosmwasm.wasm.v1.MsgStoreCode",
          value: tx_4.MsgStoreCode.fromPartial({
            sender: senderAddress,
            wasmByteCode: compressed,
            instantiatePermission
          })
        };
        const usedFee = fee == "auto" ? 1.1 : fee;
        const result = await this.signAndBroadcast(senderAddress, [storeCodeMsg], usedFee, memo);
        if ((0, stargate_1.isDeliverTxFailure)(result)) {
          throw new Error(createDeliverTxResponseErrorMessage(result));
        }
        const codeIdAttr = findAttribute(result.events, "store_code", "code_id");
        return {
          checksum: (0, encoding_1.toHex)((0, crypto_1.sha256)(wasmCode)),
          originalSize: wasmCode.length,
          compressedSize: compressed.length,
          codeId: Number.parseInt(codeIdAttr.value, 10),
          logs: stargate_1.logs.parseRawLog(result.rawLog),
          height: result.height,
          transactionHash: result.transactionHash,
          events: result.events,
          gasWanted: result.gasWanted,
          gasUsed: result.gasUsed
        };
      }
      async instantiate(senderAddress, codeId, msg, label, fee, options = {}) {
        const instantiateContractMsg = {
          typeUrl: "/cosmwasm.wasm.v1.MsgInstantiateContract",
          value: tx_4.MsgInstantiateContract.fromPartial({
            sender: senderAddress,
            codeId: BigInt(new math_1.Uint53(codeId).toString()),
            label,
            msg: (0, encoding_1.toUtf8)(JSON.stringify(msg)),
            funds: [...options.funds || []],
            admin: options.admin
          })
        };
        const result = await this.signAndBroadcast(senderAddress, [instantiateContractMsg], fee, options.memo);
        if ((0, stargate_1.isDeliverTxFailure)(result)) {
          throw new Error(createDeliverTxResponseErrorMessage(result));
        }
        const contractAddressAttr = findAttribute(result.events, "instantiate", "_contract_address");
        return {
          contractAddress: contractAddressAttr.value,
          logs: stargate_1.logs.parseRawLog(result.rawLog),
          height: result.height,
          transactionHash: result.transactionHash,
          events: result.events,
          gasWanted: result.gasWanted,
          gasUsed: result.gasUsed
        };
      }
      async instantiate2(senderAddress, codeId, salt, msg, label, fee, options = {}) {
        const instantiateContract2Msg = {
          typeUrl: "/cosmwasm.wasm.v1.MsgInstantiateContract2",
          value: tx_4.MsgInstantiateContract2.fromPartial({
            sender: senderAddress,
            codeId: BigInt(new math_1.Uint53(codeId).toString()),
            label,
            msg: (0, encoding_1.toUtf8)(JSON.stringify(msg)),
            funds: [...options.funds || []],
            admin: options.admin,
            salt,
            fixMsg: false
          })
        };
        const result = await this.signAndBroadcast(senderAddress, [instantiateContract2Msg], fee, options.memo);
        if ((0, stargate_1.isDeliverTxFailure)(result)) {
          throw new Error(createDeliverTxResponseErrorMessage(result));
        }
        const contractAddressAttr = findAttribute(result.events, "instantiate", "_contract_address");
        return {
          contractAddress: contractAddressAttr.value,
          logs: stargate_1.logs.parseRawLog(result.rawLog),
          height: result.height,
          transactionHash: result.transactionHash,
          events: result.events,
          gasWanted: result.gasWanted,
          gasUsed: result.gasUsed
        };
      }
      async updateAdmin(senderAddress, contractAddress, newAdmin, fee, memo = "") {
        const updateAdminMsg = {
          typeUrl: "/cosmwasm.wasm.v1.MsgUpdateAdmin",
          value: tx_4.MsgUpdateAdmin.fromPartial({
            sender: senderAddress,
            contract: contractAddress,
            newAdmin
          })
        };
        const result = await this.signAndBroadcast(senderAddress, [updateAdminMsg], fee, memo);
        if ((0, stargate_1.isDeliverTxFailure)(result)) {
          throw new Error(createDeliverTxResponseErrorMessage(result));
        }
        return {
          logs: stargate_1.logs.parseRawLog(result.rawLog),
          height: result.height,
          transactionHash: result.transactionHash,
          events: result.events,
          gasWanted: result.gasWanted,
          gasUsed: result.gasUsed
        };
      }
      async clearAdmin(senderAddress, contractAddress, fee, memo = "") {
        const clearAdminMsg = {
          typeUrl: "/cosmwasm.wasm.v1.MsgClearAdmin",
          value: tx_4.MsgClearAdmin.fromPartial({
            sender: senderAddress,
            contract: contractAddress
          })
        };
        const result = await this.signAndBroadcast(senderAddress, [clearAdminMsg], fee, memo);
        if ((0, stargate_1.isDeliverTxFailure)(result)) {
          throw new Error(createDeliverTxResponseErrorMessage(result));
        }
        return {
          logs: stargate_1.logs.parseRawLog(result.rawLog),
          height: result.height,
          transactionHash: result.transactionHash,
          events: result.events,
          gasWanted: result.gasWanted,
          gasUsed: result.gasUsed
        };
      }
      async migrate(senderAddress, contractAddress, codeId, migrateMsg, fee, memo = "") {
        const migrateContractMsg = {
          typeUrl: "/cosmwasm.wasm.v1.MsgMigrateContract",
          value: tx_4.MsgMigrateContract.fromPartial({
            sender: senderAddress,
            contract: contractAddress,
            codeId: BigInt(new math_1.Uint53(codeId).toString()),
            msg: (0, encoding_1.toUtf8)(JSON.stringify(migrateMsg))
          })
        };
        const result = await this.signAndBroadcast(senderAddress, [migrateContractMsg], fee, memo);
        if ((0, stargate_1.isDeliverTxFailure)(result)) {
          throw new Error(createDeliverTxResponseErrorMessage(result));
        }
        return {
          logs: stargate_1.logs.parseRawLog(result.rawLog),
          height: result.height,
          transactionHash: result.transactionHash,
          events: result.events,
          gasWanted: result.gasWanted,
          gasUsed: result.gasUsed
        };
      }
      async execute(senderAddress, contractAddress, msg, fee, memo = "", funds) {
        const instruction = {
          contractAddress,
          msg,
          funds
        };
        return this.executeMultiple(senderAddress, [instruction], fee, memo);
      }
      /**
       * Like `execute` but allows executing multiple messages in one transaction.
       */
      async executeMultiple(senderAddress, instructions, fee, memo = "") {
        const msgs = instructions.map((i3) => ({
          typeUrl: "/cosmwasm.wasm.v1.MsgExecuteContract",
          value: tx_4.MsgExecuteContract.fromPartial({
            sender: senderAddress,
            contract: i3.contractAddress,
            msg: (0, encoding_1.toUtf8)(JSON.stringify(i3.msg)),
            funds: [...i3.funds || []]
          })
        }));
        const result = await this.signAndBroadcast(senderAddress, msgs, fee, memo);
        if ((0, stargate_1.isDeliverTxFailure)(result)) {
          throw new Error(createDeliverTxResponseErrorMessage(result));
        }
        return {
          logs: stargate_1.logs.parseRawLog(result.rawLog),
          height: result.height,
          transactionHash: result.transactionHash,
          events: result.events,
          gasWanted: result.gasWanted,
          gasUsed: result.gasUsed
        };
      }
      async sendTokens(senderAddress, recipientAddress, amount, fee, memo = "") {
        const sendMsg = {
          typeUrl: "/cosmos.bank.v1beta1.MsgSend",
          value: {
            fromAddress: senderAddress,
            toAddress: recipientAddress,
            amount: [...amount]
          }
        };
        return this.signAndBroadcast(senderAddress, [sendMsg], fee, memo);
      }
      async delegateTokens(delegatorAddress, validatorAddress, amount, fee, memo = "") {
        const delegateMsg = {
          typeUrl: "/cosmos.staking.v1beta1.MsgDelegate",
          value: tx_2.MsgDelegate.fromPartial({ delegatorAddress, validatorAddress, amount })
        };
        return this.signAndBroadcast(delegatorAddress, [delegateMsg], fee, memo);
      }
      async undelegateTokens(delegatorAddress, validatorAddress, amount, fee, memo = "") {
        const undelegateMsg = {
          typeUrl: "/cosmos.staking.v1beta1.MsgUndelegate",
          value: tx_2.MsgUndelegate.fromPartial({ delegatorAddress, validatorAddress, amount })
        };
        return this.signAndBroadcast(delegatorAddress, [undelegateMsg], fee, memo);
      }
      async withdrawRewards(delegatorAddress, validatorAddress, fee, memo = "") {
        const withdrawDelegatorRewardMsg = {
          typeUrl: "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
          value: tx_1.MsgWithdrawDelegatorReward.fromPartial({ delegatorAddress, validatorAddress })
        };
        return this.signAndBroadcast(delegatorAddress, [withdrawDelegatorRewardMsg], fee, memo);
      }
      /**
       * Creates a transaction with the given messages, fee, memo and timeout height. Then signs and broadcasts the transaction.
       *
       * @param signerAddress The address that will sign transactions using this instance. The signer must be able to sign with this address.
       * @param messages
       * @param fee
       * @param memo
       * @param timeoutHeight (optional) timeout height to prevent the tx from being committed past a certain height
       */
      async signAndBroadcast(signerAddress, messages, fee, memo = "", timeoutHeight) {
        let usedFee;
        if (fee == "auto" || typeof fee === "number") {
          (0, utils_1.assertDefined)(this.gasPrice, "Gas price must be set in the client options when auto gas is used.");
          const gasEstimation = await this.simulate(signerAddress, messages, memo);
          const multiplier = typeof fee === "number" ? fee : this.defaultGasMultiplier;
          usedFee = (0, stargate_1.calculateFee)(Math.round(gasEstimation * multiplier), this.gasPrice);
        } else {
          usedFee = fee;
        }
        const txRaw = await this.sign(signerAddress, messages, usedFee, memo, void 0, timeoutHeight);
        const txBytes = tx_3.TxRaw.encode(txRaw).finish();
        return this.broadcastTx(txBytes, this.broadcastTimeoutMs, this.broadcastPollIntervalMs);
      }
      /**
       * Creates a transaction with the given messages, fee, memo and timeout height. Then signs and broadcasts the transaction.
       *
       * This method is useful if you want to send a transaction in broadcast,
       * without waiting for it to be placed inside a block, because for example
       * I would like to receive the hash to later track the transaction with another tool.
       *
       * @param signerAddress The address that will sign transactions using this instance. The signer must be able to sign with this address.
       * @param messages
       * @param fee
       * @param memo
       * @param timeoutHeight (optional) timeout height to prevent the tx from being committed past a certain height
       *
       * @returns Returns the hash of the transaction
       */
      async signAndBroadcastSync(signerAddress, messages, fee, memo = "", timeoutHeight) {
        let usedFee;
        if (fee == "auto" || typeof fee === "number") {
          (0, utils_1.assertDefined)(this.gasPrice, "Gas price must be set in the client options when auto gas is used.");
          const gasEstimation = await this.simulate(signerAddress, messages, memo);
          const multiplier = typeof fee === "number" ? fee : this.defaultGasMultiplier;
          usedFee = (0, stargate_1.calculateFee)(Math.round(gasEstimation * multiplier), this.gasPrice);
        } else {
          usedFee = fee;
        }
        const txRaw = await this.sign(signerAddress, messages, usedFee, memo, void 0, timeoutHeight);
        const txBytes = tx_3.TxRaw.encode(txRaw).finish();
        return this.broadcastTxSync(txBytes);
      }
      async sign(signerAddress, messages, fee, memo, explicitSignerData, timeoutHeight) {
        let signerData;
        if (explicitSignerData) {
          signerData = explicitSignerData;
        } else {
          const { accountNumber, sequence } = await this.getSequence(signerAddress);
          const chainId = await this.getChainId();
          signerData = {
            accountNumber,
            sequence,
            chainId
          };
        }
        return (0, proto_signing_1.isOfflineDirectSigner)(this.signer) ? this.signDirect(signerAddress, messages, fee, memo, signerData, timeoutHeight) : this.signAmino(signerAddress, messages, fee, memo, signerData, timeoutHeight);
      }
      async signAmino(signerAddress, messages, fee, memo, { accountNumber, sequence, chainId }, timeoutHeight) {
        (0, utils_1.assert)(!(0, proto_signing_1.isOfflineDirectSigner)(this.signer));
        const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);
        if (!accountFromSigner) {
          throw new Error("Failed to retrieve account from signer");
        }
        const pubkey = (0, proto_signing_1.encodePubkey)((0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey));
        const signMode = signing_1.SignMode.SIGN_MODE_LEGACY_AMINO_JSON;
        const msgs = messages.map((msg) => this.aminoTypes.toAmino(msg));
        const signDoc = (0, amino_1.makeSignDoc)(msgs, fee, chainId, memo, accountNumber, sequence, timeoutHeight);
        const { signature, signed } = await this.signer.signAmino(signerAddress, signDoc);
        const signedTxBody = {
          typeUrl: "/cosmos.tx.v1beta1.TxBody",
          value: {
            messages: signed.msgs.map((msg) => this.aminoTypes.fromAmino(msg)),
            memo: signed.memo,
            timeoutHeight
          }
        };
        const signedTxBodyBytes = this.registry.encode(signedTxBody);
        const signedGasLimit = math_1.Int53.fromString(signed.fee.gas).toNumber();
        const signedSequence = math_1.Int53.fromString(signed.sequence).toNumber();
        const signedAuthInfoBytes = (0, proto_signing_1.makeAuthInfoBytes)([{ pubkey, sequence: signedSequence }], signed.fee.amount, signedGasLimit, signed.fee.granter, signed.fee.payer, signMode);
        return tx_3.TxRaw.fromPartial({
          bodyBytes: signedTxBodyBytes,
          authInfoBytes: signedAuthInfoBytes,
          signatures: [(0, encoding_1.fromBase64)(signature.signature)]
        });
      }
      async signDirect(signerAddress, messages, fee, memo, { accountNumber, sequence, chainId }, timeoutHeight) {
        (0, utils_1.assert)((0, proto_signing_1.isOfflineDirectSigner)(this.signer));
        const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);
        if (!accountFromSigner) {
          throw new Error("Failed to retrieve account from signer");
        }
        const pubkey = (0, proto_signing_1.encodePubkey)((0, amino_1.encodeSecp256k1Pubkey)(accountFromSigner.pubkey));
        const txBody = {
          typeUrl: "/cosmos.tx.v1beta1.TxBody",
          value: {
            messages,
            memo,
            timeoutHeight
          }
        };
        const txBodyBytes = this.registry.encode(txBody);
        const gasLimit = math_1.Int53.fromString(fee.gas).toNumber();
        const authInfoBytes = (0, proto_signing_1.makeAuthInfoBytes)([{ pubkey, sequence }], fee.amount, gasLimit, fee.granter, fee.payer);
        const signDoc = (0, proto_signing_1.makeSignDoc)(txBodyBytes, authInfoBytes, chainId, accountNumber);
        const { signature, signed } = await this.signer.signDirect(signerAddress, signDoc);
        return tx_3.TxRaw.fromPartial({
          bodyBytes: signed.bodyBytes,
          authInfoBytes: signed.authInfoBytes,
          signatures: [(0, encoding_1.fromBase64)(signature.signature)]
        });
      }
    };
    exports.SigningCosmWasmClient = SigningCosmWasmClient;
  }
});

// node_modules/.pnpm/@cosmjs+cosmwasm-stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/cosmwasm-stargate/build/index.js
var require_build12 = __commonJS({
  "node_modules/.pnpm/@cosmjs+cosmwasm-stargate@0.37.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/@cosmjs/cosmwasm-stargate/build/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SigningCosmWasmClient = exports.wasmTypes = exports.setupWasmExtension = exports.isMsgUpdateAdminEncodeObject = exports.isMsgStoreCodeEncodeObject = exports.isMsgMigrateEncodeObject = exports.isMsgInstantiateContractEncodeObject = exports.isMsgInstantiateContract2EncodeObject = exports.isMsgExecuteEncodeObject = exports.isMsgClearAdminEncodeObject = exports.createWasmAminoConverters = exports.instantiate2Address = exports._instantiate2AddressIntermediate = exports.toBinary = exports.fromBinary = exports.CosmWasmClient = void 0;
    var cosmwasmclient_1 = require_cosmwasmclient();
    Object.defineProperty(exports, "CosmWasmClient", { enumerable: true, get: function() {
      return cosmwasmclient_1.CosmWasmClient;
    } });
    var encoding_1 = require_encoding2();
    Object.defineProperty(exports, "fromBinary", { enumerable: true, get: function() {
      return encoding_1.fromBinary;
    } });
    Object.defineProperty(exports, "toBinary", { enumerable: true, get: function() {
      return encoding_1.toBinary;
    } });
    var instantiate2_1 = require_instantiate2();
    Object.defineProperty(exports, "_instantiate2AddressIntermediate", { enumerable: true, get: function() {
      return instantiate2_1._instantiate2AddressIntermediate;
    } });
    Object.defineProperty(exports, "instantiate2Address", { enumerable: true, get: function() {
      return instantiate2_1.instantiate2Address;
    } });
    var modules_1 = require_modules2();
    Object.defineProperty(exports, "createWasmAminoConverters", { enumerable: true, get: function() {
      return modules_1.createWasmAminoConverters;
    } });
    Object.defineProperty(exports, "isMsgClearAdminEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgClearAdminEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgExecuteEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgExecuteEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgInstantiateContract2EncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgInstantiateContract2EncodeObject;
    } });
    Object.defineProperty(exports, "isMsgInstantiateContractEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgInstantiateContractEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgMigrateEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgMigrateEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgStoreCodeEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgStoreCodeEncodeObject;
    } });
    Object.defineProperty(exports, "isMsgUpdateAdminEncodeObject", { enumerable: true, get: function() {
      return modules_1.isMsgUpdateAdminEncodeObject;
    } });
    Object.defineProperty(exports, "setupWasmExtension", { enumerable: true, get: function() {
      return modules_1.setupWasmExtension;
    } });
    Object.defineProperty(exports, "wasmTypes", { enumerable: true, get: function() {
      return modules_1.wasmTypes;
    } });
    var signingcosmwasmclient_1 = require_signingcosmwasmclient();
    Object.defineProperty(exports, "SigningCosmWasmClient", { enumerable: true, get: function() {
      return signingcosmwasmclient_1.SigningCosmWasmClient;
    } });
  }
});

// node_modules/.pnpm/@getpara+cosmos-wallet-connectors@2.0.0-alpha.73_@cosmjs+amino@0.37.0_@cosmjs+encoding@_105e61b7335e19f95087e11f175d09d3/node_modules/@getpara/cosmos-wallet-connectors/dist/chunk-IV3L3JVM.js
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b5) => {
  for (var prop in b5 || (b5 = {}))
    if (__hasOwnProp.call(b5, prop))
      __defNormalProp(a2, prop, b5[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b5)) {
      if (__propIsEnum.call(b5, prop))
        __defNormalProp(a2, prop, b5[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b5) => __defProps(a2, __getOwnPropDescs(b5));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x3) => x3.done ? resolve(x3.value) : Promise.resolve(x3.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/.pnpm/@getpara+cosmos-wallet-connectors@2.0.0-alpha.73_@cosmjs+amino@0.37.0_@cosmjs+encoding@_105e61b7335e19f95087e11f175d09d3/node_modules/@getpara/cosmos-wallet-connectors/dist/providers/CosmosExternalWalletContext.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react4 = __toESM(require_react(), 1);

// node_modules/.pnpm/zustand@5.0.4_@types+react@19.2.7_react@19.2.1_use-sync-external-store@1.4.0_react@19.2.1_/node_modules/zustand/esm/vanilla.mjs
var createStoreImpl = (createState) => {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const getInitialState = () => initialState;
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const api = { setState, getState, getInitialState, subscribe };
  const initialState = state = createState(setState, getState, api);
  return api;
};
var createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;

// node_modules/.pnpm/zustand@5.0.4_@types+react@19.2.7_react@19.2.1_use-sync-external-store@1.4.0_react@19.2.1_/node_modules/zustand/esm/react.mjs
var import_react = __toESM(require_react(), 1);
var identity = (arg) => arg;
function useStore(api, selector = identity) {
  const slice = import_react.default.useSyncExternalStore(
    api.subscribe,
    () => selector(api.getState()),
    () => selector(api.getInitialState())
  );
  import_react.default.useDebugValue(slice);
  return slice;
}
var createImpl = (createState) => {
  const api = createStore(createState);
  const useBoundStore = (selector) => useStore(api, selector);
  Object.assign(useBoundStore, api);
  return useBoundStore;
};
var create2 = (createState) => createState ? createImpl(createState) : createImpl;

// node_modules/.pnpm/zustand@5.0.4_@types+react@19.2.7_react@19.2.1_use-sync-external-store@1.4.0_react@19.2.1_/node_modules/zustand/esm/middleware.mjs
var subscribeWithSelectorImpl = (fn3) => (set, get, api) => {
  const origSubscribe = api.subscribe;
  api.subscribe = (selector, optListener, options) => {
    let listener = selector;
    if (optListener) {
      const equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;
      let currentSlice = selector(api.getState());
      listener = (state) => {
        const nextSlice = selector(state);
        if (!equalityFn(currentSlice, nextSlice)) {
          const previousSlice = currentSlice;
          optListener(currentSlice = nextSlice, previousSlice);
        }
      };
      if (options == null ? void 0 : options.fireImmediately) {
        optListener(currentSlice, currentSlice);
      }
    }
    return origSubscribe(listener);
  };
  const initialState = fn3(set, get, api);
  return initialState;
};
var subscribeWithSelector = subscribeWithSelectorImpl;
function createJSONStorage(getStorage, options) {
  let storage;
  try {
    storage = getStorage();
  } catch (e) {
    return;
  }
  const persistStorage = {
    getItem: (name2) => {
      var _a2;
      const parse2 = (str22) => {
        if (str22 === null) {
          return null;
        }
        return JSON.parse(str22, options == null ? void 0 : options.reviver);
      };
      const str2 = (_a2 = storage.getItem(name2)) != null ? _a2 : null;
      if (str2 instanceof Promise) {
        return str2.then(parse2);
      }
      return parse2(str2);
    },
    setItem: (name2, newValue) => storage.setItem(
      name2,
      JSON.stringify(newValue, options == null ? void 0 : options.replacer)
    ),
    removeItem: (name2) => storage.removeItem(name2)
  };
  return persistStorage;
}
var toThenable = (fn3) => (input) => {
  try {
    const result = fn3(input);
    if (result instanceof Promise) {
      return result;
    }
    return {
      then(onFulfilled) {
        return toThenable(onFulfilled)(result);
      },
      catch(_onRejected) {
        return this;
      }
    };
  } catch (e) {
    return {
      then(_onFulfilled) {
        return this;
      },
      catch(onRejected) {
        return toThenable(onRejected)(e);
      }
    };
  }
};
var persistImpl = (config, baseOptions) => (set, get, api) => {
  let options = {
    storage: createJSONStorage(() => localStorage),
    partialize: (state) => state,
    version: 0,
    merge: (persistedState, currentState) => ({
      ...currentState,
      ...persistedState
    }),
    ...baseOptions
  };
  let hasHydrated = false;
  const hydrationListeners = /* @__PURE__ */ new Set();
  const finishHydrationListeners = /* @__PURE__ */ new Set();
  let storage = options.storage;
  if (!storage) {
    return config(
      (...args) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`
        );
        set(...args);
      },
      get,
      api
    );
  }
  const setItem = () => {
    const state = options.partialize({ ...get() });
    return storage.setItem(options.name, {
      state,
      version: options.version
    });
  };
  const savedSetState = api.setState;
  api.setState = (state, replace) => {
    savedSetState(state, replace);
    void setItem();
  };
  const configResult = config(
    (...args) => {
      set(...args);
      void setItem();
    },
    get,
    api
  );
  api.getInitialState = () => configResult;
  let stateFromStorage;
  const hydrate = () => {
    var _a2, _b;
    if (!storage) return;
    hasHydrated = false;
    hydrationListeners.forEach((cb) => {
      var _a22;
      return cb((_a22 = get()) != null ? _a22 : configResult);
    });
    const postRehydrationCallback = ((_b = options.onRehydrateStorage) == null ? void 0 : _b.call(options, (_a2 = get()) != null ? _a2 : configResult)) || void 0;
    return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {
      if (deserializedStorageValue) {
        if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
          if (options.migrate) {
            const migration = options.migrate(
              deserializedStorageValue.state,
              deserializedStorageValue.version
            );
            if (migration instanceof Promise) {
              return migration.then((result) => [true, result]);
            }
            return [true, migration];
          }
          console.error(
            `State loaded from storage couldn't be migrated since no migrate function was provided`
          );
        } else {
          return [false, deserializedStorageValue.state];
        }
      }
      return [false, void 0];
    }).then((migrationResult) => {
      var _a22;
      const [migrated, migratedState] = migrationResult;
      stateFromStorage = options.merge(
        migratedState,
        (_a22 = get()) != null ? _a22 : configResult
      );
      set(stateFromStorage, true);
      if (migrated) {
        return setItem();
      }
    }).then(() => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
      stateFromStorage = get();
      hasHydrated = true;
      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));
    }).catch((e) => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);
    });
  };
  api.persist = {
    setOptions: (newOptions) => {
      options = {
        ...options,
        ...newOptions
      };
      if (newOptions.storage) {
        storage = newOptions.storage;
      }
    },
    clearStorage: () => {
      storage == null ? void 0 : storage.removeItem(options.name);
    },
    getOptions: () => options,
    rehydrate: () => hydrate(),
    hasHydrated: () => hasHydrated,
    onHydrate: (cb) => {
      hydrationListeners.add(cb);
      return () => {
        hydrationListeners.delete(cb);
      };
    },
    onFinishHydration: (cb) => {
      finishHydrationListeners.add(cb);
      return () => {
        finishHydrationListeners.delete(cb);
      };
    }
  };
  if (!options.skipHydration) {
    hydrate();
  }
  return stateFromStorage || configResult;
};
var persist = persistImpl;

// node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i3 = 0; i3 < 256; ++i3) {
  byteToHex.push((i3 + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}

// node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v9;
  const arr = new Uint8Array(16);
  arr[0] = (v9 = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v9 >>> 16 & 255;
  arr[2] = v9 >>> 8 & 255;
  arr[3] = v9 & 255;
  arr[4] = (v9 = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v9 & 255;
  arr[6] = (v9 = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v9 & 255;
  arr[8] = (v9 = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v9 & 255;
  arr[10] = (v9 = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v9 / 4294967296 & 255;
  arr[12] = v9 >>> 24 & 255;
  arr[13] = v9 >>> 16 & 255;
  arr[14] = v9 >>> 8 & 255;
  arr[15] = v9 & 255;
  return arr;
}
var parse_default = parse;

// node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str2) {
  str2 = unescape(encodeURIComponent(str2));
  const bytes2 = [];
  for (let i3 = 0; i3 < str2.length; ++i3) {
    bytes2.push(str2.charCodeAt(i3));
  }
  return bytes2;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(name2, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes2 = new Uint8Array(16 + value.length);
    bytes2.set(namespace);
    bytes2.set(value, namespace.length);
    bytes2 = hashfunc(bytes2);
    bytes2[6] = bytes2[6] & 15 | version;
    bytes2[8] = bytes2[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i3 = 0; i3 < 16; ++i3) {
        buf[offset + i3] = bytes2[i3];
      }
      return buf;
    }
    return unsafeStringify(bytes2);
  }
  try {
    generateUUID.name = name2;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL2;
  return generateUUID;
}

// node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes2) {
  if (typeof bytes2 === "string") {
    const msg = unescape(encodeURIComponent(bytes2));
    bytes2 = new Uint8Array(msg.length);
    for (let i3 = 0; i3 < msg.length; ++i3) {
      bytes2[i3] = msg.charCodeAt(i3);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes2), bytes2.length * 8));
}
function md5ToHexEncodedArray(input) {
  const output = [];
  const length32 = input.length * 32;
  const hexTab = "0123456789abcdef";
  for (let i3 = 0; i3 < length32; i3 += 8) {
    const x3 = input[i3 >> 5] >>> i3 % 32 & 255;
    const hex2 = parseInt(hexTab.charAt(x3 >>> 4 & 15) + hexTab.charAt(x3 & 15), 16);
    output.push(hex2);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x3, len) {
  x3[len >> 5] |= 128 << len % 32;
  x3[getOutputLength(len) - 1] = len;
  let a2 = 1732584193;
  let b5 = -271733879;
  let c3 = -1732584194;
  let d3 = 271733878;
  for (let i3 = 0; i3 < x3.length; i3 += 16) {
    const olda = a2;
    const oldb = b5;
    const oldc = c3;
    const oldd = d3;
    a2 = md5ff(a2, b5, c3, d3, x3[i3], 7, -680876936);
    d3 = md5ff(d3, a2, b5, c3, x3[i3 + 1], 12, -389564586);
    c3 = md5ff(c3, d3, a2, b5, x3[i3 + 2], 17, 606105819);
    b5 = md5ff(b5, c3, d3, a2, x3[i3 + 3], 22, -1044525330);
    a2 = md5ff(a2, b5, c3, d3, x3[i3 + 4], 7, -176418897);
    d3 = md5ff(d3, a2, b5, c3, x3[i3 + 5], 12, 1200080426);
    c3 = md5ff(c3, d3, a2, b5, x3[i3 + 6], 17, -1473231341);
    b5 = md5ff(b5, c3, d3, a2, x3[i3 + 7], 22, -45705983);
    a2 = md5ff(a2, b5, c3, d3, x3[i3 + 8], 7, 1770035416);
    d3 = md5ff(d3, a2, b5, c3, x3[i3 + 9], 12, -1958414417);
    c3 = md5ff(c3, d3, a2, b5, x3[i3 + 10], 17, -42063);
    b5 = md5ff(b5, c3, d3, a2, x3[i3 + 11], 22, -1990404162);
    a2 = md5ff(a2, b5, c3, d3, x3[i3 + 12], 7, 1804603682);
    d3 = md5ff(d3, a2, b5, c3, x3[i3 + 13], 12, -40341101);
    c3 = md5ff(c3, d3, a2, b5, x3[i3 + 14], 17, -1502002290);
    b5 = md5ff(b5, c3, d3, a2, x3[i3 + 15], 22, 1236535329);
    a2 = md5gg(a2, b5, c3, d3, x3[i3 + 1], 5, -165796510);
    d3 = md5gg(d3, a2, b5, c3, x3[i3 + 6], 9, -1069501632);
    c3 = md5gg(c3, d3, a2, b5, x3[i3 + 11], 14, 643717713);
    b5 = md5gg(b5, c3, d3, a2, x3[i3], 20, -373897302);
    a2 = md5gg(a2, b5, c3, d3, x3[i3 + 5], 5, -701558691);
    d3 = md5gg(d3, a2, b5, c3, x3[i3 + 10], 9, 38016083);
    c3 = md5gg(c3, d3, a2, b5, x3[i3 + 15], 14, -660478335);
    b5 = md5gg(b5, c3, d3, a2, x3[i3 + 4], 20, -405537848);
    a2 = md5gg(a2, b5, c3, d3, x3[i3 + 9], 5, 568446438);
    d3 = md5gg(d3, a2, b5, c3, x3[i3 + 14], 9, -1019803690);
    c3 = md5gg(c3, d3, a2, b5, x3[i3 + 3], 14, -187363961);
    b5 = md5gg(b5, c3, d3, a2, x3[i3 + 8], 20, 1163531501);
    a2 = md5gg(a2, b5, c3, d3, x3[i3 + 13], 5, -1444681467);
    d3 = md5gg(d3, a2, b5, c3, x3[i3 + 2], 9, -51403784);
    c3 = md5gg(c3, d3, a2, b5, x3[i3 + 7], 14, 1735328473);
    b5 = md5gg(b5, c3, d3, a2, x3[i3 + 12], 20, -1926607734);
    a2 = md5hh(a2, b5, c3, d3, x3[i3 + 5], 4, -378558);
    d3 = md5hh(d3, a2, b5, c3, x3[i3 + 8], 11, -2022574463);
    c3 = md5hh(c3, d3, a2, b5, x3[i3 + 11], 16, 1839030562);
    b5 = md5hh(b5, c3, d3, a2, x3[i3 + 14], 23, -35309556);
    a2 = md5hh(a2, b5, c3, d3, x3[i3 + 1], 4, -1530992060);
    d3 = md5hh(d3, a2, b5, c3, x3[i3 + 4], 11, 1272893353);
    c3 = md5hh(c3, d3, a2, b5, x3[i3 + 7], 16, -155497632);
    b5 = md5hh(b5, c3, d3, a2, x3[i3 + 10], 23, -1094730640);
    a2 = md5hh(a2, b5, c3, d3, x3[i3 + 13], 4, 681279174);
    d3 = md5hh(d3, a2, b5, c3, x3[i3], 11, -358537222);
    c3 = md5hh(c3, d3, a2, b5, x3[i3 + 3], 16, -722521979);
    b5 = md5hh(b5, c3, d3, a2, x3[i3 + 6], 23, 76029189);
    a2 = md5hh(a2, b5, c3, d3, x3[i3 + 9], 4, -640364487);
    d3 = md5hh(d3, a2, b5, c3, x3[i3 + 12], 11, -421815835);
    c3 = md5hh(c3, d3, a2, b5, x3[i3 + 15], 16, 530742520);
    b5 = md5hh(b5, c3, d3, a2, x3[i3 + 2], 23, -995338651);
    a2 = md5ii(a2, b5, c3, d3, x3[i3], 6, -198630844);
    d3 = md5ii(d3, a2, b5, c3, x3[i3 + 7], 10, 1126891415);
    c3 = md5ii(c3, d3, a2, b5, x3[i3 + 14], 15, -1416354905);
    b5 = md5ii(b5, c3, d3, a2, x3[i3 + 5], 21, -57434055);
    a2 = md5ii(a2, b5, c3, d3, x3[i3 + 12], 6, 1700485571);
    d3 = md5ii(d3, a2, b5, c3, x3[i3 + 3], 10, -1894986606);
    c3 = md5ii(c3, d3, a2, b5, x3[i3 + 10], 15, -1051523);
    b5 = md5ii(b5, c3, d3, a2, x3[i3 + 1], 21, -2054922799);
    a2 = md5ii(a2, b5, c3, d3, x3[i3 + 8], 6, 1873313359);
    d3 = md5ii(d3, a2, b5, c3, x3[i3 + 15], 10, -30611744);
    c3 = md5ii(c3, d3, a2, b5, x3[i3 + 6], 15, -1560198380);
    b5 = md5ii(b5, c3, d3, a2, x3[i3 + 13], 21, 1309151649);
    a2 = md5ii(a2, b5, c3, d3, x3[i3 + 4], 6, -145523070);
    d3 = md5ii(d3, a2, b5, c3, x3[i3 + 11], 10, -1120210379);
    c3 = md5ii(c3, d3, a2, b5, x3[i3 + 2], 15, 718787259);
    b5 = md5ii(b5, c3, d3, a2, x3[i3 + 9], 21, -343485551);
    a2 = safeAdd(a2, olda);
    b5 = safeAdd(b5, oldb);
    c3 = safeAdd(c3, oldc);
    d3 = safeAdd(d3, oldd);
  }
  return [a2, b5, c3, d3];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  const length8 = input.length * 8;
  const output = new Uint32Array(getOutputLength(length8));
  for (let i3 = 0; i3 < length8; i3 += 8) {
    output[i3 >> 5] |= (input[i3 / 8] & 255) << i3 % 32;
  }
  return output;
}
function safeAdd(x3, y4) {
  const lsw = (x3 & 65535) + (y4 & 65535);
  const msw = (x3 >> 16) + (y4 >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q2, a2, b5, x3, s2, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a2, q2), safeAdd(x3, t)), s2), b5);
}
function md5ff(a2, b5, c3, d3, x3, s2, t) {
  return md5cmn(b5 & c3 | ~b5 & d3, a2, b5, x3, s2, t);
}
function md5gg(a2, b5, c3, d3, x3, s2, t) {
  return md5cmn(b5 & d3 | c3 & ~d3, a2, b5, x3, s2, t);
}
function md5hh(a2, b5, c3, d3, x3, s2, t) {
  return md5cmn(b5 ^ c3 ^ d3, a2, b5, x3, s2, t);
}
function md5ii(a2, b5, c3, d3, x3, s2, t) {
  return md5cmn(c3 ^ (b5 | ~d3), a2, b5, x3, s2, t);
}
var md5_default = md5;

// node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/v3.js
var v3 = v35("v3", 48, md5_default);

// node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i3 = 0; i3 < 16; ++i3) {
      buf[offset + i3] = rnds[i3];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/sha1.js
function f2(s2, x3, y4, z4) {
  switch (s2) {
    case 0:
      return x3 & y4 ^ ~x3 & z4;
    case 1:
      return x3 ^ y4 ^ z4;
    case 2:
      return x3 & y4 ^ x3 & z4 ^ y4 & z4;
    case 3:
      return x3 ^ y4 ^ z4;
  }
}
function ROTL(x3, n2) {
  return x3 << n2 | x3 >>> 32 - n2;
}
function sha1(bytes2) {
  const K5 = [1518500249, 1859775393, 2400959708, 3395469782];
  const H3 = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes2 === "string") {
    const msg = unescape(encodeURIComponent(bytes2));
    bytes2 = [];
    for (let i3 = 0; i3 < msg.length; ++i3) {
      bytes2.push(msg.charCodeAt(i3));
    }
  } else if (!Array.isArray(bytes2)) {
    bytes2 = Array.prototype.slice.call(bytes2);
  }
  bytes2.push(128);
  const l3 = bytes2.length / 4 + 2;
  const N2 = Math.ceil(l3 / 16);
  const M5 = new Array(N2);
  for (let i3 = 0; i3 < N2; ++i3) {
    const arr = new Uint32Array(16);
    for (let j3 = 0; j3 < 16; ++j3) {
      arr[j3] = bytes2[i3 * 64 + j3 * 4] << 24 | bytes2[i3 * 64 + j3 * 4 + 1] << 16 | bytes2[i3 * 64 + j3 * 4 + 2] << 8 | bytes2[i3 * 64 + j3 * 4 + 3];
    }
    M5[i3] = arr;
  }
  M5[N2 - 1][14] = (bytes2.length - 1) * 8 / Math.pow(2, 32);
  M5[N2 - 1][14] = Math.floor(M5[N2 - 1][14]);
  M5[N2 - 1][15] = (bytes2.length - 1) * 8 & 4294967295;
  for (let i3 = 0; i3 < N2; ++i3) {
    const W3 = new Uint32Array(80);
    for (let t = 0; t < 16; ++t) {
      W3[t] = M5[i3][t];
    }
    for (let t = 16; t < 80; ++t) {
      W3[t] = ROTL(W3[t - 3] ^ W3[t - 8] ^ W3[t - 14] ^ W3[t - 16], 1);
    }
    let a2 = H3[0];
    let b5 = H3[1];
    let c3 = H3[2];
    let d3 = H3[3];
    let e = H3[4];
    for (let t = 0; t < 80; ++t) {
      const s2 = Math.floor(t / 20);
      const T4 = ROTL(a2, 5) + f2(s2, b5, c3, d3) + e + K5[s2] + W3[t] >>> 0;
      e = d3;
      d3 = c3;
      c3 = ROTL(b5, 30) >>> 0;
      b5 = a2;
      a2 = T4;
    }
    H3[0] = H3[0] + a2 >>> 0;
    H3[1] = H3[1] + b5 >>> 0;
    H3[2] = H3[2] + c3 >>> 0;
    H3[3] = H3[3] + d3 >>> 0;
    H3[4] = H3[4] + e >>> 0;
  }
  return [H3[0] >> 24 & 255, H3[0] >> 16 & 255, H3[0] >> 8 & 255, H3[0] & 255, H3[1] >> 24 & 255, H3[1] >> 16 & 255, H3[1] >> 8 & 255, H3[1] & 255, H3[2] >> 24 & 255, H3[2] >> 16 & 255, H3[2] >> 8 & 255, H3[2] & 255, H3[3] >> 24 & 255, H3[3] >> 16 & 255, H3[3] >> 8 & 255, H3[3] & 255, H3[4] >> 24 & 255, H3[4] >> 16 & 255, H3[4] >> 8 & 255, H3[4] & 255];
}
var sha1_default = sha1;

// node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/v5.js
var v5 = v35("v5", 80, sha1_default);

// node_modules/.pnpm/@dao-dao+cosmiframe@1.0.0_@cosmjs+amino@0.37.0_@cosmjs+proto-signing@0.37.0/node_modules/@dao-dao/cosmiframe/dist/index.mjs
var C2 = Object.defineProperty;
var j = (n2, t, e) => t in n2 ? C2(n2, t, { enumerable: true, configurable: true, writable: true, value: e }) : n2[t] = e;
var s = (n2, t) => C2(n2, "name", { value: t, configurable: true });
var A2 = (n2, t, e) => (j(n2, typeof t != "symbol" ? t + "" : t, e), e);
var b = (n2, t, e) => {
  if (!t.has(n2)) throw TypeError("Cannot " + e);
};
var o2 = (n2, t, e) => (b(n2, t, "read from private field"), e ? e.call(n2) : t.get(n2));
var x = (n2, t, e) => {
  if (t.has(n2)) throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(n2) : t.set(n2, e);
};
var O = (n2, t, e, r2) => (b(n2, t, "write to private field"), r2 ? r2.call(n2, e) : t.set(n2, e), e);
var G = class G2 extends Error {
  constructor(t) {
    super(t), this.name = "CosmiframeTimeoutError";
  }
};
s(G, "CosmiframeTimeoutError");
var v = G;
var z = "UNSAFE_ALLOW_ANY_ORIGIN";
var p = s((n2, t, e) => new Promise((r2, c3) => {
  let h4 = null, I3 = v4_default(), l3 = s(({ origin: f6, source: _2, data: E5 }) => {
    !U(t, f6) || _2 !== window.parent || E5.id !== I3 || (window.removeEventListener("message", l3), h4 !== null && clearTimeout(h4), E5.type === "success" ? r2({ result: E5.response, origin: f6 }) : c3(new Error(E5.error)));
  }, "listener");
  window.addEventListener("message", l3);
  try {
    let f6 = { ...n2, id: I3 };
    window.parent.postMessage(f6, "*");
  } catch (f6) {
    window.removeEventListener("message", l3), c3(f6);
  }
  e && (h4 = setTimeout(() => {
    window.removeEventListener("message", l3), c3(new v(`Timed out after ${e}ms waiting for parent to respond.`));
  }, e));
}), "callParentMethod");
var K = s((n2) => {
  if (!n2 || n2.type === "error") return { type: "error", error: n2 && n2.type === "error" && n2.error || "Handled by outer wallet." };
  if (n2.type === "success") return { type: "success", response: n2.value };
}, "processOverrideHandler");
var B = s(() => typeof window < "u" && window.self !== window.parent, "isInIframe");
var U = s((n2, t) => n2.some((e) => e === "*" || typeof e == "string" && t === e || e instanceof RegExp && e.test(t)), "isOriginAllowed");
var M;
var $ = class $2 {
  constructor(t, e) {
    A2(this, "chainId");
    x(this, M, void 0);
    this.chainId = t, O(this, M, e);
  }
  async getAccounts() {
    return (await p({ method: "getAccounts", params: [], chainId: this.chainId, signerType: "direct" }, o2(this, M))).result;
  }
  async signDirect(t, e) {
    return (await p({ method: "signDirect", params: [t, e], chainId: this.chainId, signerType: "direct" }, o2(this, M))).result;
  }
};
M = /* @__PURE__ */ new WeakMap(), s($, "CosmiframeDirectSigner");
var P = $;
var T;
var R = class R2 {
  constructor(t, e) {
    A2(this, "chainId");
    x(this, T, void 0);
    this.chainId = t, O(this, T, e);
  }
  async getAccounts() {
    return (await p({ method: "getAccounts", params: [], chainId: this.chainId, signerType: "amino" }, o2(this, T))).result;
  }
  async signAmino(t, e) {
    return (await p({ method: "signAmino", params: [t, e], chainId: this.chainId, signerType: "amino" }, o2(this, T))).result;
  }
};
T = /* @__PURE__ */ new WeakMap(), s(R, "CosmiframeAminoSigner");
var D = R;
var u;
var Y = class Y2 {
  constructor(t, e) {
    A2(this, "chainId");
    x(this, u, void 0);
    this.chainId = t, O(this, u, e);
  }
  async getAccounts() {
    try {
      return (await p({ method: "getAccounts", params: [], chainId: this.chainId, signerType: "amino" }, o2(this, u))).result;
    } catch {
      return (await p({ method: "getAccounts", params: [], chainId: this.chainId, signerType: "direct" }, o2(this, u))).result;
    }
  }
  async signDirect(t, e) {
    return (await p({ method: "signDirect", params: [t, e], chainId: this.chainId, signerType: "direct" }, o2(this, u))).result;
  }
  async signAmino(t, e) {
    return (await p({ method: "signAmino", params: [t, e], chainId: this.chainId, signerType: "amino" }, o2(this, u))).result;
  }
};
u = /* @__PURE__ */ new WeakMap(), s(Y, "CosmiframeEitherSigner");
var W = Y;
var w;
(function(n2) {
  n2.IsCosmiframe = "isCosmiframe", n2.GetMetadata = "getMetadata";
})(w || (w = {}));
var m;
var F = class F2 {
  constructor(t) {
    x(this, m, void 0);
    A2(this, "p");
    if (!t.length) throw new Error("You must explicitly allow parent origins.");
    if (t.includes("*")) throw new Error("It is very unsafe to allow all origins because a controlling app has the power to manipulate messages before they are signed. If you really want to do this, pass in `UNSAFE_ALLOW_ANY_ORIGIN`.");
    O(this, m, t.includes(z) ? ["*"] : [...t]), this.p = new Proxy({ getEnigmaUtils: (e) => ({ getPubkey: () => this.p.getEnigmaPubKey(e), decrypt: (...r2) => this.p.enigmaDecrypt(e, ...r2), encrypt: (...r2) => this.p.enigmaEncrypt(e, ...r2), getTxEncryptionKey: (...r2) => this.p.getEnigmaTxEncryptionKey(e, ...r2) }) }, { get: (e, r2) => r2 in e && typeof e[r2] != "function" ? e[r2] : (...c3) => r2 in e && typeof e[r2] == "function" ? e[r2](...c3) : this.callParentMethod({ method: r2.toString(), params: c3 }).then(({ result: h4 }) => h4) });
  }
  callParentMethod(t, e) {
    return p(t, o2(this, m), e);
  }
  async isReady() {
    if (!B()) return false;
    try {
      let { origin: t, result: e } = await this.callParentMethod({ internal: true, method: w.IsCosmiframe, params: [] }, 500);
      return t || e;
    } catch (t) {
      if (t instanceof v) return false;
      throw t;
    }
  }
  async getMetadata() {
    return (await this.callParentMethod({ internal: true, method: w.GetMetadata, params: [] }, 500)).result;
  }
  getKeplrClient() {
    let t = new Proxy({ version: "cosmiframe", mode: "extension", defaultOptions: {}, getOfflineSigner: this.getOfflineSigner.bind(this), getOfflineSignerOnlyAmino: this.getOfflineSignerAmino.bind(this), getOfflineSignerAuto: (e) => Promise.resolve(this.getOfflineSigner(e)), getEnigmaUtils: (e) => ({ getPubkey: () => t.getEnigmaPubKey(e), decrypt: (...r2) => t.enigmaDecrypt(e, ...r2), encrypt: (...r2) => t.enigmaEncrypt(e, ...r2), getTxEncryptionKey: (...r2) => t.getEnigmaTxEncryptionKey(e, ...r2) }) }, { get: (e, r2) => r2 in e && typeof e[r2] != "function" ? e[r2] : (...c3) => r2 in e && typeof e[r2] == "function" ? e[r2](...c3) : this.callParentMethod({ method: r2.toString(), params: c3 }).then(({ result: h4 }) => h4) });
    return t;
  }
  getOfflineSigner(t) {
    return new W(t, o2(this, m));
  }
  getOfflineSignerAmino(t) {
    return new D(t, o2(this, m));
  }
  getOfflineSignerDirect(t) {
    return new P(t, o2(this, m));
  }
  static listen(t) {
    let { iframe: e, target: r2, getOfflineSignerDirect: c3, getOfflineSignerAmino: h4, nonSignerOverrides: I3, signerOverrides: l3, origins: f6, metadata: _2 } = t, E5 = f6?.length ? f6 : ["*"], k5 = { [w.IsCosmiframe]: () => true, [w.GetMetadata]: () => _2 || null }, H3 = s(async ({ source: Q3, origin: q2, data: y4 }) => {
      if (!e.contentWindow) throw new Error("Iframe contentWindow does not exist.");
      if (Q3 !== e.contentWindow || !U(E5, q2) || !y4 || typeof y4 != "object" || !("id" in y4) || !("method" in y4) || !("params" in y4)) return;
      let { id: V5, params: S3, chainId: L3, signType: X3, internal: Z3 } = y4, { method: i3, signerType: N2 } = y4;
      N2 || (N2 = X3), i3 = i3.replace(/^signer:/, "");
      let d3;
      try {
        if (Z3) {
          if (typeof k5[i3] != "function") throw new Error(`Unknown internal method: ${i3}`);
          d3 = { type: "success", response: await k5[i3](...S3) };
        } else if (N2) {
          if (!L3) throw new Error("Missing chainId in signer message request");
          let a2 = typeof l3 == "function" ? await l3(L3) : l3;
          if (a2 && i3 in a2) {
            let g2 = K(await a2[i3](...S3));
            g2 && (d3 = g2);
          }
          if (!d3) {
            let g2 = N2 === "direct" ? await c3(L3) : await h4(L3);
            if (!(i3 in g2) || typeof g2[i3] != "function") throw new Error(`No ${N2} signer method '${i3}' for chain ID '${L3}'.`);
            d3 = { type: "success", response: await g2[i3](...S3) };
          }
        } else {
          let a2 = typeof I3 == "function" ? await I3() : I3;
          if (a2 && i3 in a2) {
            let g2 = K(await a2[i3](...S3));
            g2 && (d3 = g2);
          }
          if (!d3) {
            if (!(i3 in r2) || typeof r2[i3] != "function") throw new Error(`No method '${i3}' on target.`);
            d3 = { type: "success", response: await r2[i3](...S3) };
          }
        }
      } catch (a2) {
        d3 = { type: "error", error: a2 instanceof Error ? a2.message : `${a2}` };
      }
      e.contentWindow?.postMessage({ ...d3, id: V5 }, q2);
    }, "listener");
    return window.addEventListener("message", H3), () => window.removeEventListener("message", H3);
  }
};
m = /* @__PURE__ */ new WeakMap(), s(F, "Cosmiframe");
var J = F;

// node_modules/.pnpm/@cosmsnap+snapper@0.2.7/node_modules/@cosmsnap/snapper/dist/snap.js
var __awaiter = function(thisArg, _arguments, P5, generator) {
  function adopt(value) {
    return value instanceof P5 ? value : new P5(function(resolve) {
      resolve(value);
    });
  }
  return new (P5 || (P5 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DEFAULT_SNAP_ID = "npm:@cosmsnap/snap";
var isSnapInstalled = (snapId = DEFAULT_SNAP_ID) => __awaiter(void 0, void 0, void 0, function* () {
  let result = yield window.ethereum.request({ method: "wallet_getSnaps" });
  const installed = Object.keys(result).includes(snapId);
  return installed;
});
var isSnapInitialized = (snapId = DEFAULT_SNAP_ID) => __awaiter(void 0, void 0, void 0, function* () {
  const initialized = yield window.ethereum.request({
    method: "wallet_invokeSnap",
    params: {
      snapId,
      request: {
        method: "initialized"
      }
    }
  });
  return initialized.data.initialized;
});
var installSnap = (snapId = DEFAULT_SNAP_ID) => __awaiter(void 0, void 0, void 0, function* () {
  let installed = yield isSnapInstalled();
  if (!installed) {
    yield window.ethereum.request({
      method: "wallet_requestSnaps",
      params: {
        [snapId]: {
          version: "^0.1.0"
        }
      }
    });
  }
  let initialized = yield isSnapInitialized();
  if (!initialized) {
    yield window.ethereum.request({
      method: "wallet_invokeSnap",
      params: {
        snapId,
        request: {
          method: "initialize"
        }
      }
    });
  }
  ;
});
var suggestChain = (chainInfo, snapId = DEFAULT_SNAP_ID) => __awaiter(void 0, void 0, void 0, function* () {
  yield window.ethereum.request({
    method: "wallet_invokeSnap",
    params: {
      snapId,
      request: {
        method: "addChain",
        params: {
          chain_info: JSON.stringify(chainInfo)
        }
      }
    }
  });
});
var getChains = (snapId = DEFAULT_SNAP_ID) => __awaiter(void 0, void 0, void 0, function* () {
  const result = yield window.ethereum.request({
    method: "wallet_invokeSnap",
    params: {
      snapId,
      request: {
        method: "getChains"
      }
    }
  });
  return result.data.chains;
});
var deleteChain = (chain_id, snapId = DEFAULT_SNAP_ID) => __awaiter(void 0, void 0, void 0, function* () {
  yield window.ethereum.request({
    method: "wallet_invokeSnap",
    params: {
      snapId,
      request: {
        method: "deleteChain",
        params: {
          chain_id
        }
      }
    }
  });
});
var signAndBroadcast = (chain_id, msgs, fees, snapId = DEFAULT_SNAP_ID) => __awaiter(void 0, void 0, void 0, function* () {
  let result = yield window.ethereum.request({
    method: "wallet_invokeSnap",
    params: {
      snapId,
      request: {
        method: "transact",
        params: {
          chain_id,
          msgs: JSON.stringify(msgs),
          // Optional: Uses default fees for chain if not specified
          fees: fees ? JSON.stringify(fees) : null
        }
      }
    }
  });
  return result.data;
});
var sign = (chain_id, msgs, fees, snapId = DEFAULT_SNAP_ID) => __awaiter(void 0, void 0, void 0, function* () {
  let result = yield window.ethereum.request({
    method: "wallet_invokeSnap",
    params: {
      snapId,
      request: {
        method: "signTx",
        params: {
          chain_id,
          msgs: JSON.stringify(msgs),
          // Optional: Uses default fees for chain if not specified
          fees: fees ? JSON.stringify(fees) : null
        }
      }
    }
  });
  return result.data;
});
var addAddressToBook = (chain_id, address, name2, snapId = DEFAULT_SNAP_ID) => __awaiter(void 0, void 0, void 0, function* () {
  yield window.ethereum.request({
    method: "wallet_invokeSnap",
    params: {
      snapId,
      request: {
        method: "addAddress",
        params: {
          chain_id,
          address,
          name: name2
        }
      }
    }
  });
});
var getAddressBook = (snapId = DEFAULT_SNAP_ID) => __awaiter(void 0, void 0, void 0, function* () {
  const result = yield window.ethereum.request({
    method: "wallet_invokeSnap",
    params: {
      snapId,
      request: {
        method: "getAddresses"
      }
    }
  });
  return result.data;
});
var deleteAddressFromBook = (address, snapId = DEFAULT_SNAP_ID) => __awaiter(void 0, void 0, void 0, function* () {
  yield window.ethereum.request({
    method: "wallet_invokeSnap",
    params: {
      snapId,
      request: {
        method: "deleteAddress",
        params: {
          address
        }
      }
    }
  });
});
var getBech32Addresses = (snapId = DEFAULT_SNAP_ID) => __awaiter(void 0, void 0, void 0, function* () {
  const result = yield window.ethereum.request({
    method: "wallet_invokeSnap",
    params: {
      snapId,
      request: {
        method: "getChainAddresses"
      }
    }
  });
  return result.data.addresses;
});
var getBech32Address = (chain_id, snapId = DEFAULT_SNAP_ID) => __awaiter(void 0, void 0, void 0, function* () {
  const result = yield window.ethereum.request({
    method: "wallet_invokeSnap",
    params: {
      snapId,
      request: {
        method: "getChainAddress",
        params: {
          chain_id
        }
      }
    }
  });
  return result.data;
});
var getAccountInfo = (chain_id, snapId = DEFAULT_SNAP_ID) => __awaiter(void 0, void 0, void 0, function* () {
  const result = yield window.ethereum.request({
    method: "wallet_invokeSnap",
    params: {
      snapId,
      request: {
        method: "getAccountInfo",
        params: {
          chain_id
        }
      }
    }
  });
  return result.data;
});
var getKey = (chain_id, snapId = DEFAULT_SNAP_ID) => __awaiter(void 0, void 0, void 0, function* () {
  const result = yield window.ethereum.request({
    method: "wallet_invokeSnap",
    params: {
      snapId,
      request: {
        method: "getKey",
        params: {
          chain_id
        }
      }
    }
  });
  return result.data;
});
var sendTx = (chain_id, tx, snapId = DEFAULT_SNAP_ID) => __awaiter(void 0, void 0, void 0, function* () {
  const result = yield window.ethereum.request({
    method: "wallet_invokeSnap",
    params: {
      snapId,
      request: {
        method: "sendTx",
        params: {
          chain_id,
          tx: JSON.stringify(tx)
        }
      }
    }
  });
  return result.data;
});
var signDirect = (chain_id, signer, sign_doc, snapId = DEFAULT_SNAP_ID) => __awaiter(void 0, void 0, void 0, function* () {
  const result = yield window.ethereum.request({
    method: "wallet_invokeSnap",
    params: {
      snapId,
      request: {
        method: "signDirect",
        params: {
          chain_id,
          sign_doc,
          signer
        }
      }
    }
  });
  return result.data;
});
var signAmino = (chain_id, signer, sign_doc, snapId = DEFAULT_SNAP_ID) => __awaiter(void 0, void 0, void 0, function* () {
  const result = yield window.ethereum.request({
    method: "wallet_invokeSnap",
    params: {
      snapId,
      request: {
        method: "signAmino",
        params: {
          chain_id,
          sign_doc,
          signer
        }
      }
    }
  });
  return result.data;
});

// node_modules/.pnpm/long@5.2.3/node_modules/long/index.js
var wasm = null;
try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0,
    97,
    115,
    109,
    1,
    0,
    0,
    0,
    1,
    13,
    2,
    96,
    0,
    1,
    127,
    96,
    4,
    127,
    127,
    127,
    127,
    1,
    127,
    3,
    7,
    6,
    0,
    1,
    1,
    1,
    1,
    1,
    6,
    6,
    1,
    127,
    1,
    65,
    0,
    11,
    7,
    50,
    6,
    3,
    109,
    117,
    108,
    0,
    1,
    5,
    100,
    105,
    118,
    95,
    115,
    0,
    2,
    5,
    100,
    105,
    118,
    95,
    117,
    0,
    3,
    5,
    114,
    101,
    109,
    95,
    115,
    0,
    4,
    5,
    114,
    101,
    109,
    95,
    117,
    0,
    5,
    8,
    103,
    101,
    116,
    95,
    104,
    105,
    103,
    104,
    0,
    0,
    10,
    191,
    1,
    6,
    4,
    0,
    35,
    0,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    126,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    127,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    128,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    129,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11,
    36,
    1,
    1,
    126,
    32,
    0,
    173,
    32,
    1,
    173,
    66,
    32,
    134,
    132,
    32,
    2,
    173,
    32,
    3,
    173,
    66,
    32,
    134,
    132,
    130,
    34,
    4,
    66,
    32,
    135,
    167,
    36,
    0,
    32,
    4,
    167,
    11
  ])), {}).exports;
} catch (e) {
}
function Long(low, high, unsigned) {
  this.low = low | 0;
  this.high = high | 0;
  this.unsigned = !!unsigned;
}
Long.prototype.__isLong__;
Object.defineProperty(Long.prototype, "__isLong__", { value: true });
function isLong(obj) {
  return (obj && obj["__isLong__"]) === true;
}
function ctz32(value) {
  var c3 = Math.clz32(value & -value);
  return value ? 31 - c3 : c3;
}
Long.isLong = isLong;
var INT_CACHE = {};
var UINT_CACHE = {};
function fromInt(value, unsigned) {
  var obj, cachedObj, cache;
  if (unsigned) {
    value >>>= 0;
    if (cache = 0 <= value && value < 256) {
      cachedObj = UINT_CACHE[value];
      if (cachedObj)
        return cachedObj;
    }
    obj = fromBits(value, 0, true);
    if (cache)
      UINT_CACHE[value] = obj;
    return obj;
  } else {
    value |= 0;
    if (cache = -128 <= value && value < 128) {
      cachedObj = INT_CACHE[value];
      if (cachedObj)
        return cachedObj;
    }
    obj = fromBits(value, value < 0 ? -1 : 0, false);
    if (cache)
      INT_CACHE[value] = obj;
    return obj;
  }
}
Long.fromInt = fromInt;
function fromNumber(value, unsigned) {
  if (isNaN(value))
    return unsigned ? UZERO : ZERO;
  if (unsigned) {
    if (value < 0)
      return UZERO;
    if (value >= TWO_PWR_64_DBL)
      return MAX_UNSIGNED_VALUE;
  } else {
    if (value <= -TWO_PWR_63_DBL)
      return MIN_VALUE;
    if (value + 1 >= TWO_PWR_63_DBL)
      return MAX_VALUE;
  }
  if (value < 0)
    return fromNumber(-value, unsigned).neg();
  return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
}
Long.fromNumber = fromNumber;
function fromBits(lowBits, highBits, unsigned) {
  return new Long(lowBits, highBits, unsigned);
}
Long.fromBits = fromBits;
var pow_dbl = Math.pow;
function fromString2(str2, unsigned, radix3) {
  if (str2.length === 0)
    throw Error("empty string");
  if (typeof unsigned === "number") {
    radix3 = unsigned;
    unsigned = false;
  } else {
    unsigned = !!unsigned;
  }
  if (str2 === "NaN" || str2 === "Infinity" || str2 === "+Infinity" || str2 === "-Infinity")
    return unsigned ? UZERO : ZERO;
  radix3 = radix3 || 10;
  if (radix3 < 2 || 36 < radix3)
    throw RangeError("radix");
  var p4;
  if ((p4 = str2.indexOf("-")) > 0)
    throw Error("interior hyphen");
  else if (p4 === 0) {
    return fromString2(str2.substring(1), unsigned, radix3).neg();
  }
  var radixToPower = fromNumber(pow_dbl(radix3, 8));
  var result = ZERO;
  for (var i3 = 0; i3 < str2.length; i3 += 8) {
    var size = Math.min(8, str2.length - i3), value = parseInt(str2.substring(i3, i3 + size), radix3);
    if (size < 8) {
      var power = fromNumber(pow_dbl(radix3, size));
      result = result.mul(power).add(fromNumber(value));
    } else {
      result = result.mul(radixToPower);
      result = result.add(fromNumber(value));
    }
  }
  result.unsigned = unsigned;
  return result;
}
Long.fromString = fromString2;
function fromValue(val, unsigned) {
  if (typeof val === "number")
    return fromNumber(val, unsigned);
  if (typeof val === "string")
    return fromString2(val, unsigned);
  return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
}
Long.fromValue = fromValue;
var TWO_PWR_16_DBL = 1 << 16;
var TWO_PWR_24_DBL = 1 << 24;
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
var ZERO = fromInt(0);
Long.ZERO = ZERO;
var UZERO = fromInt(0, true);
Long.UZERO = UZERO;
var ONE = fromInt(1);
Long.ONE = ONE;
var UONE = fromInt(1, true);
Long.UONE = UONE;
var NEG_ONE = fromInt(-1);
Long.NEG_ONE = NEG_ONE;
var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
Long.MAX_VALUE = MAX_VALUE;
var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
Long.MIN_VALUE = MIN_VALUE;
var LongPrototype = Long.prototype;
LongPrototype.toInt = function toInt() {
  return this.unsigned ? this.low >>> 0 : this.low;
};
LongPrototype.toNumber = function toNumber() {
  if (this.unsigned)
    return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
  return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};
LongPrototype.toString = function toString2(radix3) {
  radix3 = radix3 || 10;
  if (radix3 < 2 || 36 < radix3)
    throw RangeError("radix");
  if (this.isZero())
    return "0";
  if (this.isNegative()) {
    if (this.eq(MIN_VALUE)) {
      var radixLong = fromNumber(radix3), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
      return div.toString(radix3) + rem1.toInt().toString(radix3);
    } else
      return "-" + this.neg().toString(radix3);
  }
  var radixToPower = fromNumber(pow_dbl(radix3, 6), this.unsigned), rem = this;
  var result = "";
  while (true) {
    var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix3);
    rem = remDiv;
    if (rem.isZero())
      return digits + result;
    else {
      while (digits.length < 6)
        digits = "0" + digits;
      result = "" + digits + result;
    }
  }
};
LongPrototype.getHighBits = function getHighBits() {
  return this.high;
};
LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
  return this.high >>> 0;
};
LongPrototype.getLowBits = function getLowBits() {
  return this.low;
};
LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
  return this.low >>> 0;
};
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
  if (this.isNegative())
    return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
  var val = this.high != 0 ? this.high : this.low;
  for (var bit = 31; bit > 0; bit--)
    if ((val & 1 << bit) != 0)
      break;
  return this.high != 0 ? bit + 33 : bit + 1;
};
LongPrototype.isZero = function isZero() {
  return this.high === 0 && this.low === 0;
};
LongPrototype.eqz = LongPrototype.isZero;
LongPrototype.isNegative = function isNegative() {
  return !this.unsigned && this.high < 0;
};
LongPrototype.isPositive = function isPositive() {
  return this.unsigned || this.high >= 0;
};
LongPrototype.isOdd = function isOdd() {
  return (this.low & 1) === 1;
};
LongPrototype.isEven = function isEven() {
  return (this.low & 1) === 0;
};
LongPrototype.equals = function equals(other) {
  if (!isLong(other))
    other = fromValue(other);
  if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
    return false;
  return this.high === other.high && this.low === other.low;
};
LongPrototype.eq = LongPrototype.equals;
LongPrototype.notEquals = function notEquals(other) {
  return !this.eq(
    /* validates */
    other
  );
};
LongPrototype.neq = LongPrototype.notEquals;
LongPrototype.ne = LongPrototype.notEquals;
LongPrototype.lessThan = function lessThan(other) {
  return this.comp(
    /* validates */
    other
  ) < 0;
};
LongPrototype.lt = LongPrototype.lessThan;
LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
  return this.comp(
    /* validates */
    other
  ) <= 0;
};
LongPrototype.lte = LongPrototype.lessThanOrEqual;
LongPrototype.le = LongPrototype.lessThanOrEqual;
LongPrototype.greaterThan = function greaterThan(other) {
  return this.comp(
    /* validates */
    other
  ) > 0;
};
LongPrototype.gt = LongPrototype.greaterThan;
LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
  return this.comp(
    /* validates */
    other
  ) >= 0;
};
LongPrototype.gte = LongPrototype.greaterThanOrEqual;
LongPrototype.ge = LongPrototype.greaterThanOrEqual;
LongPrototype.compare = function compare(other) {
  if (!isLong(other))
    other = fromValue(other);
  if (this.eq(other))
    return 0;
  var thisNeg = this.isNegative(), otherNeg = other.isNegative();
  if (thisNeg && !otherNeg)
    return -1;
  if (!thisNeg && otherNeg)
    return 1;
  if (!this.unsigned)
    return this.sub(other).isNegative() ? -1 : 1;
  return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
};
LongPrototype.comp = LongPrototype.compare;
LongPrototype.negate = function negate() {
  if (!this.unsigned && this.eq(MIN_VALUE))
    return MIN_VALUE;
  return this.not().add(ONE);
};
LongPrototype.neg = LongPrototype.negate;
LongPrototype.add = function add(addend) {
  if (!isLong(addend))
    addend = fromValue(addend);
  var a48 = this.high >>> 16;
  var a32 = this.high & 65535;
  var a16 = this.low >>> 16;
  var a00 = this.low & 65535;
  var b48 = addend.high >>> 16;
  var b32 = addend.high & 65535;
  var b16 = addend.low >>> 16;
  var b00 = addend.low & 65535;
  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 + b00;
  c16 += c00 >>> 16;
  c00 &= 65535;
  c16 += a16 + b16;
  c32 += c16 >>> 16;
  c16 &= 65535;
  c32 += a32 + b32;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c48 += a48 + b48;
  c48 &= 65535;
  return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
};
LongPrototype.subtract = function subtract(subtrahend) {
  if (!isLong(subtrahend))
    subtrahend = fromValue(subtrahend);
  return this.add(subtrahend.neg());
};
LongPrototype.sub = LongPrototype.subtract;
LongPrototype.multiply = function multiply(multiplier) {
  if (this.isZero())
    return this;
  if (!isLong(multiplier))
    multiplier = fromValue(multiplier);
  if (wasm) {
    var low = wasm["mul"](
      this.low,
      this.high,
      multiplier.low,
      multiplier.high
    );
    return fromBits(low, wasm["get_high"](), this.unsigned);
  }
  if (multiplier.isZero())
    return this.unsigned ? UZERO : ZERO;
  if (this.eq(MIN_VALUE))
    return multiplier.isOdd() ? MIN_VALUE : ZERO;
  if (multiplier.eq(MIN_VALUE))
    return this.isOdd() ? MIN_VALUE : ZERO;
  if (this.isNegative()) {
    if (multiplier.isNegative())
      return this.neg().mul(multiplier.neg());
    else
      return this.neg().mul(multiplier).neg();
  } else if (multiplier.isNegative())
    return this.mul(multiplier.neg()).neg();
  if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
    return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
  var a48 = this.high >>> 16;
  var a32 = this.high & 65535;
  var a16 = this.low >>> 16;
  var a00 = this.low & 65535;
  var b48 = multiplier.high >>> 16;
  var b32 = multiplier.high & 65535;
  var b16 = multiplier.low >>> 16;
  var b00 = multiplier.low & 65535;
  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 * b00;
  c16 += c00 >>> 16;
  c00 &= 65535;
  c16 += a16 * b00;
  c32 += c16 >>> 16;
  c16 &= 65535;
  c16 += a00 * b16;
  c32 += c16 >>> 16;
  c16 &= 65535;
  c32 += a32 * b00;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c32 += a16 * b16;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c32 += a00 * b32;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
  c48 &= 65535;
  return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
};
LongPrototype.mul = LongPrototype.multiply;
LongPrototype.divide = function divide(divisor) {
  if (!isLong(divisor))
    divisor = fromValue(divisor);
  if (divisor.isZero())
    throw Error("division by zero");
  if (wasm) {
    if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
      return this;
    }
    var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(
      this.low,
      this.high,
      divisor.low,
      divisor.high
    );
    return fromBits(low, wasm["get_high"](), this.unsigned);
  }
  if (this.isZero())
    return this.unsigned ? UZERO : ZERO;
  var approx, rem, res;
  if (!this.unsigned) {
    if (this.eq(MIN_VALUE)) {
      if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
        return MIN_VALUE;
      else if (divisor.eq(MIN_VALUE))
        return ONE;
      else {
        var halfThis = this.shr(1);
        approx = halfThis.div(divisor).shl(1);
        if (approx.eq(ZERO)) {
          return divisor.isNegative() ? ONE : NEG_ONE;
        } else {
          rem = this.sub(divisor.mul(approx));
          res = approx.add(rem.div(divisor));
          return res;
        }
      }
    } else if (divisor.eq(MIN_VALUE))
      return this.unsigned ? UZERO : ZERO;
    if (this.isNegative()) {
      if (divisor.isNegative())
        return this.neg().div(divisor.neg());
      return this.neg().div(divisor).neg();
    } else if (divisor.isNegative())
      return this.div(divisor.neg()).neg();
    res = ZERO;
  } else {
    if (!divisor.unsigned)
      divisor = divisor.toUnsigned();
    if (divisor.gt(this))
      return UZERO;
    if (divisor.gt(this.shru(1)))
      return UONE;
    res = UZERO;
  }
  rem = this;
  while (rem.gte(divisor)) {
    approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
    var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
    while (approxRem.isNegative() || approxRem.gt(rem)) {
      approx -= delta;
      approxRes = fromNumber(approx, this.unsigned);
      approxRem = approxRes.mul(divisor);
    }
    if (approxRes.isZero())
      approxRes = ONE;
    res = res.add(approxRes);
    rem = rem.sub(approxRem);
  }
  return res;
};
LongPrototype.div = LongPrototype.divide;
LongPrototype.modulo = function modulo(divisor) {
  if (!isLong(divisor))
    divisor = fromValue(divisor);
  if (wasm) {
    var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(
      this.low,
      this.high,
      divisor.low,
      divisor.high
    );
    return fromBits(low, wasm["get_high"](), this.unsigned);
  }
  return this.sub(this.div(divisor).mul(divisor));
};
LongPrototype.mod = LongPrototype.modulo;
LongPrototype.rem = LongPrototype.modulo;
LongPrototype.not = function not() {
  return fromBits(~this.low, ~this.high, this.unsigned);
};
LongPrototype.countLeadingZeros = function countLeadingZeros() {
  return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
};
LongPrototype.clz = LongPrototype.countLeadingZeros;
LongPrototype.countTrailingZeros = function countTrailingZeros() {
  return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
};
LongPrototype.ctz = LongPrototype.countTrailingZeros;
LongPrototype.and = function and(other) {
  if (!isLong(other))
    other = fromValue(other);
  return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
};
LongPrototype.or = function or(other) {
  if (!isLong(other))
    other = fromValue(other);
  return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};
LongPrototype.xor = function xor(other) {
  if (!isLong(other))
    other = fromValue(other);
  return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};
LongPrototype.shiftLeft = function shiftLeft(numBits) {
  if (isLong(numBits))
    numBits = numBits.toInt();
  if ((numBits &= 63) === 0)
    return this;
  else if (numBits < 32)
    return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
  else
    return fromBits(0, this.low << numBits - 32, this.unsigned);
};
LongPrototype.shl = LongPrototype.shiftLeft;
LongPrototype.shiftRight = function shiftRight(numBits) {
  if (isLong(numBits))
    numBits = numBits.toInt();
  if ((numBits &= 63) === 0)
    return this;
  else if (numBits < 32)
    return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
  else
    return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
};
LongPrototype.shr = LongPrototype.shiftRight;
LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
  if (isLong(numBits)) numBits = numBits.toInt();
  if ((numBits &= 63) === 0) return this;
  if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);
  if (numBits === 32) return fromBits(this.high, 0, this.unsigned);
  return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
};
LongPrototype.shru = LongPrototype.shiftRightUnsigned;
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
LongPrototype.rotateLeft = function rotateLeft(numBits) {
  var b5;
  if (isLong(numBits)) numBits = numBits.toInt();
  if ((numBits &= 63) === 0) return this;
  if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
  if (numBits < 32) {
    b5 = 32 - numBits;
    return fromBits(this.low << numBits | this.high >>> b5, this.high << numBits | this.low >>> b5, this.unsigned);
  }
  numBits -= 32;
  b5 = 32 - numBits;
  return fromBits(this.high << numBits | this.low >>> b5, this.low << numBits | this.high >>> b5, this.unsigned);
};
LongPrototype.rotl = LongPrototype.rotateLeft;
LongPrototype.rotateRight = function rotateRight(numBits) {
  var b5;
  if (isLong(numBits)) numBits = numBits.toInt();
  if ((numBits &= 63) === 0) return this;
  if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
  if (numBits < 32) {
    b5 = 32 - numBits;
    return fromBits(this.high << b5 | this.low >>> numBits, this.low << b5 | this.high >>> numBits, this.unsigned);
  }
  numBits -= 32;
  b5 = 32 - numBits;
  return fromBits(this.low << b5 | this.high >>> numBits, this.high << b5 | this.low >>> numBits, this.unsigned);
};
LongPrototype.rotr = LongPrototype.rotateRight;
LongPrototype.toSigned = function toSigned() {
  if (!this.unsigned)
    return this;
  return fromBits(this.low, this.high, false);
};
LongPrototype.toUnsigned = function toUnsigned() {
  if (this.unsigned)
    return this;
  return fromBits(this.low, this.high, true);
};
LongPrototype.toBytes = function toBytes(le4) {
  return le4 ? this.toBytesLE() : this.toBytesBE();
};
LongPrototype.toBytesLE = function toBytesLE() {
  var hi2 = this.high, lo2 = this.low;
  return [
    lo2 & 255,
    lo2 >>> 8 & 255,
    lo2 >>> 16 & 255,
    lo2 >>> 24,
    hi2 & 255,
    hi2 >>> 8 & 255,
    hi2 >>> 16 & 255,
    hi2 >>> 24
  ];
};
LongPrototype.toBytesBE = function toBytesBE() {
  var hi2 = this.high, lo2 = this.low;
  return [
    hi2 >>> 24,
    hi2 >>> 16 & 255,
    hi2 >>> 8 & 255,
    hi2 & 255,
    lo2 >>> 24,
    lo2 >>> 16 & 255,
    lo2 >>> 8 & 255,
    lo2 & 255
  ];
};
Long.fromBytes = function fromBytes(bytes2, unsigned, le4) {
  return le4 ? Long.fromBytesLE(bytes2, unsigned) : Long.fromBytesBE(bytes2, unsigned);
};
Long.fromBytesLE = function fromBytesLE(bytes2, unsigned) {
  return new Long(
    bytes2[0] | bytes2[1] << 8 | bytes2[2] << 16 | bytes2[3] << 24,
    bytes2[4] | bytes2[5] << 8 | bytes2[6] << 16 | bytes2[7] << 24,
    unsigned
  );
};
Long.fromBytesBE = function fromBytesBE(bytes2, unsigned) {
  return new Long(
    bytes2[4] << 24 | bytes2[5] << 16 | bytes2[6] << 8 | bytes2[7],
    bytes2[0] << 24 | bytes2[1] << 16 | bytes2[2] << 8 | bytes2[3],
    unsigned
  );
};
var long_default = Long;

// node_modules/.pnpm/@cosmsnap+snapper@0.2.7/node_modules/@cosmsnap/snapper/dist/signer.js
var __awaiter2 = function(thisArg, _arguments, P5, generator) {
  function adopt(value) {
    return value instanceof P5 ? value : new P5(function(resolve) {
      resolve(value);
    });
  }
  return new (P5 || (P5 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var CosmJSOfflineSigner = class {
  constructor(chainId, snapId) {
    this.chainId = chainId;
    if (!snapId) {
      this.snapId = DEFAULT_SNAP_ID;
    } else {
      this.snapId = snapId;
    }
  }
  getAccounts() {
    return __awaiter2(this, void 0, void 0, function* () {
      let address = yield getAccountInfo(this.chainId, this.snapId);
      return [
        {
          algo: "secp256k1",
          address: address.address,
          pubkey: new Uint8Array(Object.values(address.pubkey))
        }
      ];
    });
  }
  signDirect(signerAddress, signDoc) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (this.chainId !== signDoc.chainId) {
        throw new Error("Chain IDs do not match.");
      }
      const accounts = yield this.getAccounts();
      let account = accounts[0];
      if (account.address !== signerAddress) {
        throw new Error("Signer address and wallet address do not match.");
      }
      let signRes = yield signDirect(this.chainId, signerAddress, signDoc, this.snapId);
      const { accountNumber } = signDoc;
      const accountNumberLong = new long_default((accountNumber === null || accountNumber === void 0 ? void 0 : accountNumber.low) || 0, accountNumber === null || accountNumber === void 0 ? void 0 : accountNumber.high, accountNumber === null || accountNumber === void 0 ? void 0 : accountNumber.unsigned);
      const sign2 = {
        signature: signRes.signature,
        signed: Object.assign(Object.assign({}, signRes.signed), { accountNumber: `${accountNumberLong.toString()}`, authInfoBytes: new Uint8Array(Object.values(signRes.signed.authInfoBytes)), bodyBytes: new Uint8Array(Object.values(signRes.signed.bodyBytes)) })
      };
      return sign2;
    });
  }
  // This has been added as a placeholder.
  signAmino(signerAddress, signDoc) {
    return __awaiter2(this, void 0, void 0, function* () {
      if (this.chainId !== signDoc.chain_id) {
        throw new Error("Chain IDs do not match");
      }
      const accounts = yield this.getAccounts();
      let account = accounts[0];
      if (account.address !== signerAddress) {
        throw new Error("Signer address and wallet address do not match.");
      }
      let signRes = yield signAmino(this.chainId, account.address, signDoc, this.snapId);
      return signRes;
    });
  }
};

// node_modules/.pnpm/@cosmsnap+snapper@0.2.7/node_modules/@cosmsnap/snapper/dist/appwrite.js
var __awaiter3 = function(thisArg, _arguments, P5, generator) {
  function adopt(value) {
    return value instanceof P5 ? value : new P5(function(resolve) {
      resolve(value);
    });
  }
  return new (P5 || (P5 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var MultisigTxStatus;
(function(MultisigTxStatus2) {
  MultisigTxStatus2["Created"] = "created";
})(MultisigTxStatus || (MultisigTxStatus = {}));
var Appwrite = class {
  constructor(appwrite_url, project_id) {
    this.getMultiSigs = (memberPk) => __awaiter3(this, void 0, void 0, function* () {
      const functions = yield this.getFunctions();
      const executionMethod = yield this.getExecutionMethod();
      const res = yield functions.createExecution("get_multisigs", void 0, void 0, `?memberPk=${encodeURIComponent(memberPk)}`, executionMethod.GET);
      if (res.responseStatusCode !== 200) {
        throw new Error(`Failed to getMultiSigs. ${res.responseBody}`);
      }
      const data2 = JSON.parse(res.responseBody);
      if (data2.success === false) {
        throw new Error(`Error Occured: ${data2.data}`);
      }
      return data2.data;
    });
    this.createMultiSig = (name2, threshold, pubKeys) => __awaiter3(this, void 0, void 0, function* () {
      const functions = yield this.getFunctions();
      const body = { "name": name2, "threshold": threshold, "pubKeys": pubKeys };
      const executionMethod = yield this.getExecutionMethod();
      const res = yield functions.createExecution("create_multisig", JSON.stringify(body), void 0, void 0, executionMethod.POST);
      if (res.responseStatusCode !== 200) {
        throw new Error(`Failed to createMultiSig. ${res.responseBody}`);
      }
      const data2 = JSON.parse(res.responseBody);
      if (data2.success === false) {
        throw new Error(`Error Occured: ${data2.data}`);
      }
      return data2.data;
    });
    this.createMultiSigTx = (public_key, rpc, prefix, signature, body_bytes, messages, chain_id, signer_address, fee) => __awaiter3(this, void 0, void 0, function* () {
      const functions = yield this.getFunctions();
      const body = { public_key, rpc, prefix, signature, body_bytes, messages, chain_id, signer_address, fee };
      const executionMethod = yield this.getExecutionMethod();
      const res = yield functions.createExecution("create_multisig_tx", JSON.stringify(body), void 0, void 0, executionMethod.POST);
      if (res.responseStatusCode !== 200) {
        throw new Error(`Failed to createMultiSigTx. ${res.responseBody}`);
      }
      const data2 = JSON.parse(res.responseBody);
      if (data2.success === false) {
        throw new Error(`Error Occured: ${data2.data}`);
      }
      return data2.data;
    });
    this.signMultiSigTx = (public_key, rpc, fee, prefix, signature, signer_address) => __awaiter3(this, void 0, void 0, function* () {
      const functions = yield this.getFunctions();
      const body = { public_key, rpc, fee, prefix, signature, signer_address };
      const executionMethod = yield this.getExecutionMethod();
      const res = yield functions.createExecution("sign_multisig_tx", JSON.stringify(body), void 0, void 0, executionMethod.POST);
      if (res.responseStatusCode !== 200) {
        throw new Error(`Failed to signMultiSigTx. ${res.responseBody}`);
      }
      const data2 = JSON.parse(res.responseBody);
      if (data2.success === false) {
        throw new Error(`Error Occured: ${data2.data}`);
      }
      return data2.data;
    });
    this.deleteMultisigTx = (tx_id) => __awaiter3(this, void 0, void 0, function* () {
      const functions = yield this.getFunctions();
      const body = { tx_id };
      const executionMethod = yield this.getExecutionMethod();
      const res = yield functions.createExecution("delete_multisig_tx", JSON.stringify(body), void 0, void 0, executionMethod.POST);
      if (res.responseStatusCode !== 200) {
        throw new Error(`Failed to deleteMultisigTx. ${res.responseBody}`);
      }
      const data2 = JSON.parse(res.responseBody);
      if (data2.success === false) {
        throw new Error(`Error Occured: ${data2.data}`);
      }
      return data2.data;
    });
    this.isServer = typeof window === "undefined";
    this.initializeClient(appwrite_url, project_id);
  }
  initializeClient(appwrite_url, project_id) {
    return __awaiter3(this, void 0, void 0, function* () {
      if (this.isServer) {
        const { Client } = yield import("./dist-XJIEZRMU.js");
        this.client = new Client();
      } else {
        const { Client } = yield import("./sdk-FHR4LZJC.js");
        this.client = new Client();
      }
      this.client.setEndpoint(appwrite_url).setProject(project_id);
    });
  }
  getFunctions() {
    return __awaiter3(this, void 0, void 0, function* () {
      if (this.isServer) {
        const { Functions } = yield import("./dist-XJIEZRMU.js");
        return new Functions(this.client);
      } else {
        const { Functions } = yield import("./sdk-FHR4LZJC.js");
        return new Functions(this.client);
      }
    });
  }
  getExecutionMethod() {
    return __awaiter3(this, void 0, void 0, function* () {
      if (this.isServer) {
        const { ExecutionMethod } = yield import("./dist-XJIEZRMU.js");
        return ExecutionMethod;
      } else {
        const { ExecutionMethod } = yield import("./sdk-FHR4LZJC.js");
        return ExecutionMethod;
      }
    });
  }
};

// node_modules/.pnpm/@cosmsnap+snapper@0.2.7/node_modules/@cosmsnap/snapper/dist/provider.js
var __awaiter4 = function(thisArg, _arguments, P5, generator) {
  function adopt(value) {
    return value instanceof P5 ? value : new P5(function(resolve) {
      resolve(value);
    });
  }
  return new (P5 || (P5 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var CosmosSnap = class {
  constructor() {
    this.snap_id = DEFAULT_SNAP_ID;
  }
  changeSnapId(snap_id) {
    this.snap_id = snap_id;
  }
  getAccount(chain_id) {
    return __awaiter4(this, void 0, void 0, function* () {
      let account = yield getAccountInfo(chain_id, this.snap_id);
      return Object.assign(Object.assign({}, account), { pubkey: new Uint8Array(Object.values(account.pubkey)) });
    });
  }
  getKey(chain_id) {
    return __awaiter4(this, void 0, void 0, function* () {
      let key = yield getKey(chain_id, this.snap_id);
      return Object.assign(Object.assign({}, key), { pubKey: new Uint8Array(Object.values(key.pubKey)) });
    });
  }
  deleteChain(chain_id) {
    return __awaiter4(this, void 0, void 0, function* () {
      yield deleteChain(chain_id, this.snap_id);
    });
  }
  signAndBroadcast(chain_id, msgs, fees) {
    return __awaiter4(this, void 0, void 0, function* () {
      let res = yield signAndBroadcast(chain_id, msgs, fees, this.snap_id);
      return res;
    });
  }
  sign(chain_id, msgs, fees) {
    return __awaiter4(this, void 0, void 0, function* () {
      let res = sign(chain_id, msgs, fees, this.snap_id);
      return res;
    });
  }
  addAddressToBook(chain_id, address, name2) {
    return __awaiter4(this, void 0, void 0, function* () {
      yield addAddressToBook(chain_id, address, name2, this.snap_id);
    });
  }
  getAddressBook() {
    return __awaiter4(this, void 0, void 0, function* () {
      let addresses = yield getAddressBook(this.snap_id);
      return addresses;
    });
  }
  deleteAddressFromBook(address) {
    return __awaiter4(this, void 0, void 0, function* () {
      yield deleteAddressFromBook(address, this.snap_id);
    });
  }
  getBech32Addresses() {
    return __awaiter4(this, void 0, void 0, function* () {
      let addresses = getBech32Addresses(this.snap_id);
      return addresses;
    });
  }
  getBech32Address(chain_id) {
    return __awaiter4(this, void 0, void 0, function* () {
      let address = getBech32Address(chain_id, this.snap_id);
      return address;
    });
  }
  enable() {
    return __awaiter4(this, void 0, void 0, function* () {
      yield installSnap(this.snap_id);
      return true;
    });
  }
  getChains() {
    return __awaiter4(this, void 0, void 0, function* () {
      let chains = yield getChains(this.snap_id);
      return chains;
    });
  }
  experimentalSuggestChain(chainInfo) {
    var _a2, _b;
    return __awaiter4(this, void 0, void 0, function* () {
      let chains = yield this.getChains();
      let chainIds = chains.map((item) => item.chain_id);
      if (chainIds.includes(chainInfo.chainId)) {
        return true;
      }
      let chain2 = {
        pretty_name: chainInfo.chainName,
        chain_name: chainInfo.chainName,
        chain_id: chainInfo.chainId,
        slip44: chainInfo.bip44.coinType,
        bech32_prefix: chainInfo.bech32Config.bech32PrefixAccAddr,
        fees: {
          fee_tokens: chainInfo.feeCurrencies.map((item) => {
            return {
              denom: item.coinDenom,
              low_gas_price: item.gasPriceStep.low,
              average_gas_price: item.gasPriceStep.high,
              high_gas_price: item.gasPriceStep.high
            };
          })
        },
        staking: {
          staking_tokens: [
            { denom: chainInfo.stakeCurrency.coinDenom }
          ]
        },
        logo_URIs: {
          png: (_a2 = chainInfo.chainSymbolImageUrl) !== null && _a2 !== void 0 ? _a2 : void 0,
          svg: (_b = chainInfo.chainSymbolImageUrl) !== null && _b !== void 0 ? _b : void 0
        },
        apis: {
          rpc: [
            {
              address: chainInfo.rpc
            }
          ],
          rest: [
            {
              address: chainInfo.rest
            }
          ]
        },
        address: void 0
      };
      yield suggestChain(chain2, this.snap_id);
      return true;
    });
  }
  signAmino(chainId, signer, signDoc) {
    return __awaiter4(this, void 0, void 0, function* () {
      let res = yield signAmino(chainId, signer, signDoc, this.snap_id);
      return res;
    });
  }
  signDirect(chainId, signer, signDoc) {
    return __awaiter4(this, void 0, void 0, function* () {
      let res = yield signDirect(chainId, signer, signDoc, this.snap_id);
      return {
        signature: res.signature,
        signed: {
          chainId: res.signed.chainId,
          accountNumber: signDoc.accountNumber,
          bodyBytes: new Uint8Array(Object.values(res.signed.bodyBytes)),
          authInfoBytes: new Uint8Array(Object.values(res.signed.authInfoBytes))
        }
      };
    });
  }
  signArbitrary(chainId, signer, data2) {
    return __awaiter4(this, void 0, void 0, function* () {
      let dataBase64 = typeof data2 != "string" ? Buffer.from(signer).toString("base64") : data2;
      let signDoc = {
        chain_id: "",
        account_number: "0",
        sequence: "0",
        fee: {
          "gas": "0",
          amount: []
        },
        msgs: [
          {
            type: "sign/MsgSignData",
            value: {
              signer,
              data: dataBase64
            }
          }
        ],
        memo: ""
      };
      let res = yield signAmino(chainId, signer, signDoc);
      return res.signature;
    });
  }
  sendTx(chainId, tx) {
    return __awaiter4(this, void 0, void 0, function* () {
      let res = yield sendTx(chainId, tx, this.snap_id);
      return res;
    });
  }
  getOfflineSigner(chainId, mode = "direct") {
    if (mode == "amino") {
      let signer = new CosmJSOfflineSigner(chainId, this.snap_id);
      signer.signDirect = void 0;
      return signer;
    } else {
      let signer = new CosmJSOfflineSigner(chainId, this.snap_id);
      signer.signAmino = void 0;
      return signer;
    }
  }
  getOfflineSignerOnlyAmino(chainId) {
    let signer = new CosmJSOfflineSigner(chainId, this.snap_id);
    signer.signDirect = void 0;
    return signer;
  }
  setupAppwrite(appwrite_url, appwrite_id) {
    this.appwrite = new Appwrite(appwrite_url, appwrite_id);
  }
  checkMultisigSetup() {
    if (!this.appwrite) {
      throw new Error('Multisig use is not setup. Please use "setupAppwrite" method to setup the multisig database.');
    }
  }
  getPendingMultisigTx(multisigPublicKey, memberPublicKey) {
    return __awaiter4(this, void 0, void 0, function* () {
      this.checkMultisigSetup();
      const multisigs = yield this.appwrite.getMultiSigs(memberPublicKey);
      const ms2 = multisigs.find((ms3) => ms3.public_key === multisigPublicKey);
      if (!ms2) {
        throw new Error(`Multisig with public key ${multisigPublicKey} not found`);
      }
      return {
        transaction: ms2.transactions.length > 0 ? ms2.transactions[0] : null,
        hasPending: ms2.transactions.length > 0
      };
    });
  }
  signPendingMultisigTx(public_key, rpc, fee, prefix, signature, signer_address) {
    return __awaiter4(this, void 0, void 0, function* () {
      this.checkMultisigSetup();
      const res = yield this.appwrite.signMultiSigTx(public_key, rpc, fee, prefix, signature, signer_address);
      return res;
    });
  }
  deletePendingMultisigTx(tx_id) {
    return __awaiter4(this, void 0, void 0, function* () {
      this.checkMultisigSetup();
      const res = yield this.appwrite.deleteMultisigTx(tx_id);
      return res;
    });
  }
  createMultisigTx(public_key, rpc, prefix, signature, body_bytes, messages, chain_id, signer_address, fee) {
    return __awaiter4(this, void 0, void 0, function* () {
      this.checkMultisigSetup();
      const res = yield this.appwrite.createMultiSigTx(public_key, rpc, prefix, signature, body_bytes, messages, chain_id, signer_address, fee);
      return res;
    });
  }
  getMultisigs(memberPublicKey) {
    return __awaiter4(this, void 0, void 0, function* () {
      this.checkMultisigSetup();
      const multisigs = yield this.appwrite.getMultiSigs(memberPublicKey);
      return multisigs;
    });
  }
  createNewMultisig(name2, threshold, pubKeys) {
    return __awaiter4(this, void 0, void 0, function* () {
      this.checkMultisigSetup();
      const res = yield this.appwrite.createMultiSig(name2, threshold, pubKeys);
      return res;
    });
  }
};

// node_modules/.pnpm/graz@0.4.2_@cosmjs+amino@0.37.0_@cosmjs+cosmwasm-stargate@0.37.0_bufferutil@4.0.9_utf-8_5d60c0582feff04f176a50b2e50a338d/node_modules/graz/dist/index.mjs
var import_amino = __toESM(require_build5(), 1);
var import_long2 = __toESM(require_long(), 1);
var import_encoding = __toESM(require_build2(), 1);

// node_modules/.pnpm/@walletconnect+modal@2.7.0_@types+react@19.2.7_react@19.2.1/node_modules/@walletconnect/modal/dist/index.js
var WalletConnectModal = class {
  constructor(config) {
    this.openModal = ModalCtrl.open;
    this.closeModal = ModalCtrl.close;
    this.subscribeModal = ModalCtrl.subscribe;
    this.setTheme = ThemeCtrl.setThemeConfig;
    ThemeCtrl.setThemeConfig(config);
    ConfigCtrl.setConfig(config);
    this.initUi();
  }
  async initUi() {
    if (typeof window !== "undefined") {
      await import("./dist-JBZPCH7M.js");
      const modal = document.createElement("wcm-modal");
      document.body.insertAdjacentElement("beforeend", modal);
      OptionsCtrl.setIsUiLoaded(true);
    }
  }
};

// node_modules/.pnpm/@walletconnect+core@2.20.2_@react-native-async-storage+async-storage@1.24.0_react-nativ_cc14b32657dc4d181db251c4aab5d975/node_modules/@walletconnect/core/dist/index.es.js
var import_events3 = __toESM(require_events());

// node_modules/.pnpm/@walletconnect+types@2.20.2_@react-native-async-storage+async-storage@1.24.0_react-nati_fb5ce7986fb12d90b8d936a34fdf0362/node_modules/@walletconnect/types/dist/index.es.js
var import_events2 = __toESM(require_events());
var a = Object.defineProperty;
var u2 = (e, s2, r2) => s2 in e ? a(e, s2, { enumerable: true, configurable: true, writable: true, value: r2 }) : e[s2] = r2;
var c = (e, s2, r2) => u2(e, typeof s2 != "symbol" ? s2 + "" : s2, r2);
var h2 = class extends IEvents {
  constructor(s2) {
    super(), this.opts = s2, c(this, "protocol", "wc"), c(this, "version", 2);
  }
};
var p2 = Object.defineProperty;
var b2 = (e, s2, r2) => s2 in e ? p2(e, s2, { enumerable: true, configurable: true, writable: true, value: r2 }) : e[s2] = r2;
var v2 = (e, s2, r2) => b2(e, typeof s2 != "symbol" ? s2 + "" : s2, r2);
var I = class extends IEvents {
  constructor(s2, r2) {
    super(), this.core = s2, this.logger = r2, v2(this, "records", /* @__PURE__ */ new Map());
  }
};
var y2 = class {
  constructor(s2, r2) {
    this.logger = s2, this.core = r2;
  }
};
var m2 = class extends IEvents {
  constructor(s2, r2) {
    super(), this.relayer = s2, this.logger = r2;
  }
};
var d = class extends IEvents {
  constructor(s2) {
    super();
  }
};
var f3 = class {
  constructor(s2, r2, t, q2) {
    this.core = s2, this.logger = r2, this.name = t;
  }
};
var P2 = class extends IEvents {
  constructor(s2, r2) {
    super(), this.relayer = s2, this.logger = r2;
  }
};
var S = class extends IEvents {
  constructor(s2, r2) {
    super(), this.core = s2, this.logger = r2;
  }
};
var M2 = class {
  constructor(s2, r2, t) {
    this.core = s2, this.logger = r2, this.store = t;
  }
};
var O2 = class {
  constructor(s2, r2) {
    this.projectId = s2, this.logger = r2;
  }
};
var R3 = class {
  constructor(s2, r2, t) {
    this.core = s2, this.logger = r2, this.telemetryEnabled = t;
  }
};
var T2 = Object.defineProperty;
var k2 = (e, s2, r2) => s2 in e ? T2(e, s2, { enumerable: true, configurable: true, writable: true, value: r2 }) : e[s2] = r2;
var i2 = (e, s2, r2) => k2(e, typeof s2 != "symbol" ? s2 + "" : s2, r2);
var J2 = class {
  constructor(s2) {
    this.opts = s2, i2(this, "protocol", "wc"), i2(this, "version", 2);
  }
};
var V = class {
  constructor(s2) {
    this.client = s2;
  }
};

// node_modules/.pnpm/@walletconnect+core@2.20.2_@react-native-async-storage+async-storage@1.24.0_react-nativ_cc14b32657dc4d181db251c4aab5d975/node_modules/@walletconnect/core/dist/index.es.js
var import_time2 = __toESM(require_cjs());

// node_modules/.pnpm/@walletconnect+utils@2.20.2_@react-native-async-storage+async-storage@1.24.0_react-nati_e08490726070128b4e0247c6bf3c2e85/node_modules/@walletconnect/utils/dist/index.es.js
var import_time = __toESM(require_cjs());
var import_window_getters = __toESM(require_cjs2());
var import_window_metadata = __toESM(require_cjs3());
var se = ":";
function Ie(t) {
  const [e, n2] = t.split(se);
  return { namespace: e, reference: n2 };
}
function ce(t, e) {
  return t.includes(":") ? [t] : e.chains || [];
}
var Zo = Object.defineProperty;
var Yo = Object.defineProperties;
var Go = Object.getOwnPropertyDescriptors;
var Tn = Object.getOwnPropertySymbols;
var Wo = Object.prototype.hasOwnProperty;
var Xo = Object.prototype.propertyIsEnumerable;
var Rn = (t, e, n2) => e in t ? Zo(t, e, { enumerable: true, configurable: true, writable: true, value: n2 }) : t[e] = n2;
var _n = (t, e) => {
  for (var n2 in e || (e = {})) Wo.call(e, n2) && Rn(t, n2, e[n2]);
  if (Tn) for (var n2 of Tn(e)) Xo.call(e, n2) && Rn(t, n2, e[n2]);
  return t;
};
var Jo = (t, e) => Yo(t, Go(e));
var $n = "ReactNative";
var Y3 = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" };
var jn = "js";
function Re() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function pt() {
  return !(0, import_window_getters.getDocument)() && !!(0, import_window_getters.getNavigator)() && navigator.product === $n;
}
function ei() {
  return pt() && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u" && (global == null ? void 0 : global.Platform.OS) === "android";
}
function ni() {
  return pt() && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u" && (global == null ? void 0 : global.Platform.OS) === "ios";
}
function Yt() {
  return !Re() && !!(0, import_window_getters.getNavigator)() && !!(0, import_window_getters.getDocument)();
}
function xt() {
  return pt() ? Y3.reactNative : Re() ? Y3.node : Yt() ? Y3.browser : Y3.unknown;
}
function ri() {
  var t;
  try {
    return pt() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (t = global.Application) == null ? void 0 : t.applicationId : void 0;
  } catch {
    return;
  }
}
function Cn(t, e) {
  const n2 = new URLSearchParams(t);
  for (const r2 of Object.keys(e).sort()) if (e.hasOwnProperty(r2)) {
    const o3 = e[r2];
    o3 !== void 0 && n2.set(r2, o3);
  }
  return n2.toString();
}
function oi(t) {
  var e, n2;
  const r2 = Pn();
  try {
    return t != null && t.url && r2.url && t.url !== r2.url && (console.warn(`The configured WalletConnect 'metadata.url':${t.url} differs from the actual page url:${r2.url}. This is probably unintended and can lead to issues.`), t.url = r2.url), (e = t?.icons) != null && e.length && t.icons.length > 0 && (t.icons = t.icons.filter((o3) => o3 !== "")), Jo(_n(_n({}, r2), t), { url: t?.url || r2.url, name: t?.name || r2.name, description: t?.description || r2.description, icons: (n2 = t?.icons) != null && n2.length && t.icons.length > 0 ? t.icons : r2.icons });
  } catch (o3) {
    return console.warn("Error populating app metadata", o3), t || r2;
  }
}
function Pn() {
  return (0, import_window_metadata.getWindowMetadata)() || { name: "", description: "", url: "", icons: [""] };
}
function kn() {
  if (xt() === Y3.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: n2, Version: r2 } = global.Platform;
    return [n2, r2].join("-");
  }
  const t = detect();
  if (t === null) return "unknown";
  const e = t.os ? t.os.replace(" ", "").toLowerCase() : "unknown";
  return t.type === "browser" ? [e, t.name, t.version].join("-") : [e, t.version].join("-");
}
function Vn() {
  var t;
  const e = xt();
  return e === Y3.browser ? [e, ((t = (0, import_window_getters.getLocation)()) == null ? void 0 : t.host) || "unknown"].join(":") : e;
}
function Mn(t, e, n2) {
  const r2 = kn(), o3 = Vn();
  return [[t, e].join("-"), [jn, n2].join("-"), r2, o3].join("/");
}
function si({ protocol: t, version: e, relayUrl: n2, sdkVersion: r2, auth: o3, projectId: i3, useOnCloseEvent: s2, bundleId: c3, packageName: a2 }) {
  const u4 = n2.split("?"), l3 = Mn(t, e, r2), f6 = { auth: o3, ua: l3, projectId: i3, useOnCloseEvent: s2 || void 0, packageName: a2 || void 0, bundleId: c3 || void 0 }, h4 = Cn(u4[1] || "", f6);
  return u4[0] + "?" + h4;
}
function gt(t, e) {
  return t.filter((n2) => e.includes(n2)).length === t.length;
}
function fi(t) {
  return Object.fromEntries(t.entries());
}
function li(t) {
  return new Map(Object.entries(t));
}
function gi(t = import_time.FIVE_MINUTES, e) {
  const n2 = (0, import_time.toMiliseconds)(t || import_time.FIVE_MINUTES);
  let r2, o3, i3, s2;
  return { resolve: (c3) => {
    i3 && r2 && (clearTimeout(i3), r2(c3), s2 = Promise.resolve(c3));
  }, reject: (c3) => {
    i3 && o3 && (clearTimeout(i3), o3(c3));
  }, done: () => new Promise((c3, a2) => {
    if (s2) return c3(s2);
    i3 = setTimeout(() => {
      const u4 = new Error(e);
      s2 = Promise.reject(u4), a2(u4);
    }, n2), r2 = c3, o3 = a2;
  }) };
}
function yi(t, e, n2) {
  return new Promise(async (r2, o3) => {
    const i3 = setTimeout(() => o3(new Error(n2)), e);
    try {
      const s2 = await t;
      r2(s2);
    } catch (s2) {
      o3(s2);
    }
    clearTimeout(i3);
  });
}
function _e(t, e) {
  if (typeof e == "string" && e.startsWith(`${t}:`)) return e;
  if (t.toLowerCase() === "topic") {
    if (typeof e != "string") throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${e}`;
  } else if (t.toLowerCase() === "id") {
    if (typeof e != "number") throw new Error('Value must be "number" for expirer target type: id');
    return `id:${e}`;
  }
  throw new Error(`Unknown expirer target type: ${t}`);
}
function mi(t) {
  return _e("topic", t);
}
function wi(t) {
  return _e("id", t);
}
function bi(t) {
  const [e, n2] = t.split(":"), r2 = { id: void 0, topic: void 0 };
  if (e === "topic" && typeof n2 == "string") r2.topic = n2;
  else if (e === "id" && Number.isInteger(Number(n2))) r2.id = Number(n2);
  else throw new Error(`Invalid target, expected id:number or topic:string, got ${e}:${n2}`);
  return r2;
}
function Ei(t, e) {
  return (0, import_time.fromMiliseconds)((e || Date.now()) + (0, import_time.toMiliseconds)(t));
}
function vi(t) {
  return Date.now() >= (0, import_time.toMiliseconds)(t);
}
function xi(t, e) {
  return `${t}${e ? `:${e}` : ""}`;
}
function at(t = [], e = []) {
  return [.../* @__PURE__ */ new Set([...t, ...e])];
}
async function Si({ id: t, topic: e, wcDeepLink: n2 }) {
  var r2;
  try {
    if (!n2) return;
    const o3 = typeof n2 == "string" ? JSON.parse(n2) : n2, i3 = o3?.href;
    if (typeof i3 != "string") return;
    const s2 = Kn(i3, t, e), c3 = xt();
    if (c3 === Y3.browser) {
      if (!((r2 = (0, import_window_getters.getDocument)()) != null && r2.hasFocus())) {
        console.warn("Document does not have focus, skipping deeplink.");
        return;
      }
      Fn(s2);
    } else c3 === Y3.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(s2);
  } catch (o3) {
    console.error(o3);
  }
}
function Kn(t, e, n2) {
  const r2 = `requestId=${e}&sessionTopic=${n2}`;
  t.endsWith("/") && (t = t.slice(0, -1));
  let o3 = `${t}`;
  if (t.startsWith("https://t.me")) {
    const i3 = t.includes("?") ? "&startapp=" : "?startapp=";
    o3 = `${o3}${i3}${Yn(r2, true)}`;
  } else o3 = `${o3}/wc?${r2}`;
  return o3;
}
function Fn(t) {
  let e = "_self";
  Zn() ? e = "_top" : (zn() || t.startsWith("https://") || t.startsWith("http://")) && (e = "_blank"), window.open(t, e, "noreferrer noopener");
}
async function Oi(t, e) {
  let n2 = "";
  try {
    if (Yt() && (n2 = localStorage.getItem(e), n2)) return n2;
    n2 = await t.getItem(e);
  } catch (r2) {
    console.error(r2);
  }
  return n2;
}
function Ai(t, e) {
  if (!t.includes(e)) return null;
  const n2 = t.split(/([&,?,=])/), r2 = n2.indexOf(e);
  return n2[r2 + 2];
}
function Bi() {
  return typeof crypto < "u" && crypto != null && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (t) => {
    const e = Math.random() * 16 | 0;
    return (t === "x" ? e : e & 3 | 8).toString(16);
  });
}
function Ii() {
  return typeof process < "u" && process.env.IS_VITEST === "true";
}
function zn() {
  return typeof window < "u" && (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto);
}
function Zn() {
  try {
    return window.self !== window.top;
  } catch {
    return false;
  }
}
function Yn(t, e = false) {
  const n2 = Buffer.from(t).toString("base64");
  return e ? n2.replace(/[=]/g, "") : n2;
}
function Le(t) {
  return Buffer.from(t, "base64").toString("utf-8");
}
function Ni(t) {
  return new Promise((e) => setTimeout(e, t));
}
function Gt(t) {
  if (!Number.isSafeInteger(t) || t < 0) throw new Error("positive integer expected, got " + t);
}
function Ui(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function Wt(t, ...e) {
  if (!Ui(t)) throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(t.length)) throw new Error("Uint8Array expected of length " + e + ", got length=" + t.length);
}
function je(t) {
  if (typeof t != "function" || typeof t.create != "function") throw new Error("Hash should be wrapped by utils.wrapConstructor");
  Gt(t.outputLen), Gt(t.blockLen);
}
function Tt(t, e = true) {
  if (t.destroyed) throw new Error("Hash instance has been destroyed");
  if (e && t.finished) throw new Error("Hash#digest() has already been called");
}
function Gn(t, e) {
  Wt(t);
  const n2 = e.outputLen;
  if (t.length < n2) throw new Error("digestInto() expects output buffer of length at least " + n2);
}
var ue = BigInt(2 ** 32 - 1);
var Wn = BigInt(32);
function Ti(t, e = false) {
  return e ? { h: Number(t & ue), l: Number(t >> Wn & ue) } : { h: Number(t >> Wn & ue) | 0, l: Number(t & ue) | 0 };
}
function Ri(t, e = false) {
  let n2 = new Uint32Array(t.length), r2 = new Uint32Array(t.length);
  for (let o3 = 0; o3 < t.length; o3++) {
    const { h: i3, l: s2 } = Ti(t[o3], e);
    [n2[o3], r2[o3]] = [i3, s2];
  }
  return [n2, r2];
}
var _i = (t, e, n2) => t << n2 | e >>> 32 - n2;
var $i = (t, e, n2) => e << n2 | t >>> 32 - n2;
var Li = (t, e, n2) => e << n2 - 32 | t >>> 64 - n2;
var ji = (t, e, n2) => t << n2 - 32 | e >>> 64 - n2;
var Rt = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
function Ci(t) {
  return new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4));
}
function Ce(t) {
  return new DataView(t.buffer, t.byteOffset, t.byteLength);
}
function st(t, e) {
  return t << 32 - e | t >>> e;
}
var Xn = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function Pi(t) {
  return t << 24 & 4278190080 | t << 8 & 16711680 | t >>> 8 & 65280 | t >>> 24 & 255;
}
function Jn(t) {
  for (let e = 0; e < t.length; e++) t[e] = Pi(t[e]);
}
function ki(t) {
  if (typeof t != "string") throw new Error("utf8ToBytes expected string, got " + typeof t);
  return new Uint8Array(new TextEncoder().encode(t));
}
function _t(t) {
  return typeof t == "string" && (t = ki(t)), Wt(t), t;
}
function Vi(...t) {
  let e = 0;
  for (let r2 = 0; r2 < t.length; r2++) {
    const o3 = t[r2];
    Wt(o3), e += o3.length;
  }
  const n2 = new Uint8Array(e);
  for (let r2 = 0, o3 = 0; r2 < t.length; r2++) {
    const i3 = t[r2];
    n2.set(i3, o3), o3 += i3.length;
  }
  return n2;
}
var Pe = class {
  clone() {
    return this._cloneInto();
  }
};
function Qn(t) {
  const e = (r2) => t().update(_t(r2)).digest(), n2 = t();
  return e.outputLen = n2.outputLen, e.blockLen = n2.blockLen, e.create = () => t(), e;
}
function $t(t = 32) {
  if (Rt && typeof Rt.getRandomValues == "function") return Rt.getRandomValues(new Uint8Array(t));
  if (Rt && typeof Rt.randomBytes == "function") return Rt.randomBytes(t);
  throw new Error("crypto.getRandomValues must be defined");
}
var tr = [];
var er = [];
var nr = [];
var Mi = BigInt(0);
var Xt = BigInt(1);
var Di = BigInt(2);
var Hi = BigInt(7);
var qi = BigInt(256);
var Ki = BigInt(113);
for (let t = 0, e = Xt, n2 = 1, r2 = 0; t < 24; t++) {
  [n2, r2] = [r2, (2 * n2 + 3 * r2) % 5], tr.push(2 * (5 * r2 + n2)), er.push((t + 1) * (t + 2) / 2 % 64);
  let o3 = Mi;
  for (let i3 = 0; i3 < 7; i3++) e = (e << Xt ^ (e >> Hi) * Ki) % qi, e & Di && (o3 ^= Xt << (Xt << BigInt(i3)) - Xt);
  nr.push(o3);
}
var [Fi, zi] = Ri(nr, true);
var rr = (t, e, n2) => n2 > 32 ? Li(t, e, n2) : _i(t, e, n2);
var or2 = (t, e, n2) => n2 > 32 ? ji(t, e, n2) : $i(t, e, n2);
function Zi(t, e = 24) {
  const n2 = new Uint32Array(10);
  for (let r2 = 24 - e; r2 < 24; r2++) {
    for (let s2 = 0; s2 < 10; s2++) n2[s2] = t[s2] ^ t[s2 + 10] ^ t[s2 + 20] ^ t[s2 + 30] ^ t[s2 + 40];
    for (let s2 = 0; s2 < 10; s2 += 2) {
      const c3 = (s2 + 8) % 10, a2 = (s2 + 2) % 10, u4 = n2[a2], l3 = n2[a2 + 1], f6 = rr(u4, l3, 1) ^ n2[c3], h4 = or2(u4, l3, 1) ^ n2[c3 + 1];
      for (let y4 = 0; y4 < 50; y4 += 10) t[s2 + y4] ^= f6, t[s2 + y4 + 1] ^= h4;
    }
    let o3 = t[2], i3 = t[3];
    for (let s2 = 0; s2 < 24; s2++) {
      const c3 = er[s2], a2 = rr(o3, i3, c3), u4 = or2(o3, i3, c3), l3 = tr[s2];
      o3 = t[l3], i3 = t[l3 + 1], t[l3] = a2, t[l3 + 1] = u4;
    }
    for (let s2 = 0; s2 < 50; s2 += 10) {
      for (let c3 = 0; c3 < 10; c3++) n2[c3] = t[s2 + c3];
      for (let c3 = 0; c3 < 10; c3++) t[s2 + c3] ^= ~n2[(c3 + 2) % 10] & n2[(c3 + 4) % 10];
    }
    t[0] ^= Fi[r2], t[1] ^= zi[r2];
  }
  n2.fill(0);
}
var En = class _En extends Pe {
  constructor(e, n2, r2, o3 = false, i3 = 24) {
    if (super(), this.blockLen = e, this.suffix = n2, this.outputLen = r2, this.enableXOF = o3, this.rounds = i3, this.pos = 0, this.posOut = 0, this.finished = false, this.destroyed = false, Gt(r2), 0 >= this.blockLen || this.blockLen >= 200) throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = Ci(this.state);
  }
  keccak() {
    Xn || Jn(this.state32), Zi(this.state32, this.rounds), Xn || Jn(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(e) {
    Tt(this);
    const { blockLen: n2, state: r2 } = this;
    e = _t(e);
    const o3 = e.length;
    for (let i3 = 0; i3 < o3; ) {
      const s2 = Math.min(n2 - this.pos, o3 - i3);
      for (let c3 = 0; c3 < s2; c3++) r2[this.pos++] ^= e[i3++];
      this.pos === n2 && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished) return;
    this.finished = true;
    const { state: e, suffix: n2, pos: r2, blockLen: o3 } = this;
    e[r2] ^= n2, (n2 & 128) !== 0 && r2 === o3 - 1 && this.keccak(), e[o3 - 1] ^= 128, this.keccak();
  }
  writeInto(e) {
    Tt(this, false), Wt(e), this.finish();
    const n2 = this.state, { blockLen: r2 } = this;
    for (let o3 = 0, i3 = e.length; o3 < i3; ) {
      this.posOut >= r2 && this.keccak();
      const s2 = Math.min(r2 - this.posOut, i3 - o3);
      e.set(n2.subarray(this.posOut, this.posOut + s2), o3), this.posOut += s2, o3 += s2;
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return Gt(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if (Gn(e, this), this.finished) throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true, this.state.fill(0);
  }
  _cloneInto(e) {
    const { blockLen: n2, suffix: r2, outputLen: o3, rounds: i3, enableXOF: s2 } = this;
    return e || (e = new _En(n2, r2, o3, s2, i3)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = i3, e.suffix = r2, e.outputLen = o3, e.enableXOF = s2, e.destroyed = this.destroyed, e;
  }
};
var Yi = (t, e, n2) => Qn(() => new En(e, t, n2));
var Gi = Yi(1, 136, 256 / 8);
var Wi = "https://rpc.walletconnect.org/v1";
function ke(t) {
  const e = `Ethereum Signed Message:
${t.length}`, n2 = new TextEncoder().encode(e + t);
  return "0x" + Buffer.from(Gi(n2)).toString("hex");
}
async function ir(t, e, n2, r2, o3, i3) {
  switch (n2.t) {
    case "eip191":
      return await sr(t, e, n2.s);
    case "eip1271":
      return await cr(t, e, n2.s, r2, o3, i3);
    default:
      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${n2.t}`);
  }
}
async function sr(t, e, n2) {
  return (await recoverAddress({ hash: ke(e), signature: n2 })).toLowerCase() === t.toLowerCase();
}
async function cr(t, e, n2, r2, o3, i3) {
  const s2 = Ie(r2);
  if (!s2.namespace || !s2.reference) throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${r2}`);
  try {
    const c3 = "0x1626ba7e", a2 = "0000000000000000000000000000000000000000000000000000000000000040", u4 = "0000000000000000000000000000000000000000000000000000000000000041", l3 = n2.substring(2), f6 = ke(e).substring(2), h4 = c3 + f6 + a2 + u4 + l3, y4 = await fetch(`${i3 || Wi}/?chainId=${r2}&projectId=${o3}`, { method: "POST", body: JSON.stringify({ id: Xi(), jsonrpc: "2.0", method: "eth_call", params: [{ to: t, data: h4 }, "latest"] }) }), { result: E5 } = await y4.json();
    return E5 ? E5.slice(0, c3.length).toLowerCase() === c3.toLowerCase() : false;
  } catch (c3) {
    return console.error("isValidEip1271Signature: ", c3), false;
  }
}
function Xi() {
  return Date.now() + Math.floor(Math.random() * 1e3);
}
function Ji(t) {
  const e = atob(t), n2 = new Uint8Array(e.length);
  for (let s2 = 0; s2 < e.length; s2++) n2[s2] = e.charCodeAt(s2);
  const r2 = n2[0];
  if (r2 === 0) throw new Error("No signatures found");
  const o3 = 1 + r2 * 64;
  if (n2.length < o3) throw new Error("Transaction data too short for claimed signature count");
  if (n2.length < 100) throw new Error("Transaction too short");
  const i3 = Buffer.from(t, "base64").slice(1, 65);
  return esm_default.encode(i3);
}
var Qi = Object.defineProperty;
var ts = Object.defineProperties;
var es = Object.getOwnPropertyDescriptors;
var ar = Object.getOwnPropertySymbols;
var ns = Object.prototype.hasOwnProperty;
var rs = Object.prototype.propertyIsEnumerable;
var ur = (t, e, n2) => e in t ? Qi(t, e, { enumerable: true, configurable: true, writable: true, value: n2 }) : t[e] = n2;
var Ve = (t, e) => {
  for (var n2 in e || (e = {})) ns.call(e, n2) && ur(t, n2, e[n2]);
  if (ar) for (var n2 of ar(e)) rs.call(e, n2) && ur(t, n2, e[n2]);
  return t;
};
var fr = (t, e) => ts(t, es(e));
var os = "did:pkh:";
var fe = (t) => t?.split(":");
var lr = (t) => {
  const e = t && fe(t);
  if (e) return t.includes(os) ? e[3] : e[1];
};
var dr = (t) => {
  const e = t && fe(t);
  if (e) return e[2] + ":" + e[3];
};
var Me = (t) => {
  const e = t && fe(t);
  if (e) return e.pop();
};
async function is(t) {
  const { cacao: e, projectId: n2 } = t, { s: r2, p: o3 } = e, i3 = hr(o3, o3.iss), s2 = Me(o3.iss);
  return await ir(s2, i3, r2, dr(o3.iss), n2);
}
var hr = (t, e) => {
  const n2 = `${t.domain} wants you to sign in with your Ethereum account:`, r2 = Me(e);
  if (!t.aud && !t.uri) throw new Error("Either `aud` or `uri` is required to construct the message");
  let o3 = t.statement || void 0;
  const i3 = `URI: ${t.aud || t.uri}`, s2 = `Version: ${t.version}`, c3 = `Chain ID: ${lr(e)}`, a2 = `Nonce: ${t.nonce}`, u4 = `Issued At: ${t.iat}`, l3 = t.exp ? `Expiration Time: ${t.exp}` : void 0, f6 = t.nbf ? `Not Before: ${t.nbf}` : void 0, h4 = t.requestId ? `Request ID: ${t.requestId}` : void 0, y4 = t.resources ? `Resources:${t.resources.map((p4) => `
- ${p4}`).join("")}` : void 0, E5 = de(t.resources);
  if (E5) {
    const p4 = yt(E5);
    o3 = qe(o3, p4);
  }
  return [n2, r2, "", o3, "", i3, s2, c3, a2, u4, l3, f6, h4, y4].filter((p4) => p4 != null).join(`
`);
};
function mr(t) {
  return Buffer.from(JSON.stringify(t)).toString("base64");
}
function wr(t) {
  return JSON.parse(Buffer.from(t, "base64").toString("utf-8"));
}
function ct(t) {
  if (!t) throw new Error("No recap provided, value is undefined");
  if (!t.att) throw new Error("No `att` property found");
  const e = Object.keys(t.att);
  if (!(e != null && e.length)) throw new Error("No resources found in `att` property");
  e.forEach((n2) => {
    const r2 = t.att[n2];
    if (Array.isArray(r2)) throw new Error(`Resource must be an object: ${n2}`);
    if (typeof r2 != "object") throw new Error(`Resource must be an object: ${n2}`);
    if (!Object.keys(r2).length) throw new Error(`Resource object is empty: ${n2}`);
    Object.keys(r2).forEach((o3) => {
      const i3 = r2[o3];
      if (!Array.isArray(i3)) throw new Error(`Ability limits ${o3} must be an array of objects, found: ${i3}`);
      if (!i3.length) throw new Error(`Value of ${o3} is empty array, must be an array with objects`);
      i3.forEach((s2) => {
        if (typeof s2 != "object") throw new Error(`Ability limits (${o3}) must be an array of objects, found: ${s2}`);
      });
    });
  });
}
function br(t, e, n2, r2 = {}) {
  return n2?.sort((o3, i3) => o3.localeCompare(i3)), { att: { [t]: De(e, n2, r2) } };
}
function De(t, e, n2 = {}) {
  e = e?.sort((o3, i3) => o3.localeCompare(i3));
  const r2 = e.map((o3) => ({ [`${t}/${o3}`]: [n2] }));
  return Object.assign({}, ...r2);
}
function le(t) {
  return ct(t), `urn:recap:${mr(t).replace(/=/g, "")}`;
}
function yt(t) {
  const e = wr(t.replace("urn:recap:", ""));
  return ct(e), e;
}
function fs(t, e, n2) {
  const r2 = br(t, e, n2);
  return le(r2);
}
function He(t) {
  return t && t.includes("urn:recap:");
}
function ls(t, e) {
  const n2 = yt(t), r2 = yt(e), o3 = vr(n2, r2);
  return le(o3);
}
function vr(t, e) {
  ct(t), ct(e);
  const n2 = Object.keys(t.att).concat(Object.keys(e.att)).sort((o3, i3) => o3.localeCompare(i3)), r2 = { att: {} };
  return n2.forEach((o3) => {
    var i3, s2;
    Object.keys(((i3 = t.att) == null ? void 0 : i3[o3]) || {}).concat(Object.keys(((s2 = e.att) == null ? void 0 : s2[o3]) || {})).sort((c3, a2) => c3.localeCompare(a2)).forEach((c3) => {
      var a2, u4;
      r2.att[o3] = fr(Ve({}, r2.att[o3]), { [c3]: ((a2 = t.att[o3]) == null ? void 0 : a2[c3]) || ((u4 = e.att[o3]) == null ? void 0 : u4[c3]) });
    });
  }), r2;
}
function qe(t = "", e) {
  ct(e);
  const n2 = "I further authorize the stated URI to perform the following actions on my behalf: ";
  if (t.includes(n2)) return t;
  const r2 = [];
  let o3 = 0;
  Object.keys(e.att).forEach((c3) => {
    const a2 = Object.keys(e.att[c3]).map((f6) => ({ ability: f6.split("/")[0], action: f6.split("/")[1] }));
    a2.sort((f6, h4) => f6.action.localeCompare(h4.action));
    const u4 = {};
    a2.forEach((f6) => {
      u4[f6.ability] || (u4[f6.ability] = []), u4[f6.ability].push(f6.action);
    });
    const l3 = Object.keys(u4).map((f6) => (o3++, `(${o3}) '${f6}': '${u4[f6].join("', '")}' for '${c3}'.`));
    r2.push(l3.join(", ").replace(".,", "."));
  });
  const i3 = r2.join(" "), s2 = `${n2}${i3}`;
  return `${t ? t + " " : ""}${s2}`;
}
function ds(t) {
  var e;
  const n2 = yt(t);
  ct(n2);
  const r2 = (e = n2.att) == null ? void 0 : e.eip155;
  return r2 ? Object.keys(r2).map((o3) => o3.split("/")[1]) : [];
}
function hs(t) {
  const e = yt(t);
  ct(e);
  const n2 = [];
  return Object.values(e.att).forEach((r2) => {
    Object.values(r2).forEach((o3) => {
      var i3;
      (i3 = o3?.[0]) != null && i3.chains && n2.push(o3[0].chains);
    });
  }), [...new Set(n2.flat())];
}
function de(t) {
  if (!t) return;
  const e = t?.[t.length - 1];
  return He(e) ? e : void 0;
}
function Ke(t) {
  if (!Number.isSafeInteger(t) || t < 0) throw new Error("positive integer expected, got " + t);
}
function Sr(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function tt(t, ...e) {
  if (!Sr(t)) throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(t.length)) throw new Error("Uint8Array expected of length " + e + ", got length=" + t.length);
}
function Or(t, e = true) {
  if (t.destroyed) throw new Error("Hash instance has been destroyed");
  if (e && t.finished) throw new Error("Hash#digest() has already been called");
}
function ps(t, e) {
  tt(t);
  const n2 = e.outputLen;
  if (t.length < n2) throw new Error("digestInto() expects output buffer of length at least " + n2);
}
function Ar(t) {
  if (typeof t != "boolean") throw new Error(`boolean expected, not ${t}`);
}
var mt = (t) => new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4));
var gs = (t) => new DataView(t.buffer, t.byteOffset, t.byteLength);
var ys = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!ys) throw new Error("Non little-endian hardware is not supported");
function ms(t) {
  if (typeof t != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(t));
}
function Fe(t) {
  if (typeof t == "string") t = ms(t);
  else if (Sr(t)) t = ze(t);
  else throw new Error("Uint8Array expected, got " + typeof t);
  return t;
}
function ws(t, e) {
  if (e == null || typeof e != "object") throw new Error("options must be defined");
  return Object.assign(t, e);
}
function bs(t, e) {
  if (t.length !== e.length) return false;
  let n2 = 0;
  for (let r2 = 0; r2 < t.length; r2++) n2 |= t[r2] ^ e[r2];
  return n2 === 0;
}
var Es = (t, e) => {
  function n2(r2, ...o3) {
    if (tt(r2), t.nonceLength !== void 0) {
      const l3 = o3[0];
      if (!l3) throw new Error("nonce / iv required");
      t.varSizeNonce ? tt(l3) : tt(l3, t.nonceLength);
    }
    const i3 = t.tagLength;
    i3 && o3[1] !== void 0 && tt(o3[1]);
    const s2 = e(r2, ...o3), c3 = (l3, f6) => {
      if (f6 !== void 0) {
        if (l3 !== 2) throw new Error("cipher output not supported");
        tt(f6);
      }
    };
    let a2 = false;
    return { encrypt(l3, f6) {
      if (a2) throw new Error("cannot encrypt() twice with same key + nonce");
      return a2 = true, tt(l3), c3(s2.encrypt.length, f6), s2.encrypt(l3, f6);
    }, decrypt(l3, f6) {
      if (tt(l3), i3 && l3.length < i3) throw new Error("invalid ciphertext length: smaller than tagLength=" + i3);
      return c3(s2.decrypt.length, f6), s2.decrypt(l3, f6);
    } };
  }
  return Object.assign(n2, t), n2;
};
function Br(t, e, n2 = true) {
  if (e === void 0) return new Uint8Array(t);
  if (e.length !== t) throw new Error("invalid output length, expected " + t + ", got: " + e.length);
  if (n2 && !vs(e)) throw new Error("invalid output, must be aligned");
  return e;
}
function Ir(t, e, n2, r2) {
  if (typeof t.setBigUint64 == "function") return t.setBigUint64(e, n2, r2);
  const o3 = BigInt(32), i3 = BigInt(4294967295), s2 = Number(n2 >> o3 & i3), c3 = Number(n2 & i3), a2 = r2 ? 4 : 0, u4 = r2 ? 0 : 4;
  t.setUint32(e + a2, s2, r2), t.setUint32(e + u4, c3, r2);
}
function vs(t) {
  return t.byteOffset % 4 === 0;
}
function ze(t) {
  return Uint8Array.from(t);
}
function Lt(...t) {
  for (let e = 0; e < t.length; e++) t[e].fill(0);
}
var Nr = (t) => Uint8Array.from(t.split("").map((e) => e.charCodeAt(0)));
var xs = Nr("expand 16-byte k");
var Ss = Nr("expand 32-byte k");
var Os = mt(xs);
var As = mt(Ss);
function V2(t, e) {
  return t << e | t >>> 32 - e;
}
function Ze(t) {
  return t.byteOffset % 4 === 0;
}
var he = 64;
var Bs = 16;
var Ur = 2 ** 32 - 1;
var Tr = new Uint32Array();
function Is(t, e, n2, r2, o3, i3, s2, c3) {
  const a2 = o3.length, u4 = new Uint8Array(he), l3 = mt(u4), f6 = Ze(o3) && Ze(i3), h4 = f6 ? mt(o3) : Tr, y4 = f6 ? mt(i3) : Tr;
  for (let E5 = 0; E5 < a2; s2++) {
    if (t(e, n2, r2, l3, s2, c3), s2 >= Ur) throw new Error("arx: counter overflow");
    const p4 = Math.min(he, a2 - E5);
    if (f6 && p4 === he) {
      const d3 = E5 / 4;
      if (E5 % 4 !== 0) throw new Error("arx: invalid block position");
      for (let v9 = 0, m3; v9 < Bs; v9++) m3 = d3 + v9, y4[m3] = h4[m3] ^ l3[v9];
      E5 += he;
      continue;
    }
    for (let d3 = 0, v9; d3 < p4; d3++) v9 = E5 + d3, i3[v9] = o3[v9] ^ u4[d3];
    E5 += p4;
  }
}
function Ns(t, e) {
  const { allowShortKeys: n2, extendNonceFn: r2, counterLength: o3, counterRight: i3, rounds: s2 } = ws({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, e);
  if (typeof t != "function") throw new Error("core must be a function");
  return Ke(o3), Ke(s2), Ar(i3), Ar(n2), (c3, a2, u4, l3, f6 = 0) => {
    tt(c3), tt(a2), tt(u4);
    const h4 = u4.length;
    if (l3 === void 0 && (l3 = new Uint8Array(h4)), tt(l3), Ke(f6), f6 < 0 || f6 >= Ur) throw new Error("arx: counter overflow");
    if (l3.length < h4) throw new Error(`arx: output (${l3.length}) is shorter than data (${h4})`);
    const y4 = [];
    let E5 = c3.length, p4, d3;
    if (E5 === 32) y4.push(p4 = ze(c3)), d3 = As;
    else if (E5 === 16 && n2) p4 = new Uint8Array(32), p4.set(c3), p4.set(c3, 16), d3 = Os, y4.push(p4);
    else throw new Error(`arx: invalid 32-byte key, got length=${E5}`);
    Ze(a2) || y4.push(a2 = ze(a2));
    const v9 = mt(p4);
    if (r2) {
      if (a2.length !== 24) throw new Error("arx: extended nonce must be 24 bytes");
      r2(d3, v9, mt(a2.subarray(0, 16)), v9), a2 = a2.subarray(16);
    }
    const m3 = 16 - o3;
    if (m3 !== a2.length) throw new Error(`arx: nonce must be ${m3} or 16 bytes`);
    if (m3 !== 12) {
      const N2 = new Uint8Array(12);
      N2.set(a2, i3 ? 0 : 12 - a2.length), a2 = N2, y4.push(a2);
    }
    const O5 = mt(a2);
    return Is(t, d3, v9, O5, u4, l3, f6, s2), Lt(...y4), l3;
  };
}
var F3 = (t, e) => t[e++] & 255 | (t[e++] & 255) << 8;
var Us = class {
  constructor(e) {
    this.blockLen = 16, this.outputLen = 16, this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.pos = 0, this.finished = false, e = Fe(e), tt(e, 32);
    const n2 = F3(e, 0), r2 = F3(e, 2), o3 = F3(e, 4), i3 = F3(e, 6), s2 = F3(e, 8), c3 = F3(e, 10), a2 = F3(e, 12), u4 = F3(e, 14);
    this.r[0] = n2 & 8191, this.r[1] = (n2 >>> 13 | r2 << 3) & 8191, this.r[2] = (r2 >>> 10 | o3 << 6) & 7939, this.r[3] = (o3 >>> 7 | i3 << 9) & 8191, this.r[4] = (i3 >>> 4 | s2 << 12) & 255, this.r[5] = s2 >>> 1 & 8190, this.r[6] = (s2 >>> 14 | c3 << 2) & 8191, this.r[7] = (c3 >>> 11 | a2 << 5) & 8065, this.r[8] = (a2 >>> 8 | u4 << 8) & 8191, this.r[9] = u4 >>> 5 & 127;
    for (let l3 = 0; l3 < 8; l3++) this.pad[l3] = F3(e, 16 + 2 * l3);
  }
  process(e, n2, r2 = false) {
    const o3 = r2 ? 0 : 2048, { h: i3, r: s2 } = this, c3 = s2[0], a2 = s2[1], u4 = s2[2], l3 = s2[3], f6 = s2[4], h4 = s2[5], y4 = s2[6], E5 = s2[7], p4 = s2[8], d3 = s2[9], v9 = F3(e, n2 + 0), m3 = F3(e, n2 + 2), O5 = F3(e, n2 + 4), N2 = F3(e, n2 + 6), $6 = F3(e, n2 + 8), B4 = F3(e, n2 + 10), A5 = F3(e, n2 + 12), T4 = F3(e, n2 + 14);
    let S3 = i3[0] + (v9 & 8191), L3 = i3[1] + ((v9 >>> 13 | m3 << 3) & 8191), U4 = i3[2] + ((m3 >>> 10 | O5 << 6) & 8191), _2 = i3[3] + ((O5 >>> 7 | N2 << 9) & 8191), j3 = i3[4] + ((N2 >>> 4 | $6 << 12) & 8191), g2 = i3[5] + ($6 >>> 1 & 8191), w4 = i3[6] + (($6 >>> 14 | B4 << 2) & 8191), b5 = i3[7] + ((B4 >>> 11 | A5 << 5) & 8191), I3 = i3[8] + ((A5 >>> 8 | T4 << 8) & 8191), R6 = i3[9] + (T4 >>> 5 | o3), x3 = 0, C5 = x3 + S3 * c3 + L3 * (5 * d3) + U4 * (5 * p4) + _2 * (5 * E5) + j3 * (5 * y4);
    x3 = C5 >>> 13, C5 &= 8191, C5 += g2 * (5 * h4) + w4 * (5 * f6) + b5 * (5 * l3) + I3 * (5 * u4) + R6 * (5 * a2), x3 += C5 >>> 13, C5 &= 8191;
    let P5 = x3 + S3 * a2 + L3 * c3 + U4 * (5 * d3) + _2 * (5 * p4) + j3 * (5 * E5);
    x3 = P5 >>> 13, P5 &= 8191, P5 += g2 * (5 * y4) + w4 * (5 * h4) + b5 * (5 * f6) + I3 * (5 * l3) + R6 * (5 * u4), x3 += P5 >>> 13, P5 &= 8191;
    let k5 = x3 + S3 * u4 + L3 * a2 + U4 * c3 + _2 * (5 * d3) + j3 * (5 * p4);
    x3 = k5 >>> 13, k5 &= 8191, k5 += g2 * (5 * E5) + w4 * (5 * y4) + b5 * (5 * h4) + I3 * (5 * f6) + R6 * (5 * l3), x3 += k5 >>> 13, k5 &= 8191;
    let M5 = x3 + S3 * l3 + L3 * u4 + U4 * a2 + _2 * c3 + j3 * (5 * d3);
    x3 = M5 >>> 13, M5 &= 8191, M5 += g2 * (5 * p4) + w4 * (5 * E5) + b5 * (5 * y4) + I3 * (5 * h4) + R6 * (5 * f6), x3 += M5 >>> 13, M5 &= 8191;
    let D3 = x3 + S3 * f6 + L3 * l3 + U4 * u4 + _2 * a2 + j3 * c3;
    x3 = D3 >>> 13, D3 &= 8191, D3 += g2 * (5 * d3) + w4 * (5 * p4) + b5 * (5 * E5) + I3 * (5 * y4) + R6 * (5 * h4), x3 += D3 >>> 13, D3 &= 8191;
    let z4 = x3 + S3 * h4 + L3 * f6 + U4 * l3 + _2 * u4 + j3 * a2;
    x3 = z4 >>> 13, z4 &= 8191, z4 += g2 * c3 + w4 * (5 * d3) + b5 * (5 * p4) + I3 * (5 * E5) + R6 * (5 * y4), x3 += z4 >>> 13, z4 &= 8191;
    let Z3 = x3 + S3 * y4 + L3 * h4 + U4 * f6 + _2 * l3 + j3 * u4;
    x3 = Z3 >>> 13, Z3 &= 8191, Z3 += g2 * a2 + w4 * c3 + b5 * (5 * d3) + I3 * (5 * p4) + R6 * (5 * E5), x3 += Z3 >>> 13, Z3 &= 8191;
    let it2 = x3 + S3 * E5 + L3 * y4 + U4 * h4 + _2 * f6 + j3 * l3;
    x3 = it2 >>> 13, it2 &= 8191, it2 += g2 * u4 + w4 * a2 + b5 * c3 + I3 * (5 * d3) + R6 * (5 * p4), x3 += it2 >>> 13, it2 &= 8191;
    let W3 = x3 + S3 * p4 + L3 * E5 + U4 * y4 + _2 * h4 + j3 * f6;
    x3 = W3 >>> 13, W3 &= 8191, W3 += g2 * l3 + w4 * u4 + b5 * a2 + I3 * c3 + R6 * (5 * d3), x3 += W3 >>> 13, W3 &= 8191;
    let J5 = x3 + S3 * d3 + L3 * p4 + U4 * E5 + _2 * y4 + j3 * h4;
    x3 = J5 >>> 13, J5 &= 8191, J5 += g2 * f6 + w4 * l3 + b5 * u4 + I3 * a2 + R6 * c3, x3 += J5 >>> 13, J5 &= 8191, x3 = (x3 << 2) + x3 | 0, x3 = x3 + C5 | 0, C5 = x3 & 8191, x3 = x3 >>> 13, P5 += x3, i3[0] = C5, i3[1] = P5, i3[2] = k5, i3[3] = M5, i3[4] = D3, i3[5] = z4, i3[6] = Z3, i3[7] = it2, i3[8] = W3, i3[9] = J5;
  }
  finalize() {
    const { h: e, pad: n2 } = this, r2 = new Uint16Array(10);
    let o3 = e[1] >>> 13;
    e[1] &= 8191;
    for (let c3 = 2; c3 < 10; c3++) e[c3] += o3, o3 = e[c3] >>> 13, e[c3] &= 8191;
    e[0] += o3 * 5, o3 = e[0] >>> 13, e[0] &= 8191, e[1] += o3, o3 = e[1] >>> 13, e[1] &= 8191, e[2] += o3, r2[0] = e[0] + 5, o3 = r2[0] >>> 13, r2[0] &= 8191;
    for (let c3 = 1; c3 < 10; c3++) r2[c3] = e[c3] + o3, o3 = r2[c3] >>> 13, r2[c3] &= 8191;
    r2[9] -= 8192;
    let i3 = (o3 ^ 1) - 1;
    for (let c3 = 0; c3 < 10; c3++) r2[c3] &= i3;
    i3 = ~i3;
    for (let c3 = 0; c3 < 10; c3++) e[c3] = e[c3] & i3 | r2[c3];
    e[0] = (e[0] | e[1] << 13) & 65535, e[1] = (e[1] >>> 3 | e[2] << 10) & 65535, e[2] = (e[2] >>> 6 | e[3] << 7) & 65535, e[3] = (e[3] >>> 9 | e[4] << 4) & 65535, e[4] = (e[4] >>> 12 | e[5] << 1 | e[6] << 14) & 65535, e[5] = (e[6] >>> 2 | e[7] << 11) & 65535, e[6] = (e[7] >>> 5 | e[8] << 8) & 65535, e[7] = (e[8] >>> 8 | e[9] << 5) & 65535;
    let s2 = e[0] + n2[0];
    e[0] = s2 & 65535;
    for (let c3 = 1; c3 < 8; c3++) s2 = (e[c3] + n2[c3] | 0) + (s2 >>> 16) | 0, e[c3] = s2 & 65535;
    Lt(r2);
  }
  update(e) {
    Or(this);
    const { buffer: n2, blockLen: r2 } = this;
    e = Fe(e);
    const o3 = e.length;
    for (let i3 = 0; i3 < o3; ) {
      const s2 = Math.min(r2 - this.pos, o3 - i3);
      if (s2 === r2) {
        for (; r2 <= o3 - i3; i3 += r2) this.process(e, i3);
        continue;
      }
      n2.set(e.subarray(i3, i3 + s2), this.pos), this.pos += s2, i3 += s2, this.pos === r2 && (this.process(n2, 0, false), this.pos = 0);
    }
    return this;
  }
  destroy() {
    Lt(this.h, this.r, this.buffer, this.pad);
  }
  digestInto(e) {
    Or(this), ps(e, this), this.finished = true;
    const { buffer: n2, h: r2 } = this;
    let { pos: o3 } = this;
    if (o3) {
      for (n2[o3++] = 1; o3 < 16; o3++) n2[o3] = 0;
      this.process(n2, 0, true);
    }
    this.finalize();
    let i3 = 0;
    for (let s2 = 0; s2 < 8; s2++) e[i3++] = r2[s2] >>> 0, e[i3++] = r2[s2] >>> 8;
    return e;
  }
  digest() {
    const { buffer: e, outputLen: n2 } = this;
    this.digestInto(e);
    const r2 = e.slice(0, n2);
    return this.destroy(), r2;
  }
};
function Ts(t) {
  const e = (r2, o3) => t(o3).update(Fe(r2)).digest(), n2 = t(new Uint8Array(32));
  return e.outputLen = n2.outputLen, e.blockLen = n2.blockLen, e.create = (r2) => t(r2), e;
}
var Rs = Ts((t) => new Us(t));
function _s(t, e, n2, r2, o3, i3 = 20) {
  let s2 = t[0], c3 = t[1], a2 = t[2], u4 = t[3], l3 = e[0], f6 = e[1], h4 = e[2], y4 = e[3], E5 = e[4], p4 = e[5], d3 = e[6], v9 = e[7], m3 = o3, O5 = n2[0], N2 = n2[1], $6 = n2[2], B4 = s2, A5 = c3, T4 = a2, S3 = u4, L3 = l3, U4 = f6, _2 = h4, j3 = y4, g2 = E5, w4 = p4, b5 = d3, I3 = v9, R6 = m3, x3 = O5, C5 = N2, P5 = $6;
  for (let M5 = 0; M5 < i3; M5 += 2) B4 = B4 + L3 | 0, R6 = V2(R6 ^ B4, 16), g2 = g2 + R6 | 0, L3 = V2(L3 ^ g2, 12), B4 = B4 + L3 | 0, R6 = V2(R6 ^ B4, 8), g2 = g2 + R6 | 0, L3 = V2(L3 ^ g2, 7), A5 = A5 + U4 | 0, x3 = V2(x3 ^ A5, 16), w4 = w4 + x3 | 0, U4 = V2(U4 ^ w4, 12), A5 = A5 + U4 | 0, x3 = V2(x3 ^ A5, 8), w4 = w4 + x3 | 0, U4 = V2(U4 ^ w4, 7), T4 = T4 + _2 | 0, C5 = V2(C5 ^ T4, 16), b5 = b5 + C5 | 0, _2 = V2(_2 ^ b5, 12), T4 = T4 + _2 | 0, C5 = V2(C5 ^ T4, 8), b5 = b5 + C5 | 0, _2 = V2(_2 ^ b5, 7), S3 = S3 + j3 | 0, P5 = V2(P5 ^ S3, 16), I3 = I3 + P5 | 0, j3 = V2(j3 ^ I3, 12), S3 = S3 + j3 | 0, P5 = V2(P5 ^ S3, 8), I3 = I3 + P5 | 0, j3 = V2(j3 ^ I3, 7), B4 = B4 + U4 | 0, P5 = V2(P5 ^ B4, 16), b5 = b5 + P5 | 0, U4 = V2(U4 ^ b5, 12), B4 = B4 + U4 | 0, P5 = V2(P5 ^ B4, 8), b5 = b5 + P5 | 0, U4 = V2(U4 ^ b5, 7), A5 = A5 + _2 | 0, R6 = V2(R6 ^ A5, 16), I3 = I3 + R6 | 0, _2 = V2(_2 ^ I3, 12), A5 = A5 + _2 | 0, R6 = V2(R6 ^ A5, 8), I3 = I3 + R6 | 0, _2 = V2(_2 ^ I3, 7), T4 = T4 + j3 | 0, x3 = V2(x3 ^ T4, 16), g2 = g2 + x3 | 0, j3 = V2(j3 ^ g2, 12), T4 = T4 + j3 | 0, x3 = V2(x3 ^ T4, 8), g2 = g2 + x3 | 0, j3 = V2(j3 ^ g2, 7), S3 = S3 + L3 | 0, C5 = V2(C5 ^ S3, 16), w4 = w4 + C5 | 0, L3 = V2(L3 ^ w4, 12), S3 = S3 + L3 | 0, C5 = V2(C5 ^ S3, 8), w4 = w4 + C5 | 0, L3 = V2(L3 ^ w4, 7);
  let k5 = 0;
  r2[k5++] = s2 + B4 | 0, r2[k5++] = c3 + A5 | 0, r2[k5++] = a2 + T4 | 0, r2[k5++] = u4 + S3 | 0, r2[k5++] = l3 + L3 | 0, r2[k5++] = f6 + U4 | 0, r2[k5++] = h4 + _2 | 0, r2[k5++] = y4 + j3 | 0, r2[k5++] = E5 + g2 | 0, r2[k5++] = p4 + w4 | 0, r2[k5++] = d3 + b5 | 0, r2[k5++] = v9 + I3 | 0, r2[k5++] = m3 + R6 | 0, r2[k5++] = O5 + x3 | 0, r2[k5++] = N2 + C5 | 0, r2[k5++] = $6 + P5 | 0;
}
var $s = Ns(_s, { counterRight: false, counterLength: 4, allowShortKeys: false });
var Ls = new Uint8Array(16);
var Rr = (t, e) => {
  t.update(e);
  const n2 = e.length % 16;
  n2 && t.update(Ls.subarray(n2));
};
var js = new Uint8Array(32);
function _r(t, e, n2, r2, o3) {
  const i3 = t(e, n2, js), s2 = Rs.create(i3);
  o3 && Rr(s2, o3), Rr(s2, r2);
  const c3 = new Uint8Array(16), a2 = gs(c3);
  Ir(a2, 0, BigInt(o3 ? o3.length : 0), true), Ir(a2, 8, BigInt(r2.length), true), s2.update(c3);
  const u4 = s2.digest();
  return Lt(i3, c3), u4;
}
var Cs = (t) => (e, n2, r2) => ({ encrypt(i3, s2) {
  const c3 = i3.length;
  s2 = Br(c3 + 16, s2, false), s2.set(i3);
  const a2 = s2.subarray(0, -16);
  t(e, n2, a2, a2, 1);
  const u4 = _r(t, e, n2, a2, r2);
  return s2.set(u4, c3), Lt(u4), s2;
}, decrypt(i3, s2) {
  s2 = Br(i3.length - 16, s2, false);
  const c3 = i3.subarray(0, -16), a2 = i3.subarray(-16), u4 = _r(t, e, n2, c3, r2);
  if (!bs(a2, u4)) throw new Error("invalid tag");
  return s2.set(i3.subarray(0, -16)), t(e, n2, s2, s2, 1), Lt(u4), s2;
} });
var $r = Es({ blockSize: 64, nonceLength: 12, tagLength: 16 }, Cs($s));
var Lr = class extends Pe {
  constructor(e, n2) {
    super(), this.finished = false, this.destroyed = false, je(e);
    const r2 = _t(n2);
    if (this.iHash = e.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const o3 = this.blockLen, i3 = new Uint8Array(o3);
    i3.set(r2.length > o3 ? e.create().update(r2).digest() : r2);
    for (let s2 = 0; s2 < i3.length; s2++) i3[s2] ^= 54;
    this.iHash.update(i3), this.oHash = e.create();
    for (let s2 = 0; s2 < i3.length; s2++) i3[s2] ^= 106;
    this.oHash.update(i3), i3.fill(0);
  }
  update(e) {
    return Tt(this), this.iHash.update(e), this;
  }
  digestInto(e) {
    Tt(this), Wt(e, this.outputLen), this.finished = true, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e), e;
  }
  _cloneInto(e) {
    e || (e = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: n2, iHash: r2, finished: o3, destroyed: i3, blockLen: s2, outputLen: c3 } = this;
    return e = e, e.finished = o3, e.destroyed = i3, e.blockLen = s2, e.outputLen = c3, e.oHash = n2._cloneInto(e.oHash), e.iHash = r2._cloneInto(e.iHash), e;
  }
  destroy() {
    this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
  }
};
var pe = (t, e, n2) => new Lr(t, e).update(n2).digest();
pe.create = (t, e) => new Lr(t, e);
function Ps(t, e, n2) {
  return je(t), n2 === void 0 && (n2 = new Uint8Array(t.outputLen)), pe(t, _t(n2), _t(e));
}
var Ye = new Uint8Array([0]);
var jr = new Uint8Array();
function ks(t, e, n2, r2 = 32) {
  if (je(t), Gt(r2), r2 > 255 * t.outputLen) throw new Error("Length should be <= 255*HashLen");
  const o3 = Math.ceil(r2 / t.outputLen);
  n2 === void 0 && (n2 = jr);
  const i3 = new Uint8Array(o3 * t.outputLen), s2 = pe.create(t, e), c3 = s2._cloneInto(), a2 = new Uint8Array(s2.outputLen);
  for (let u4 = 0; u4 < o3; u4++) Ye[0] = u4 + 1, c3.update(u4 === 0 ? jr : a2).update(n2).update(Ye).digestInto(a2), i3.set(a2, t.outputLen * u4), s2._cloneInto(c3);
  return s2.destroy(), c3.destroy(), a2.fill(0), Ye.fill(0), i3.slice(0, r2);
}
var Vs = (t, e, n2, r2, o3) => ks(t, Ps(t, e, n2), r2, o3);
function Ms(t, e, n2, r2) {
  if (typeof t.setBigUint64 == "function") return t.setBigUint64(e, n2, r2);
  const o3 = BigInt(32), i3 = BigInt(4294967295), s2 = Number(n2 >> o3 & i3), c3 = Number(n2 & i3), a2 = r2 ? 4 : 0, u4 = r2 ? 0 : 4;
  t.setUint32(e + a2, s2, r2), t.setUint32(e + u4, c3, r2);
}
function Ds(t, e, n2) {
  return t & e ^ ~t & n2;
}
function Hs(t, e, n2) {
  return t & e ^ t & n2 ^ e & n2;
}
var qs = class extends Pe {
  constructor(e, n2, r2, o3) {
    super(), this.blockLen = e, this.outputLen = n2, this.padOffset = r2, this.isLE = o3, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(e), this.view = Ce(this.buffer);
  }
  update(e) {
    Tt(this);
    const { view: n2, buffer: r2, blockLen: o3 } = this;
    e = _t(e);
    const i3 = e.length;
    for (let s2 = 0; s2 < i3; ) {
      const c3 = Math.min(o3 - this.pos, i3 - s2);
      if (c3 === o3) {
        const a2 = Ce(e);
        for (; o3 <= i3 - s2; s2 += o3) this.process(a2, s2);
        continue;
      }
      r2.set(e.subarray(s2, s2 + c3), this.pos), this.pos += c3, s2 += c3, this.pos === o3 && (this.process(n2, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    Tt(this), Gn(e, this), this.finished = true;
    const { buffer: n2, view: r2, blockLen: o3, isLE: i3 } = this;
    let { pos: s2 } = this;
    n2[s2++] = 128, this.buffer.subarray(s2).fill(0), this.padOffset > o3 - s2 && (this.process(r2, 0), s2 = 0);
    for (let f6 = s2; f6 < o3; f6++) n2[f6] = 0;
    Ms(r2, o3 - 8, BigInt(this.length * 8), i3), this.process(r2, 0);
    const c3 = Ce(e), a2 = this.outputLen;
    if (a2 % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u4 = a2 / 4, l3 = this.get();
    if (u4 > l3.length) throw new Error("_sha2: outputLen bigger than state");
    for (let f6 = 0; f6 < u4; f6++) c3.setUint32(4 * f6, l3[f6], i3);
  }
  digest() {
    const { buffer: e, outputLen: n2 } = this;
    this.digestInto(e);
    const r2 = e.slice(0, n2);
    return this.destroy(), r2;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: n2, buffer: r2, length: o3, finished: i3, destroyed: s2, pos: c3 } = this;
    return e.length = o3, e.pos = c3, e.finished = i3, e.destroyed = s2, o3 % n2 && e.buffer.set(r2), e;
  }
};
var Ks = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
var wt = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]);
var bt = new Uint32Array(64);
var Fs = class extends qs {
  constructor() {
    super(64, 32, 8, false), this.A = wt[0] | 0, this.B = wt[1] | 0, this.C = wt[2] | 0, this.D = wt[3] | 0, this.E = wt[4] | 0, this.F = wt[5] | 0, this.G = wt[6] | 0, this.H = wt[7] | 0;
  }
  get() {
    const { A: e, B: n2, C: r2, D: o3, E: i3, F: s2, G: c3, H: a2 } = this;
    return [e, n2, r2, o3, i3, s2, c3, a2];
  }
  set(e, n2, r2, o3, i3, s2, c3, a2) {
    this.A = e | 0, this.B = n2 | 0, this.C = r2 | 0, this.D = o3 | 0, this.E = i3 | 0, this.F = s2 | 0, this.G = c3 | 0, this.H = a2 | 0;
  }
  process(e, n2) {
    for (let f6 = 0; f6 < 16; f6++, n2 += 4) bt[f6] = e.getUint32(n2, false);
    for (let f6 = 16; f6 < 64; f6++) {
      const h4 = bt[f6 - 15], y4 = bt[f6 - 2], E5 = st(h4, 7) ^ st(h4, 18) ^ h4 >>> 3, p4 = st(y4, 17) ^ st(y4, 19) ^ y4 >>> 10;
      bt[f6] = p4 + bt[f6 - 7] + E5 + bt[f6 - 16] | 0;
    }
    let { A: r2, B: o3, C: i3, D: s2, E: c3, F: a2, G: u4, H: l3 } = this;
    for (let f6 = 0; f6 < 64; f6++) {
      const h4 = st(c3, 6) ^ st(c3, 11) ^ st(c3, 25), y4 = l3 + h4 + Ds(c3, a2, u4) + Ks[f6] + bt[f6] | 0, p4 = (st(r2, 2) ^ st(r2, 13) ^ st(r2, 22)) + Hs(r2, o3, i3) | 0;
      l3 = u4, u4 = a2, a2 = c3, c3 = s2 + y4 | 0, s2 = i3, i3 = o3, o3 = r2, r2 = y4 + p4 | 0;
    }
    r2 = r2 + this.A | 0, o3 = o3 + this.B | 0, i3 = i3 + this.C | 0, s2 = s2 + this.D | 0, c3 = c3 + this.E | 0, a2 = a2 + this.F | 0, u4 = u4 + this.G | 0, l3 = l3 + this.H | 0, this.set(r2, o3, i3, s2, c3, a2, u4, l3);
  }
  roundClean() {
    bt.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
var Jt = Qn(() => new Fs());
var ge = BigInt(0);
var ye = BigInt(1);
var zs = BigInt(2);
function St(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function Qt(t) {
  if (!St(t)) throw new Error("Uint8Array expected");
}
function jt(t, e) {
  if (typeof e != "boolean") throw new Error(t + " boolean expected, got " + e);
}
var Zs = Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
function Ct(t) {
  Qt(t);
  let e = "";
  for (let n2 = 0; n2 < t.length; n2++) e += Zs[t[n2]];
  return e;
}
function Pt(t) {
  const e = t.toString(16);
  return e.length & 1 ? "0" + e : e;
}
function Ge(t) {
  if (typeof t != "string") throw new Error("hex string expected, got " + typeof t);
  return t === "" ? ge : BigInt("0x" + t);
}
var ut = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function Cr(t) {
  if (t >= ut._0 && t <= ut._9) return t - ut._0;
  if (t >= ut.A && t <= ut.F) return t - (ut.A - 10);
  if (t >= ut.a && t <= ut.f) return t - (ut.a - 10);
}
function kt(t) {
  if (typeof t != "string") throw new Error("hex string expected, got " + typeof t);
  const e = t.length, n2 = e / 2;
  if (e % 2) throw new Error("hex string expected, got unpadded hex of length " + e);
  const r2 = new Uint8Array(n2);
  for (let o3 = 0, i3 = 0; o3 < n2; o3++, i3 += 2) {
    const s2 = Cr(t.charCodeAt(i3)), c3 = Cr(t.charCodeAt(i3 + 1));
    if (s2 === void 0 || c3 === void 0) {
      const a2 = t[i3] + t[i3 + 1];
      throw new Error('hex string expected, got non-hex character "' + a2 + '" at index ' + i3);
    }
    r2[o3] = s2 * 16 + c3;
  }
  return r2;
}
function Ot(t) {
  return Ge(Ct(t));
}
function te(t) {
  return Qt(t), Ge(Ct(Uint8Array.from(t).reverse()));
}
function Vt(t, e) {
  return kt(t.toString(16).padStart(e * 2, "0"));
}
function me(t, e) {
  return Vt(t, e).reverse();
}
function Ys(t) {
  return kt(Pt(t));
}
function et(t, e, n2) {
  let r2;
  if (typeof e == "string") try {
    r2 = kt(e);
  } catch (i3) {
    throw new Error(t + " must be hex string or Uint8Array, cause: " + i3);
  }
  else if (St(e)) r2 = Uint8Array.from(e);
  else throw new Error(t + " must be hex string or Uint8Array");
  const o3 = r2.length;
  if (typeof n2 == "number" && o3 !== n2) throw new Error(t + " of length " + n2 + " expected, got " + o3);
  return r2;
}
function ee(...t) {
  let e = 0;
  for (let r2 = 0; r2 < t.length; r2++) {
    const o3 = t[r2];
    Qt(o3), e += o3.length;
  }
  const n2 = new Uint8Array(e);
  for (let r2 = 0, o3 = 0; r2 < t.length; r2++) {
    const i3 = t[r2];
    n2.set(i3, o3), o3 += i3.length;
  }
  return n2;
}
function Gs(t, e) {
  if (t.length !== e.length) return false;
  let n2 = 0;
  for (let r2 = 0; r2 < t.length; r2++) n2 |= t[r2] ^ e[r2];
  return n2 === 0;
}
function Ws(t) {
  if (typeof t != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(t));
}
var We = (t) => typeof t == "bigint" && ge <= t;
function we(t, e, n2) {
  return We(t) && We(e) && We(n2) && e <= t && t < n2;
}
function ft(t, e, n2, r2) {
  if (!we(e, n2, r2)) throw new Error("expected valid " + t + ": " + n2 + " <= n < " + r2 + ", got " + e);
}
function Pr(t) {
  let e;
  for (e = 0; t > ge; t >>= ye, e += 1) ;
  return e;
}
function Xs(t, e) {
  return t >> BigInt(e) & ye;
}
function Js(t, e, n2) {
  return t | (n2 ? ye : ge) << BigInt(e);
}
var Xe = (t) => (zs << BigInt(t - 1)) - ye;
var Je = (t) => new Uint8Array(t);
var kr = (t) => Uint8Array.from(t);
function Vr(t, e, n2) {
  if (typeof t != "number" || t < 2) throw new Error("hashLen must be a number");
  if (typeof e != "number" || e < 2) throw new Error("qByteLen must be a number");
  if (typeof n2 != "function") throw new Error("hmacFn must be a function");
  let r2 = Je(t), o3 = Je(t), i3 = 0;
  const s2 = () => {
    r2.fill(1), o3.fill(0), i3 = 0;
  }, c3 = (...f6) => n2(o3, r2, ...f6), a2 = (f6 = Je()) => {
    o3 = c3(kr([0]), f6), r2 = c3(), f6.length !== 0 && (o3 = c3(kr([1]), f6), r2 = c3());
  }, u4 = () => {
    if (i3++ >= 1e3) throw new Error("drbg: tried 1000 values");
    let f6 = 0;
    const h4 = [];
    for (; f6 < e; ) {
      r2 = c3();
      const y4 = r2.slice();
      h4.push(y4), f6 += r2.length;
    }
    return ee(...h4);
  };
  return (f6, h4) => {
    s2(), a2(f6);
    let y4;
    for (; !(y4 = h4(u4())); ) a2();
    return s2(), y4;
  };
}
var Qs = { bigint: (t) => typeof t == "bigint", function: (t) => typeof t == "function", boolean: (t) => typeof t == "boolean", string: (t) => typeof t == "string", stringOrUint8Array: (t) => typeof t == "string" || St(t), isSafeInteger: (t) => Number.isSafeInteger(t), array: (t) => Array.isArray(t), field: (t, e) => e.Fp.isValid(t), hash: (t) => typeof t == "function" && Number.isSafeInteger(t.outputLen) };
function Mt(t, e, n2 = {}) {
  const r2 = (o3, i3, s2) => {
    const c3 = Qs[i3];
    if (typeof c3 != "function") throw new Error("invalid validator function");
    const a2 = t[o3];
    if (!(s2 && a2 === void 0) && !c3(a2, t)) throw new Error("param " + String(o3) + " is invalid. Expected " + i3 + ", got " + a2);
  };
  for (const [o3, i3] of Object.entries(e)) r2(o3, i3, false);
  for (const [o3, i3] of Object.entries(n2)) r2(o3, i3, true);
  return t;
}
var tc = () => {
  throw new Error("not implemented");
};
function Qe2(t) {
  const e = /* @__PURE__ */ new WeakMap();
  return (n2, ...r2) => {
    const o3 = e.get(n2);
    if (o3 !== void 0) return o3;
    const i3 = t(n2, ...r2);
    return e.set(n2, i3), i3;
  };
}
var ec = Object.freeze({ __proto__: null, isBytes: St, abytes: Qt, abool: jt, bytesToHex: Ct, numberToHexUnpadded: Pt, hexToNumber: Ge, hexToBytes: kt, bytesToNumberBE: Ot, bytesToNumberLE: te, numberToBytesBE: Vt, numberToBytesLE: me, numberToVarBytesBE: Ys, ensureBytes: et, concatBytes: ee, equalBytes: Gs, utf8ToBytes: Ws, inRange: we, aInRange: ft, bitLen: Pr, bitGet: Xs, bitSet: Js, bitMask: Xe, createHmacDrbg: Vr, validateObject: Mt, notImplemented: tc, memoized: Qe2 });
var q = BigInt(0);
var H = BigInt(1);
var At = BigInt(2);
var nc = BigInt(3);
var tn = BigInt(4);
var Mr = BigInt(5);
var Dr = BigInt(8);
function X(t, e) {
  const n2 = t % e;
  return n2 >= q ? n2 : e + n2;
}
function Hr(t, e, n2) {
  if (e < q) throw new Error("invalid exponent, negatives unsupported");
  if (n2 <= q) throw new Error("invalid modulus");
  if (n2 === H) return q;
  let r2 = H;
  for (; e > q; ) e & H && (r2 = r2 * t % n2), t = t * t % n2, e >>= H;
  return r2;
}
function ot(t, e, n2) {
  let r2 = t;
  for (; e-- > q; ) r2 *= r2, r2 %= n2;
  return r2;
}
function en(t, e) {
  if (t === q) throw new Error("invert: expected non-zero number");
  if (e <= q) throw new Error("invert: expected positive modulus, got " + e);
  let n2 = X(t, e), r2 = e, o3 = q, i3 = H;
  for (; n2 !== q; ) {
    const c3 = r2 / n2, a2 = r2 % n2, u4 = o3 - i3 * c3;
    r2 = n2, n2 = a2, o3 = i3, i3 = u4;
  }
  if (r2 !== H) throw new Error("invert: does not exist");
  return X(o3, e);
}
function rc(t) {
  const e = (t - H) / At;
  let n2, r2, o3;
  for (n2 = t - H, r2 = 0; n2 % At === q; n2 /= At, r2++) ;
  for (o3 = At; o3 < t && Hr(o3, e, t) !== t - H; o3++) if (o3 > 1e3) throw new Error("Cannot find square root: likely non-prime P");
  if (r2 === 1) {
    const s2 = (t + H) / tn;
    return function(a2, u4) {
      const l3 = a2.pow(u4, s2);
      if (!a2.eql(a2.sqr(l3), u4)) throw new Error("Cannot find square root");
      return l3;
    };
  }
  const i3 = (n2 + H) / At;
  return function(c3, a2) {
    if (c3.pow(a2, e) === c3.neg(c3.ONE)) throw new Error("Cannot find square root");
    let u4 = r2, l3 = c3.pow(c3.mul(c3.ONE, o3), n2), f6 = c3.pow(a2, i3), h4 = c3.pow(a2, n2);
    for (; !c3.eql(h4, c3.ONE); ) {
      if (c3.eql(h4, c3.ZERO)) return c3.ZERO;
      let y4 = 1;
      for (let p4 = c3.sqr(h4); y4 < u4 && !c3.eql(p4, c3.ONE); y4++) p4 = c3.sqr(p4);
      const E5 = c3.pow(l3, H << BigInt(u4 - y4 - 1));
      l3 = c3.sqr(E5), f6 = c3.mul(f6, E5), h4 = c3.mul(h4, l3), u4 = y4;
    }
    return f6;
  };
}
function oc(t) {
  if (t % tn === nc) {
    const e = (t + H) / tn;
    return function(r2, o3) {
      const i3 = r2.pow(o3, e);
      if (!r2.eql(r2.sqr(i3), o3)) throw new Error("Cannot find square root");
      return i3;
    };
  }
  if (t % Dr === Mr) {
    const e = (t - Mr) / Dr;
    return function(r2, o3) {
      const i3 = r2.mul(o3, At), s2 = r2.pow(i3, e), c3 = r2.mul(o3, s2), a2 = r2.mul(r2.mul(c3, At), s2), u4 = r2.mul(c3, r2.sub(a2, r2.ONE));
      if (!r2.eql(r2.sqr(u4), o3)) throw new Error("Cannot find square root");
      return u4;
    };
  }
  return rc(t);
}
var ic = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function sc(t) {
  const e = { ORDER: "bigint", MASK: "bigint", BYTES: "isSafeInteger", BITS: "isSafeInteger" }, n2 = ic.reduce((r2, o3) => (r2[o3] = "function", r2), e);
  return Mt(t, n2);
}
function cc(t, e, n2) {
  if (n2 < q) throw new Error("invalid exponent, negatives unsupported");
  if (n2 === q) return t.ONE;
  if (n2 === H) return e;
  let r2 = t.ONE, o3 = e;
  for (; n2 > q; ) n2 & H && (r2 = t.mul(r2, o3)), o3 = t.sqr(o3), n2 >>= H;
  return r2;
}
function ac(t, e) {
  const n2 = new Array(e.length), r2 = e.reduce((i3, s2, c3) => t.is0(s2) ? i3 : (n2[c3] = i3, t.mul(i3, s2)), t.ONE), o3 = t.inv(r2);
  return e.reduceRight((i3, s2, c3) => t.is0(s2) ? i3 : (n2[c3] = t.mul(i3, n2[c3]), t.mul(i3, s2)), o3), n2;
}
function qr(t, e) {
  const n2 = e !== void 0 ? e : t.toString(2).length, r2 = Math.ceil(n2 / 8);
  return { nBitLength: n2, nByteLength: r2 };
}
function Kr(t, e, n2 = false, r2 = {}) {
  if (t <= q) throw new Error("invalid field: expected ORDER > 0, got " + t);
  const { nBitLength: o3, nByteLength: i3 } = qr(t, e);
  if (i3 > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let s2;
  const c3 = Object.freeze({ ORDER: t, isLE: n2, BITS: o3, BYTES: i3, MASK: Xe(o3), ZERO: q, ONE: H, create: (a2) => X(a2, t), isValid: (a2) => {
    if (typeof a2 != "bigint") throw new Error("invalid field element: expected bigint, got " + typeof a2);
    return q <= a2 && a2 < t;
  }, is0: (a2) => a2 === q, isOdd: (a2) => (a2 & H) === H, neg: (a2) => X(-a2, t), eql: (a2, u4) => a2 === u4, sqr: (a2) => X(a2 * a2, t), add: (a2, u4) => X(a2 + u4, t), sub: (a2, u4) => X(a2 - u4, t), mul: (a2, u4) => X(a2 * u4, t), pow: (a2, u4) => cc(c3, a2, u4), div: (a2, u4) => X(a2 * en(u4, t), t), sqrN: (a2) => a2 * a2, addN: (a2, u4) => a2 + u4, subN: (a2, u4) => a2 - u4, mulN: (a2, u4) => a2 * u4, inv: (a2) => en(a2, t), sqrt: r2.sqrt || ((a2) => (s2 || (s2 = oc(t)), s2(c3, a2))), invertBatch: (a2) => ac(c3, a2), cmov: (a2, u4, l3) => l3 ? u4 : a2, toBytes: (a2) => n2 ? me(a2, i3) : Vt(a2, i3), fromBytes: (a2) => {
    if (a2.length !== i3) throw new Error("Field.fromBytes: expected " + i3 + " bytes, got " + a2.length);
    return n2 ? te(a2) : Ot(a2);
  } });
  return Object.freeze(c3);
}
function Fr(t) {
  if (typeof t != "bigint") throw new Error("field order must be bigint");
  const e = t.toString(2).length;
  return Math.ceil(e / 8);
}
function zr(t) {
  const e = Fr(t);
  return e + Math.ceil(e / 2);
}
function uc(t, e, n2 = false) {
  const r2 = t.length, o3 = Fr(e), i3 = zr(e);
  if (r2 < 16 || r2 < i3 || r2 > 1024) throw new Error("expected " + i3 + "-1024 bytes of input, got " + r2);
  const s2 = n2 ? te(t) : Ot(t), c3 = X(s2, e - H) + H;
  return n2 ? me(c3, o3) : Vt(c3, o3);
}
var Zr = BigInt(0);
var be = BigInt(1);
function nn(t, e) {
  const n2 = e.negate();
  return t ? n2 : e;
}
function Yr(t, e) {
  if (!Number.isSafeInteger(t) || t <= 0 || t > e) throw new Error("invalid window size, expected [1.." + e + "], got W=" + t);
}
function rn(t, e) {
  Yr(t, e);
  const n2 = Math.ceil(e / t) + 1, r2 = 2 ** (t - 1);
  return { windows: n2, windowSize: r2 };
}
function fc(t, e) {
  if (!Array.isArray(t)) throw new Error("array expected");
  t.forEach((n2, r2) => {
    if (!(n2 instanceof e)) throw new Error("invalid point at index " + r2);
  });
}
function lc(t, e) {
  if (!Array.isArray(t)) throw new Error("array of scalars expected");
  t.forEach((n2, r2) => {
    if (!e.isValid(n2)) throw new Error("invalid scalar at index " + r2);
  });
}
var on = /* @__PURE__ */ new WeakMap();
var Gr = /* @__PURE__ */ new WeakMap();
function sn2(t) {
  return Gr.get(t) || 1;
}
function dc(t, e) {
  return { constTimeNegate: nn, hasPrecomputes(n2) {
    return sn2(n2) !== 1;
  }, unsafeLadder(n2, r2, o3 = t.ZERO) {
    let i3 = n2;
    for (; r2 > Zr; ) r2 & be && (o3 = o3.add(i3)), i3 = i3.double(), r2 >>= be;
    return o3;
  }, precomputeWindow(n2, r2) {
    const { windows: o3, windowSize: i3 } = rn(r2, e), s2 = [];
    let c3 = n2, a2 = c3;
    for (let u4 = 0; u4 < o3; u4++) {
      a2 = c3, s2.push(a2);
      for (let l3 = 1; l3 < i3; l3++) a2 = a2.add(c3), s2.push(a2);
      c3 = a2.double();
    }
    return s2;
  }, wNAF(n2, r2, o3) {
    const { windows: i3, windowSize: s2 } = rn(n2, e);
    let c3 = t.ZERO, a2 = t.BASE;
    const u4 = BigInt(2 ** n2 - 1), l3 = 2 ** n2, f6 = BigInt(n2);
    for (let h4 = 0; h4 < i3; h4++) {
      const y4 = h4 * s2;
      let E5 = Number(o3 & u4);
      o3 >>= f6, E5 > s2 && (E5 -= l3, o3 += be);
      const p4 = y4, d3 = y4 + Math.abs(E5) - 1, v9 = h4 % 2 !== 0, m3 = E5 < 0;
      E5 === 0 ? a2 = a2.add(nn(v9, r2[p4])) : c3 = c3.add(nn(m3, r2[d3]));
    }
    return { p: c3, f: a2 };
  }, wNAFUnsafe(n2, r2, o3, i3 = t.ZERO) {
    const { windows: s2, windowSize: c3 } = rn(n2, e), a2 = BigInt(2 ** n2 - 1), u4 = 2 ** n2, l3 = BigInt(n2);
    for (let f6 = 0; f6 < s2; f6++) {
      const h4 = f6 * c3;
      if (o3 === Zr) break;
      let y4 = Number(o3 & a2);
      if (o3 >>= l3, y4 > c3 && (y4 -= u4, o3 += be), y4 === 0) continue;
      let E5 = r2[h4 + Math.abs(y4) - 1];
      y4 < 0 && (E5 = E5.negate()), i3 = i3.add(E5);
    }
    return i3;
  }, getPrecomputes(n2, r2, o3) {
    let i3 = on.get(r2);
    return i3 || (i3 = this.precomputeWindow(r2, n2), n2 !== 1 && on.set(r2, o3(i3))), i3;
  }, wNAFCached(n2, r2, o3) {
    const i3 = sn2(n2);
    return this.wNAF(i3, this.getPrecomputes(i3, n2, o3), r2);
  }, wNAFCachedUnsafe(n2, r2, o3, i3) {
    const s2 = sn2(n2);
    return s2 === 1 ? this.unsafeLadder(n2, r2, i3) : this.wNAFUnsafe(s2, this.getPrecomputes(s2, n2, o3), r2, i3);
  }, setWindowSize(n2, r2) {
    Yr(r2, e), Gr.set(n2, r2), on.delete(n2);
  } };
}
function hc(t, e, n2, r2) {
  if (fc(n2, t), lc(r2, e), n2.length !== r2.length) throw new Error("arrays of points and scalars must have equal length");
  const o3 = t.ZERO, i3 = Pr(BigInt(n2.length)), s2 = i3 > 12 ? i3 - 3 : i3 > 4 ? i3 - 2 : i3 ? 2 : 1, c3 = (1 << s2) - 1, a2 = new Array(c3 + 1).fill(o3), u4 = Math.floor((e.BITS - 1) / s2) * s2;
  let l3 = o3;
  for (let f6 = u4; f6 >= 0; f6 -= s2) {
    a2.fill(o3);
    for (let y4 = 0; y4 < r2.length; y4++) {
      const E5 = r2[y4], p4 = Number(E5 >> BigInt(f6) & BigInt(c3));
      a2[p4] = a2[p4].add(n2[y4]);
    }
    let h4 = o3;
    for (let y4 = a2.length - 1, E5 = o3; y4 > 0; y4--) E5 = E5.add(a2[y4]), h4 = h4.add(E5);
    if (l3 = l3.add(h4), f6 !== 0) for (let y4 = 0; y4 < s2; y4++) l3 = l3.double();
  }
  return l3;
}
function Wr(t) {
  return sc(t.Fp), Mt(t, { n: "bigint", h: "bigint", Gx: "field", Gy: "field" }, { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" }), Object.freeze({ ...qr(t.n, t.nBitLength), ...t, p: t.Fp.ORDER });
}
BigInt(0), BigInt(1), BigInt(2), BigInt(8);
var Dt = BigInt(0);
var cn = BigInt(1);
function pc(t) {
  return Mt(t, { a: "bigint" }, { montgomeryBits: "isSafeInteger", nByteLength: "isSafeInteger", adjustScalarBytes: "function", domain: "function", powPminus2: "function", Gu: "bigint" }), Object.freeze({ ...t });
}
function gc(t) {
  const e = pc(t), { P: n2 } = e, r2 = (m3) => X(m3, n2), o3 = e.montgomeryBits, i3 = Math.ceil(o3 / 8), s2 = e.nByteLength, c3 = e.adjustScalarBytes || ((m3) => m3), a2 = e.powPminus2 || ((m3) => Hr(m3, n2 - BigInt(2), n2));
  function u4(m3, O5, N2) {
    const $6 = r2(m3 * (O5 - N2));
    return O5 = r2(O5 - $6), N2 = r2(N2 + $6), [O5, N2];
  }
  const l3 = (e.a - BigInt(2)) / BigInt(4);
  function f6(m3, O5) {
    ft("u", m3, Dt, n2), ft("scalar", O5, Dt, n2);
    const N2 = O5, $6 = m3;
    let B4 = cn, A5 = Dt, T4 = m3, S3 = cn, L3 = Dt, U4;
    for (let j3 = BigInt(o3 - 1); j3 >= Dt; j3--) {
      const g2 = N2 >> j3 & cn;
      L3 ^= g2, U4 = u4(L3, B4, T4), B4 = U4[0], T4 = U4[1], U4 = u4(L3, A5, S3), A5 = U4[0], S3 = U4[1], L3 = g2;
      const w4 = B4 + A5, b5 = r2(w4 * w4), I3 = B4 - A5, R6 = r2(I3 * I3), x3 = b5 - R6, C5 = T4 + S3, P5 = T4 - S3, k5 = r2(P5 * w4), M5 = r2(C5 * I3), D3 = k5 + M5, z4 = k5 - M5;
      T4 = r2(D3 * D3), S3 = r2($6 * r2(z4 * z4)), B4 = r2(b5 * R6), A5 = r2(x3 * (b5 + r2(l3 * x3)));
    }
    U4 = u4(L3, B4, T4), B4 = U4[0], T4 = U4[1], U4 = u4(L3, A5, S3), A5 = U4[0], S3 = U4[1];
    const _2 = a2(A5);
    return r2(B4 * _2);
  }
  function h4(m3) {
    return me(r2(m3), i3);
  }
  function y4(m3) {
    const O5 = et("u coordinate", m3, i3);
    return s2 === 32 && (O5[31] &= 127), te(O5);
  }
  function E5(m3) {
    const O5 = et("scalar", m3), N2 = O5.length;
    if (N2 !== i3 && N2 !== s2) {
      let $6 = "" + i3 + " or " + s2;
      throw new Error("invalid scalar, expected " + $6 + " bytes, got " + N2);
    }
    return te(c3(O5));
  }
  function p4(m3, O5) {
    const N2 = y4(O5), $6 = E5(m3), B4 = f6(N2, $6);
    if (B4 === Dt) throw new Error("invalid private or public key received");
    return h4(B4);
  }
  const d3 = h4(e.Gu);
  function v9(m3) {
    return p4(m3, d3);
  }
  return { scalarMult: p4, scalarMultBase: v9, getSharedSecret: (m3, O5) => p4(m3, O5), getPublicKey: (m3) => v9(m3), utils: { randomPrivateKey: () => e.randomBytes(e.nByteLength) }, GuBytes: d3 };
}
var an = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
BigInt(0);
var yc = BigInt(1);
var Xr = BigInt(2);
var mc = BigInt(3);
var wc = BigInt(5);
BigInt(8);
function bc(t) {
  const e = BigInt(10), n2 = BigInt(20), r2 = BigInt(40), o3 = BigInt(80), i3 = an, c3 = t * t % i3 * t % i3, a2 = ot(c3, Xr, i3) * c3 % i3, u4 = ot(a2, yc, i3) * t % i3, l3 = ot(u4, wc, i3) * u4 % i3, f6 = ot(l3, e, i3) * l3 % i3, h4 = ot(f6, n2, i3) * f6 % i3, y4 = ot(h4, r2, i3) * h4 % i3, E5 = ot(y4, o3, i3) * y4 % i3, p4 = ot(E5, o3, i3) * y4 % i3, d3 = ot(p4, e, i3) * l3 % i3;
  return { pow_p_5_8: ot(d3, Xr, i3) * t % i3, b2: c3 };
}
function Ec(t) {
  return t[0] &= 248, t[31] &= 127, t[31] |= 64, t;
}
var un = gc({ P: an, a: BigInt(486662), montgomeryBits: 255, nByteLength: 32, Gu: BigInt(9), powPminus2: (t) => {
  const e = an, { pow_p_5_8: n2, b2: r2 } = bc(t);
  return X(ot(n2, mc, e) * r2, e);
}, adjustScalarBytes: Ec, randomBytes: $t });
function Jr(t) {
  t.lowS !== void 0 && jt("lowS", t.lowS), t.prehash !== void 0 && jt("prehash", t.prehash);
}
function vc(t) {
  const e = Wr(t);
  Mt(e, { a: "field", b: "field" }, { allowedPrivateKeyLengths: "array", wrapPrivateKey: "boolean", isTorsionFree: "function", clearCofactor: "function", allowInfinityPoint: "boolean", fromBytes: "function", toBytes: "function" });
  const { endo: n2, Fp: r2, a: o3 } = e;
  if (n2) {
    if (!r2.eql(o3, r2.ZERO)) throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");
    if (typeof n2 != "object" || typeof n2.beta != "bigint" || typeof n2.splitScalar != "function") throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...e });
}
var { bytesToNumberBE: xc, hexToBytes: Sc } = ec;
var Oc = class extends Error {
  constructor(e = "") {
    super(e);
  }
};
var lt = { Err: Oc, _tlv: { encode: (t, e) => {
  const { Err: n2 } = lt;
  if (t < 0 || t > 256) throw new n2("tlv.encode: wrong tag");
  if (e.length & 1) throw new n2("tlv.encode: unpadded data");
  const r2 = e.length / 2, o3 = Pt(r2);
  if (o3.length / 2 & 128) throw new n2("tlv.encode: long form length too big");
  const i3 = r2 > 127 ? Pt(o3.length / 2 | 128) : "";
  return Pt(t) + i3 + o3 + e;
}, decode(t, e) {
  const { Err: n2 } = lt;
  let r2 = 0;
  if (t < 0 || t > 256) throw new n2("tlv.encode: wrong tag");
  if (e.length < 2 || e[r2++] !== t) throw new n2("tlv.decode: wrong tlv");
  const o3 = e[r2++], i3 = !!(o3 & 128);
  let s2 = 0;
  if (!i3) s2 = o3;
  else {
    const a2 = o3 & 127;
    if (!a2) throw new n2("tlv.decode(long): indefinite length not supported");
    if (a2 > 4) throw new n2("tlv.decode(long): byte length is too big");
    const u4 = e.subarray(r2, r2 + a2);
    if (u4.length !== a2) throw new n2("tlv.decode: length bytes not complete");
    if (u4[0] === 0) throw new n2("tlv.decode(long): zero leftmost byte");
    for (const l3 of u4) s2 = s2 << 8 | l3;
    if (r2 += a2, s2 < 128) throw new n2("tlv.decode(long): not minimal encoding");
  }
  const c3 = e.subarray(r2, r2 + s2);
  if (c3.length !== s2) throw new n2("tlv.decode: wrong value length");
  return { v: c3, l: e.subarray(r2 + s2) };
} }, _int: { encode(t) {
  const { Err: e } = lt;
  if (t < dt) throw new e("integer: negative integers are not allowed");
  let n2 = Pt(t);
  if (Number.parseInt(n2[0], 16) & 8 && (n2 = "00" + n2), n2.length & 1) throw new e("unexpected DER parsing assertion: unpadded hex");
  return n2;
}, decode(t) {
  const { Err: e } = lt;
  if (t[0] & 128) throw new e("invalid signature integer: negative");
  if (t[0] === 0 && !(t[1] & 128)) throw new e("invalid signature integer: unnecessary leading zero");
  return xc(t);
} }, toSig(t) {
  const { Err: e, _int: n2, _tlv: r2 } = lt, o3 = typeof t == "string" ? Sc(t) : t;
  Qt(o3);
  const { v: i3, l: s2 } = r2.decode(48, o3);
  if (s2.length) throw new e("invalid signature: left bytes after parsing");
  const { v: c3, l: a2 } = r2.decode(2, i3), { v: u4, l: l3 } = r2.decode(2, a2);
  if (l3.length) throw new e("invalid signature: left bytes after parsing");
  return { r: n2.decode(c3), s: n2.decode(u4) };
}, hexFromSig(t) {
  const { _tlv: e, _int: n2 } = lt, r2 = e.encode(2, n2.encode(t.r)), o3 = e.encode(2, n2.encode(t.s)), i3 = r2 + o3;
  return e.encode(48, i3);
} };
var dt = BigInt(0);
var K2 = BigInt(1);
BigInt(2);
var Qr = BigInt(3);
BigInt(4);
function Ac(t) {
  const e = vc(t), { Fp: n2 } = e, r2 = Kr(e.n, e.nBitLength), o3 = e.toBytes || ((p4, d3, v9) => {
    const m3 = d3.toAffine();
    return ee(Uint8Array.from([4]), n2.toBytes(m3.x), n2.toBytes(m3.y));
  }), i3 = e.fromBytes || ((p4) => {
    const d3 = p4.subarray(1), v9 = n2.fromBytes(d3.subarray(0, n2.BYTES)), m3 = n2.fromBytes(d3.subarray(n2.BYTES, 2 * n2.BYTES));
    return { x: v9, y: m3 };
  });
  function s2(p4) {
    const { a: d3, b: v9 } = e, m3 = n2.sqr(p4), O5 = n2.mul(m3, p4);
    return n2.add(n2.add(O5, n2.mul(p4, d3)), v9);
  }
  if (!n2.eql(n2.sqr(e.Gy), s2(e.Gx))) throw new Error("bad generator point: equation left != right");
  function c3(p4) {
    return we(p4, K2, e.n);
  }
  function a2(p4) {
    const { allowedPrivateKeyLengths: d3, nByteLength: v9, wrapPrivateKey: m3, n: O5 } = e;
    if (d3 && typeof p4 != "bigint") {
      if (St(p4) && (p4 = Ct(p4)), typeof p4 != "string" || !d3.includes(p4.length)) throw new Error("invalid private key");
      p4 = p4.padStart(v9 * 2, "0");
    }
    let N2;
    try {
      N2 = typeof p4 == "bigint" ? p4 : Ot(et("private key", p4, v9));
    } catch {
      throw new Error("invalid private key, expected hex or " + v9 + " bytes, got " + typeof p4);
    }
    return m3 && (N2 = X(N2, O5)), ft("private key", N2, K2, O5), N2;
  }
  function u4(p4) {
    if (!(p4 instanceof h4)) throw new Error("ProjectivePoint expected");
  }
  const l3 = Qe2((p4, d3) => {
    const { px: v9, py: m3, pz: O5 } = p4;
    if (n2.eql(O5, n2.ONE)) return { x: v9, y: m3 };
    const N2 = p4.is0();
    d3 == null && (d3 = N2 ? n2.ONE : n2.inv(O5));
    const $6 = n2.mul(v9, d3), B4 = n2.mul(m3, d3), A5 = n2.mul(O5, d3);
    if (N2) return { x: n2.ZERO, y: n2.ZERO };
    if (!n2.eql(A5, n2.ONE)) throw new Error("invZ was invalid");
    return { x: $6, y: B4 };
  }), f6 = Qe2((p4) => {
    if (p4.is0()) {
      if (e.allowInfinityPoint && !n2.is0(p4.py)) return;
      throw new Error("bad point: ZERO");
    }
    const { x: d3, y: v9 } = p4.toAffine();
    if (!n2.isValid(d3) || !n2.isValid(v9)) throw new Error("bad point: x or y not FE");
    const m3 = n2.sqr(v9), O5 = s2(d3);
    if (!n2.eql(m3, O5)) throw new Error("bad point: equation left != right");
    if (!p4.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  class h4 {
    constructor(d3, v9, m3) {
      if (this.px = d3, this.py = v9, this.pz = m3, d3 == null || !n2.isValid(d3)) throw new Error("x required");
      if (v9 == null || !n2.isValid(v9)) throw new Error("y required");
      if (m3 == null || !n2.isValid(m3)) throw new Error("z required");
      Object.freeze(this);
    }
    static fromAffine(d3) {
      const { x: v9, y: m3 } = d3 || {};
      if (!d3 || !n2.isValid(v9) || !n2.isValid(m3)) throw new Error("invalid affine point");
      if (d3 instanceof h4) throw new Error("projective point not allowed");
      const O5 = (N2) => n2.eql(N2, n2.ZERO);
      return O5(v9) && O5(m3) ? h4.ZERO : new h4(v9, m3, n2.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(d3) {
      const v9 = n2.invertBatch(d3.map((m3) => m3.pz));
      return d3.map((m3, O5) => m3.toAffine(v9[O5])).map(h4.fromAffine);
    }
    static fromHex(d3) {
      const v9 = h4.fromAffine(i3(et("pointHex", d3)));
      return v9.assertValidity(), v9;
    }
    static fromPrivateKey(d3) {
      return h4.BASE.multiply(a2(d3));
    }
    static msm(d3, v9) {
      return hc(h4, r2, d3, v9);
    }
    _setWindowSize(d3) {
      E5.setWindowSize(this, d3);
    }
    assertValidity() {
      f6(this);
    }
    hasEvenY() {
      const { y: d3 } = this.toAffine();
      if (n2.isOdd) return !n2.isOdd(d3);
      throw new Error("Field doesn't support isOdd");
    }
    equals(d3) {
      u4(d3);
      const { px: v9, py: m3, pz: O5 } = this, { px: N2, py: $6, pz: B4 } = d3, A5 = n2.eql(n2.mul(v9, B4), n2.mul(N2, O5)), T4 = n2.eql(n2.mul(m3, B4), n2.mul($6, O5));
      return A5 && T4;
    }
    negate() {
      return new h4(this.px, n2.neg(this.py), this.pz);
    }
    double() {
      const { a: d3, b: v9 } = e, m3 = n2.mul(v9, Qr), { px: O5, py: N2, pz: $6 } = this;
      let B4 = n2.ZERO, A5 = n2.ZERO, T4 = n2.ZERO, S3 = n2.mul(O5, O5), L3 = n2.mul(N2, N2), U4 = n2.mul($6, $6), _2 = n2.mul(O5, N2);
      return _2 = n2.add(_2, _2), T4 = n2.mul(O5, $6), T4 = n2.add(T4, T4), B4 = n2.mul(d3, T4), A5 = n2.mul(m3, U4), A5 = n2.add(B4, A5), B4 = n2.sub(L3, A5), A5 = n2.add(L3, A5), A5 = n2.mul(B4, A5), B4 = n2.mul(_2, B4), T4 = n2.mul(m3, T4), U4 = n2.mul(d3, U4), _2 = n2.sub(S3, U4), _2 = n2.mul(d3, _2), _2 = n2.add(_2, T4), T4 = n2.add(S3, S3), S3 = n2.add(T4, S3), S3 = n2.add(S3, U4), S3 = n2.mul(S3, _2), A5 = n2.add(A5, S3), U4 = n2.mul(N2, $6), U4 = n2.add(U4, U4), S3 = n2.mul(U4, _2), B4 = n2.sub(B4, S3), T4 = n2.mul(U4, L3), T4 = n2.add(T4, T4), T4 = n2.add(T4, T4), new h4(B4, A5, T4);
    }
    add(d3) {
      u4(d3);
      const { px: v9, py: m3, pz: O5 } = this, { px: N2, py: $6, pz: B4 } = d3;
      let A5 = n2.ZERO, T4 = n2.ZERO, S3 = n2.ZERO;
      const L3 = e.a, U4 = n2.mul(e.b, Qr);
      let _2 = n2.mul(v9, N2), j3 = n2.mul(m3, $6), g2 = n2.mul(O5, B4), w4 = n2.add(v9, m3), b5 = n2.add(N2, $6);
      w4 = n2.mul(w4, b5), b5 = n2.add(_2, j3), w4 = n2.sub(w4, b5), b5 = n2.add(v9, O5);
      let I3 = n2.add(N2, B4);
      return b5 = n2.mul(b5, I3), I3 = n2.add(_2, g2), b5 = n2.sub(b5, I3), I3 = n2.add(m3, O5), A5 = n2.add($6, B4), I3 = n2.mul(I3, A5), A5 = n2.add(j3, g2), I3 = n2.sub(I3, A5), S3 = n2.mul(L3, b5), A5 = n2.mul(U4, g2), S3 = n2.add(A5, S3), A5 = n2.sub(j3, S3), S3 = n2.add(j3, S3), T4 = n2.mul(A5, S3), j3 = n2.add(_2, _2), j3 = n2.add(j3, _2), g2 = n2.mul(L3, g2), b5 = n2.mul(U4, b5), j3 = n2.add(j3, g2), g2 = n2.sub(_2, g2), g2 = n2.mul(L3, g2), b5 = n2.add(b5, g2), _2 = n2.mul(j3, b5), T4 = n2.add(T4, _2), _2 = n2.mul(I3, b5), A5 = n2.mul(w4, A5), A5 = n2.sub(A5, _2), _2 = n2.mul(w4, j3), S3 = n2.mul(I3, S3), S3 = n2.add(S3, _2), new h4(A5, T4, S3);
    }
    subtract(d3) {
      return this.add(d3.negate());
    }
    is0() {
      return this.equals(h4.ZERO);
    }
    wNAF(d3) {
      return E5.wNAFCached(this, d3, h4.normalizeZ);
    }
    multiplyUnsafe(d3) {
      const { endo: v9, n: m3 } = e;
      ft("scalar", d3, dt, m3);
      const O5 = h4.ZERO;
      if (d3 === dt) return O5;
      if (this.is0() || d3 === K2) return this;
      if (!v9 || E5.hasPrecomputes(this)) return E5.wNAFCachedUnsafe(this, d3, h4.normalizeZ);
      let { k1neg: N2, k1: $6, k2neg: B4, k2: A5 } = v9.splitScalar(d3), T4 = O5, S3 = O5, L3 = this;
      for (; $6 > dt || A5 > dt; ) $6 & K2 && (T4 = T4.add(L3)), A5 & K2 && (S3 = S3.add(L3)), L3 = L3.double(), $6 >>= K2, A5 >>= K2;
      return N2 && (T4 = T4.negate()), B4 && (S3 = S3.negate()), S3 = new h4(n2.mul(S3.px, v9.beta), S3.py, S3.pz), T4.add(S3);
    }
    multiply(d3) {
      const { endo: v9, n: m3 } = e;
      ft("scalar", d3, K2, m3);
      let O5, N2;
      if (v9) {
        const { k1neg: $6, k1: B4, k2neg: A5, k2: T4 } = v9.splitScalar(d3);
        let { p: S3, f: L3 } = this.wNAF(B4), { p: U4, f: _2 } = this.wNAF(T4);
        S3 = E5.constTimeNegate($6, S3), U4 = E5.constTimeNegate(A5, U4), U4 = new h4(n2.mul(U4.px, v9.beta), U4.py, U4.pz), O5 = S3.add(U4), N2 = L3.add(_2);
      } else {
        const { p: $6, f: B4 } = this.wNAF(d3);
        O5 = $6, N2 = B4;
      }
      return h4.normalizeZ([O5, N2])[0];
    }
    multiplyAndAddUnsafe(d3, v9, m3) {
      const O5 = h4.BASE, N2 = (B4, A5) => A5 === dt || A5 === K2 || !B4.equals(O5) ? B4.multiplyUnsafe(A5) : B4.multiply(A5), $6 = N2(this, v9).add(N2(d3, m3));
      return $6.is0() ? void 0 : $6;
    }
    toAffine(d3) {
      return l3(this, d3);
    }
    isTorsionFree() {
      const { h: d3, isTorsionFree: v9 } = e;
      if (d3 === K2) return true;
      if (v9) return v9(h4, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: d3, clearCofactor: v9 } = e;
      return d3 === K2 ? this : v9 ? v9(h4, this) : this.multiplyUnsafe(e.h);
    }
    toRawBytes(d3 = true) {
      return jt("isCompressed", d3), this.assertValidity(), o3(h4, this, d3);
    }
    toHex(d3 = true) {
      return jt("isCompressed", d3), Ct(this.toRawBytes(d3));
    }
  }
  h4.BASE = new h4(e.Gx, e.Gy, n2.ONE), h4.ZERO = new h4(n2.ZERO, n2.ONE, n2.ZERO);
  const y4 = e.nBitLength, E5 = dc(h4, e.endo ? Math.ceil(y4 / 2) : y4);
  return { CURVE: e, ProjectivePoint: h4, normPrivateKeyToScalar: a2, weierstrassEquation: s2, isWithinCurveOrder: c3 };
}
function Bc(t) {
  const e = Wr(t);
  return Mt(e, { hash: "hash", hmac: "function", randomBytes: "function" }, { bits2int: "function", bits2int_modN: "function", lowS: "boolean" }), Object.freeze({ lowS: true, ...e });
}
function Ic(t) {
  const e = Bc(t), { Fp: n2, n: r2 } = e, o3 = n2.BYTES + 1, i3 = 2 * n2.BYTES + 1;
  function s2(g2) {
    return X(g2, r2);
  }
  function c3(g2) {
    return en(g2, r2);
  }
  const { ProjectivePoint: a2, normPrivateKeyToScalar: u4, weierstrassEquation: l3, isWithinCurveOrder: f6 } = Ac({ ...e, toBytes(g2, w4, b5) {
    const I3 = w4.toAffine(), R6 = n2.toBytes(I3.x), x3 = ee;
    return jt("isCompressed", b5), b5 ? x3(Uint8Array.from([w4.hasEvenY() ? 2 : 3]), R6) : x3(Uint8Array.from([4]), R6, n2.toBytes(I3.y));
  }, fromBytes(g2) {
    const w4 = g2.length, b5 = g2[0], I3 = g2.subarray(1);
    if (w4 === o3 && (b5 === 2 || b5 === 3)) {
      const R6 = Ot(I3);
      if (!we(R6, K2, n2.ORDER)) throw new Error("Point is not on curve");
      const x3 = l3(R6);
      let C5;
      try {
        C5 = n2.sqrt(x3);
      } catch (M5) {
        const D3 = M5 instanceof Error ? ": " + M5.message : "";
        throw new Error("Point is not on curve" + D3);
      }
      const P5 = (C5 & K2) === K2;
      return (b5 & 1) === 1 !== P5 && (C5 = n2.neg(C5)), { x: R6, y: C5 };
    } else if (w4 === i3 && b5 === 4) {
      const R6 = n2.fromBytes(I3.subarray(0, n2.BYTES)), x3 = n2.fromBytes(I3.subarray(n2.BYTES, 2 * n2.BYTES));
      return { x: R6, y: x3 };
    } else {
      const R6 = o3, x3 = i3;
      throw new Error("invalid Point, expected length of " + R6 + ", or uncompressed " + x3 + ", got " + w4);
    }
  } }), h4 = (g2) => Ct(Vt(g2, e.nByteLength));
  function y4(g2) {
    const w4 = r2 >> K2;
    return g2 > w4;
  }
  function E5(g2) {
    return y4(g2) ? s2(-g2) : g2;
  }
  const p4 = (g2, w4, b5) => Ot(g2.slice(w4, b5));
  class d3 {
    constructor(w4, b5, I3) {
      this.r = w4, this.s = b5, this.recovery = I3, this.assertValidity();
    }
    static fromCompact(w4) {
      const b5 = e.nByteLength;
      return w4 = et("compactSignature", w4, b5 * 2), new d3(p4(w4, 0, b5), p4(w4, b5, 2 * b5));
    }
    static fromDER(w4) {
      const { r: b5, s: I3 } = lt.toSig(et("DER", w4));
      return new d3(b5, I3);
    }
    assertValidity() {
      ft("r", this.r, K2, r2), ft("s", this.s, K2, r2);
    }
    addRecoveryBit(w4) {
      return new d3(this.r, this.s, w4);
    }
    recoverPublicKey(w4) {
      const { r: b5, s: I3, recovery: R6 } = this, x3 = B4(et("msgHash", w4));
      if (R6 == null || ![0, 1, 2, 3].includes(R6)) throw new Error("recovery id invalid");
      const C5 = R6 === 2 || R6 === 3 ? b5 + e.n : b5;
      if (C5 >= n2.ORDER) throw new Error("recovery id 2 or 3 invalid");
      const P5 = (R6 & 1) === 0 ? "02" : "03", k5 = a2.fromHex(P5 + h4(C5)), M5 = c3(C5), D3 = s2(-x3 * M5), z4 = s2(I3 * M5), Z3 = a2.BASE.multiplyAndAddUnsafe(k5, D3, z4);
      if (!Z3) throw new Error("point at infinify");
      return Z3.assertValidity(), Z3;
    }
    hasHighS() {
      return y4(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new d3(this.r, s2(-this.s), this.recovery) : this;
    }
    toDERRawBytes() {
      return kt(this.toDERHex());
    }
    toDERHex() {
      return lt.hexFromSig({ r: this.r, s: this.s });
    }
    toCompactRawBytes() {
      return kt(this.toCompactHex());
    }
    toCompactHex() {
      return h4(this.r) + h4(this.s);
    }
  }
  const v9 = { isValidPrivateKey(g2) {
    try {
      return u4(g2), true;
    } catch {
      return false;
    }
  }, normPrivateKeyToScalar: u4, randomPrivateKey: () => {
    const g2 = zr(e.n);
    return uc(e.randomBytes(g2), e.n);
  }, precompute(g2 = 8, w4 = a2.BASE) {
    return w4._setWindowSize(g2), w4.multiply(BigInt(3)), w4;
  } };
  function m3(g2, w4 = true) {
    return a2.fromPrivateKey(g2).toRawBytes(w4);
  }
  function O5(g2) {
    const w4 = St(g2), b5 = typeof g2 == "string", I3 = (w4 || b5) && g2.length;
    return w4 ? I3 === o3 || I3 === i3 : b5 ? I3 === 2 * o3 || I3 === 2 * i3 : g2 instanceof a2;
  }
  function N2(g2, w4, b5 = true) {
    if (O5(g2)) throw new Error("first arg must be private key");
    if (!O5(w4)) throw new Error("second arg must be public key");
    return a2.fromHex(w4).multiply(u4(g2)).toRawBytes(b5);
  }
  const $6 = e.bits2int || function(g2) {
    if (g2.length > 8192) throw new Error("input is too large");
    const w4 = Ot(g2), b5 = g2.length * 8 - e.nBitLength;
    return b5 > 0 ? w4 >> BigInt(b5) : w4;
  }, B4 = e.bits2int_modN || function(g2) {
    return s2($6(g2));
  }, A5 = Xe(e.nBitLength);
  function T4(g2) {
    return ft("num < 2^" + e.nBitLength, g2, dt, A5), Vt(g2, e.nByteLength);
  }
  function S3(g2, w4, b5 = L3) {
    if (["recovered", "canonical"].some((W3) => W3 in b5)) throw new Error("sign() legacy options not supported");
    const { hash: I3, randomBytes: R6 } = e;
    let { lowS: x3, prehash: C5, extraEntropy: P5 } = b5;
    x3 == null && (x3 = true), g2 = et("msgHash", g2), Jr(b5), C5 && (g2 = et("prehashed msgHash", I3(g2)));
    const k5 = B4(g2), M5 = u4(w4), D3 = [T4(M5), T4(k5)];
    if (P5 != null && P5 !== false) {
      const W3 = P5 === true ? R6(n2.BYTES) : P5;
      D3.push(et("extraEntropy", W3));
    }
    const z4 = ee(...D3), Z3 = k5;
    function it2(W3) {
      const J5 = $6(W3);
      if (!f6(J5)) return;
      const Oe3 = c3(J5), Ft2 = a2.BASE.multiply(J5).toAffine(), vt = s2(Ft2.x);
      if (vt === dt) return;
      const zt2 = s2(Oe3 * s2(Z3 + vt * M5));
      if (zt2 === dt) return;
      let Ut2 = (Ft2.x === vt ? 0 : 2) | Number(Ft2.y & K2), vn2 = zt2;
      return x3 && y4(zt2) && (vn2 = E5(zt2), Ut2 ^= 1), new d3(vt, vn2, Ut2);
    }
    return { seed: z4, k2sig: it2 };
  }
  const L3 = { lowS: e.lowS, prehash: false }, U4 = { lowS: e.lowS, prehash: false };
  function _2(g2, w4, b5 = L3) {
    const { seed: I3, k2sig: R6 } = S3(g2, w4, b5), x3 = e;
    return Vr(x3.hash.outputLen, x3.nByteLength, x3.hmac)(I3, R6);
  }
  a2.BASE._setWindowSize(8);
  function j3(g2, w4, b5, I3 = U4) {
    const R6 = g2;
    w4 = et("msgHash", w4), b5 = et("publicKey", b5);
    const { lowS: x3, prehash: C5, format: P5 } = I3;
    if (Jr(I3), "strict" in I3) throw new Error("options.strict was renamed to lowS");
    if (P5 !== void 0 && P5 !== "compact" && P5 !== "der") throw new Error("format must be compact or der");
    const k5 = typeof R6 == "string" || St(R6), M5 = !k5 && !P5 && typeof R6 == "object" && R6 !== null && typeof R6.r == "bigint" && typeof R6.s == "bigint";
    if (!k5 && !M5) throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    let D3, z4;
    try {
      if (M5 && (D3 = new d3(R6.r, R6.s)), k5) {
        try {
          P5 !== "compact" && (D3 = d3.fromDER(R6));
        } catch (Ut2) {
          if (!(Ut2 instanceof lt.Err)) throw Ut2;
        }
        !D3 && P5 !== "der" && (D3 = d3.fromCompact(R6));
      }
      z4 = a2.fromHex(b5);
    } catch {
      return false;
    }
    if (!D3 || x3 && D3.hasHighS()) return false;
    C5 && (w4 = e.hash(w4));
    const { r: Z3, s: it2 } = D3, W3 = B4(w4), J5 = c3(it2), Oe3 = s2(W3 * J5), Ft2 = s2(Z3 * J5), vt = a2.BASE.multiplyAndAddUnsafe(z4, Oe3, Ft2)?.toAffine();
    return vt ? s2(vt.x) === Z3 : false;
  }
  return { CURVE: e, getPublicKey: m3, getSharedSecret: N2, sign: _2, verify: j3, ProjectivePoint: a2, Signature: d3, utils: v9 };
}
function Nc(t) {
  return { hash: t, hmac: (e, ...n2) => pe(t, e, Vi(...n2)), randomBytes: $t };
}
function Uc(t, e) {
  const n2 = (r2) => Ic({ ...t, ...Nc(r2) });
  return { ...n2(e), create: n2 };
}
var to = Kr(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"));
var Tc = to.create(BigInt("-3"));
var Rc = BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b");
var _c = Uc({ a: Tc, b: Rc, Fp: to, n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"), Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"), Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"), h: BigInt(1), lowS: false }, Jt);
var fn = "base10";
var G3 = "base16";
var Ht = "base64pad";
var Ee = "base64url";
var qt = "utf8";
var ln = 0;
var Kt = 1;
var ne = 2;
var $c = 0;
var eo = 1;
var re = 12;
var dn = 32;
function Lc() {
  const t = un.utils.randomPrivateKey(), e = un.getPublicKey(t);
  return { privateKey: toString(t, G3), publicKey: toString(e, G3) };
}
function jc() {
  const t = $t(dn);
  return toString(t, G3);
}
function Cc(t, e) {
  const n2 = un.getSharedSecret(fromString(t, G3), fromString(e, G3)), r2 = Vs(Jt, n2, void 0, void 0, dn);
  return toString(r2, G3);
}
function Pc(t) {
  const e = Jt(fromString(t, G3));
  return toString(e, G3);
}
function kc(t) {
  const e = Jt(fromString(t, qt));
  return toString(e, G3);
}
function hn(t) {
  return fromString(`${t}`, fn);
}
function Bt(t) {
  return Number(toString(t, fn));
}
function no(t) {
  return t.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function ro(t) {
  const e = t.replace(/-/g, "+").replace(/_/g, "/"), n2 = (4 - e.length % 4) % 4;
  return e + "=".repeat(n2);
}
function Vc(t) {
  const e = hn(typeof t.type < "u" ? t.type : ln);
  if (Bt(e) === Kt && typeof t.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
  const n2 = typeof t.senderPublicKey < "u" ? fromString(t.senderPublicKey, G3) : void 0, r2 = typeof t.iv < "u" ? fromString(t.iv, G3) : $t(re), o3 = fromString(t.symKey, G3), i3 = $r(o3, r2).encrypt(fromString(t.message, qt)), s2 = pn({ type: e, sealed: i3, iv: r2, senderPublicKey: n2 });
  return t.encoding === Ee ? no(s2) : s2;
}
function Mc(t) {
  const e = fromString(t.symKey, G3), { sealed: n2, iv: r2 } = ve({ encoded: t.encoded, encoding: t.encoding }), o3 = $r(e, r2).decrypt(n2);
  if (o3 === null) throw new Error("Failed to decrypt");
  return toString(o3, qt);
}
function Dc(t, e) {
  const n2 = hn(ne), r2 = $t(re), o3 = fromString(t, qt), i3 = pn({ type: n2, sealed: o3, iv: r2 });
  return e === Ee ? no(i3) : i3;
}
function Hc(t, e) {
  const { sealed: n2 } = ve({ encoded: t, encoding: e });
  return toString(n2, qt);
}
function pn(t) {
  if (Bt(t.type) === ne) return toString(concat([t.type, t.sealed]), Ht);
  if (Bt(t.type) === Kt) {
    if (typeof t.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
    return toString(concat([t.type, t.senderPublicKey, t.iv, t.sealed]), Ht);
  }
  return toString(concat([t.type, t.iv, t.sealed]), Ht);
}
function ve(t) {
  const e = (t.encoding || Ht) === Ee ? ro(t.encoded) : t.encoded, n2 = fromString(e, Ht), r2 = n2.slice($c, eo), o3 = eo;
  if (Bt(r2) === Kt) {
    const a2 = o3 + dn, u4 = a2 + re, l3 = n2.slice(o3, a2), f6 = n2.slice(a2, u4), h4 = n2.slice(u4);
    return { type: r2, sealed: h4, iv: f6, senderPublicKey: l3 };
  }
  if (Bt(r2) === ne) {
    const a2 = n2.slice(o3), u4 = $t(re);
    return { type: r2, sealed: a2, iv: u4 };
  }
  const i3 = o3 + re, s2 = n2.slice(o3, i3), c3 = n2.slice(i3);
  return { type: r2, sealed: c3, iv: s2 };
}
function qc(t, e) {
  const n2 = ve({ encoded: t, encoding: e?.encoding });
  return oo({ type: Bt(n2.type), senderPublicKey: typeof n2.senderPublicKey < "u" ? toString(n2.senderPublicKey, G3) : void 0, receiverPublicKey: e?.receiverPublicKey });
}
function oo(t) {
  const e = t?.type || ln;
  if (e === Kt) {
    if (typeof t?.senderPublicKey > "u") throw new Error("missing sender public key");
    if (typeof t?.receiverPublicKey > "u") throw new Error("missing receiver public key");
  }
  return { type: e, senderPublicKey: t?.senderPublicKey, receiverPublicKey: t?.receiverPublicKey };
}
function Kc(t) {
  return t.type === Kt && typeof t.senderPublicKey == "string" && typeof t.receiverPublicKey == "string";
}
function Fc(t) {
  return t.type === ne;
}
function io(t) {
  const e = Buffer.from(t.x, "base64"), n2 = Buffer.from(t.y, "base64");
  return concat([new Uint8Array([4]), e, n2]);
}
function zc(t, e) {
  const [n2, r2, o3] = t.split("."), i3 = Buffer.from(ro(o3), "base64");
  if (i3.length !== 64) throw new Error("Invalid signature length");
  const s2 = i3.slice(0, 32), c3 = i3.slice(32, 64), a2 = `${n2}.${r2}`, u4 = Jt(a2), l3 = io(e);
  if (!_c.verify(concat([s2, c3]), u4, l3)) throw new Error("Invalid signature");
  return sn(t).payload;
}
var so = "irn";
function Zc(t) {
  return t?.relay || { protocol: so };
}
function Yc(t) {
  const e = C[t];
  if (typeof e > "u") throw new Error(`Relay Protocol not supported: ${t}`);
  return e;
}
function co(t, e = "-") {
  const n2 = {}, r2 = "relay" + e;
  return Object.keys(t).forEach((o3) => {
    if (o3.startsWith(r2)) {
      const i3 = o3.replace(r2, ""), s2 = t[o3];
      n2[i3] = s2;
    }
  }), n2;
}
function Gc(t) {
  if (!t.includes("wc:")) {
    const u4 = Le(t);
    u4 != null && u4.includes("wc:") && (t = u4);
  }
  t = t.includes("wc://") ? t.replace("wc://", "") : t, t = t.includes("wc:") ? t.replace("wc:", "") : t;
  const e = t.indexOf(":"), n2 = t.indexOf("?") !== -1 ? t.indexOf("?") : void 0, r2 = t.substring(0, e), o3 = t.substring(e + 1, n2).split("@"), i3 = typeof n2 < "u" ? t.substring(n2) : "", s2 = new URLSearchParams(i3), c3 = {};
  s2.forEach((u4, l3) => {
    c3[l3] = u4;
  });
  const a2 = typeof c3.methods == "string" ? c3.methods.split(",") : void 0;
  return { protocol: r2, topic: ao(o3[0]), version: parseInt(o3[1], 10), symKey: c3.symKey, relay: co(c3), methods: a2, expiryTimestamp: c3.expiryTimestamp ? parseInt(c3.expiryTimestamp, 10) : void 0 };
}
function ao(t) {
  return t.startsWith("//") ? t.substring(2) : t;
}
function uo(t, e = "-") {
  const n2 = "relay", r2 = {};
  return Object.keys(t).forEach((o3) => {
    const i3 = o3, s2 = n2 + e + i3;
    t[i3] && (r2[s2] = t[i3]);
  }), r2;
}
function Wc(t) {
  const e = new URLSearchParams(), n2 = uo(t.relay);
  Object.keys(n2).sort().forEach((o3) => {
    e.set(o3, n2[o3]);
  }), e.set("symKey", t.symKey), t.expiryTimestamp && e.set("expiryTimestamp", t.expiryTimestamp.toString()), t.methods && e.set("methods", t.methods.join(","));
  const r2 = e.toString();
  return `${t.protocol}:${t.topic}@${t.version}?${r2}`;
}
function Xc(t, e, n2) {
  return `${t}?wc_ev=${n2}&topic=${e}`;
}
function It(t) {
  const e = [];
  return t.forEach((n2) => {
    const [r2, o3] = n2.split(":");
    e.push(`${r2}:${o3}`);
  }), e;
}
function ho(t) {
  const e = [];
  return Object.values(t).forEach((n2) => {
    e.push(...It(n2.accounts));
  }), e;
}
function po(t, e) {
  const n2 = [];
  return Object.values(t).forEach((r2) => {
    It(r2.accounts).includes(e) && n2.push(...r2.methods);
  }), n2;
}
function go(t, e) {
  const n2 = [];
  return Object.values(t).forEach((r2) => {
    It(r2.accounts).includes(e) && n2.push(...r2.events);
  }), n2;
}
function mo(t) {
  const e = {};
  return t?.forEach((n2) => {
    var r2;
    const [o3, i3] = n2.split(":");
    e[o3] || (e[o3] = { accounts: [], chains: [], events: [], methods: [] }), e[o3].accounts.push(n2), (r2 = e[o3].chains) == null || r2.push(`${o3}:${i3}`);
  }), e;
}
function ca(t, e) {
  e = e.map((r2) => r2.replace("did:pkh:", ""));
  const n2 = mo(e);
  for (const [r2, o3] of Object.entries(n2)) o3.methods ? o3.methods = at(o3.methods, t) : o3.methods = t, o3.events = ["chainChanged", "accountsChanged"];
  return n2;
}
var wo = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };
var bo = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function ht(t, e) {
  const { message: n2, code: r2 } = bo[t];
  return { message: e ? `${n2} ${e}` : n2, code: r2 };
}
function Nt(t, e) {
  const { message: n2, code: r2 } = wo[t];
  return { message: e ? `${n2} ${e}` : n2, code: r2 };
}
function oe(t, e) {
  return Array.isArray(t) ? typeof e < "u" && t.length ? t.every(e) : true : false;
}
function xe(t) {
  return Object.getPrototypeOf(t) === Object.prototype && Object.keys(t).length;
}
function Et(t) {
  return typeof t > "u";
}
function nt(t, e) {
  return e && Et(t) ? true : typeof t == "string" && !!t.trim().length;
}
function Se(t, e) {
  return e && Et(t) ? true : typeof t == "number" && !isNaN(t);
}
function aa(t, e) {
  const { requiredNamespaces: n2 } = e, r2 = Object.keys(t.namespaces), o3 = Object.keys(n2);
  let i3 = true;
  return gt(o3, r2) ? (r2.forEach((s2) => {
    const { accounts: c3, methods: a2, events: u4 } = t.namespaces[s2], l3 = It(c3), f6 = n2[s2];
    (!gt(ce(s2, f6), l3) || !gt(f6.methods, a2) || !gt(f6.events, u4)) && (i3 = false);
  }), i3) : false;
}
function ie(t) {
  return nt(t, false) && t.includes(":") ? t.split(":").length === 2 : false;
}
function Eo(t) {
  if (nt(t, false) && t.includes(":")) {
    const e = t.split(":");
    if (e.length === 3) {
      const n2 = e[0] + ":" + e[1];
      return !!e[2] && ie(n2);
    }
  }
  return false;
}
function ua(t) {
  function e(n2) {
    try {
      return typeof new URL(n2) < "u";
    } catch {
      return false;
    }
  }
  try {
    if (nt(t, false)) {
      if (e(t)) return true;
      const n2 = Le(t);
      return e(n2);
    }
  } catch {
  }
  return false;
}
function fa(t) {
  var e;
  return (e = t?.proposer) == null ? void 0 : e.publicKey;
}
function la(t) {
  return t?.topic;
}
function da(t, e) {
  let n2 = null;
  return nt(t?.publicKey, false) || (n2 = ht("MISSING_OR_INVALID", `${e} controller public key should be a string`)), n2;
}
function mn(t) {
  let e = true;
  return oe(t) ? t.length && (e = t.every((n2) => nt(n2, false))) : e = false, e;
}
function vo(t, e, n2) {
  let r2 = null;
  return oe(e) && e.length ? e.forEach((o3) => {
    r2 || ie(o3) || (r2 = Nt("UNSUPPORTED_CHAINS", `${n2}, chain ${o3} should be a string and conform to "namespace:chainId" format`));
  }) : ie(t) || (r2 = Nt("UNSUPPORTED_CHAINS", `${n2}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), r2;
}
function xo(t, e, n2) {
  let r2 = null;
  return Object.entries(t).forEach(([o3, i3]) => {
    if (r2) return;
    const s2 = vo(o3, ce(o3, i3), `${e} ${n2}`);
    s2 && (r2 = s2);
  }), r2;
}
function So(t, e) {
  let n2 = null;
  return oe(t) ? t.forEach((r2) => {
    n2 || Eo(r2) || (n2 = Nt("UNSUPPORTED_ACCOUNTS", `${e}, account ${r2} should be a string and conform to "namespace:chainId:address" format`));
  }) : n2 = Nt("UNSUPPORTED_ACCOUNTS", `${e}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), n2;
}
function Oo(t, e) {
  let n2 = null;
  return Object.values(t).forEach((r2) => {
    if (n2) return;
    const o3 = So(r2?.accounts, `${e} namespace`);
    o3 && (n2 = o3);
  }), n2;
}
function Ao(t, e) {
  let n2 = null;
  return mn(t?.methods) ? mn(t?.events) || (n2 = Nt("UNSUPPORTED_EVENTS", `${e}, events should be an array of strings or empty array for no events`)) : n2 = Nt("UNSUPPORTED_METHODS", `${e}, methods should be an array of strings or empty array for no methods`), n2;
}
function wn(t, e) {
  let n2 = null;
  return Object.values(t).forEach((r2) => {
    if (n2) return;
    const o3 = Ao(r2, `${e}, namespace`);
    o3 && (n2 = o3);
  }), n2;
}
function ha(t, e, n2) {
  let r2 = null;
  if (t && xe(t)) {
    const o3 = wn(t, e);
    o3 && (r2 = o3);
    const i3 = xo(t, e, n2);
    i3 && (r2 = i3);
  } else r2 = ht("MISSING_OR_INVALID", `${e}, ${n2} should be an object with data`);
  return r2;
}
function Bo(t, e) {
  let n2 = null;
  if (t && xe(t)) {
    const r2 = wn(t, e);
    r2 && (n2 = r2);
    const o3 = Oo(t, e);
    o3 && (n2 = o3);
  } else n2 = ht("MISSING_OR_INVALID", `${e}, namespaces should be an object with data`);
  return n2;
}
function Io(t) {
  return nt(t.protocol, true);
}
function pa(t, e) {
  let n2 = false;
  return e && !t ? n2 = true : t && oe(t) && t.length && t.forEach((r2) => {
    n2 = Io(r2);
  }), n2;
}
function ga(t) {
  return typeof t == "number";
}
function ya(t) {
  return typeof t < "u" && typeof t !== null;
}
function ma(t) {
  return !(!t || typeof t != "object" || !t.code || !Se(t.code, false) || !t.message || !nt(t.message, false));
}
function wa(t) {
  return !(Et(t) || !nt(t.method, false));
}
function ba(t) {
  return !(Et(t) || Et(t.result) && Et(t.error) || !Se(t.id, false) || !nt(t.jsonrpc, false));
}
function Ea(t) {
  return !(Et(t) || !nt(t.name, false));
}
function va(t, e) {
  return !(!ie(e) || !ho(t).includes(e));
}
function xa(t, e, n2) {
  return nt(n2, false) ? po(t, e).includes(n2) : false;
}
function Sa(t, e, n2) {
  return nt(n2, false) ? go(t, e).includes(n2) : false;
}
function No(t, e, n2) {
  let r2 = null;
  const o3 = Oa(t), i3 = Aa(e), s2 = Object.keys(o3), c3 = Object.keys(i3), a2 = Uo(Object.keys(t)), u4 = Uo(Object.keys(e)), l3 = a2.filter((f6) => !u4.includes(f6));
  return l3.length && (r2 = ht("NON_CONFORMING_NAMESPACES", `${n2} namespaces keys don't satisfy requiredNamespaces.
      Required: ${l3.toString()}
      Received: ${Object.keys(e).toString()}`)), gt(s2, c3) || (r2 = ht("NON_CONFORMING_NAMESPACES", `${n2} namespaces chains don't satisfy required namespaces.
      Required: ${s2.toString()}
      Approved: ${c3.toString()}`)), Object.keys(e).forEach((f6) => {
    if (!f6.includes(":") || r2) return;
    const h4 = It(e[f6].accounts);
    h4.includes(f6) || (r2 = ht("NON_CONFORMING_NAMESPACES", `${n2} namespaces accounts don't satisfy namespace accounts for ${f6}
        Required: ${f6}
        Approved: ${h4.toString()}`));
  }), s2.forEach((f6) => {
    r2 || (gt(o3[f6].methods, i3[f6].methods) ? gt(o3[f6].events, i3[f6].events) || (r2 = ht("NON_CONFORMING_NAMESPACES", `${n2} namespaces events don't satisfy namespace events for ${f6}`)) : r2 = ht("NON_CONFORMING_NAMESPACES", `${n2} namespaces methods don't satisfy namespace methods for ${f6}`));
  }), r2;
}
function Oa(t) {
  const e = {};
  return Object.keys(t).forEach((n2) => {
    var r2;
    n2.includes(":") ? e[n2] = t[n2] : (r2 = t[n2].chains) == null || r2.forEach((o3) => {
      e[o3] = { methods: t[n2].methods, events: t[n2].events };
    });
  }), e;
}
function Uo(t) {
  return [...new Set(t.map((e) => e.includes(":") ? e.split(":")[0] : e))];
}
function Aa(t) {
  const e = {};
  return Object.keys(t).forEach((n2) => {
    if (n2.includes(":")) e[n2] = t[n2];
    else {
      const r2 = It(t[n2].accounts);
      r2?.forEach((o3) => {
        e[o3] = { accounts: t[n2].accounts.filter((i3) => i3.includes(`${o3}:`)), methods: t[n2].methods, events: t[n2].events };
      });
    }
  }), e;
}
function Ba(t, e) {
  return Se(t, false) && t <= e.max && t >= e.min;
}
function Ia() {
  const t = xt();
  return new Promise((e) => {
    switch (t) {
      case Y3.browser:
        e(To());
        break;
      case Y3.reactNative:
        e(Ro());
        break;
      case Y3.node:
        e(_o());
        break;
      default:
        e(true);
    }
  });
}
function To() {
  return Yt() && navigator?.onLine;
}
async function Ro() {
  if (pt() && typeof global < "u" && global != null && global.NetInfo) {
    const t = await (global == null ? void 0 : global.NetInfo.fetch());
    return t?.isConnected;
  }
  return true;
}
function _o() {
  return true;
}
function Na(t) {
  switch (xt()) {
    case Y3.browser:
      $o(t);
      break;
    case Y3.reactNative:
      Lo(t);
      break;
    case Y3.node:
      break;
  }
}
function $o(t) {
  !pt() && Yt() && (window.addEventListener("online", () => t(true)), window.addEventListener("offline", () => t(false)));
}
function Lo(t) {
  pt() && typeof global < "u" && global != null && global.NetInfo && global?.NetInfo.addEventListener((e) => t(e?.isConnected));
}
var bn = {};
var Ua = class {
  static get(e) {
    return bn[e];
  }
  static set(e, n2) {
    bn[e] = n2;
  }
  static delete(e) {
    delete bn[e];
  }
};

// node_modules/.pnpm/@walletconnect+core@2.20.2_@react-native-async-storage+async-storage@1.24.0_react-nativ_cc14b32657dc4d181db251c4aab5d975/node_modules/@walletconnect/core/dist/index.es.js
var import_window_getters2 = __toESM(require_cjs2());
var ze2 = "wc";
var Le2 = 2;
var he2 = "core";
var B2 = `${ze2}@2:${he2}:`;
var Et2 = { name: he2, logger: "error" };
var It2 = { database: ":memory:" };
var Tt2 = "crypto";
var ke2 = "client_ed25519_seed";
var Ct2 = import_time2.ONE_DAY;
var Pt2 = "keychain";
var St2 = "0.3";
var Rt2 = "messages";
var Ot2 = "0.3";
var je2 = import_time2.SIX_HOURS;
var At2 = "publisher";
var xt2 = "irn";
var Nt2 = "error";
var Ue = "wss://relay.walletconnect.org";
var $t2 = "relayer";
var C3 = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" };
var zt = "_subscription";
var L = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" };
var Lt2 = 0.1;
var _e2 = "2.20.2";
var Q = { link_mode: "link_mode", relay: "relay" };
var le2 = { inbound: "inbound", outbound: "outbound" };
var kt2 = "0.3";
var jt2 = "WALLETCONNECT_CLIENT_ID";
var Fe2 = "WALLETCONNECT_LINK_MODE_APPS";
var $3 = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" };
var Ut = "subscription";
var Ft = "0.3";
var Hs2 = import_time2.FIVE_SECONDS * 1e3;
var Mt2 = "pairing";
var Kt2 = "0.3";
var ie2 = { wc_pairingDelete: { req: { ttl: import_time2.ONE_DAY, prompt: false, tag: 1e3 }, res: { ttl: import_time2.ONE_DAY, prompt: false, tag: 1001 } }, wc_pairingPing: { req: { ttl: import_time2.THIRTY_SECONDS, prompt: false, tag: 1002 }, res: { ttl: import_time2.THIRTY_SECONDS, prompt: false, tag: 1003 } }, unregistered_method: { req: { ttl: import_time2.ONE_DAY, prompt: false, tag: 0 }, res: { ttl: import_time2.ONE_DAY, prompt: false, tag: 0 } } };
var se2 = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" };
var F4 = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" };
var Bt2 = "history";
var Vt2 = "0.3";
var qt2 = "expirer";
var M3 = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" };
var Gt2 = "0.3";
var Wt2 = "verify-api";
var Xs2 = "https://verify.walletconnect.com";
var Ht2 = "https://verify.walletconnect.org";
var ue2 = Ht2;
var Yt2 = `${ue2}/v3`;
var Jt2 = [Xs2, Ht2];
var Xt2 = "echo";
var Zt = "https://echo.walletconnect.com";
var G4 = { pairing_started: "pairing_started", pairing_uri_validation_success: "pairing_uri_validation_success", pairing_uri_not_expired: "pairing_uri_not_expired", store_new_pairing: "store_new_pairing", subscribing_pairing_topic: "subscribing_pairing_topic", subscribe_pairing_topic_success: "subscribe_pairing_topic_success", existing_pairing: "existing_pairing", pairing_not_expired: "pairing_not_expired", emit_inactive_pairing: "emit_inactive_pairing", emit_session_proposal: "emit_session_proposal", subscribing_to_pairing_topic: "subscribing_to_pairing_topic" };
var Y4 = { no_wss_connection: "no_wss_connection", no_internet_connection: "no_internet_connection", malformed_pairing_uri: "malformed_pairing_uri", active_pairing_already_exists: "active_pairing_already_exists", subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure", pairing_expired: "pairing_expired", proposal_expired: "proposal_expired", proposal_listener_not_found: "proposal_listener_not_found" };
var Qs2 = { session_approve_started: "session_approve_started", proposal_not_expired: "proposal_not_expired", session_namespaces_validation_success: "session_namespaces_validation_success", create_session_topic: "create_session_topic", subscribing_session_topic: "subscribing_session_topic", subscribe_session_topic_success: "subscribe_session_topic_success", publishing_session_approve: "publishing_session_approve", session_approve_publish_success: "session_approve_publish_success", store_session: "store_session", publishing_session_settle: "publishing_session_settle", session_settle_publish_success: "session_settle_publish_success" };
var er2 = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", proposal_expired: "proposal_expired", subscribe_session_topic_failure: "subscribe_session_topic_failure", session_approve_publish_failure: "session_approve_publish_failure", session_settle_publish_failure: "session_settle_publish_failure", session_approve_namespace_validation_failure: "session_approve_namespace_validation_failure", proposal_not_found: "proposal_not_found" };
var tr2 = { authenticated_session_approve_started: "authenticated_session_approve_started", authenticated_session_not_expired: "authenticated_session_not_expired", chains_caip2_compliant: "chains_caip2_compliant", chains_evm_compliant: "chains_evm_compliant", create_authenticated_session_topic: "create_authenticated_session_topic", cacaos_verified: "cacaos_verified", store_authenticated_session: "store_authenticated_session", subscribing_authenticated_session_topic: "subscribing_authenticated_session_topic", subscribe_authenticated_session_topic_success: "subscribe_authenticated_session_topic_success", publishing_authenticated_session_approve: "publishing_authenticated_session_approve", authenticated_session_approve_publish_success: "authenticated_session_approve_publish_success" };
var ir2 = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", missing_session_authenticate_request: "missing_session_authenticate_request", session_authenticate_request_expired: "session_authenticate_request_expired", chains_caip2_compliant_failure: "chains_caip2_compliant_failure", chains_evm_compliant_failure: "chains_evm_compliant_failure", invalid_cacao: "invalid_cacao", subscribe_authenticated_session_topic_failure: "subscribe_authenticated_session_topic_failure", authenticated_session_approve_publish_failure: "authenticated_session_approve_publish_failure", authenticated_session_pending_request_not_found: "authenticated_session_pending_request_not_found" };
var Qt2 = 0.1;
var ei2 = "event-client";
var ti = 86400;
var ii = "https://pulse.walletconnect.org/batch";
function sr2(r2, e) {
  if (r2.length >= 255) throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), i3 = 0; i3 < t.length; i3++) t[i3] = 255;
  for (var s2 = 0; s2 < r2.length; s2++) {
    var n2 = r2.charAt(s2), o3 = n2.charCodeAt(0);
    if (t[o3] !== 255) throw new TypeError(n2 + " is ambiguous");
    t[o3] = s2;
  }
  var a2 = r2.length, c3 = r2.charAt(0), h4 = Math.log(a2) / Math.log(256), l3 = Math.log(256) / Math.log(a2);
  function d3(u4) {
    if (u4 instanceof Uint8Array || (ArrayBuffer.isView(u4) ? u4 = new Uint8Array(u4.buffer, u4.byteOffset, u4.byteLength) : Array.isArray(u4) && (u4 = Uint8Array.from(u4))), !(u4 instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (u4.length === 0) return "";
    for (var b5 = 0, x3 = 0, I3 = 0, D3 = u4.length; I3 !== D3 && u4[I3] === 0; ) I3++, b5++;
    for (var j3 = (D3 - I3) * l3 + 1 >>> 0, T4 = new Uint8Array(j3); I3 !== D3; ) {
      for (var q2 = u4[I3], J5 = 0, K5 = j3 - 1; (q2 !== 0 || J5 < x3) && K5 !== -1; K5--, J5++) q2 += 256 * T4[K5] >>> 0, T4[K5] = q2 % a2 >>> 0, q2 = q2 / a2 >>> 0;
      if (q2 !== 0) throw new Error("Non-zero carry");
      x3 = J5, I3++;
    }
    for (var H3 = j3 - x3; H3 !== j3 && T4[H3] === 0; ) H3++;
    for (var me4 = c3.repeat(b5); H3 < j3; ++H3) me4 += r2.charAt(T4[H3]);
    return me4;
  }
  function g2(u4) {
    if (typeof u4 != "string") throw new TypeError("Expected String");
    if (u4.length === 0) return new Uint8Array();
    var b5 = 0;
    if (u4[b5] !== " ") {
      for (var x3 = 0, I3 = 0; u4[b5] === c3; ) x3++, b5++;
      for (var D3 = (u4.length - b5) * h4 + 1 >>> 0, j3 = new Uint8Array(D3); u4[b5]; ) {
        var T4 = t[u4.charCodeAt(b5)];
        if (T4 === 255) return;
        for (var q2 = 0, J5 = D3 - 1; (T4 !== 0 || q2 < I3) && J5 !== -1; J5--, q2++) T4 += a2 * j3[J5] >>> 0, j3[J5] = T4 % 256 >>> 0, T4 = T4 / 256 >>> 0;
        if (T4 !== 0) throw new Error("Non-zero carry");
        I3 = q2, b5++;
      }
      if (u4[b5] !== " ") {
        for (var K5 = D3 - I3; K5 !== D3 && j3[K5] === 0; ) K5++;
        for (var H3 = new Uint8Array(x3 + (D3 - K5)), me4 = x3; K5 !== D3; ) H3[me4++] = j3[K5++];
        return H3;
      }
    }
  }
  function _2(u4) {
    var b5 = g2(u4);
    if (b5) return b5;
    throw new Error(`Non-${e} character`);
  }
  return { encode: d3, decodeUnsafe: g2, decode: _2 };
}
var rr2 = sr2;
var nr2 = rr2;
var si2 = (r2) => {
  if (r2 instanceof Uint8Array && r2.constructor.name === "Uint8Array") return r2;
  if (r2 instanceof ArrayBuffer) return new Uint8Array(r2);
  if (ArrayBuffer.isView(r2)) return new Uint8Array(r2.buffer, r2.byteOffset, r2.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var or3 = (r2) => new TextEncoder().encode(r2);
var ar2 = (r2) => new TextDecoder().decode(r2);
var cr2 = class {
  constructor(e, t, i3) {
    this.name = e, this.prefix = t, this.baseEncode = i3;
  }
  encode(e) {
    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var hr2 = class {
  constructor(e, t, i3) {
    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = i3;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(e) {
    return ri2(this, e);
  }
};
var lr2 = class {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return ri2(this, e);
  }
  decode(e) {
    const t = e[0], i3 = this.decoders[t];
    if (i3) return i3.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var ri2 = (r2, e) => new lr2({ ...r2.decoders || { [r2.prefix]: r2 }, ...e.decoders || { [e.prefix]: e } });
var ur2 = class {
  constructor(e, t, i3, s2) {
    this.name = e, this.prefix = t, this.baseEncode = i3, this.baseDecode = s2, this.encoder = new cr2(e, t, i3), this.decoder = new hr2(e, t, s2);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
};
var Ee2 = ({ name: r2, prefix: e, encode: t, decode: i3 }) => new ur2(r2, e, t, i3);
var de2 = ({ prefix: r2, name: e, alphabet: t }) => {
  const { encode: i3, decode: s2 } = nr2(t, e);
  return Ee2({ prefix: r2, name: e, encode: i3, decode: (n2) => si2(s2(n2)) });
};
var dr2 = (r2, e, t, i3) => {
  const s2 = {};
  for (let l3 = 0; l3 < e.length; ++l3) s2[e[l3]] = l3;
  let n2 = r2.length;
  for (; r2[n2 - 1] === "="; ) --n2;
  const o3 = new Uint8Array(n2 * t / 8 | 0);
  let a2 = 0, c3 = 0, h4 = 0;
  for (let l3 = 0; l3 < n2; ++l3) {
    const d3 = s2[r2[l3]];
    if (d3 === void 0) throw new SyntaxError(`Non-${i3} character`);
    c3 = c3 << t | d3, a2 += t, a2 >= 8 && (a2 -= 8, o3[h4++] = 255 & c3 >> a2);
  }
  if (a2 >= t || 255 & c3 << 8 - a2) throw new SyntaxError("Unexpected end of data");
  return o3;
};
var gr = (r2, e, t) => {
  const i3 = e[e.length - 1] === "=", s2 = (1 << t) - 1;
  let n2 = "", o3 = 0, a2 = 0;
  for (let c3 = 0; c3 < r2.length; ++c3) for (a2 = a2 << 8 | r2[c3], o3 += 8; o3 > t; ) o3 -= t, n2 += e[s2 & a2 >> o3];
  if (o3 && (n2 += e[s2 & a2 << t - o3]), i3) for (; n2.length * t & 7; ) n2 += "=";
  return n2;
};
var P3 = ({ name: r2, prefix: e, bitsPerChar: t, alphabet: i3 }) => Ee2({ prefix: e, name: r2, encode(s2) {
  return gr(s2, i3, t);
}, decode(s2) {
  return dr2(s2, i3, t, r2);
} });
var pr = Ee2({ prefix: "\0", name: "identity", encode: (r2) => ar2(r2), decode: (r2) => or3(r2) });
var yr = Object.freeze({ __proto__: null, identity: pr });
var br2 = P3({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var mr2 = Object.freeze({ __proto__: null, base2: br2 });
var fr2 = P3({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var Dr2 = Object.freeze({ __proto__: null, base8: fr2 });
var vr2 = de2({ prefix: "9", name: "base10", alphabet: "0123456789" });
var wr2 = Object.freeze({ __proto__: null, base10: vr2 });
var _r2 = P3({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var Er = P3({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Ir2 = Object.freeze({ __proto__: null, base16: _r2, base16upper: Er });
var Tr2 = P3({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var Cr2 = P3({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var Pr2 = P3({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var Sr2 = P3({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var Rr2 = P3({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var Or2 = P3({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var Ar2 = P3({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var xr = P3({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var Nr2 = P3({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var $r2 = Object.freeze({ __proto__: null, base32: Tr2, base32upper: Cr2, base32pad: Pr2, base32padupper: Sr2, base32hex: Rr2, base32hexupper: Or2, base32hexpad: Ar2, base32hexpadupper: xr, base32z: Nr2 });
var zr2 = de2({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var Lr2 = de2({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var kr2 = Object.freeze({ __proto__: null, base36: zr2, base36upper: Lr2 });
var jr2 = de2({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var Ur2 = de2({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var Fr2 = Object.freeze({ __proto__: null, base58btc: jr2, base58flickr: Ur2 });
var Mr2 = P3({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var Kr2 = P3({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var Br2 = P3({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var Vr2 = P3({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var qr2 = Object.freeze({ __proto__: null, base64: Mr2, base64pad: Kr2, base64url: Br2, base64urlpad: Vr2 });
var ni2 = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂");
var Gr2 = ni2.reduce((r2, e, t) => (r2[t] = e, r2), []);
var Wr2 = ni2.reduce((r2, e, t) => (r2[e.codePointAt(0)] = t, r2), []);
function Hr2(r2) {
  return r2.reduce((e, t) => (e += Gr2[t], e), "");
}
function Yr2(r2) {
  const e = [];
  for (const t of r2) {
    const i3 = Wr2[t.codePointAt(0)];
    if (i3 === void 0) throw new Error(`Non-base256emoji character: ${t}`);
    e.push(i3);
  }
  return new Uint8Array(e);
}
var Jr2 = Ee2({ prefix: "🚀", name: "base256emoji", encode: Hr2, decode: Yr2 });
var Xr2 = Object.freeze({ __proto__: null, base256emoji: Jr2 });
var Zr2 = ai;
var oi2 = 128;
var Qr2 = 127;
var en2 = ~Qr2;
var tn2 = Math.pow(2, 31);
function ai(r2, e, t) {
  e = e || [], t = t || 0;
  for (var i3 = t; r2 >= tn2; ) e[t++] = r2 & 255 | oi2, r2 /= 128;
  for (; r2 & en2; ) e[t++] = r2 & 255 | oi2, r2 >>>= 7;
  return e[t] = r2 | 0, ai.bytes = t - i3 + 1, e;
}
var sn3 = Me2;
var rn2 = 128;
var ci = 127;
function Me2(r2, i3) {
  var t = 0, i3 = i3 || 0, s2 = 0, n2 = i3, o3, a2 = r2.length;
  do {
    if (n2 >= a2) throw Me2.bytes = 0, new RangeError("Could not decode varint");
    o3 = r2[n2++], t += s2 < 28 ? (o3 & ci) << s2 : (o3 & ci) * Math.pow(2, s2), s2 += 7;
  } while (o3 >= rn2);
  return Me2.bytes = n2 - i3, t;
}
var nn2 = Math.pow(2, 7);
var on2 = Math.pow(2, 14);
var an2 = Math.pow(2, 21);
var cn2 = Math.pow(2, 28);
var hn2 = Math.pow(2, 35);
var ln2 = Math.pow(2, 42);
var un2 = Math.pow(2, 49);
var dn2 = Math.pow(2, 56);
var gn = Math.pow(2, 63);
var pn2 = function(r2) {
  return r2 < nn2 ? 1 : r2 < on2 ? 2 : r2 < an2 ? 3 : r2 < cn2 ? 4 : r2 < hn2 ? 5 : r2 < ln2 ? 6 : r2 < un2 ? 7 : r2 < dn2 ? 8 : r2 < gn ? 9 : 10;
};
var yn = { encode: Zr2, decode: sn3, encodingLength: pn2 };
var hi = yn;
var li2 = (r2, e, t = 0) => (hi.encode(r2, e, t), e);
var ui = (r2) => hi.encodingLength(r2);
var Ke2 = (r2, e) => {
  const t = e.byteLength, i3 = ui(r2), s2 = i3 + ui(t), n2 = new Uint8Array(s2 + t);
  return li2(r2, n2, 0), li2(t, n2, i3), n2.set(e, s2), new bn2(r2, t, e, n2);
};
var bn2 = class {
  constructor(e, t, i3, s2) {
    this.code = e, this.size = t, this.digest = i3, this.bytes = s2;
  }
};
var di = ({ name: r2, code: e, encode: t }) => new mn2(r2, e, t);
var mn2 = class {
  constructor(e, t, i3) {
    this.name = e, this.code = t, this.encode = i3;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const t = this.encode(e);
      return t instanceof Uint8Array ? Ke2(this.code, t) : t.then((i3) => Ke2(this.code, i3));
    } else throw Error("Unknown type, must be binary type");
  }
};
var gi2 = (r2) => async (e) => new Uint8Array(await crypto.subtle.digest(r2, e));
var fn2 = di({ name: "sha2-256", code: 18, encode: gi2("SHA-256") });
var Dn = di({ name: "sha2-512", code: 19, encode: gi2("SHA-512") });
var vn = Object.freeze({ __proto__: null, sha256: fn2, sha512: Dn });
var pi = 0;
var wn2 = "identity";
var yi2 = si2;
var _n2 = (r2) => Ke2(pi, yi2(r2));
var En2 = { code: pi, name: wn2, encode: yi2, digest: _n2 };
var In = Object.freeze({ __proto__: null, identity: En2 });
new TextEncoder(), new TextDecoder();
var bi2 = { ...yr, ...mr2, ...Dr2, ...wr2, ...Ir2, ...$r2, ...kr2, ...Fr2, ...qr2, ...Xr2 };
({ ...vn, ...In });
function Tn2(r2 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(r2) : new Uint8Array(r2);
}
function mi2(r2, e, t, i3) {
  return { name: r2, prefix: e, encoder: { name: r2, prefix: e, encode: t }, decoder: { decode: i3 } };
}
var fi2 = mi2("utf8", "u", (r2) => "u" + new TextDecoder("utf8").decode(r2), (r2) => new TextEncoder().encode(r2.substring(1)));
var Be2 = mi2("ascii", "a", (r2) => {
  let e = "a";
  for (let t = 0; t < r2.length; t++) e += String.fromCharCode(r2[t]);
  return e;
}, (r2) => {
  r2 = r2.substring(1);
  const e = Tn2(r2.length);
  for (let t = 0; t < r2.length; t++) e[t] = r2.charCodeAt(t);
  return e;
});
var Cn2 = { utf8: fi2, "utf-8": fi2, hex: bi2.base16, latin1: Be2, ascii: Be2, binary: Be2, ...bi2 };
function Pn2(r2, e = "utf8") {
  const t = Cn2[e];
  if (!t) throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r2, "utf8") : t.decoder.decode(`${t.prefix}${r2}`);
}
var Sn2 = Object.defineProperty;
var Rn2 = (r2, e, t) => e in r2 ? Sn2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var W2 = (r2, e, t) => Rn2(r2, typeof e != "symbol" ? e + "" : e, t);
var Di2 = class {
  constructor(e, t) {
    this.core = e, this.logger = t, W2(this, "keychain", /* @__PURE__ */ new Map()), W2(this, "name", Pt2), W2(this, "version", St2), W2(this, "initialized", false), W2(this, "storagePrefix", B2), W2(this, "init", async () => {
      if (!this.initialized) {
        const i3 = await this.getKeyChain();
        typeof i3 < "u" && (this.keychain = i3), this.initialized = true;
      }
    }), W2(this, "has", (i3) => (this.isInitialized(), this.keychain.has(i3))), W2(this, "set", async (i3, s2) => {
      this.isInitialized(), this.keychain.set(i3, s2), await this.persist();
    }), W2(this, "get", (i3) => {
      this.isInitialized();
      const s2 = this.keychain.get(i3);
      if (typeof s2 > "u") {
        const { message: n2 } = ht("NO_MATCHING_KEY", `${this.name}: ${i3}`);
        throw new Error(n2);
      }
      return s2;
    }), W2(this, "del", async (i3) => {
      this.isInitialized(), this.keychain.delete(i3), await this.persist();
    }), this.core = e, this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(e) {
    await this.core.storage.setItem(this.storageKey, fi(e));
  }
  async getKeyChain() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? li(e) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ht("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var On2 = Object.defineProperty;
var An = (r2, e, t) => e in r2 ? On2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var S2 = (r2, e, t) => An(r2, typeof e != "symbol" ? e + "" : e, t);
var vi2 = class {
  constructor(e, t, i3) {
    this.core = e, this.logger = t, S2(this, "name", Tt2), S2(this, "keychain"), S2(this, "randomSessionIdentifier", jc()), S2(this, "initialized", false), S2(this, "init", async () => {
      this.initialized || (await this.keychain.init(), this.initialized = true);
    }), S2(this, "hasKeys", (s2) => (this.isInitialized(), this.keychain.has(s2))), S2(this, "getClientId", async () => {
      this.isInitialized();
      const s2 = await this.getClientSeed(), n2 = Po(s2);
      return Qe(n2.publicKey);
    }), S2(this, "generateKeyPair", () => {
      this.isInitialized();
      const s2 = Lc();
      return this.setPrivateKey(s2.publicKey, s2.privateKey);
    }), S2(this, "signJWT", async (s2) => {
      this.isInitialized();
      const n2 = await this.getClientSeed(), o3 = Po(n2), a2 = this.randomSessionIdentifier, c3 = Ct2;
      return await Qo(a2, s2, c3, o3);
    }), S2(this, "generateSharedKey", (s2, n2, o3) => {
      this.isInitialized();
      const a2 = this.getPrivateKey(s2), c3 = Cc(a2, n2);
      return this.setSymKey(c3, o3);
    }), S2(this, "setSymKey", async (s2, n2) => {
      this.isInitialized();
      const o3 = n2 || Pc(s2);
      return await this.keychain.set(o3, s2), o3;
    }), S2(this, "deleteKeyPair", async (s2) => {
      this.isInitialized(), await this.keychain.del(s2);
    }), S2(this, "deleteSymKey", async (s2) => {
      this.isInitialized(), await this.keychain.del(s2);
    }), S2(this, "encode", async (s2, n2, o3) => {
      this.isInitialized();
      const a2 = oo(o3), c3 = safeJsonStringify(n2);
      if (Fc(a2)) return Dc(c3, o3?.encoding);
      if (Kc(a2)) {
        const g2 = a2.senderPublicKey, _2 = a2.receiverPublicKey;
        s2 = await this.generateSharedKey(g2, _2);
      }
      const h4 = this.getSymKey(s2), { type: l3, senderPublicKey: d3 } = a2;
      return Vc({ type: l3, symKey: h4, message: c3, senderPublicKey: d3, encoding: o3?.encoding });
    }), S2(this, "decode", async (s2, n2, o3) => {
      this.isInitialized();
      const a2 = qc(n2, o3);
      if (Fc(a2)) {
        const c3 = Hc(n2, o3?.encoding);
        return safeJsonParse(c3);
      }
      if (Kc(a2)) {
        const c3 = a2.receiverPublicKey, h4 = a2.senderPublicKey;
        s2 = await this.generateSharedKey(c3, h4);
      }
      try {
        const c3 = this.getSymKey(s2), h4 = Mc({ symKey: c3, encoded: n2, encoding: o3?.encoding });
        return safeJsonParse(h4);
      } catch (c3) {
        this.logger.error(`Failed to decode message from topic: '${s2}', clientId: '${await this.getClientId()}'`), this.logger.error(c3);
      }
    }), S2(this, "getPayloadType", (s2, n2 = Ht) => {
      const o3 = ve({ encoded: s2, encoding: n2 });
      return Bt(o3.type);
    }), S2(this, "getPayloadSenderPublicKey", (s2, n2 = Ht) => {
      const o3 = ve({ encoded: s2, encoding: n2 });
      return o3.senderPublicKey ? toString(o3.senderPublicKey, G3) : void 0;
    }), this.core = e, this.logger = E(t, this.name), this.keychain = i3 || new Di2(this.core, this.logger);
  }
  get context() {
    return y(this.logger);
  }
  async setPrivateKey(e, t) {
    return await this.keychain.set(e, t), e;
  }
  getPrivateKey(e) {
    return this.keychain.get(e);
  }
  async getClientSeed() {
    let e = "";
    try {
      e = this.keychain.get(ke2);
    } catch {
      e = jc(), await this.keychain.set(ke2, e);
    }
    return Pn2(e, "base16");
  }
  getSymKey(e) {
    return this.keychain.get(e);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ht("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var xn2 = Object.defineProperty;
var Nn = Object.defineProperties;
var $n2 = Object.getOwnPropertyDescriptors;
var wi2 = Object.getOwnPropertySymbols;
var zn2 = Object.prototype.hasOwnProperty;
var Ln = Object.prototype.propertyIsEnumerable;
var Ve2 = (r2, e, t) => e in r2 ? xn2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var kn2 = (r2, e) => {
  for (var t in e || (e = {})) zn2.call(e, t) && Ve2(r2, t, e[t]);
  if (wi2) for (var t of wi2(e)) Ln.call(e, t) && Ve2(r2, t, e[t]);
  return r2;
};
var jn2 = (r2, e) => Nn(r2, $n2(e));
var k3 = (r2, e, t) => Ve2(r2, typeof e != "symbol" ? e + "" : e, t);
var _i2 = class extends y2 {
  constructor(e, t) {
    super(e, t), this.logger = e, this.core = t, k3(this, "messages", /* @__PURE__ */ new Map()), k3(this, "messagesWithoutClientAck", /* @__PURE__ */ new Map()), k3(this, "name", Rt2), k3(this, "version", Ot2), k3(this, "initialized", false), k3(this, "storagePrefix", B2), k3(this, "init", async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const i3 = await this.getRelayerMessages();
          typeof i3 < "u" && (this.messages = i3);
          const s2 = await this.getRelayerMessagesWithoutClientAck();
          typeof s2 < "u" && (this.messagesWithoutClientAck = s2), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (i3) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(i3);
        } finally {
          this.initialized = true;
        }
      }
    }), k3(this, "set", async (i3, s2, n2) => {
      this.isInitialized();
      const o3 = kc(s2);
      let a2 = this.messages.get(i3);
      if (typeof a2 > "u" && (a2 = {}), typeof a2[o3] < "u") return o3;
      if (a2[o3] = s2, this.messages.set(i3, a2), n2 === le2.inbound) {
        const c3 = this.messagesWithoutClientAck.get(i3) || {};
        this.messagesWithoutClientAck.set(i3, jn2(kn2({}, c3), { [o3]: s2 }));
      }
      return await this.persist(), o3;
    }), k3(this, "get", (i3) => {
      this.isInitialized();
      let s2 = this.messages.get(i3);
      return typeof s2 > "u" && (s2 = {}), s2;
    }), k3(this, "getWithoutAck", (i3) => {
      this.isInitialized();
      const s2 = {};
      for (const n2 of i3) {
        const o3 = this.messagesWithoutClientAck.get(n2) || {};
        s2[n2] = Object.values(o3);
      }
      return s2;
    }), k3(this, "has", (i3, s2) => {
      this.isInitialized();
      const n2 = this.get(i3), o3 = kc(s2);
      return typeof n2[o3] < "u";
    }), k3(this, "ack", async (i3, s2) => {
      this.isInitialized();
      const n2 = this.messagesWithoutClientAck.get(i3);
      if (typeof n2 > "u") return;
      const o3 = kc(s2);
      delete n2[o3], Object.keys(n2).length === 0 ? this.messagesWithoutClientAck.delete(i3) : this.messagesWithoutClientAck.set(i3, n2), await this.persist();
    }), k3(this, "del", async (i3) => {
      this.isInitialized(), this.messages.delete(i3), this.messagesWithoutClientAck.delete(i3), await this.persist();
    }), this.logger = E(e, this.name), this.core = t;
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get storageKeyWithoutClientAck() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name + "_withoutClientAck";
  }
  async setRelayerMessages(e) {
    await this.core.storage.setItem(this.storageKey, fi(e));
  }
  async setRelayerMessagesWithoutClientAck(e) {
    await this.core.storage.setItem(this.storageKeyWithoutClientAck, fi(e));
  }
  async getRelayerMessages() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? li(e) : void 0;
  }
  async getRelayerMessagesWithoutClientAck() {
    const e = await this.core.storage.getItem(this.storageKeyWithoutClientAck);
    return typeof e < "u" ? li(e) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages), await this.setRelayerMessagesWithoutClientAck(this.messagesWithoutClientAck);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ht("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Un = Object.defineProperty;
var Fn2 = Object.defineProperties;
var Mn2 = Object.getOwnPropertyDescriptors;
var Ei2 = Object.getOwnPropertySymbols;
var Kn2 = Object.prototype.hasOwnProperty;
var Bn = Object.prototype.propertyIsEnumerable;
var qe2 = (r2, e, t) => e in r2 ? Un(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var Ie2 = (r2, e) => {
  for (var t in e || (e = {})) Kn2.call(e, t) && qe2(r2, t, e[t]);
  if (Ei2) for (var t of Ei2(e)) Bn.call(e, t) && qe2(r2, t, e[t]);
  return r2;
};
var Ge2 = (r2, e) => Fn2(r2, Mn2(e));
var V3 = (r2, e, t) => qe2(r2, typeof e != "symbol" ? e + "" : e, t);
var Vn2 = class extends m2 {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, V3(this, "events", new import_events3.EventEmitter()), V3(this, "name", At2), V3(this, "queue", /* @__PURE__ */ new Map()), V3(this, "publishTimeout", (0, import_time2.toMiliseconds)(import_time2.ONE_MINUTE)), V3(this, "initialPublishTimeout", (0, import_time2.toMiliseconds)(import_time2.ONE_SECOND * 15)), V3(this, "needsTransportRestart", false), V3(this, "publish", async (i3, s2, n2) => {
      var o3;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: i3, message: s2, opts: n2 } });
      const a2 = n2?.ttl || je2, c3 = Zc(n2), h4 = n2?.prompt || false, l3 = n2?.tag || 0, d3 = n2?.id || getBigIntRpcId().toString(), g2 = { topic: i3, message: s2, opts: { ttl: a2, relay: c3, prompt: h4, tag: l3, id: d3, attestation: n2?.attestation, tvf: n2?.tvf } }, _2 = `Failed to publish payload, please try again. id:${d3} tag:${l3}`;
      try {
        const u4 = new Promise(async (b5) => {
          const x3 = ({ id: D3 }) => {
            g2.opts.id === D3 && (this.removeRequestFromQueue(D3), this.relayer.events.removeListener(C3.publish, x3), b5(g2));
          };
          this.relayer.events.on(C3.publish, x3);
          const I3 = yi(new Promise((D3, j3) => {
            this.rpcPublish({ topic: i3, message: s2, ttl: a2, prompt: h4, tag: l3, id: d3, attestation: n2?.attestation, tvf: n2?.tvf }).then(D3).catch((T4) => {
              this.logger.warn(T4, T4?.message), j3(T4);
            });
          }), this.initialPublishTimeout, `Failed initial publish, retrying.... id:${d3} tag:${l3}`);
          try {
            await I3, this.events.removeListener(C3.publish, x3);
          } catch (D3) {
            this.queue.set(d3, Ge2(Ie2({}, g2), { attempt: 1 })), this.logger.warn(D3, D3?.message);
          }
        });
        this.logger.trace({ type: "method", method: "publish", params: { id: d3, topic: i3, message: s2, opts: n2 } }), await yi(u4, this.publishTimeout, _2);
      } catch (u4) {
        if (this.logger.debug("Failed to Publish Payload"), this.logger.error(u4), (o3 = n2?.internal) != null && o3.throwOnFailedPublish) throw u4;
      } finally {
        this.queue.delete(d3);
      }
    }), V3(this, "on", (i3, s2) => {
      this.events.on(i3, s2);
    }), V3(this, "once", (i3, s2) => {
      this.events.once(i3, s2);
    }), V3(this, "off", (i3, s2) => {
      this.events.off(i3, s2);
    }), V3(this, "removeListener", (i3, s2) => {
      this.events.removeListener(i3, s2);
    }), this.relayer = e, this.logger = E(t, this.name), this.registerEventListeners();
  }
  get context() {
    return y(this.logger);
  }
  async rpcPublish(e) {
    var t, i3, s2, n2;
    const { topic: o3, message: a2, ttl: c3 = je2, prompt: h4, tag: l3, id: d3, attestation: g2, tvf: _2 } = e, u4 = { method: Yc(Zc().protocol).publish, params: Ie2({ topic: o3, message: a2, ttl: c3, prompt: h4, tag: l3, attestation: g2 }, _2), id: d3 };
    Et((t = u4.params) == null ? void 0 : t.prompt) && ((i3 = u4.params) == null || delete i3.prompt), Et((s2 = u4.params) == null ? void 0 : s2.tag) && ((n2 = u4.params) == null || delete n2.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: u4 });
    const b5 = await this.relayer.request(u4);
    return this.relayer.events.emit(C3.publish, e), this.logger.debug("Successfully Published Payload"), b5;
  }
  removeRequestFromQueue(e) {
    this.queue.delete(e);
  }
  checkQueue() {
    this.queue.forEach(async (e, t) => {
      const i3 = e.attempt + 1;
      this.queue.set(t, Ge2(Ie2({}, e), { attempt: i3 }));
      const { topic: s2, message: n2, opts: o3, attestation: a2 } = e;
      this.logger.warn({}, `Publisher: queue->publishing: ${e.opts.id}, tag: ${e.opts.tag}, attempt: ${i3}`), await this.rpcPublish(Ge2(Ie2({}, e), { topic: s2, message: n2, ttl: o3.ttl, prompt: o3.prompt, tag: o3.tag, id: o3.id, attestation: a2, tvf: o3.tvf })), this.logger.warn({}, `Publisher: queue->published: ${e.opts.id}`);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(r.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = false, this.relayer.events.emit(C3.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(C3.message_ack, (e) => {
      this.removeRequestFromQueue(e.id.toString());
    });
  }
};
var qn = Object.defineProperty;
var Gn2 = (r2, e, t) => e in r2 ? qn(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var re2 = (r2, e, t) => Gn2(r2, typeof e != "symbol" ? e + "" : e, t);
var Wn2 = class {
  constructor() {
    re2(this, "map", /* @__PURE__ */ new Map()), re2(this, "set", (e, t) => {
      const i3 = this.get(e);
      this.exists(e, t) || this.map.set(e, [...i3, t]);
    }), re2(this, "get", (e) => this.map.get(e) || []), re2(this, "exists", (e, t) => this.get(e).includes(t)), re2(this, "delete", (e, t) => {
      if (typeof t > "u") {
        this.map.delete(e);
        return;
      }
      if (!this.map.has(e)) return;
      const i3 = this.get(e);
      if (!this.exists(e, t)) return;
      const s2 = i3.filter((n2) => n2 !== t);
      if (!s2.length) {
        this.map.delete(e);
        return;
      }
      this.map.set(e, s2);
    }), re2(this, "clear", () => {
      this.map.clear();
    });
  }
  get topics() {
    return Array.from(this.map.keys());
  }
};
var Hn = Object.defineProperty;
var Yn2 = Object.defineProperties;
var Jn2 = Object.getOwnPropertyDescriptors;
var Ii2 = Object.getOwnPropertySymbols;
var Xn2 = Object.prototype.hasOwnProperty;
var Zn2 = Object.prototype.propertyIsEnumerable;
var We2 = (r2, e, t) => e in r2 ? Hn(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var ge2 = (r2, e) => {
  for (var t in e || (e = {})) Xn2.call(e, t) && We2(r2, t, e[t]);
  if (Ii2) for (var t of Ii2(e)) Zn2.call(e, t) && We2(r2, t, e[t]);
  return r2;
};
var He2 = (r2, e) => Yn2(r2, Jn2(e));
var f4 = (r2, e, t) => We2(r2, typeof e != "symbol" ? e + "" : e, t);
var Ti2 = class extends P2 {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, f4(this, "subscriptions", /* @__PURE__ */ new Map()), f4(this, "topicMap", new Wn2()), f4(this, "events", new import_events3.EventEmitter()), f4(this, "name", Ut), f4(this, "version", Ft), f4(this, "pending", /* @__PURE__ */ new Map()), f4(this, "cached", []), f4(this, "initialized", false), f4(this, "storagePrefix", B2), f4(this, "subscribeTimeout", (0, import_time2.toMiliseconds)(import_time2.ONE_MINUTE)), f4(this, "initialSubscribeTimeout", (0, import_time2.toMiliseconds)(import_time2.ONE_SECOND * 15)), f4(this, "clientId"), f4(this, "batchSubscribeTopicsLimit", 500), f4(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), await this.restore()), this.initialized = true;
    }), f4(this, "subscribe", async (i3, s2) => {
      this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i3, opts: s2 } });
      try {
        const n2 = Zc(s2), o3 = { topic: i3, relay: n2, transportType: s2?.transportType };
        this.pending.set(i3, o3);
        const a2 = await this.rpcSubscribe(i3, n2, s2);
        return typeof a2 == "string" && (this.onSubscribe(a2, o3), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i3, opts: s2 } })), a2;
      } catch (n2) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(n2), n2;
      }
    }), f4(this, "unsubscribe", async (i3, s2) => {
      this.isInitialized(), typeof s2?.id < "u" ? await this.unsubscribeById(i3, s2.id, s2) : await this.unsubscribeByTopic(i3, s2);
    }), f4(this, "isSubscribed", (i3) => new Promise((s2) => {
      s2(this.topicMap.topics.includes(i3));
    })), f4(this, "isKnownTopic", (i3) => new Promise((s2) => {
      s2(this.topicMap.topics.includes(i3) || this.pending.has(i3) || this.cached.some((n2) => n2.topic === i3));
    })), f4(this, "on", (i3, s2) => {
      this.events.on(i3, s2);
    }), f4(this, "once", (i3, s2) => {
      this.events.once(i3, s2);
    }), f4(this, "off", (i3, s2) => {
      this.events.off(i3, s2);
    }), f4(this, "removeListener", (i3, s2) => {
      this.events.removeListener(i3, s2);
    }), f4(this, "start", async () => {
      await this.onConnect();
    }), f4(this, "stop", async () => {
      await this.onDisconnect();
    }), f4(this, "restart", async () => {
      await this.restore(), await this.onRestart();
    }), f4(this, "checkPending", async () => {
      if (this.pending.size === 0 && (!this.initialized || !this.relayer.connected)) return;
      const i3 = [];
      this.pending.forEach((s2) => {
        i3.push(s2);
      }), await this.batchSubscribe(i3);
    }), f4(this, "registerEventListeners", () => {
      this.relayer.core.heartbeat.on(r.pulse, async () => {
        await this.checkPending();
      }), this.events.on($3.created, async (i3) => {
        const s2 = $3.created;
        this.logger.info(`Emitting ${s2}`), this.logger.debug({ type: "event", event: s2, data: i3 }), await this.persist();
      }), this.events.on($3.deleted, async (i3) => {
        const s2 = $3.deleted;
        this.logger.info(`Emitting ${s2}`), this.logger.debug({ type: "event", event: s2, data: i3 }), await this.persist();
      });
    }), this.relayer = e, this.logger = E(t, this.name), this.clientId = "";
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  get hasAnyTopics() {
    return this.topicMap.topics.length > 0 || this.pending.size > 0 || this.cached.length > 0 || this.subscriptions.size > 0;
  }
  hasSubscription(e, t) {
    let i3 = false;
    try {
      i3 = this.getSubscription(e).topic === t;
    } catch {
    }
    return i3;
  }
  reset() {
    this.cached = [], this.initialized = true;
  }
  onDisable() {
    this.values.length > 0 && (this.cached = this.values), this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e, t) {
    const i3 = this.topicMap.get(e);
    await Promise.all(i3.map(async (s2) => await this.unsubscribeById(e, s2, t)));
  }
  async unsubscribeById(e, t, i3) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: i3 } });
    try {
      const s2 = Zc(i3);
      await this.restartToComplete({ topic: e, id: t, relay: s2 }), await this.rpcUnsubscribe(e, t, s2);
      const n2 = Nt("USER_DISCONNECTED", `${this.name}, ${e}`);
      await this.onUnsubscribe(e, t, n2), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: i3 } });
    } catch (s2) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(s2), s2;
    }
  }
  async rpcSubscribe(e, t, i3) {
    var s2;
    (!i3 || i3?.transportType === Q.relay) && await this.restartToComplete({ topic: e, id: e, relay: t });
    const n2 = { method: Yc(t.protocol).subscribe, params: { topic: e } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: n2 });
    const o3 = (s2 = i3?.internal) == null ? void 0 : s2.throwOnFailedPublish;
    try {
      const a2 = await this.getSubscriptionId(e);
      if (i3?.transportType === Q.link_mode) return setTimeout(() => {
        (this.relayer.connected || this.relayer.connecting) && this.relayer.request(n2).catch((l3) => this.logger.warn(l3));
      }, (0, import_time2.toMiliseconds)(import_time2.ONE_SECOND)), a2;
      const c3 = new Promise(async (l3) => {
        const d3 = (g2) => {
          g2.topic === e && (this.events.removeListener($3.created, d3), l3(g2.id));
        };
        this.events.on($3.created, d3);
        try {
          const g2 = await yi(new Promise((_2, u4) => {
            this.relayer.request(n2).catch((b5) => {
              this.logger.warn(b5, b5?.message), u4(b5);
            }).then(_2);
          }), this.initialSubscribeTimeout, `Subscribing to ${e} failed, please try again`);
          this.events.removeListener($3.created, d3), l3(g2);
        } catch {
        }
      }), h4 = await yi(c3, this.subscribeTimeout, `Subscribing to ${e} failed, please try again`);
      if (!h4 && o3) throw new Error(`Subscribing to ${e} failed, please try again`);
      return h4 ? a2 : null;
    } catch (a2) {
      if (this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(C3.connection_stalled), o3) throw a2;
    }
    return null;
  }
  async rpcBatchSubscribe(e) {
    if (!e.length) return;
    const t = e[0].relay, i3 = { method: Yc(t.protocol).batchSubscribe, params: { topics: e.map((s2) => s2.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i3 });
    try {
      await await yi(new Promise((s2) => {
        this.relayer.request(i3).catch((n2) => this.logger.warn(n2)).then(s2);
      }), this.subscribeTimeout, "rpcBatchSubscribe failed, please try again");
    } catch {
      this.relayer.events.emit(C3.connection_stalled);
    }
  }
  async rpcBatchFetchMessages(e) {
    if (!e.length) return;
    const t = e[0].relay, i3 = { method: Yc(t.protocol).batchFetchMessages, params: { topics: e.map((n2) => n2.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i3 });
    let s2;
    try {
      s2 = await await yi(new Promise((n2, o3) => {
        this.relayer.request(i3).catch((a2) => {
          this.logger.warn(a2), o3(a2);
        }).then(n2);
      }), this.subscribeTimeout, "rpcBatchFetchMessages failed, please try again");
    } catch {
      this.relayer.events.emit(C3.connection_stalled);
    }
    return s2;
  }
  rpcUnsubscribe(e, t, i3) {
    const s2 = { method: Yc(i3.protocol).unsubscribe, params: { topic: e, id: t } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s2 }), this.relayer.request(s2);
  }
  onSubscribe(e, t) {
    this.setSubscription(e, He2(ge2({}, t), { id: e })), this.pending.delete(t.topic);
  }
  onBatchSubscribe(e) {
    e.length && e.forEach((t) => {
      this.setSubscription(t.id, ge2({}, t)), this.pending.delete(t.topic);
    });
  }
  async onUnsubscribe(e, t, i3) {
    this.events.removeAllListeners(t), this.hasSubscription(t, e) && this.deleteSubscription(t, i3), await this.relayer.messages.del(e);
  }
  async setRelayerSubscriptions(e) {
    await this.relayer.core.storage.setItem(this.storageKey, e);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e, t) {
    this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e, subscription: t }), this.addSubscription(e, t);
  }
  addSubscription(e, t) {
    this.subscriptions.set(e, ge2({}, t)), this.topicMap.set(t.topic, e), this.events.emit($3.created, t);
  }
  getSubscription(e) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e });
    const t = this.subscriptions.get(e);
    if (!t) {
      const { message: i3 } = ht("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(i3);
    }
    return t;
  }
  deleteSubscription(e, t) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e, reason: t });
    const i3 = this.getSubscription(e);
    this.subscriptions.delete(e), this.topicMap.delete(i3.topic, e), this.events.emit($3.deleted, He2(ge2({}, i3), { reason: t }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit($3.sync);
  }
  async onRestart() {
    if (this.cached.length) {
      const e = [...this.cached], t = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let i3 = 0; i3 < t; i3++) {
        const s2 = e.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(s2);
      }
    }
    this.events.emit($3.resubscribed);
  }
  async restore() {
    try {
      const e = await this.getRelayerSubscriptions();
      if (typeof e > "u" || !e.length) return;
      if (this.subscriptions.size) {
        const { message: t } = ht("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);
    }
  }
  async batchSubscribe(e) {
    e.length && (await this.rpcBatchSubscribe(e), this.onBatchSubscribe(await Promise.all(e.map(async (t) => He2(ge2({}, t), { id: await this.getSubscriptionId(t.topic) })))));
  }
  async batchFetchMessages(e) {
    if (!e.length) return;
    this.logger.trace(`Fetching batch messages for ${e.length} subscriptions`);
    const t = await this.rpcBatchFetchMessages(e);
    t && t.messages && (await Ni((0, import_time2.toMiliseconds)(import_time2.ONE_SECOND)), await this.relayer.handleBatchMessageEvents(t.messages));
  }
  async onConnect() {
    await this.restart(), this.reset();
  }
  onDisconnect() {
    this.onDisable();
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ht("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async restartToComplete(e) {
    !this.relayer.connected && !this.relayer.connecting && (this.cached.push(e), await this.relayer.transportOpen());
  }
  async getClientId() {
    return this.clientId || (this.clientId = await this.relayer.core.crypto.getClientId()), this.clientId;
  }
  async getSubscriptionId(e) {
    return kc(e + await this.getClientId());
  }
};
var Qn2 = Object.defineProperty;
var Ci2 = Object.getOwnPropertySymbols;
var eo2 = Object.prototype.hasOwnProperty;
var to2 = Object.prototype.propertyIsEnumerable;
var Ye2 = (r2, e, t) => e in r2 ? Qn2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var Pi2 = (r2, e) => {
  for (var t in e || (e = {})) eo2.call(e, t) && Ye2(r2, t, e[t]);
  if (Ci2) for (var t of Ci2(e)) to2.call(e, t) && Ye2(r2, t, e[t]);
  return r2;
};
var y3 = (r2, e, t) => Ye2(r2, typeof e != "symbol" ? e + "" : e, t);
var Si2 = class extends d {
  constructor(e) {
    super(e), y3(this, "protocol", "wc"), y3(this, "version", 2), y3(this, "core"), y3(this, "logger"), y3(this, "events", new import_events3.EventEmitter()), y3(this, "provider"), y3(this, "messages"), y3(this, "subscriber"), y3(this, "publisher"), y3(this, "name", $t2), y3(this, "transportExplicitlyClosed", false), y3(this, "initialized", false), y3(this, "connectionAttemptInProgress", false), y3(this, "relayUrl"), y3(this, "projectId"), y3(this, "packageName"), y3(this, "bundleId"), y3(this, "hasExperiencedNetworkDisruption", false), y3(this, "pingTimeout"), y3(this, "heartBeatTimeout", (0, import_time2.toMiliseconds)(import_time2.THIRTY_SECONDS + import_time2.FIVE_SECONDS)), y3(this, "reconnectTimeout"), y3(this, "connectPromise"), y3(this, "reconnectInProgress", false), y3(this, "requestsInFlight", []), y3(this, "connectTimeout", (0, import_time2.toMiliseconds)(import_time2.ONE_SECOND * 15)), y3(this, "request", async (t) => {
      var i3, s2;
      this.logger.debug("Publishing Request Payload");
      const n2 = t.id || getBigIntRpcId().toString();
      await this.toEstablishConnection();
      try {
        this.logger.trace({ id: n2, method: t.method, topic: (i3 = t.params) == null ? void 0 : i3.topic }, "relayer.request - publishing...");
        const o3 = `${n2}:${((s2 = t.params) == null ? void 0 : s2.tag) || ""}`;
        this.requestsInFlight.push(o3);
        const a2 = await this.provider.request(t);
        return this.requestsInFlight = this.requestsInFlight.filter((c3) => c3 !== o3), a2;
      } catch (o3) {
        throw this.logger.debug(`Failed to Publish Request: ${n2}`), o3;
      }
    }), y3(this, "resetPingTimeout", () => {
      Re() && (clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
        var t, i3, s2, n2;
        try {
          this.logger.debug({}, "pingTimeout: Connection stalled, terminating..."), (n2 = (s2 = (i3 = (t = this.provider) == null ? void 0 : t.connection) == null ? void 0 : i3.socket) == null ? void 0 : s2.terminate) == null || n2.call(s2);
        } catch (o3) {
          this.logger.warn(o3, o3?.message);
        }
      }, this.heartBeatTimeout));
    }), y3(this, "onPayloadHandler", (t) => {
      this.onProviderPayload(t), this.resetPingTimeout();
    }), y3(this, "onConnectHandler", () => {
      this.logger.warn({}, "Relayer connected 🛜"), this.startPingTimeout(), this.events.emit(C3.connect);
    }), y3(this, "onDisconnectHandler", () => {
      this.logger.warn({}, "Relayer disconnected 🛑"), this.requestsInFlight = [], this.onProviderDisconnect();
    }), y3(this, "onProviderErrorHandler", (t) => {
      this.logger.fatal(`Fatal socket error: ${t.message}`), this.events.emit(C3.error, t), this.logger.fatal("Fatal socket error received, closing transport"), this.transportClose();
    }), y3(this, "registerProviderListeners", () => {
      this.provider.on(L.payload, this.onPayloadHandler), this.provider.on(L.connect, this.onConnectHandler), this.provider.on(L.disconnect, this.onDisconnectHandler), this.provider.on(L.error, this.onProviderErrorHandler);
    }), this.core = e.core, this.logger = typeof e.logger < "u" && typeof e.logger != "string" ? E(e.logger, this.name) : (0, import_pino.default)(k({ level: e.logger || Nt2 })), this.messages = new _i2(this.logger, e.core), this.subscriber = new Ti2(this, this.logger), this.publisher = new Vn2(this, this.logger), this.relayUrl = e?.relayUrl || Ue, this.projectId = e.projectId, ei() ? this.packageName = ri() : ni() && (this.bundleId = ri()), this.provider = {};
  }
  async init() {
    if (this.logger.trace("Initialized"), this.registerEventListeners(), await Promise.all([this.messages.init(), this.subscriber.init()]), this.initialized = true, this.subscriber.hasAnyTopics) try {
      await this.transportOpen();
    } catch (e) {
      this.logger.warn(e, e?.message);
    }
  }
  get context() {
    return y(this.logger);
  }
  get connected() {
    var e, t, i3;
    return ((i3 = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : i3.readyState) === 1 || false;
  }
  get connecting() {
    var e, t, i3;
    return ((i3 = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : i3.readyState) === 0 || this.connectPromise !== void 0 || false;
  }
  async publish(e, t, i3) {
    this.isInitialized(), await this.publisher.publish(e, t, i3), await this.recordMessageEvent({ topic: e, message: t, publishedAt: Date.now(), transportType: Q.relay }, le2.outbound);
  }
  async subscribe(e, t) {
    var i3, s2, n2;
    this.isInitialized(), (!(t != null && t.transportType) || t?.transportType === "relay") && await this.toEstablishConnection();
    const o3 = typeof ((i3 = t?.internal) == null ? void 0 : i3.throwOnFailedPublish) > "u" ? true : (s2 = t?.internal) == null ? void 0 : s2.throwOnFailedPublish;
    let a2 = ((n2 = this.subscriber.topicMap.get(e)) == null ? void 0 : n2[0]) || "", c3;
    const h4 = (l3) => {
      l3.topic === e && (this.subscriber.off($3.created, h4), c3());
    };
    return await Promise.all([new Promise((l3) => {
      c3 = l3, this.subscriber.on($3.created, h4);
    }), new Promise(async (l3, d3) => {
      a2 = await this.subscriber.subscribe(e, Pi2({ internal: { throwOnFailedPublish: o3 } }, t)).catch((g2) => {
        o3 && d3(g2);
      }) || a2, l3();
    })]), a2;
  }
  async unsubscribe(e, t) {
    this.isInitialized(), await this.subscriber.unsubscribe(e, t);
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async transportDisconnect() {
    this.provider.disconnect && (this.hasExperiencedNetworkDisruption || this.connected) ? await yi(this.provider.disconnect(), 2e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.onProviderDisconnect();
  }
  async transportClose() {
    this.transportExplicitlyClosed = true, await this.transportDisconnect();
  }
  async transportOpen(e) {
    if (!this.subscriber.hasAnyTopics) {
      this.logger.warn("Starting WS connection skipped because the client has no topics to work with.");
      return;
    }
    if (this.connectPromise ? (this.logger.debug({}, "Waiting for existing connection attempt to resolve..."), await this.connectPromise, this.logger.debug({}, "Existing connection attempt resolved")) : (this.connectPromise = new Promise(async (t, i3) => {
      await this.connect(e).then(t).catch(i3).finally(() => {
        this.connectPromise = void 0;
      });
    }), await this.connectPromise), !this.connected) throw new Error(`Couldn't establish socket connection to the relay server: ${this.relayUrl}`);
  }
  async restartTransport(e) {
    this.logger.debug({}, "Restarting transport..."), !this.connectionAttemptInProgress && (this.relayUrl = e || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await Ia()) throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  async handleBatchMessageEvents(e) {
    if (e?.length === 0) {
      this.logger.trace("Batch message events is empty. Ignoring...");
      return;
    }
    const t = e.sort((i3, s2) => i3.publishedAt - s2.publishedAt);
    this.logger.debug(`Batch of ${t.length} message events sorted`);
    for (const i3 of t) try {
      await this.onMessageEvent(i3);
    } catch (s2) {
      this.logger.warn(s2, "Error while processing batch message event: " + s2?.message);
    }
    this.logger.trace(`Batch of ${t.length} message events processed`);
  }
  async onLinkMessageEvent(e, t) {
    const { topic: i3 } = e;
    if (!t.sessionExists) {
      const s2 = Ei(import_time2.FIVE_MINUTES), n2 = { topic: i3, expiry: s2, relay: { protocol: "irn" }, active: false };
      await this.core.pairing.pairings.set(i3, n2);
    }
    this.events.emit(C3.message, e), await this.recordMessageEvent(e, le2.inbound);
  }
  async connect(e) {
    await this.confirmOnlineStateOrThrow(), e && e !== this.relayUrl && (this.relayUrl = e, await this.transportDisconnect()), this.connectionAttemptInProgress = true, this.transportExplicitlyClosed = false;
    let t = 1;
    for (; t < 6; ) {
      try {
        if (this.transportExplicitlyClosed) break;
        this.logger.debug({}, `Connecting to ${this.relayUrl}, attempt: ${t}...`), await this.createProvider(), await new Promise(async (i3, s2) => {
          const n2 = () => {
            s2(new Error("Connection interrupted while trying to subscribe"));
          };
          this.provider.once(L.disconnect, n2), await yi(new Promise((o3, a2) => {
            this.provider.connect().then(o3).catch(a2);
          }), this.connectTimeout, `Socket stalled when trying to connect to ${this.relayUrl}`).catch((o3) => {
            s2(o3);
          }).finally(() => {
            this.provider.off(L.disconnect, n2), clearTimeout(this.reconnectTimeout);
          }), await new Promise(async (o3, a2) => {
            const c3 = () => {
              a2(new Error("Connection interrupted while trying to subscribe"));
            };
            this.provider.once(L.disconnect, c3), await this.subscriber.start().then(o3).catch(a2).finally(() => {
              this.provider.off(L.disconnect, c3);
            });
          }), this.hasExperiencedNetworkDisruption = false, i3();
        });
      } catch (i3) {
        await this.subscriber.stop();
        const s2 = i3;
        this.logger.warn({}, s2.message), this.hasExperiencedNetworkDisruption = true;
      } finally {
        this.connectionAttemptInProgress = false;
      }
      if (this.connected) {
        this.logger.debug({}, `Connected to ${this.relayUrl} successfully on attempt: ${t}`);
        break;
      }
      await new Promise((i3) => setTimeout(i3, (0, import_time2.toMiliseconds)(t * 1))), t++;
    }
  }
  startPingTimeout() {
    var e, t, i3, s2, n2;
    if (Re()) try {
      (t = (e = this.provider) == null ? void 0 : e.connection) != null && t.socket && ((n2 = (s2 = (i3 = this.provider) == null ? void 0 : i3.connection) == null ? void 0 : s2.socket) == null || n2.on("ping", () => {
        this.resetPingTimeout();
      })), this.resetPingTimeout();
    } catch (o3) {
      this.logger.warn(o3, o3?.message);
    }
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new o(new f(si({ sdkVersion: _e2, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e, useOnCloseEvent: true, bundleId: this.bundleId, packageName: this.packageName }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e, t) {
    const { topic: i3, message: s2 } = e;
    await this.messages.set(i3, s2, t);
  }
  async shouldIgnoreMessageEvent(e) {
    const { topic: t, message: i3 } = e;
    if (!i3 || i3.length === 0) return this.logger.warn(`Ignoring invalid/empty message: ${i3}`), true;
    if (!await this.subscriber.isKnownTopic(t)) return this.logger.warn(`Ignoring message for unknown topic ${t}`), true;
    const s2 = this.messages.has(t, i3);
    return s2 && this.logger.warn(`Ignoring duplicate message: ${i3}`), s2;
  }
  async onProviderPayload(e) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e }), isJsonRpcRequest(e)) {
      if (!e.method.endsWith(zt)) return;
      const t = e.params, { topic: i3, message: s2, publishedAt: n2, attestation: o3 } = t.data, a2 = { topic: i3, message: s2, publishedAt: n2, transportType: Q.relay, attestation: o3 };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(Pi2({ type: "event", event: t.id }, a2)), this.events.emit(t.id, a2), await this.acknowledgePayload(e), await this.onMessageEvent(a2);
    } else isJsonRpcResponse(e) && this.events.emit(C3.message_ack, e);
  }
  async onMessageEvent(e) {
    await this.shouldIgnoreMessageEvent(e) || (await this.recordMessageEvent(e, le2.inbound), this.events.emit(C3.message, e));
  }
  async acknowledgePayload(e) {
    const t = formatJsonRpcResult(e.id, true);
    await this.provider.connection.send(t);
  }
  unregisterProviderListeners() {
    this.provider.off(L.payload, this.onPayloadHandler), this.provider.off(L.connect, this.onConnectHandler), this.provider.off(L.disconnect, this.onDisconnectHandler), this.provider.off(L.error, this.onProviderErrorHandler), clearTimeout(this.pingTimeout);
  }
  async registerEventListeners() {
    let e = await Ia();
    Na(async (t) => {
      e !== t && (e = t, t ? await this.transportOpen().catch((i3) => this.logger.error(i3, i3?.message)) : (this.hasExperiencedNetworkDisruption = true, await this.transportDisconnect(), this.transportExplicitlyClosed = false));
    });
  }
  async onProviderDisconnect() {
    clearTimeout(this.pingTimeout), this.events.emit(C3.disconnect), this.connectionAttemptInProgress = false, !this.reconnectInProgress && (this.reconnectInProgress = true, await this.subscriber.stop(), this.subscriber.hasAnyTopics && (this.transportExplicitlyClosed || (this.reconnectTimeout = setTimeout(async () => {
      await this.transportOpen().catch((e) => this.logger.error(e, e?.message)), this.reconnectTimeout = void 0, this.reconnectInProgress = false;
    }, (0, import_time2.toMiliseconds)(Lt2)))));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ht("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async toEstablishConnection() {
    if (await this.confirmOnlineStateOrThrow(), !this.connected) {
      if (this.connectPromise) {
        await this.connectPromise;
        return;
      }
      await this.connect();
    }
  }
};
function io2() {
}
function Ri2(r2) {
  if (!r2 || typeof r2 != "object") return false;
  const e = Object.getPrototypeOf(r2);
  return e === null || e === Object.prototype || Object.getPrototypeOf(e) === null ? Object.prototype.toString.call(r2) === "[object Object]" : false;
}
function Oi2(r2) {
  return Object.getOwnPropertySymbols(r2).filter((e) => Object.prototype.propertyIsEnumerable.call(r2, e));
}
function Ai2(r2) {
  return r2 == null ? r2 === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(r2);
}
var so2 = "[object RegExp]";
var ro2 = "[object String]";
var no2 = "[object Number]";
var oo2 = "[object Boolean]";
var xi2 = "[object Arguments]";
var ao2 = "[object Symbol]";
var co2 = "[object Date]";
var ho2 = "[object Map]";
var lo = "[object Set]";
var uo2 = "[object Array]";
var go2 = "[object Function]";
var po2 = "[object ArrayBuffer]";
var Je2 = "[object Object]";
var yo = "[object Error]";
var bo2 = "[object DataView]";
var mo2 = "[object Uint8Array]";
var fo = "[object Uint8ClampedArray]";
var Do = "[object Uint16Array]";
var vo2 = "[object Uint32Array]";
var wo2 = "[object BigUint64Array]";
var _o2 = "[object Int8Array]";
var Eo2 = "[object Int16Array]";
var Io2 = "[object Int32Array]";
var To2 = "[object BigInt64Array]";
var Co2 = "[object Float32Array]";
var Po3 = "[object Float64Array]";
function So2(r2, e) {
  return r2 === e || Number.isNaN(r2) && Number.isNaN(e);
}
function Ro2(r2, e, t) {
  return pe2(r2, e, void 0, void 0, void 0, void 0, t);
}
function pe2(r2, e, t, i3, s2, n2, o3) {
  const a2 = o3(r2, e, t, i3, s2, n2);
  if (a2 !== void 0) return a2;
  if (typeof r2 == typeof e) switch (typeof r2) {
    case "bigint":
    case "string":
    case "boolean":
    case "symbol":
    case "undefined":
      return r2 === e;
    case "number":
      return r2 === e || Object.is(r2, e);
    case "function":
      return r2 === e;
    case "object":
      return ye2(r2, e, n2, o3);
  }
  return ye2(r2, e, n2, o3);
}
function ye2(r2, e, t, i3) {
  if (Object.is(r2, e)) return true;
  let s2 = Ai2(r2), n2 = Ai2(e);
  if (s2 === xi2 && (s2 = Je2), n2 === xi2 && (n2 = Je2), s2 !== n2) return false;
  switch (s2) {
    case ro2:
      return r2.toString() === e.toString();
    case no2: {
      const c3 = r2.valueOf(), h4 = e.valueOf();
      return So2(c3, h4);
    }
    case oo2:
    case co2:
    case ao2:
      return Object.is(r2.valueOf(), e.valueOf());
    case so2:
      return r2.source === e.source && r2.flags === e.flags;
    case go2:
      return r2 === e;
  }
  t = t ?? /* @__PURE__ */ new Map();
  const o3 = t.get(r2), a2 = t.get(e);
  if (o3 != null && a2 != null) return o3 === e;
  t.set(r2, e), t.set(e, r2);
  try {
    switch (s2) {
      case ho2: {
        if (r2.size !== e.size) return false;
        for (const [c3, h4] of r2.entries()) if (!e.has(c3) || !pe2(h4, e.get(c3), c3, r2, e, t, i3)) return false;
        return true;
      }
      case lo: {
        if (r2.size !== e.size) return false;
        const c3 = Array.from(r2.values()), h4 = Array.from(e.values());
        for (let l3 = 0; l3 < c3.length; l3++) {
          const d3 = c3[l3], g2 = h4.findIndex((_2) => pe2(d3, _2, void 0, r2, e, t, i3));
          if (g2 === -1) return false;
          h4.splice(g2, 1);
        }
        return true;
      }
      case uo2:
      case mo2:
      case fo:
      case Do:
      case vo2:
      case wo2:
      case _o2:
      case Eo2:
      case Io2:
      case To2:
      case Co2:
      case Po3: {
        if (typeof Buffer < "u" && Buffer.isBuffer(r2) !== Buffer.isBuffer(e) || r2.length !== e.length) return false;
        for (let c3 = 0; c3 < r2.length; c3++) if (!pe2(r2[c3], e[c3], c3, r2, e, t, i3)) return false;
        return true;
      }
      case po2:
        return r2.byteLength !== e.byteLength ? false : ye2(new Uint8Array(r2), new Uint8Array(e), t, i3);
      case bo2:
        return r2.byteLength !== e.byteLength || r2.byteOffset !== e.byteOffset ? false : ye2(new Uint8Array(r2), new Uint8Array(e), t, i3);
      case yo:
        return r2.name === e.name && r2.message === e.message;
      case Je2: {
        if (!(ye2(r2.constructor, e.constructor, t, i3) || Ri2(r2) && Ri2(e))) return false;
        const h4 = [...Object.keys(r2), ...Oi2(r2)], l3 = [...Object.keys(e), ...Oi2(e)];
        if (h4.length !== l3.length) return false;
        for (let d3 = 0; d3 < h4.length; d3++) {
          const g2 = h4[d3], _2 = r2[g2];
          if (!Object.hasOwn(e, g2)) return false;
          const u4 = e[g2];
          if (!pe2(_2, u4, g2, r2, e, t, i3)) return false;
        }
        return true;
      }
      default:
        return false;
    }
  } finally {
    t.delete(r2), t.delete(e);
  }
}
function Oo2(r2, e) {
  return Ro2(r2, e, io2);
}
var Ao2 = Object.defineProperty;
var Ni2 = Object.getOwnPropertySymbols;
var xo2 = Object.prototype.hasOwnProperty;
var No2 = Object.prototype.propertyIsEnumerable;
var Xe2 = (r2, e, t) => e in r2 ? Ao2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var $i2 = (r2, e) => {
  for (var t in e || (e = {})) xo2.call(e, t) && Xe2(r2, t, e[t]);
  if (Ni2) for (var t of Ni2(e)) No2.call(e, t) && Xe2(r2, t, e[t]);
  return r2;
};
var z2 = (r2, e, t) => Xe2(r2, typeof e != "symbol" ? e + "" : e, t);
var zi2 = class extends f3 {
  constructor(e, t, i3, s2 = B2, n2 = void 0) {
    super(e, t, i3, s2), this.core = e, this.logger = t, this.name = i3, z2(this, "map", /* @__PURE__ */ new Map()), z2(this, "version", kt2), z2(this, "cached", []), z2(this, "initialized", false), z2(this, "getKey"), z2(this, "storagePrefix", B2), z2(this, "recentlyDeleted", []), z2(this, "recentlyDeletedLimit", 200), z2(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((o3) => {
        this.getKey && o3 !== null && !Et(o3) ? this.map.set(this.getKey(o3), o3) : fa(o3) ? this.map.set(o3.id, o3) : la(o3) && this.map.set(o3.topic, o3);
      }), this.cached = [], this.initialized = true);
    }), z2(this, "set", async (o3, a2) => {
      this.isInitialized(), this.map.has(o3) ? await this.update(o3, a2) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: o3, value: a2 }), this.map.set(o3, a2), await this.persist());
    }), z2(this, "get", (o3) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: o3 }), this.getData(o3))), z2(this, "getAll", (o3) => (this.isInitialized(), o3 ? this.values.filter((a2) => Object.keys(o3).every((c3) => Oo2(a2[c3], o3[c3]))) : this.values)), z2(this, "update", async (o3, a2) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: o3, update: a2 });
      const c3 = $i2($i2({}, this.getData(o3)), a2);
      this.map.set(o3, c3), await this.persist();
    }), z2(this, "delete", async (o3, a2) => {
      this.isInitialized(), this.map.has(o3) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: o3, reason: a2 }), this.map.delete(o3), this.addToRecentlyDeleted(o3), await this.persist());
    }), this.logger = E(t, this.name), this.storagePrefix = s2, this.getKey = n2;
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  addToRecentlyDeleted(e) {
    this.recentlyDeleted.push(e), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
  }
  async setDataStore(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e) {
    const t = this.map.get(e);
    if (!t) {
      if (this.recentlyDeleted.includes(e)) {
        const { message: s2 } = ht("MISSING_OR_INVALID", `Record was recently deleted - ${this.name}: ${e}`);
        throw this.logger.error(s2), new Error(s2);
      }
      const { message: i3 } = ht("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(i3), new Error(i3);
    }
    return t;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e = await this.getDataStore();
      if (typeof e > "u" || !e.length) return;
      if (this.map.size) {
        const { message: t } = ht("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ht("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var $o2 = Object.defineProperty;
var zo = (r2, e, t) => e in r2 ? $o2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var p3 = (r2, e, t) => zo(r2, typeof e != "symbol" ? e + "" : e, t);
var Li2 = class {
  constructor(e, t) {
    this.core = e, this.logger = t, p3(this, "name", Mt2), p3(this, "version", Kt2), p3(this, "events", new import_events3.default()), p3(this, "pairings"), p3(this, "initialized", false), p3(this, "storagePrefix", B2), p3(this, "ignoredPayloadTypes", [Kt]), p3(this, "registeredMethods", []), p3(this, "init", async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = true, this.logger.trace("Initialized"));
    }), p3(this, "register", ({ methods: i3 }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...i3])];
    }), p3(this, "create", async (i3) => {
      this.isInitialized();
      const s2 = jc(), n2 = await this.core.crypto.setSymKey(s2), o3 = Ei(import_time2.FIVE_MINUTES), a2 = { protocol: xt2 }, c3 = { topic: n2, expiry: o3, relay: a2, active: false, methods: i3?.methods }, h4 = Wc({ protocol: this.core.protocol, version: this.core.version, topic: n2, symKey: s2, relay: a2, expiryTimestamp: o3, methods: i3?.methods });
      return this.events.emit(se2.create, c3), this.core.expirer.set(n2, o3), await this.pairings.set(n2, c3), await this.core.relayer.subscribe(n2, { transportType: i3?.transportType }), { topic: n2, uri: h4 };
    }), p3(this, "pair", async (i3) => {
      this.isInitialized();
      const s2 = this.core.eventClient.createEvent({ properties: { topic: i3?.uri, trace: [G4.pairing_started] } });
      this.isValidPair(i3, s2);
      const { topic: n2, symKey: o3, relay: a2, expiryTimestamp: c3, methods: h4 } = Gc(i3.uri);
      s2.props.properties.topic = n2, s2.addTrace(G4.pairing_uri_validation_success), s2.addTrace(G4.pairing_uri_not_expired);
      let l3;
      if (this.pairings.keys.includes(n2)) {
        if (l3 = this.pairings.get(n2), s2.addTrace(G4.existing_pairing), l3.active) throw s2.setError(Y4.active_pairing_already_exists), new Error(`Pairing already exists: ${n2}. Please try again with a new connection URI.`);
        s2.addTrace(G4.pairing_not_expired);
      }
      const d3 = c3 || Ei(import_time2.FIVE_MINUTES), g2 = { topic: n2, relay: a2, expiry: d3, active: false, methods: h4 };
      this.core.expirer.set(n2, d3), await this.pairings.set(n2, g2), s2.addTrace(G4.store_new_pairing), i3.activatePairing && await this.activate({ topic: n2 }), this.events.emit(se2.create, g2), s2.addTrace(G4.emit_inactive_pairing), this.core.crypto.keychain.has(n2) || await this.core.crypto.setSymKey(o3, n2), s2.addTrace(G4.subscribing_pairing_topic);
      try {
        await this.core.relayer.confirmOnlineStateOrThrow();
      } catch {
        s2.setError(Y4.no_internet_connection);
      }
      try {
        await this.core.relayer.subscribe(n2, { relay: a2 });
      } catch (_2) {
        throw s2.setError(Y4.subscribe_pairing_topic_failure), _2;
      }
      return s2.addTrace(G4.subscribe_pairing_topic_success), g2;
    }), p3(this, "activate", async ({ topic: i3 }) => {
      this.isInitialized();
      const s2 = Ei(import_time2.FIVE_MINUTES);
      this.core.expirer.set(i3, s2), await this.pairings.update(i3, { active: true, expiry: s2 });
    }), p3(this, "ping", async (i3) => {
      this.isInitialized(), await this.isValidPing(i3), this.logger.warn("ping() is deprecated and will be removed in the next major release.");
      const { topic: s2 } = i3;
      if (this.pairings.keys.includes(s2)) {
        const n2 = await this.sendRequest(s2, "wc_pairingPing", {}), { done: o3, resolve: a2, reject: c3 } = gi();
        this.events.once(xi("pairing_ping", n2), ({ error: h4 }) => {
          h4 ? c3(h4) : a2();
        }), await o3();
      }
    }), p3(this, "updateExpiry", async ({ topic: i3, expiry: s2 }) => {
      this.isInitialized(), await this.pairings.update(i3, { expiry: s2 });
    }), p3(this, "updateMetadata", async ({ topic: i3, metadata: s2 }) => {
      this.isInitialized(), await this.pairings.update(i3, { peerMetadata: s2 });
    }), p3(this, "getPairings", () => (this.isInitialized(), this.pairings.values)), p3(this, "disconnect", async (i3) => {
      this.isInitialized(), await this.isValidDisconnect(i3);
      const { topic: s2 } = i3;
      this.pairings.keys.includes(s2) && (await this.sendRequest(s2, "wc_pairingDelete", Nt("USER_DISCONNECTED")), await this.deletePairing(s2));
    }), p3(this, "formatUriFromPairing", (i3) => {
      this.isInitialized();
      const { topic: s2, relay: n2, expiry: o3, methods: a2 } = i3, c3 = this.core.crypto.keychain.get(s2);
      return Wc({ protocol: this.core.protocol, version: this.core.version, topic: s2, symKey: c3, relay: n2, expiryTimestamp: o3, methods: a2 });
    }), p3(this, "sendRequest", async (i3, s2, n2) => {
      const o3 = formatJsonRpcRequest(s2, n2), a2 = await this.core.crypto.encode(i3, o3), c3 = ie2[s2].req;
      return this.core.history.set(i3, o3), this.core.relayer.publish(i3, a2, c3), o3.id;
    }), p3(this, "sendResult", async (i3, s2, n2) => {
      const o3 = formatJsonRpcResult(i3, n2), a2 = await this.core.crypto.encode(s2, o3), c3 = (await this.core.history.get(s2, i3)).request.method, h4 = ie2[c3].res;
      await this.core.relayer.publish(s2, a2, h4), await this.core.history.resolve(o3);
    }), p3(this, "sendError", async (i3, s2, n2) => {
      const o3 = formatJsonRpcError(i3, n2), a2 = await this.core.crypto.encode(s2, o3), c3 = (await this.core.history.get(s2, i3)).request.method, h4 = ie2[c3] ? ie2[c3].res : ie2.unregistered_method.res;
      await this.core.relayer.publish(s2, a2, h4), await this.core.history.resolve(o3);
    }), p3(this, "deletePairing", async (i3, s2) => {
      await this.core.relayer.unsubscribe(i3), await Promise.all([this.pairings.delete(i3, Nt("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(i3), s2 ? Promise.resolve() : this.core.expirer.del(i3)]);
    }), p3(this, "cleanup", async () => {
      const i3 = this.pairings.getAll().filter((s2) => vi(s2.expiry));
      await Promise.all(i3.map((s2) => this.deletePairing(s2.topic)));
    }), p3(this, "onRelayEventRequest", async (i3) => {
      const { topic: s2, payload: n2 } = i3;
      switch (n2.method) {
        case "wc_pairingPing":
          return await this.onPairingPingRequest(s2, n2);
        case "wc_pairingDelete":
          return await this.onPairingDeleteRequest(s2, n2);
        default:
          return await this.onUnknownRpcMethodRequest(s2, n2);
      }
    }), p3(this, "onRelayEventResponse", async (i3) => {
      const { topic: s2, payload: n2 } = i3, o3 = (await this.core.history.get(s2, n2.id)).request.method;
      switch (o3) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(s2, n2);
        default:
          return this.onUnknownRpcMethodResponse(o3);
      }
    }), p3(this, "onPairingPingRequest", async (i3, s2) => {
      const { id: n2 } = s2;
      try {
        this.isValidPing({ topic: i3 }), await this.sendResult(n2, i3, true), this.events.emit(se2.ping, { id: n2, topic: i3 });
      } catch (o3) {
        await this.sendError(n2, i3, o3), this.logger.error(o3);
      }
    }), p3(this, "onPairingPingResponse", (i3, s2) => {
      const { id: n2 } = s2;
      setTimeout(() => {
        isJsonRpcResult(s2) ? this.events.emit(xi("pairing_ping", n2), {}) : isJsonRpcError(s2) && this.events.emit(xi("pairing_ping", n2), { error: s2.error });
      }, 500);
    }), p3(this, "onPairingDeleteRequest", async (i3, s2) => {
      const { id: n2 } = s2;
      try {
        this.isValidDisconnect({ topic: i3 }), await this.deletePairing(i3), this.events.emit(se2.delete, { id: n2, topic: i3 });
      } catch (o3) {
        await this.sendError(n2, i3, o3), this.logger.error(o3);
      }
    }), p3(this, "onUnknownRpcMethodRequest", async (i3, s2) => {
      const { id: n2, method: o3 } = s2;
      try {
        if (this.registeredMethods.includes(o3)) return;
        const a2 = Nt("WC_METHOD_UNSUPPORTED", o3);
        await this.sendError(n2, i3, a2), this.logger.error(a2);
      } catch (a2) {
        await this.sendError(n2, i3, a2), this.logger.error(a2);
      }
    }), p3(this, "onUnknownRpcMethodResponse", (i3) => {
      this.registeredMethods.includes(i3) || this.logger.error(Nt("WC_METHOD_UNSUPPORTED", i3));
    }), p3(this, "isValidPair", (i3, s2) => {
      var n2;
      if (!ya(i3)) {
        const { message: a2 } = ht("MISSING_OR_INVALID", `pair() params: ${i3}`);
        throw s2.setError(Y4.malformed_pairing_uri), new Error(a2);
      }
      if (!ua(i3.uri)) {
        const { message: a2 } = ht("MISSING_OR_INVALID", `pair() uri: ${i3.uri}`);
        throw s2.setError(Y4.malformed_pairing_uri), new Error(a2);
      }
      const o3 = Gc(i3?.uri);
      if (!((n2 = o3?.relay) != null && n2.protocol)) {
        const { message: a2 } = ht("MISSING_OR_INVALID", "pair() uri#relay-protocol");
        throw s2.setError(Y4.malformed_pairing_uri), new Error(a2);
      }
      if (!(o3 != null && o3.symKey)) {
        const { message: a2 } = ht("MISSING_OR_INVALID", "pair() uri#symKey");
        throw s2.setError(Y4.malformed_pairing_uri), new Error(a2);
      }
      if (o3 != null && o3.expiryTimestamp && (0, import_time2.toMiliseconds)(o3?.expiryTimestamp) < Date.now()) {
        s2.setError(Y4.pairing_expired);
        const { message: a2 } = ht("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
        throw new Error(a2);
      }
    }), p3(this, "isValidPing", async (i3) => {
      if (!ya(i3)) {
        const { message: n2 } = ht("MISSING_OR_INVALID", `ping() params: ${i3}`);
        throw new Error(n2);
      }
      const { topic: s2 } = i3;
      await this.isValidPairingTopic(s2);
    }), p3(this, "isValidDisconnect", async (i3) => {
      if (!ya(i3)) {
        const { message: n2 } = ht("MISSING_OR_INVALID", `disconnect() params: ${i3}`);
        throw new Error(n2);
      }
      const { topic: s2 } = i3;
      await this.isValidPairingTopic(s2);
    }), p3(this, "isValidPairingTopic", async (i3) => {
      if (!nt(i3, false)) {
        const { message: s2 } = ht("MISSING_OR_INVALID", `pairing topic should be a string: ${i3}`);
        throw new Error(s2);
      }
      if (!this.pairings.keys.includes(i3)) {
        const { message: s2 } = ht("NO_MATCHING_KEY", `pairing topic doesn't exist: ${i3}`);
        throw new Error(s2);
      }
      if (vi(this.pairings.get(i3).expiry)) {
        await this.deletePairing(i3);
        const { message: s2 } = ht("EXPIRED", `pairing topic: ${i3}`);
        throw new Error(s2);
      }
    }), this.core = e, this.logger = E(t, this.name), this.pairings = new zi2(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return y(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ht("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(C3.message, async (e) => {
      const { topic: t, message: i3, transportType: s2 } = e;
      if (this.pairings.keys.includes(t) && s2 !== Q.link_mode && !this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(i3))) try {
        const n2 = await this.core.crypto.decode(t, i3);
        isJsonRpcRequest(n2) ? (this.core.history.set(t, n2), await this.onRelayEventRequest({ topic: t, payload: n2 })) : isJsonRpcResponse(n2) && (await this.core.history.resolve(n2), await this.onRelayEventResponse({ topic: t, payload: n2 }), this.core.history.delete(t, n2.id)), await this.core.relayer.messages.ack(t, i3);
      } catch (n2) {
        this.logger.error(n2);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(M3.expired, async (e) => {
      const { topic: t } = bi(e.target);
      t && this.pairings.keys.includes(t) && (await this.deletePairing(t, true), this.events.emit(se2.expire, { topic: t }));
    });
  }
};
var Lo2 = Object.defineProperty;
var ko = (r2, e, t) => e in r2 ? Lo2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var R4 = (r2, e, t) => ko(r2, typeof e != "symbol" ? e + "" : e, t);
var ki2 = class extends I {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, R4(this, "records", /* @__PURE__ */ new Map()), R4(this, "events", new import_events3.EventEmitter()), R4(this, "name", Bt2), R4(this, "version", Vt2), R4(this, "cached", []), R4(this, "initialized", false), R4(this, "storagePrefix", B2), R4(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i3) => this.records.set(i3.id, i3)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }), R4(this, "set", (i3, s2, n2) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: i3, request: s2, chainId: n2 }), this.records.has(s2.id)) return;
      const o3 = { id: s2.id, topic: i3, request: { method: s2.method, params: s2.params || null }, chainId: n2, expiry: Ei(import_time2.THIRTY_DAYS) };
      this.records.set(o3.id, o3), this.persist(), this.events.emit(F4.created, o3);
    }), R4(this, "resolve", async (i3) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: i3 }), !this.records.has(i3.id)) return;
      const s2 = await this.getRecord(i3.id);
      typeof s2.response > "u" && (s2.response = isJsonRpcError(i3) ? { error: i3.error } : { result: i3.result }, this.records.set(s2.id, s2), this.persist(), this.events.emit(F4.updated, s2));
    }), R4(this, "get", async (i3, s2) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: i3, id: s2 }), await this.getRecord(s2))), R4(this, "delete", (i3, s2) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: s2 }), this.values.forEach((n2) => {
        if (n2.topic === i3) {
          if (typeof s2 < "u" && n2.id !== s2) return;
          this.records.delete(n2.id), this.events.emit(F4.deleted, n2);
        }
      }), this.persist();
    }), R4(this, "exists", async (i3, s2) => (this.isInitialized(), this.records.has(s2) ? (await this.getRecord(s2)).topic === i3 : false)), R4(this, "on", (i3, s2) => {
      this.events.on(i3, s2);
    }), R4(this, "once", (i3, s2) => {
      this.events.once(i3, s2);
    }), R4(this, "off", (i3, s2) => {
      this.events.off(i3, s2);
    }), R4(this, "removeListener", (i3, s2) => {
      this.events.removeListener(i3, s2);
    }), this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e = [];
    return this.values.forEach((t) => {
      if (typeof t.response < "u") return;
      const i3 = { topic: t.topic, request: formatJsonRpcRequest(t.request.method, t.request.params, t.id), chainId: t.chainId };
      return e.push(i3);
    }), e;
  }
  async setJsonRpcRecords(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e) {
    this.isInitialized();
    const t = this.records.get(e);
    if (!t) {
      const { message: i3 } = ht("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(i3);
    }
    return t;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(F4.sync);
  }
  async restore() {
    try {
      const e = await this.getJsonRpcRecords();
      if (typeof e > "u" || !e.length) return;
      if (this.records.size) {
        const { message: t } = ht("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);
    }
  }
  registerEventListeners() {
    this.events.on(F4.created, (e) => {
      const t = F4.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.events.on(F4.updated, (e) => {
      const t = F4.updated;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.events.on(F4.deleted, (e) => {
      const t = F4.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.core.heartbeat.on(r.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.isInitialized();
      let e = false;
      this.records.forEach((t) => {
        (0, import_time2.toMiliseconds)(t.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${t.id}`), this.records.delete(t.id), this.events.emit(F4.deleted, t, false), e = true);
      }), e && this.persist();
    } catch (e) {
      this.logger.warn(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ht("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var jo = Object.defineProperty;
var Uo2 = (r2, e, t) => e in r2 ? jo(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var A3 = (r2, e, t) => Uo2(r2, typeof e != "symbol" ? e + "" : e, t);
var ji2 = class extends S {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, A3(this, "expirations", /* @__PURE__ */ new Map()), A3(this, "events", new import_events3.EventEmitter()), A3(this, "name", qt2), A3(this, "version", Gt2), A3(this, "cached", []), A3(this, "initialized", false), A3(this, "storagePrefix", B2), A3(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i3) => this.expirations.set(i3.target, i3)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }), A3(this, "has", (i3) => {
      try {
        const s2 = this.formatTarget(i3);
        return typeof this.getExpiration(s2) < "u";
      } catch {
        return false;
      }
    }), A3(this, "set", (i3, s2) => {
      this.isInitialized();
      const n2 = this.formatTarget(i3), o3 = { target: n2, expiry: s2 };
      this.expirations.set(n2, o3), this.checkExpiry(n2, o3), this.events.emit(M3.created, { target: n2, expiration: o3 });
    }), A3(this, "get", (i3) => {
      this.isInitialized();
      const s2 = this.formatTarget(i3);
      return this.getExpiration(s2);
    }), A3(this, "del", (i3) => {
      if (this.isInitialized(), this.has(i3)) {
        const s2 = this.formatTarget(i3), n2 = this.getExpiration(s2);
        this.expirations.delete(s2), this.events.emit(M3.deleted, { target: s2, expiration: n2 });
      }
    }), A3(this, "on", (i3, s2) => {
      this.events.on(i3, s2);
    }), A3(this, "once", (i3, s2) => {
      this.events.once(i3, s2);
    }), A3(this, "off", (i3, s2) => {
      this.events.off(i3, s2);
    }), A3(this, "removeListener", (i3, s2) => {
      this.events.removeListener(i3, s2);
    }), this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e) {
    if (typeof e == "string") return mi(e);
    if (typeof e == "number") return wi(e);
    const { message: t } = ht("UNKNOWN_TYPE", `Target type: ${typeof e}`);
    throw new Error(t);
  }
  async setExpirations(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(M3.sync);
  }
  async restore() {
    try {
      const e = await this.getExpirations();
      if (typeof e > "u" || !e.length) return;
      if (this.expirations.size) {
        const { message: t } = ht("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);
    }
  }
  getExpiration(e) {
    const t = this.expirations.get(e);
    if (!t) {
      const { message: i3 } = ht("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.warn(i3), new Error(i3);
    }
    return t;
  }
  checkExpiry(e, t) {
    const { expiry: i3 } = t;
    (0, import_time2.toMiliseconds)(i3) - Date.now() <= 0 && this.expire(e, t);
  }
  expire(e, t) {
    this.expirations.delete(e), this.events.emit(M3.expired, { target: e, expiration: t });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e, t) => this.checkExpiry(t, e));
  }
  registerEventListeners() {
    this.core.heartbeat.on(r.pulse, () => this.checkExpirations()), this.events.on(M3.created, (e) => {
      const t = M3.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(M3.expired, (e) => {
      const t = M3.expired;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(M3.deleted, (e) => {
      const t = M3.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ht("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Fo = Object.defineProperty;
var Mo = (r2, e, t) => e in r2 ? Fo(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var w2 = (r2, e, t) => Mo(r2, typeof e != "symbol" ? e + "" : e, t);
var Ui2 = class extends M2 {
  constructor(e, t, i3) {
    super(e, t, i3), this.core = e, this.logger = t, this.store = i3, w2(this, "name", Wt2), w2(this, "abortController"), w2(this, "isDevEnv"), w2(this, "verifyUrlV3", Yt2), w2(this, "storagePrefix", B2), w2(this, "version", Le2), w2(this, "publicKey"), w2(this, "fetchPromise"), w2(this, "init", async () => {
      var s2;
      this.isDevEnv || (this.publicKey = await this.store.getItem(this.storeKey), this.publicKey && (0, import_time2.toMiliseconds)((s2 = this.publicKey) == null ? void 0 : s2.expiresAt) < Date.now() && (this.logger.debug("verify v2 public key expired"), await this.removePublicKey()));
    }), w2(this, "register", async (s2) => {
      if (!Yt() || this.isDevEnv) return;
      const n2 = window.location.origin, { id: o3, decryptedId: a2 } = s2, c3 = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${n2}&id=${o3}&decryptedId=${a2}`;
      try {
        const h4 = (0, import_window_getters2.getDocument)(), l3 = this.startAbortTimer(import_time2.ONE_SECOND * 5), d3 = await new Promise((g2, _2) => {
          const u4 = () => {
            window.removeEventListener("message", x3), h4.body.removeChild(b5), _2("attestation aborted");
          };
          this.abortController.signal.addEventListener("abort", u4);
          const b5 = h4.createElement("iframe");
          b5.src = c3, b5.style.display = "none", b5.addEventListener("error", u4, { signal: this.abortController.signal });
          const x3 = (I3) => {
            if (I3.data && typeof I3.data == "string") try {
              const D3 = JSON.parse(I3.data);
              if (D3.type === "verify_attestation") {
                if (sn(D3.attestation).payload.id !== o3) return;
                clearInterval(l3), h4.body.removeChild(b5), this.abortController.signal.removeEventListener("abort", u4), window.removeEventListener("message", x3), g2(D3.attestation === null ? "" : D3.attestation);
              }
            } catch (D3) {
              this.logger.warn(D3);
            }
          };
          h4.body.appendChild(b5), window.addEventListener("message", x3, { signal: this.abortController.signal });
        });
        return this.logger.debug("jwt attestation", d3), d3;
      } catch (h4) {
        this.logger.warn(h4);
      }
      return "";
    }), w2(this, "resolve", async (s2) => {
      if (this.isDevEnv) return "";
      const { attestationId: n2, hash: o3, encryptedId: a2 } = s2;
      if (n2 === "") {
        this.logger.debug("resolve: attestationId is empty, skipping");
        return;
      }
      if (n2) {
        if (sn(n2).payload.id !== a2) return;
        const h4 = await this.isValidJwtAttestation(n2);
        if (h4) {
          if (!h4.isVerified) {
            this.logger.warn("resolve: jwt attestation: origin url not verified");
            return;
          }
          return h4;
        }
      }
      if (!o3) return;
      const c3 = this.getVerifyUrl(s2?.verifyUrl);
      return this.fetchAttestation(o3, c3);
    }), w2(this, "fetchAttestation", async (s2, n2) => {
      this.logger.debug(`resolving attestation: ${s2} from url: ${n2}`);
      const o3 = this.startAbortTimer(import_time2.ONE_SECOND * 5), a2 = await fetch(`${n2}/attestation/${s2}?v2Supported=true`, { signal: this.abortController.signal });
      return clearTimeout(o3), a2.status === 200 ? await a2.json() : void 0;
    }), w2(this, "getVerifyUrl", (s2) => {
      let n2 = s2 || ue2;
      return Jt2.includes(n2) || (this.logger.info(`verify url: ${n2}, not included in trusted list, assigning default: ${ue2}`), n2 = ue2), n2;
    }), w2(this, "fetchPublicKey", async () => {
      try {
        this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
        const s2 = this.startAbortTimer(import_time2.FIVE_SECONDS), n2 = await fetch(`${this.verifyUrlV3}/public-key`, { signal: this.abortController.signal });
        return clearTimeout(s2), await n2.json();
      } catch (s2) {
        this.logger.warn(s2);
      }
    }), w2(this, "persistPublicKey", async (s2) => {
      this.logger.debug("persisting public key to local storage", s2), await this.store.setItem(this.storeKey, s2), this.publicKey = s2;
    }), w2(this, "removePublicKey", async () => {
      this.logger.debug("removing verify v2 public key from storage"), await this.store.removeItem(this.storeKey), this.publicKey = void 0;
    }), w2(this, "isValidJwtAttestation", async (s2) => {
      const n2 = await this.getPublicKey();
      try {
        if (n2) return this.validateAttestation(s2, n2);
      } catch (a2) {
        this.logger.error(a2), this.logger.warn("error validating attestation");
      }
      const o3 = await this.fetchAndPersistPublicKey();
      try {
        if (o3) return this.validateAttestation(s2, o3);
      } catch (a2) {
        this.logger.error(a2), this.logger.warn("error validating attestation");
      }
    }), w2(this, "getPublicKey", async () => this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey()), w2(this, "fetchAndPersistPublicKey", async () => {
      if (this.fetchPromise) return await this.fetchPromise, this.publicKey;
      this.fetchPromise = new Promise(async (n2) => {
        const o3 = await this.fetchPublicKey();
        o3 && (await this.persistPublicKey(o3), n2(o3));
      });
      const s2 = await this.fetchPromise;
      return this.fetchPromise = void 0, s2;
    }), w2(this, "validateAttestation", (s2, n2) => {
      const o3 = zc(s2, n2.publicKey), a2 = { hasExpired: (0, import_time2.toMiliseconds)(o3.exp) < Date.now(), payload: o3 };
      if (a2.hasExpired) throw this.logger.warn("resolve: jwt attestation expired"), new Error("JWT attestation expired");
      return { origin: a2.payload.origin, isScam: a2.payload.isScam, isVerified: a2.payload.isVerified };
    }), this.logger = E(t, this.name), this.abortController = new AbortController(), this.isDevEnv = Ii(), this.init();
  }
  get storeKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//verify:public:key";
  }
  get context() {
    return y(this.logger);
  }
  startAbortTimer(e) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), (0, import_time2.toMiliseconds)(e));
  }
};
var Ko = Object.defineProperty;
var Bo2 = (r2, e, t) => e in r2 ? Ko(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var Fi2 = (r2, e, t) => Bo2(r2, typeof e != "symbol" ? e + "" : e, t);
var Mi2 = class extends O2 {
  constructor(e, t) {
    super(e, t), this.projectId = e, this.logger = t, Fi2(this, "context", Xt2), Fi2(this, "registerDeviceToken", async (i3) => {
      const { clientId: s2, token: n2, notificationType: o3, enableEncrypted: a2 = false } = i3, c3 = `${Zt}/${this.projectId}/clients`;
      await fetch(c3, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ client_id: s2, type: o3, token: n2, always_raw: a2 }) });
    }), this.logger = E(t, this.context);
  }
};
var Vo = Object.defineProperty;
var Ki2 = Object.getOwnPropertySymbols;
var qo = Object.prototype.hasOwnProperty;
var Go2 = Object.prototype.propertyIsEnumerable;
var Ze2 = (r2, e, t) => e in r2 ? Vo(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var be2 = (r2, e) => {
  for (var t in e || (e = {})) qo.call(e, t) && Ze2(r2, t, e[t]);
  if (Ki2) for (var t of Ki2(e)) Go2.call(e, t) && Ze2(r2, t, e[t]);
  return r2;
};
var E2 = (r2, e, t) => Ze2(r2, typeof e != "symbol" ? e + "" : e, t);
var Bi2 = class extends R3 {
  constructor(e, t, i3 = true) {
    super(e, t, i3), this.core = e, this.logger = t, E2(this, "context", ei2), E2(this, "storagePrefix", B2), E2(this, "storageVersion", Qt2), E2(this, "events", /* @__PURE__ */ new Map()), E2(this, "shouldPersist", false), E2(this, "init", async () => {
      if (!Ii()) try {
        const s2 = { eventId: Bi(), timestamp: Date.now(), domain: this.getAppDomain(), props: { event: "INIT", type: "", properties: { client_id: await this.core.crypto.getClientId(), user_agent: Mn(this.core.relayer.protocol, this.core.relayer.version, _e2) } } };
        await this.sendEvent([s2]);
      } catch (s2) {
        this.logger.warn(s2);
      }
    }), E2(this, "createEvent", (s2) => {
      const { event: n2 = "ERROR", type: o3 = "", properties: { topic: a2, trace: c3 } } = s2, h4 = Bi(), l3 = this.core.projectId || "", d3 = Date.now(), g2 = be2({ eventId: h4, timestamp: d3, props: { event: n2, type: o3, properties: { topic: a2, trace: c3 } }, bundleId: l3, domain: this.getAppDomain() }, this.setMethods(h4));
      return this.telemetryEnabled && (this.events.set(h4, g2), this.shouldPersist = true), g2;
    }), E2(this, "getEvent", (s2) => {
      const { eventId: n2, topic: o3 } = s2;
      if (n2) return this.events.get(n2);
      const a2 = Array.from(this.events.values()).find((c3) => c3.props.properties.topic === o3);
      if (a2) return be2(be2({}, a2), this.setMethods(a2.eventId));
    }), E2(this, "deleteEvent", (s2) => {
      const { eventId: n2 } = s2;
      this.events.delete(n2), this.shouldPersist = true;
    }), E2(this, "setEventListeners", () => {
      this.core.heartbeat.on(r.pulse, async () => {
        this.shouldPersist && await this.persist(), this.events.forEach((s2) => {
          (0, import_time2.fromMiliseconds)(Date.now()) - (0, import_time2.fromMiliseconds)(s2.timestamp) > ti && (this.events.delete(s2.eventId), this.shouldPersist = true);
        });
      });
    }), E2(this, "setMethods", (s2) => ({ addTrace: (n2) => this.addTrace(s2, n2), setError: (n2) => this.setError(s2, n2) })), E2(this, "addTrace", (s2, n2) => {
      const o3 = this.events.get(s2);
      o3 && (o3.props.properties.trace.push(n2), this.events.set(s2, o3), this.shouldPersist = true);
    }), E2(this, "setError", (s2, n2) => {
      const o3 = this.events.get(s2);
      o3 && (o3.props.type = n2, o3.timestamp = Date.now(), this.events.set(s2, o3), this.shouldPersist = true);
    }), E2(this, "persist", async () => {
      await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())), this.shouldPersist = false;
    }), E2(this, "restore", async () => {
      try {
        const s2 = await this.core.storage.getItem(this.storageKey) || [];
        if (!s2.length) return;
        s2.forEach((n2) => {
          this.events.set(n2.eventId, be2(be2({}, n2), this.setMethods(n2.eventId)));
        });
      } catch (s2) {
        this.logger.warn(s2);
      }
    }), E2(this, "submit", async () => {
      if (!this.telemetryEnabled || this.events.size === 0) return;
      const s2 = [];
      for (const [n2, o3] of this.events) o3.props.type && s2.push(o3);
      if (s2.length !== 0) try {
        if ((await this.sendEvent(s2)).ok) for (const n2 of s2) this.events.delete(n2.eventId), this.shouldPersist = true;
      } catch (n2) {
        this.logger.warn(n2);
      }
    }), E2(this, "sendEvent", async (s2) => {
      const n2 = this.getAppDomain() ? "" : "&sp=desktop";
      return await fetch(`${ii}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${_e2}${n2}`, { method: "POST", body: JSON.stringify(s2) });
    }), E2(this, "getAppDomain", () => Pn().url), this.logger = E(t, this.context), this.telemetryEnabled = i3, i3 ? this.restore().then(async () => {
      await this.submit(), this.setEventListeners();
    }) : this.persist();
  }
  get storageKey() {
    return this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + "//" + this.context;
  }
};
var Wo2 = Object.defineProperty;
var Vi2 = Object.getOwnPropertySymbols;
var Ho = Object.prototype.hasOwnProperty;
var Yo2 = Object.prototype.propertyIsEnumerable;
var Qe3 = (r2, e, t) => e in r2 ? Wo2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var qi2 = (r2, e) => {
  for (var t in e || (e = {})) Ho.call(e, t) && Qe3(r2, t, e[t]);
  if (Vi2) for (var t of Vi2(e)) Yo2.call(e, t) && Qe3(r2, t, e[t]);
  return r2;
};
var v6 = (r2, e, t) => Qe3(r2, typeof e != "symbol" ? e + "" : e, t);
var Te = class _Te extends h2 {
  constructor(e) {
    var t;
    super(e), v6(this, "protocol", ze2), v6(this, "version", Le2), v6(this, "name", he2), v6(this, "relayUrl"), v6(this, "projectId"), v6(this, "customStoragePrefix"), v6(this, "events", new import_events3.EventEmitter()), v6(this, "logger"), v6(this, "heartbeat"), v6(this, "relayer"), v6(this, "crypto"), v6(this, "storage"), v6(this, "history"), v6(this, "expirer"), v6(this, "pairing"), v6(this, "verify"), v6(this, "echoClient"), v6(this, "linkModeSupportedApps"), v6(this, "eventClient"), v6(this, "initialized", false), v6(this, "logChunkController"), v6(this, "on", (a2, c3) => this.events.on(a2, c3)), v6(this, "once", (a2, c3) => this.events.once(a2, c3)), v6(this, "off", (a2, c3) => this.events.off(a2, c3)), v6(this, "removeListener", (a2, c3) => this.events.removeListener(a2, c3)), v6(this, "dispatchEnvelope", ({ topic: a2, message: c3, sessionExists: h4 }) => {
      if (!a2 || !c3) return;
      const l3 = { topic: a2, message: c3, publishedAt: Date.now(), transportType: Q.link_mode };
      this.relayer.onLinkMessageEvent(l3, { sessionExists: h4 });
    });
    const i3 = this.getGlobalCore(e?.customStoragePrefix);
    if (i3) try {
      return this.customStoragePrefix = i3.customStoragePrefix, this.logger = i3.logger, this.heartbeat = i3.heartbeat, this.crypto = i3.crypto, this.history = i3.history, this.expirer = i3.expirer, this.storage = i3.storage, this.relayer = i3.relayer, this.pairing = i3.pairing, this.verify = i3.verify, this.echoClient = i3.echoClient, this.linkModeSupportedApps = i3.linkModeSupportedApps, this.eventClient = i3.eventClient, this.initialized = i3.initialized, this.logChunkController = i3.logChunkController, i3;
    } catch (a2) {
      console.warn("Failed to copy global core", a2);
    }
    this.projectId = e?.projectId, this.relayUrl = e?.relayUrl || Ue, this.customStoragePrefix = e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : "";
    const s2 = k({ level: typeof e?.logger == "string" && e.logger ? e.logger : Et2.logger, name: he2 }), { logger: n2, chunkLoggerController: o3 } = A({ opts: s2, maxSizeInBytes: e?.maxLogBlobSizeInBytes, loggerOverride: e?.logger });
    this.logChunkController = o3, (t = this.logChunkController) != null && t.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {
      var a2, c3;
      (a2 = this.logChunkController) != null && a2.downloadLogsBlobInBrowser && ((c3 = this.logChunkController) == null || c3.downloadLogsBlobInBrowser({ clientId: await this.crypto.getClientId() }));
    }), this.logger = E(n2, this.name), this.heartbeat = new i(), this.crypto = new vi2(this, this.logger, e?.keychain), this.history = new ki2(this, this.logger), this.expirer = new ji2(this, this.logger), this.storage = e != null && e.storage ? e.storage : new h(qi2(qi2({}, It2), e?.storageOptions)), this.relayer = new Si2({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new Li2(this, this.logger), this.verify = new Ui2(this, this.logger, this.storage), this.echoClient = new Mi2(this.projectId || "", this.logger), this.linkModeSupportedApps = [], this.eventClient = new Bi2(this, this.logger, e?.telemetryEnabled), this.setGlobalCore(this);
  }
  static async init(e) {
    const t = new _Te(e);
    await t.initialize();
    const i3 = await t.crypto.getClientId();
    return await t.storage.setItem(jt2, i3), t;
  }
  get context() {
    return y(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async getLogsBlob() {
    var e;
    return (e = this.logChunkController) == null ? void 0 : e.logsToBlob({ clientId: await this.crypto.getClientId() });
  }
  async addLinkModeSupportedApp(e) {
    this.linkModeSupportedApps.includes(e) || (this.linkModeSupportedApps.push(e), await this.storage.setItem(Fe2, this.linkModeSupportedApps));
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.linkModeSupportedApps = await this.storage.getItem(Fe2) || [], this.initialized = true, this.logger.info("Core Initialization Success");
    } catch (e) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;
    }
  }
  getGlobalCore(e = "") {
    try {
      if (this.isGlobalCoreDisabled()) return;
      const t = `_walletConnectCore_${e}`, i3 = `${t}_count`;
      return globalThis[i3] = (globalThis[i3] || 0) + 1, globalThis[i3] > 1 && console.warn(`WalletConnect Core is already initialized. This is probably a mistake and can lead to unexpected behavior. Init() was called ${globalThis[i3]} times.`), globalThis[t];
    } catch (t) {
      console.warn("Failed to get global WalletConnect core", t);
      return;
    }
  }
  setGlobalCore(e) {
    var t;
    try {
      if (this.isGlobalCoreDisabled()) return;
      const i3 = `_walletConnectCore_${((t = e.opts) == null ? void 0 : t.customStoragePrefix) || ""}`;
      globalThis[i3] = e;
    } catch (i3) {
      console.warn("Failed to set global WalletConnect core", i3);
    }
  }
  isGlobalCoreDisabled() {
    try {
      return typeof process < "u" && process.env.DISABLE_GLOBAL_CORE === "true";
    } catch {
      return true;
    }
  }
};
var Jo2 = Te;

// node_modules/.pnpm/@walletconnect+sign-client@2.20.2_@react-native-async-storage+async-storage@1.24.0_reac_098f109391ad96dfdb40148c9bacae64/node_modules/@walletconnect/sign-client/dist/index.es.js
var import_time3 = __toESM(require_cjs());
var import_events4 = __toESM(require_events());
var De2 = "wc";
var Le3 = 2;
var ke3 = "client";
var we2 = `${De2}@${Le3}:${ke3}:`;
var me2 = { name: ke3, logger: "error", controller: false, relayUrl: "wss://relay.walletconnect.org" };
var Me3 = "WALLETCONNECT_DEEPLINK_CHOICE";
var pt2 = "proposal";
var $e = "Proposal expired";
var ht2 = "session";
var J3 = import_time3.SEVEN_DAYS;
var dt2 = "engine";
var N = { wc_sessionPropose: { req: { ttl: import_time3.FIVE_MINUTES, prompt: true, tag: 1100 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1101 }, reject: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1120 }, autoReject: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1121 } }, wc_sessionSettle: { req: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1102 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1104 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1105 } }, wc_sessionExtend: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1106 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1107 } }, wc_sessionRequest: { req: { ttl: import_time3.FIVE_MINUTES, prompt: true, tag: 1108 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1109 } }, wc_sessionEvent: { req: { ttl: import_time3.FIVE_MINUTES, prompt: true, tag: 1110 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1111 } }, wc_sessionDelete: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1112 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1113 } }, wc_sessionPing: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1114 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1115 } }, wc_sessionAuthenticate: { req: { ttl: import_time3.ONE_HOUR, prompt: true, tag: 1116 }, res: { ttl: import_time3.ONE_HOUR, prompt: false, tag: 1117 }, reject: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1118 }, autoReject: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1119 } } };
var _e3 = { min: import_time3.FIVE_MINUTES, max: import_time3.SEVEN_DAYS };
var $4 = { idle: "IDLE", active: "ACTIVE" };
var Ue2 = { eth_sendTransaction: { key: "" }, eth_sendRawTransaction: { key: "" }, wallet_sendCalls: { key: "" }, solana_signTransaction: { key: "signature" }, solana_signAllTransactions: { key: "transactions" }, solana_signAndSendTransaction: { key: "signature" } };
var ut2 = "request";
var gt2 = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest", "wc_sessionAuthenticate"];
var yt2 = "wc";
var wt2 = "auth";
var mt2 = "authKeys";
var _t2 = "pairingTopics";
var Et3 = "requests";
var ae = `${yt2}@${1.5}:${wt2}:`;
var ce2 = `${ae}:PUB_KEY`;
var Rs2 = Object.defineProperty;
var vs2 = Object.defineProperties;
var Is2 = Object.getOwnPropertyDescriptors;
var ft2 = Object.getOwnPropertySymbols;
var Ts2 = Object.prototype.hasOwnProperty;
var qs2 = Object.prototype.propertyIsEnumerable;
var Ke3 = (S3, n2, e) => n2 in S3 ? Rs2(S3, n2, { enumerable: true, configurable: true, writable: true, value: e }) : S3[n2] = e;
var v7 = (S3, n2) => {
  for (var e in n2 || (n2 = {})) Ts2.call(n2, e) && Ke3(S3, e, n2[e]);
  if (ft2) for (var e of ft2(n2)) qs2.call(n2, e) && Ke3(S3, e, n2[e]);
  return S3;
};
var b3 = (S3, n2) => vs2(S3, Is2(n2));
var c2 = (S3, n2, e) => Ke3(S3, typeof n2 != "symbol" ? n2 + "" : n2, e);
var Ps2 = class extends V {
  constructor(n2) {
    super(n2), c2(this, "name", dt2), c2(this, "events", new import_events4.default()), c2(this, "initialized", false), c2(this, "requestQueue", { state: $4.idle, queue: [] }), c2(this, "sessionRequestQueue", { state: $4.idle, queue: [] }), c2(this, "requestQueueDelay", import_time3.ONE_SECOND), c2(this, "expectedPairingMethodMap", /* @__PURE__ */ new Map()), c2(this, "recentlyDeletedMap", /* @__PURE__ */ new Map()), c2(this, "recentlyDeletedLimit", 200), c2(this, "relayMessageCache", []), c2(this, "pendingSessions", /* @__PURE__ */ new Map()), c2(this, "init", async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), await this.registerLinkModeListeners(), this.client.core.pairing.register({ methods: Object.keys(N) }), this.initialized = true, setTimeout(async () => {
        await this.processPendingMessageEvents(), this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, (0, import_time3.toMiliseconds)(this.requestQueueDelay)));
    }), c2(this, "connect", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      const t = b3(v7({}, e), { requiredNamespaces: e.requiredNamespaces || {}, optionalNamespaces: e.optionalNamespaces || {} });
      await this.isValidConnect(t);
      const { pairingTopic: s2, requiredNamespaces: i3, optionalNamespaces: r2, sessionProperties: o3, scopedProperties: a2, relays: l3 } = t;
      let p4 = s2, h4, u4 = false;
      try {
        if (p4) {
          const T4 = this.client.core.pairing.pairings.get(p4);
          this.client.logger.warn("connect() with existing pairing topic is deprecated and will be removed in the next major release."), u4 = T4.active;
        }
      } catch (T4) {
        throw this.client.logger.error(`connect() -> pairing.get(${p4}) failed`), T4;
      }
      if (!p4 || !u4) {
        const { topic: T4, uri: U4 } = await this.client.core.pairing.create();
        p4 = T4, h4 = U4;
      }
      if (!p4) {
        const { message: T4 } = ht("NO_MATCHING_KEY", `connect() pairing topic: ${p4}`);
        throw new Error(T4);
      }
      const d3 = await this.client.core.crypto.generateKeyPair(), w4 = N.wc_sessionPropose.req.ttl || import_time3.FIVE_MINUTES, m3 = Ei(w4), f6 = b3(v7(v7({ requiredNamespaces: i3, optionalNamespaces: r2, relays: l3 ?? [{ protocol: xt2 }], proposer: { publicKey: d3, metadata: this.client.metadata }, expiryTimestamp: m3, pairingTopic: p4 }, o3 && { sessionProperties: o3 }), a2 && { scopedProperties: a2 }), { id: payloadId() }), _2 = xi("session_connect", f6.id), { reject: g2, resolve: A5, done: D3 } = gi(w4, $e), I3 = ({ id: T4 }) => {
        T4 === f6.id && (this.client.events.off("proposal_expire", I3), this.pendingSessions.delete(f6.id), this.events.emit(_2, { error: { message: $e, code: 0 } }));
      };
      return this.client.events.on("proposal_expire", I3), this.events.once(_2, ({ error: T4, session: U4 }) => {
        this.client.events.off("proposal_expire", I3), T4 ? g2(T4) : U4 && A5(U4);
      }), await this.sendRequest({ topic: p4, method: "wc_sessionPropose", params: f6, throwOnFailedPublish: true, clientRpcId: f6.id }), await this.setProposal(f6.id, f6), { uri: h4, approval: D3 };
    }), c2(this, "pair", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        return await this.client.core.pairing.pair(e);
      } catch (t) {
        throw this.client.logger.error("pair() failed"), t;
      }
    }), c2(this, "approve", async (e) => {
      var t, s2, i3;
      const r2 = this.client.core.eventClient.createEvent({ properties: { topic: (t = e?.id) == null ? void 0 : t.toString(), trace: [Qs2.session_approve_started] } });
      try {
        this.isInitialized(), await this.confirmOnlineStateOrThrow();
      } catch (q2) {
        throw r2.setError(er2.no_internet_connection), q2;
      }
      try {
        await this.isValidProposalId(e?.id);
      } catch (q2) {
        throw this.client.logger.error(`approve() -> proposal.get(${e?.id}) failed`), r2.setError(er2.proposal_not_found), q2;
      }
      try {
        await this.isValidApprove(e);
      } catch (q2) {
        throw this.client.logger.error("approve() -> isValidApprove() failed"), r2.setError(er2.session_approve_namespace_validation_failure), q2;
      }
      const { id: o3, relayProtocol: a2, namespaces: l3, sessionProperties: p4, scopedProperties: h4, sessionConfig: u4 } = e, d3 = this.client.proposal.get(o3);
      this.client.core.eventClient.deleteEvent({ eventId: r2.eventId });
      const { pairingTopic: w4, proposer: m3, requiredNamespaces: f6, optionalNamespaces: _2 } = d3;
      let g2 = (s2 = this.client.core.eventClient) == null ? void 0 : s2.getEvent({ topic: w4 });
      g2 || (g2 = (i3 = this.client.core.eventClient) == null ? void 0 : i3.createEvent({ type: Qs2.session_approve_started, properties: { topic: w4, trace: [Qs2.session_approve_started, Qs2.session_namespaces_validation_success] } }));
      const A5 = await this.client.core.crypto.generateKeyPair(), D3 = m3.publicKey, I3 = await this.client.core.crypto.generateSharedKey(A5, D3), T4 = v7(v7(v7({ relay: { protocol: a2 ?? "irn" }, namespaces: l3, controller: { publicKey: A5, metadata: this.client.metadata }, expiry: Ei(J3) }, p4 && { sessionProperties: p4 }), h4 && { scopedProperties: h4 }), u4 && { sessionConfig: u4 }), U4 = Q.relay;
      g2.addTrace(Qs2.subscribing_session_topic);
      try {
        await this.client.core.relayer.subscribe(I3, { transportType: U4 });
      } catch (q2) {
        throw g2.setError(er2.subscribe_session_topic_failure), q2;
      }
      g2.addTrace(Qs2.subscribe_session_topic_success);
      const fe4 = b3(v7({}, T4), { topic: I3, requiredNamespaces: f6, optionalNamespaces: _2, pairingTopic: w4, acknowledged: false, self: T4.controller, peer: { publicKey: m3.publicKey, metadata: m3.metadata }, controller: A5, transportType: Q.relay });
      await this.client.session.set(I3, fe4), g2.addTrace(Qs2.store_session);
      try {
        g2.addTrace(Qs2.publishing_session_settle), await this.sendRequest({ topic: I3, method: "wc_sessionSettle", params: T4, throwOnFailedPublish: true }).catch((q2) => {
          throw g2?.setError(er2.session_settle_publish_failure), q2;
        }), g2.addTrace(Qs2.session_settle_publish_success), g2.addTrace(Qs2.publishing_session_approve), await this.sendResult({ id: o3, topic: w4, result: { relay: { protocol: a2 ?? "irn" }, responderPublicKey: A5 }, throwOnFailedPublish: true }).catch((q2) => {
          throw g2?.setError(er2.session_approve_publish_failure), q2;
        }), g2.addTrace(Qs2.session_approve_publish_success);
      } catch (q2) {
        throw this.client.logger.error(q2), this.client.session.delete(I3, Nt("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe(I3), q2;
      }
      return this.client.core.eventClient.deleteEvent({ eventId: g2.eventId }), await this.client.core.pairing.updateMetadata({ topic: w4, metadata: m3.metadata }), await this.client.proposal.delete(o3, Nt("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: w4 }), await this.setExpiry(I3, Ei(J3)), { topic: I3, acknowledged: () => Promise.resolve(this.client.session.get(I3)) };
    }), c2(this, "reject", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidReject(e);
      } catch (r2) {
        throw this.client.logger.error("reject() -> isValidReject() failed"), r2;
      }
      const { id: t, reason: s2 } = e;
      let i3;
      try {
        i3 = this.client.proposal.get(t).pairingTopic;
      } catch (r2) {
        throw this.client.logger.error(`reject() -> proposal.get(${t}) failed`), r2;
      }
      i3 && (await this.sendError({ id: t, topic: i3, error: s2, rpcOpts: N.wc_sessionPropose.reject }), await this.client.proposal.delete(t, Nt("USER_DISCONNECTED")));
    }), c2(this, "update", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidUpdate(e);
      } catch (h4) {
        throw this.client.logger.error("update() -> isValidUpdate() failed"), h4;
      }
      const { topic: t, namespaces: s2 } = e, { done: i3, resolve: r2, reject: o3 } = gi(), a2 = payloadId(), l3 = getBigIntRpcId().toString(), p4 = this.client.session.get(t).namespaces;
      return this.events.once(xi("session_update", a2), ({ error: h4 }) => {
        h4 ? o3(h4) : r2();
      }), await this.client.session.update(t, { namespaces: s2 }), await this.sendRequest({ topic: t, method: "wc_sessionUpdate", params: { namespaces: s2 }, throwOnFailedPublish: true, clientRpcId: a2, relayRpcId: l3 }).catch((h4) => {
        this.client.logger.error(h4), this.client.session.update(t, { namespaces: p4 }), o3(h4);
      }), { acknowledged: i3 };
    }), c2(this, "extend", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidExtend(e);
      } catch (a2) {
        throw this.client.logger.error("extend() -> isValidExtend() failed"), a2;
      }
      const { topic: t } = e, s2 = payloadId(), { done: i3, resolve: r2, reject: o3 } = gi();
      return this.events.once(xi("session_extend", s2), ({ error: a2 }) => {
        a2 ? o3(a2) : r2();
      }), await this.setExpiry(t, Ei(J3)), this.sendRequest({ topic: t, method: "wc_sessionExtend", params: {}, clientRpcId: s2, throwOnFailedPublish: true }).catch((a2) => {
        o3(a2);
      }), { acknowledged: i3 };
    }), c2(this, "request", async (e) => {
      this.isInitialized();
      try {
        await this.isValidRequest(e);
      } catch (_2) {
        throw this.client.logger.error("request() -> isValidRequest() failed"), _2;
      }
      const { chainId: t, request: s2, topic: i3, expiry: r2 = N.wc_sessionRequest.req.ttl } = e, o3 = this.client.session.get(i3);
      o3?.transportType === Q.relay && await this.confirmOnlineStateOrThrow();
      const a2 = payloadId(), l3 = getBigIntRpcId().toString(), { done: p4, resolve: h4, reject: u4 } = gi(r2, "Request expired. Please try again.");
      this.events.once(xi("session_request", a2), ({ error: _2, result: g2 }) => {
        _2 ? u4(_2) : h4(g2);
      });
      const d3 = "wc_sessionRequest", w4 = this.getAppLinkIfEnabled(o3.peer.metadata, o3.transportType);
      if (w4) return await this.sendRequest({ clientRpcId: a2, relayRpcId: l3, topic: i3, method: d3, params: { request: b3(v7({}, s2), { expiryTimestamp: Ei(r2) }), chainId: t }, expiry: r2, throwOnFailedPublish: true, appLink: w4 }).catch((_2) => u4(_2)), this.client.events.emit("session_request_sent", { topic: i3, request: s2, chainId: t, id: a2 }), await p4();
      const m3 = { request: b3(v7({}, s2), { expiryTimestamp: Ei(r2) }), chainId: t }, f6 = this.shouldSetTVF(d3, m3);
      return await Promise.all([new Promise(async (_2) => {
        await this.sendRequest(v7({ clientRpcId: a2, relayRpcId: l3, topic: i3, method: d3, params: m3, expiry: r2, throwOnFailedPublish: true }, f6 && { tvf: this.getTVFParams(a2, m3) })).catch((g2) => u4(g2)), this.client.events.emit("session_request_sent", { topic: i3, request: s2, chainId: t, id: a2 }), _2();
      }), new Promise(async (_2) => {
        var g2;
        if (!((g2 = o3.sessionConfig) != null && g2.disableDeepLink)) {
          const A5 = await Oi(this.client.core.storage, Me3);
          await Si({ id: a2, topic: i3, wcDeepLink: A5 });
        }
        _2();
      }), p4()]).then((_2) => _2[2]);
    }), c2(this, "respond", async (e) => {
      this.isInitialized(), await this.isValidRespond(e);
      const { topic: t, response: s2 } = e, { id: i3 } = s2, r2 = this.client.session.get(t);
      r2.transportType === Q.relay && await this.confirmOnlineStateOrThrow();
      const o3 = this.getAppLinkIfEnabled(r2.peer.metadata, r2.transportType);
      isJsonRpcResult(s2) ? await this.sendResult({ id: i3, topic: t, result: s2.result, throwOnFailedPublish: true, appLink: o3 }) : isJsonRpcError(s2) && await this.sendError({ id: i3, topic: t, error: s2.error, appLink: o3 }), this.cleanupAfterResponse(e);
    }), c2(this, "ping", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidPing(e);
      } catch (s2) {
        throw this.client.logger.error("ping() -> isValidPing() failed"), s2;
      }
      const { topic: t } = e;
      if (this.client.session.keys.includes(t)) {
        const s2 = payloadId(), i3 = getBigIntRpcId().toString(), { done: r2, resolve: o3, reject: a2 } = gi();
        this.events.once(xi("session_ping", s2), ({ error: l3 }) => {
          l3 ? a2(l3) : o3();
        }), await Promise.all([this.sendRequest({ topic: t, method: "wc_sessionPing", params: {}, throwOnFailedPublish: true, clientRpcId: s2, relayRpcId: i3 }), r2()]);
      } else this.client.core.pairing.pairings.keys.includes(t) && (this.client.logger.warn("ping() on pairing topic is deprecated and will be removed in the next major release."), await this.client.core.pairing.ping({ topic: t }));
    }), c2(this, "emit", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidEmit(e);
      const { topic: t, event: s2, chainId: i3 } = e, r2 = getBigIntRpcId().toString(), o3 = payloadId();
      await this.sendRequest({ topic: t, method: "wc_sessionEvent", params: { event: s2, chainId: i3 }, throwOnFailedPublish: true, relayRpcId: r2, clientRpcId: o3 });
    }), c2(this, "disconnect", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidDisconnect(e);
      const { topic: t } = e;
      if (this.client.session.keys.includes(t)) await this.sendRequest({ topic: t, method: "wc_sessionDelete", params: Nt("USER_DISCONNECTED"), throwOnFailedPublish: true }), await this.deleteSession({ topic: t, emitEvent: false });
      else if (this.client.core.pairing.pairings.keys.includes(t)) await this.client.core.pairing.disconnect({ topic: t });
      else {
        const { message: s2 } = ht("MISMATCHED_TOPIC", `Session or pairing topic not found: ${t}`);
        throw new Error(s2);
      }
    }), c2(this, "find", (e) => (this.isInitialized(), this.client.session.getAll().filter((t) => aa(t, e)))), c2(this, "getPendingSessionRequests", () => this.client.pendingRequest.getAll()), c2(this, "authenticate", async (e, t) => {
      var s2;
      this.isInitialized(), this.isValidAuthenticate(e);
      const i3 = t && this.client.core.linkModeSupportedApps.includes(t) && ((s2 = this.client.metadata.redirect) == null ? void 0 : s2.linkMode), r2 = i3 ? Q.link_mode : Q.relay;
      r2 === Q.relay && await this.confirmOnlineStateOrThrow();
      const { chains: o3, statement: a2 = "", uri: l3, domain: p4, nonce: h4, type: u4, exp: d3, nbf: w4, methods: m3 = [], expiry: f6 } = e, _2 = [...e.resources || []], { topic: g2, uri: A5 } = await this.client.core.pairing.create({ methods: ["wc_sessionAuthenticate"], transportType: r2 });
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: g2, uri: A5 } });
      const D3 = await this.client.core.crypto.generateKeyPair(), I3 = Pc(D3);
      if (await Promise.all([this.client.auth.authKeys.set(ce2, { responseTopic: I3, publicKey: D3 }), this.client.auth.pairingTopics.set(I3, { topic: I3, pairingTopic: g2 })]), await this.client.core.relayer.subscribe(I3, { transportType: r2 }), this.client.logger.info(`sending request to new pairing topic: ${g2}`), m3.length > 0) {
        const { namespace: x3 } = Ie(o3[0]);
        let L3 = fs(x3, "request", m3);
        de(_2) && (L3 = ls(L3, _2.pop())), _2.push(L3);
      }
      const T4 = f6 && f6 > N.wc_sessionAuthenticate.req.ttl ? f6 : N.wc_sessionAuthenticate.req.ttl, U4 = { authPayload: { type: u4 ?? "caip122", chains: o3, statement: a2, aud: l3, domain: p4, version: "1", nonce: h4, iat: (/* @__PURE__ */ new Date()).toISOString(), exp: d3, nbf: w4, resources: _2 }, requester: { publicKey: D3, metadata: this.client.metadata }, expiryTimestamp: Ei(T4) }, fe4 = { eip155: { chains: o3, methods: [.../* @__PURE__ */ new Set(["personal_sign", ...m3])], events: ["chainChanged", "accountsChanged"] } }, q2 = { requiredNamespaces: {}, optionalNamespaces: fe4, relays: [{ protocol: "irn" }], pairingTopic: g2, proposer: { publicKey: D3, metadata: this.client.metadata }, expiryTimestamp: Ei(N.wc_sessionPropose.req.ttl), id: payloadId() }, { done: Rt3, resolve: je3, reject: Se4 } = gi(T4, "Request expired"), te4 = payloadId(), le4 = xi("session_connect", q2.id), Re2 = xi("session_request", te4), pe4 = async ({ error: x3, session: L3 }) => {
        this.events.off(Re2, ve3), x3 ? Se4(x3) : L3 && je3({ session: L3 });
      }, ve3 = async (x3) => {
        var L3, Fe4, Qe4;
        if (await this.deletePendingAuthRequest(te4, { message: "fulfilled", code: 0 }), x3.error) {
          const ie4 = Nt("WC_METHOD_UNSUPPORTED", "wc_sessionAuthenticate");
          return x3.error.code === ie4.code ? void 0 : (this.events.off(le4, pe4), Se4(x3.error.message));
        }
        await this.deleteProposal(q2.id), this.events.off(le4, pe4);
        const { cacaos: He3, responder: Q3 } = x3.result, Te3 = [], ze3 = [];
        for (const ie4 of He3) {
          await is({ cacao: ie4, projectId: this.client.core.projectId }) || (this.client.logger.error(ie4, "Signature verification failed"), Se4(Nt("SESSION_SETTLEMENT_FAILED", "Signature verification failed")));
          const { p: qe4 } = ie4, Pe3 = de(qe4.resources), Ye3 = [dr(qe4.iss)], vt = Me(qe4.iss);
          if (Pe3) {
            const Ne2 = ds(Pe3), It3 = hs(Pe3);
            Te3.push(...Ne2), Ye3.push(...It3);
          }
          for (const Ne2 of Ye3) ze3.push(`${Ne2}:${vt}`);
        }
        const se4 = await this.client.core.crypto.generateSharedKey(D3, Q3.publicKey);
        let he4;
        Te3.length > 0 && (he4 = { topic: se4, acknowledged: true, self: { publicKey: D3, metadata: this.client.metadata }, peer: Q3, controller: Q3.publicKey, expiry: Ei(J3), requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: g2, namespaces: ca([...new Set(Te3)], [...new Set(ze3)]), transportType: r2 }, await this.client.core.relayer.subscribe(se4, { transportType: r2 }), await this.client.session.set(se4, he4), g2 && await this.client.core.pairing.updateMetadata({ topic: g2, metadata: Q3.metadata }), he4 = this.client.session.get(se4)), (L3 = this.client.metadata.redirect) != null && L3.linkMode && (Fe4 = Q3.metadata.redirect) != null && Fe4.linkMode && (Qe4 = Q3.metadata.redirect) != null && Qe4.universal && t && (this.client.core.addLinkModeSupportedApp(Q3.metadata.redirect.universal), this.client.session.update(se4, { transportType: Q.link_mode })), je3({ auths: He3, session: he4 });
      };
      this.events.once(le4, pe4), this.events.once(Re2, ve3);
      let Ie4;
      try {
        if (i3) {
          const x3 = formatJsonRpcRequest("wc_sessionAuthenticate", U4, te4);
          this.client.core.history.set(g2, x3);
          const L3 = await this.client.core.crypto.encode("", x3, { type: ne, encoding: Ee });
          Ie4 = Xc(t, g2, L3);
        } else await Promise.all([this.sendRequest({ topic: g2, method: "wc_sessionAuthenticate", params: U4, expiry: e.expiry, throwOnFailedPublish: true, clientRpcId: te4 }), this.sendRequest({ topic: g2, method: "wc_sessionPropose", params: q2, expiry: N.wc_sessionPropose.req.ttl, throwOnFailedPublish: true, clientRpcId: q2.id })]);
      } catch (x3) {
        throw this.events.off(le4, pe4), this.events.off(Re2, ve3), x3;
      }
      return await this.setProposal(q2.id, q2), await this.setAuthRequest(te4, { request: b3(v7({}, U4), { verifyContext: {} }), pairingTopic: g2, transportType: r2 }), { uri: Ie4 ?? A5, response: Rt3 };
    }), c2(this, "approveSessionAuthenticate", async (e) => {
      const { id: t, auths: s2 } = e, i3 = this.client.core.eventClient.createEvent({ properties: { topic: t.toString(), trace: [tr2.authenticated_session_approve_started] } });
      try {
        this.isInitialized();
      } catch (f6) {
        throw i3.setError(ir2.no_internet_connection), f6;
      }
      const r2 = this.getPendingAuthRequest(t);
      if (!r2) throw i3.setError(ir2.authenticated_session_pending_request_not_found), new Error(`Could not find pending auth request with id ${t}`);
      const o3 = r2.transportType || Q.relay;
      o3 === Q.relay && await this.confirmOnlineStateOrThrow();
      const a2 = r2.requester.publicKey, l3 = await this.client.core.crypto.generateKeyPair(), p4 = Pc(a2), h4 = { type: Kt, receiverPublicKey: a2, senderPublicKey: l3 }, u4 = [], d3 = [];
      for (const f6 of s2) {
        if (!await is({ cacao: f6, projectId: this.client.core.projectId })) {
          i3.setError(ir2.invalid_cacao);
          const I3 = Nt("SESSION_SETTLEMENT_FAILED", "Signature verification failed");
          throw await this.sendError({ id: t, topic: p4, error: I3, encodeOpts: h4 }), new Error(I3.message);
        }
        i3.addTrace(tr2.cacaos_verified);
        const { p: _2 } = f6, g2 = de(_2.resources), A5 = [dr(_2.iss)], D3 = Me(_2.iss);
        if (g2) {
          const I3 = ds(g2), T4 = hs(g2);
          u4.push(...I3), A5.push(...T4);
        }
        for (const I3 of A5) d3.push(`${I3}:${D3}`);
      }
      const w4 = await this.client.core.crypto.generateSharedKey(l3, a2);
      i3.addTrace(tr2.create_authenticated_session_topic);
      let m3;
      if (u4?.length > 0) {
        m3 = { topic: w4, acknowledged: true, self: { publicKey: l3, metadata: this.client.metadata }, peer: { publicKey: a2, metadata: r2.requester.metadata }, controller: a2, expiry: Ei(J3), authentication: s2, requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: r2.pairingTopic, namespaces: ca([...new Set(u4)], [...new Set(d3)]), transportType: o3 }, i3.addTrace(tr2.subscribing_authenticated_session_topic);
        try {
          await this.client.core.relayer.subscribe(w4, { transportType: o3 });
        } catch (f6) {
          throw i3.setError(ir2.subscribe_authenticated_session_topic_failure), f6;
        }
        i3.addTrace(tr2.subscribe_authenticated_session_topic_success), await this.client.session.set(w4, m3), i3.addTrace(tr2.store_authenticated_session), await this.client.core.pairing.updateMetadata({ topic: r2.pairingTopic, metadata: r2.requester.metadata });
      }
      i3.addTrace(tr2.publishing_authenticated_session_approve);
      try {
        await this.sendResult({ topic: p4, id: t, result: { cacaos: s2, responder: { publicKey: l3, metadata: this.client.metadata } }, encodeOpts: h4, throwOnFailedPublish: true, appLink: this.getAppLinkIfEnabled(r2.requester.metadata, o3) });
      } catch (f6) {
        throw i3.setError(ir2.authenticated_session_approve_publish_failure), f6;
      }
      return await this.client.auth.requests.delete(t, { message: "fulfilled", code: 0 }), await this.client.core.pairing.activate({ topic: r2.pairingTopic }), this.client.core.eventClient.deleteEvent({ eventId: i3.eventId }), { session: m3 };
    }), c2(this, "rejectSessionAuthenticate", async (e) => {
      this.isInitialized();
      const { id: t, reason: s2 } = e, i3 = this.getPendingAuthRequest(t);
      if (!i3) throw new Error(`Could not find pending auth request with id ${t}`);
      i3.transportType === Q.relay && await this.confirmOnlineStateOrThrow();
      const r2 = i3.requester.publicKey, o3 = await this.client.core.crypto.generateKeyPair(), a2 = Pc(r2), l3 = { type: Kt, receiverPublicKey: r2, senderPublicKey: o3 };
      await this.sendError({ id: t, topic: a2, error: s2, encodeOpts: l3, rpcOpts: N.wc_sessionAuthenticate.reject, appLink: this.getAppLinkIfEnabled(i3.requester.metadata, i3.transportType) }), await this.client.auth.requests.delete(t, { message: "rejected", code: 0 }), await this.client.proposal.delete(t, Nt("USER_DISCONNECTED"));
    }), c2(this, "formatAuthMessage", (e) => {
      this.isInitialized();
      const { request: t, iss: s2 } = e;
      return hr(t, s2);
    }), c2(this, "processRelayMessageCache", () => {
      setTimeout(async () => {
        if (this.relayMessageCache.length !== 0) for (; this.relayMessageCache.length > 0; ) try {
          const e = this.relayMessageCache.shift();
          e && await this.onRelayMessage(e);
        } catch (e) {
          this.client.logger.error(e);
        }
      }, 50);
    }), c2(this, "cleanupDuplicatePairings", async (e) => {
      if (e.pairingTopic) try {
        const t = this.client.core.pairing.pairings.get(e.pairingTopic), s2 = this.client.core.pairing.pairings.getAll().filter((i3) => {
          var r2, o3;
          return ((r2 = i3.peerMetadata) == null ? void 0 : r2.url) && ((o3 = i3.peerMetadata) == null ? void 0 : o3.url) === e.peer.metadata.url && i3.topic && i3.topic !== t.topic;
        });
        if (s2.length === 0) return;
        this.client.logger.info(`Cleaning up ${s2.length} duplicate pairing(s)`), await Promise.all(s2.map((i3) => this.client.core.pairing.disconnect({ topic: i3.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
      } catch (t) {
        this.client.logger.error(t);
      }
    }), c2(this, "deleteSession", async (e) => {
      var t;
      const { topic: s2, expirerHasDeleted: i3 = false, emitEvent: r2 = true, id: o3 = 0 } = e, { self: a2 } = this.client.session.get(s2);
      await this.client.core.relayer.unsubscribe(s2), await this.client.session.delete(s2, Nt("USER_DISCONNECTED")), this.addToRecentlyDeleted(s2, "session"), this.client.core.crypto.keychain.has(a2.publicKey) && await this.client.core.crypto.deleteKeyPair(a2.publicKey), this.client.core.crypto.keychain.has(s2) && await this.client.core.crypto.deleteSymKey(s2), i3 || this.client.core.expirer.del(s2), this.client.core.storage.removeItem(Me3).catch((l3) => this.client.logger.warn(l3)), this.getPendingSessionRequests().forEach((l3) => {
        l3.topic === s2 && this.deletePendingSessionRequest(l3.id, Nt("USER_DISCONNECTED"));
      }), s2 === ((t = this.sessionRequestQueue.queue[0]) == null ? void 0 : t.topic) && (this.sessionRequestQueue.state = $4.idle), r2 && this.client.events.emit("session_delete", { id: o3, topic: s2 });
    }), c2(this, "deleteProposal", async (e, t) => {
      if (t) try {
        const s2 = this.client.proposal.get(e), i3 = this.client.core.eventClient.getEvent({ topic: s2.pairingTopic });
        i3?.setError(er2.proposal_expired);
      } catch {
      }
      await Promise.all([this.client.proposal.delete(e, Nt("USER_DISCONNECTED")), t ? Promise.resolve() : this.client.core.expirer.del(e)]), this.addToRecentlyDeleted(e, "proposal");
    }), c2(this, "deletePendingSessionRequest", async (e, t, s2 = false) => {
      await Promise.all([this.client.pendingRequest.delete(e, t), s2 ? Promise.resolve() : this.client.core.expirer.del(e)]), this.addToRecentlyDeleted(e, "request"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((i3) => i3.id !== e), s2 && (this.sessionRequestQueue.state = $4.idle, this.client.events.emit("session_request_expire", { id: e }));
    }), c2(this, "deletePendingAuthRequest", async (e, t, s2 = false) => {
      await Promise.all([this.client.auth.requests.delete(e, t), s2 ? Promise.resolve() : this.client.core.expirer.del(e)]);
    }), c2(this, "setExpiry", async (e, t) => {
      this.client.session.keys.includes(e) && (this.client.core.expirer.set(e, t), await this.client.session.update(e, { expiry: t }));
    }), c2(this, "setProposal", async (e, t) => {
      this.client.core.expirer.set(e, Ei(N.wc_sessionPropose.req.ttl)), await this.client.proposal.set(e, t);
    }), c2(this, "setAuthRequest", async (e, t) => {
      const { request: s2, pairingTopic: i3, transportType: r2 = Q.relay } = t;
      this.client.core.expirer.set(e, s2.expiryTimestamp), await this.client.auth.requests.set(e, { authPayload: s2.authPayload, requester: s2.requester, expiryTimestamp: s2.expiryTimestamp, id: e, pairingTopic: i3, verifyContext: s2.verifyContext, transportType: r2 });
    }), c2(this, "setPendingSessionRequest", async (e) => {
      const { id: t, topic: s2, params: i3, verifyContext: r2 } = e, o3 = i3.request.expiryTimestamp || Ei(N.wc_sessionRequest.req.ttl);
      this.client.core.expirer.set(t, o3), await this.client.pendingRequest.set(t, { id: t, topic: s2, params: i3, verifyContext: r2 });
    }), c2(this, "sendRequest", async (e) => {
      const { topic: t, method: s2, params: i3, expiry: r2, relayRpcId: o3, clientRpcId: a2, throwOnFailedPublish: l3, appLink: p4, tvf: h4 } = e, u4 = formatJsonRpcRequest(s2, i3, a2);
      let d3;
      const w4 = !!p4;
      try {
        const _2 = w4 ? Ee : Ht;
        d3 = await this.client.core.crypto.encode(t, u4, { encoding: _2 });
      } catch (_2) {
        throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${t} failed`), _2;
      }
      let m3;
      if (gt2.includes(s2)) {
        const _2 = kc(JSON.stringify(u4)), g2 = kc(d3);
        m3 = await this.client.core.verify.register({ id: g2, decryptedId: _2 });
      }
      const f6 = N[s2].req;
      if (f6.attestation = m3, r2 && (f6.ttl = r2), o3 && (f6.id = o3), this.client.core.history.set(t, u4), w4) {
        const _2 = Xc(p4, t, d3);
        await global.Linking.openURL(_2, this.client.name);
      } else {
        const _2 = N[s2].req;
        r2 && (_2.ttl = r2), o3 && (_2.id = o3), _2.tvf = b3(v7({}, h4), { correlationId: u4.id }), l3 ? (_2.internal = b3(v7({}, _2.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(t, d3, _2)) : this.client.core.relayer.publish(t, d3, _2).catch((g2) => this.client.logger.error(g2));
      }
      return u4.id;
    }), c2(this, "sendResult", async (e) => {
      const { id: t, topic: s2, result: i3, throwOnFailedPublish: r2, encodeOpts: o3, appLink: a2 } = e, l3 = formatJsonRpcResult(t, i3);
      let p4;
      const h4 = a2 && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const w4 = h4 ? Ee : Ht;
        p4 = await this.client.core.crypto.encode(s2, l3, b3(v7({}, o3 || {}), { encoding: w4 }));
      } catch (w4) {
        throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s2} failed`), w4;
      }
      let u4, d3;
      try {
        u4 = await this.client.core.history.get(s2, t);
        const w4 = u4.request;
        try {
          this.shouldSetTVF(w4.method, w4.params) && (d3 = this.getTVFParams(t, w4.params, i3));
        } catch (m3) {
          this.client.logger.warn("sendResult() -> getTVFParams() failed", m3);
        }
      } catch (w4) {
        throw this.client.logger.error(`sendResult() -> history.get(${s2}, ${t}) failed`), w4;
      }
      if (h4) {
        const w4 = Xc(a2, s2, p4);
        await global.Linking.openURL(w4, this.client.name);
      } else {
        const w4 = u4.request.method, m3 = N[w4].res;
        m3.tvf = b3(v7({}, d3), { correlationId: t }), r2 ? (m3.internal = b3(v7({}, m3.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(s2, p4, m3)) : this.client.core.relayer.publish(s2, p4, m3).catch((f6) => this.client.logger.error(f6));
      }
      await this.client.core.history.resolve(l3);
    }), c2(this, "sendError", async (e) => {
      const { id: t, topic: s2, error: i3, encodeOpts: r2, rpcOpts: o3, appLink: a2 } = e, l3 = formatJsonRpcError(t, i3);
      let p4;
      const h4 = a2 && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const d3 = h4 ? Ee : Ht;
        p4 = await this.client.core.crypto.encode(s2, l3, b3(v7({}, r2 || {}), { encoding: d3 }));
      } catch (d3) {
        throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s2} failed`), d3;
      }
      let u4;
      try {
        u4 = await this.client.core.history.get(s2, t);
      } catch (d3) {
        throw this.client.logger.error(`sendError() -> history.get(${s2}, ${t}) failed`), d3;
      }
      if (h4) {
        const d3 = Xc(a2, s2, p4);
        await global.Linking.openURL(d3, this.client.name);
      } else {
        const d3 = u4.request.method, w4 = o3 || N[d3].res;
        this.client.core.relayer.publish(s2, p4, w4);
      }
      await this.client.core.history.resolve(l3);
    }), c2(this, "cleanup", async () => {
      const e = [], t = [];
      this.client.session.getAll().forEach((s2) => {
        let i3 = false;
        vi(s2.expiry) && (i3 = true), this.client.core.crypto.keychain.has(s2.topic) || (i3 = true), i3 && e.push(s2.topic);
      }), this.client.proposal.getAll().forEach((s2) => {
        vi(s2.expiryTimestamp) && t.push(s2.id);
      }), await Promise.all([...e.map((s2) => this.deleteSession({ topic: s2 })), ...t.map((s2) => this.deleteProposal(s2))]);
    }), c2(this, "onProviderMessageEvent", async (e) => {
      !this.initialized || this.relayMessageCache.length > 0 ? this.relayMessageCache.push(e) : await this.onRelayMessage(e);
    }), c2(this, "onRelayEventRequest", async (e) => {
      this.requestQueue.queue.push(e), await this.processRequestsQueue();
    }), c2(this, "processRequestsQueue", async () => {
      if (this.requestQueue.state === $4.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = $4.active;
        const e = this.requestQueue.queue.shift();
        if (e) try {
          await this.processRequest(e);
        } catch (t) {
          this.client.logger.warn(t);
        }
      }
      this.requestQueue.state = $4.idle;
    }), c2(this, "processRequest", async (e) => {
      const { topic: t, payload: s2, attestation: i3, transportType: r2, encryptedId: o3 } = e, a2 = s2.method;
      if (!this.shouldIgnorePairingRequest({ topic: t, requestMethod: a2 })) switch (a2) {
        case "wc_sessionPropose":
          return await this.onSessionProposeRequest({ topic: t, payload: s2, attestation: i3, encryptedId: o3 });
        case "wc_sessionSettle":
          return await this.onSessionSettleRequest(t, s2);
        case "wc_sessionUpdate":
          return await this.onSessionUpdateRequest(t, s2);
        case "wc_sessionExtend":
          return await this.onSessionExtendRequest(t, s2);
        case "wc_sessionPing":
          return await this.onSessionPingRequest(t, s2);
        case "wc_sessionDelete":
          return await this.onSessionDeleteRequest(t, s2);
        case "wc_sessionRequest":
          return await this.onSessionRequest({ topic: t, payload: s2, attestation: i3, encryptedId: o3, transportType: r2 });
        case "wc_sessionEvent":
          return await this.onSessionEventRequest(t, s2);
        case "wc_sessionAuthenticate":
          return await this.onSessionAuthenticateRequest({ topic: t, payload: s2, attestation: i3, encryptedId: o3, transportType: r2 });
        default:
          return this.client.logger.info(`Unsupported request method ${a2}`);
      }
    }), c2(this, "onRelayEventResponse", async (e) => {
      const { topic: t, payload: s2, transportType: i3 } = e, r2 = (await this.client.core.history.get(t, s2.id)).request.method;
      switch (r2) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(t, s2, i3);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(t, s2);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(t, s2);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(t, s2);
        case "wc_sessionPing":
          return this.onSessionPingResponse(t, s2);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(t, s2);
        case "wc_sessionAuthenticate":
          return this.onSessionAuthenticateResponse(t, s2);
        default:
          return this.client.logger.info(`Unsupported response method ${r2}`);
      }
    }), c2(this, "onRelayEventUnknownPayload", (e) => {
      const { topic: t } = e, { message: s2 } = ht("MISSING_OR_INVALID", `Decoded payload on topic ${t} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(s2);
    }), c2(this, "shouldIgnorePairingRequest", (e) => {
      const { topic: t, requestMethod: s2 } = e, i3 = this.expectedPairingMethodMap.get(t);
      return !i3 || i3.includes(s2) ? false : !!(i3.includes("wc_sessionAuthenticate") && this.client.events.listenerCount("session_authenticate") > 0);
    }), c2(this, "onSessionProposeRequest", async (e) => {
      const { topic: t, payload: s2, attestation: i3, encryptedId: r2 } = e, { params: o3, id: a2 } = s2;
      try {
        const l3 = this.client.core.eventClient.getEvent({ topic: t });
        this.client.events.listenerCount("session_proposal") === 0 && (console.warn("No listener for session_proposal event"), l3?.setError(Y4.proposal_listener_not_found)), this.isValidConnect(v7({}, s2.params));
        const p4 = o3.expiryTimestamp || Ei(N.wc_sessionPropose.req.ttl), h4 = v7({ id: a2, pairingTopic: t, expiryTimestamp: p4 }, o3);
        await this.setProposal(a2, h4);
        const u4 = await this.getVerifyContext({ attestationId: i3, hash: kc(JSON.stringify(s2)), encryptedId: r2, metadata: h4.proposer.metadata });
        l3?.addTrace(G4.emit_session_proposal), this.client.events.emit("session_proposal", { id: a2, params: h4, verifyContext: u4 });
      } catch (l3) {
        await this.sendError({ id: a2, topic: t, error: l3, rpcOpts: N.wc_sessionPropose.autoReject }), this.client.logger.error(l3);
      }
    }), c2(this, "onSessionProposeResponse", async (e, t, s2) => {
      const { id: i3 } = t;
      if (isJsonRpcResult(t)) {
        const { result: r2 } = t;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: r2 });
        const o3 = this.client.proposal.get(i3);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: o3 });
        const a2 = o3.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: a2 });
        const l3 = r2.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: l3 });
        const p4 = await this.client.core.crypto.generateSharedKey(a2, l3);
        this.pendingSessions.set(i3, { sessionTopic: p4, pairingTopic: e, proposalId: i3, publicKey: a2 });
        const h4 = await this.client.core.relayer.subscribe(p4, { transportType: s2 });
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: h4 }), await this.client.core.pairing.activate({ topic: e });
      } else if (isJsonRpcError(t)) {
        await this.client.proposal.delete(i3, Nt("USER_DISCONNECTED"));
        const r2 = xi("session_connect", i3);
        if (this.events.listenerCount(r2) === 0) throw new Error(`emitting ${r2} without any listeners, 954`);
        this.events.emit(r2, { error: t.error });
      }
    }), c2(this, "onSessionSettleRequest", async (e, t) => {
      const { id: s2, params: i3 } = t;
      try {
        this.isValidSessionSettleRequest(i3);
        const { relay: r2, controller: o3, expiry: a2, namespaces: l3, sessionProperties: p4, scopedProperties: h4, sessionConfig: u4 } = t.params, d3 = [...this.pendingSessions.values()].find((f6) => f6.sessionTopic === e);
        if (!d3) return this.client.logger.error(`Pending session not found for topic ${e}`);
        const w4 = this.client.proposal.get(d3.proposalId), m3 = b3(v7(v7(v7({ topic: e, relay: r2, expiry: a2, namespaces: l3, acknowledged: true, pairingTopic: d3.pairingTopic, requiredNamespaces: w4.requiredNamespaces, optionalNamespaces: w4.optionalNamespaces, controller: o3.publicKey, self: { publicKey: d3.publicKey, metadata: this.client.metadata }, peer: { publicKey: o3.publicKey, metadata: o3.metadata } }, p4 && { sessionProperties: p4 }), h4 && { scopedProperties: h4 }), u4 && { sessionConfig: u4 }), { transportType: Q.relay });
        await this.client.session.set(m3.topic, m3), await this.setExpiry(m3.topic, m3.expiry), await this.client.core.pairing.updateMetadata({ topic: d3.pairingTopic, metadata: m3.peer.metadata }), this.client.events.emit("session_connect", { session: m3 }), this.events.emit(xi("session_connect", d3.proposalId), { session: m3 }), this.pendingSessions.delete(d3.proposalId), this.deleteProposal(d3.proposalId, false), this.cleanupDuplicatePairings(m3), await this.sendResult({ id: t.id, topic: e, result: true, throwOnFailedPublish: true });
      } catch (r2) {
        await this.sendError({ id: s2, topic: e, error: r2 }), this.client.logger.error(r2);
      }
    }), c2(this, "onSessionSettleResponse", async (e, t) => {
      const { id: s2 } = t;
      isJsonRpcResult(t) ? (await this.client.session.update(e, { acknowledged: true }), this.events.emit(xi("session_approve", s2), {})) : isJsonRpcError(t) && (await this.client.session.delete(e, Nt("USER_DISCONNECTED")), this.events.emit(xi("session_approve", s2), { error: t.error }));
    }), c2(this, "onSessionUpdateRequest", async (e, t) => {
      const { params: s2, id: i3 } = t;
      try {
        const r2 = `${e}_session_update`, o3 = Ua.get(r2);
        if (o3 && this.isRequestOutOfSync(o3, i3)) {
          this.client.logger.warn(`Discarding out of sync request - ${i3}`), this.sendError({ id: i3, topic: e, error: Nt("INVALID_UPDATE_REQUEST") });
          return;
        }
        this.isValidUpdate(v7({ topic: e }, s2));
        try {
          Ua.set(r2, i3), await this.client.session.update(e, { namespaces: s2.namespaces }), await this.sendResult({ id: i3, topic: e, result: true, throwOnFailedPublish: true });
        } catch (a2) {
          throw Ua.delete(r2), a2;
        }
        this.client.events.emit("session_update", { id: i3, topic: e, params: s2 });
      } catch (r2) {
        await this.sendError({ id: i3, topic: e, error: r2 }), this.client.logger.error(r2);
      }
    }), c2(this, "isRequestOutOfSync", (e, t) => t.toString().slice(0, -3) < e.toString().slice(0, -3)), c2(this, "onSessionUpdateResponse", (e, t) => {
      const { id: s2 } = t, i3 = xi("session_update", s2);
      if (this.events.listenerCount(i3) === 0) throw new Error(`emitting ${i3} without any listeners`);
      isJsonRpcResult(t) ? this.events.emit(xi("session_update", s2), {}) : isJsonRpcError(t) && this.events.emit(xi("session_update", s2), { error: t.error });
    }), c2(this, "onSessionExtendRequest", async (e, t) => {
      const { id: s2 } = t;
      try {
        this.isValidExtend({ topic: e }), await this.setExpiry(e, Ei(J3)), await this.sendResult({ id: s2, topic: e, result: true, throwOnFailedPublish: true }), this.client.events.emit("session_extend", { id: s2, topic: e });
      } catch (i3) {
        await this.sendError({ id: s2, topic: e, error: i3 }), this.client.logger.error(i3);
      }
    }), c2(this, "onSessionExtendResponse", (e, t) => {
      const { id: s2 } = t, i3 = xi("session_extend", s2);
      if (this.events.listenerCount(i3) === 0) throw new Error(`emitting ${i3} without any listeners`);
      isJsonRpcResult(t) ? this.events.emit(xi("session_extend", s2), {}) : isJsonRpcError(t) && this.events.emit(xi("session_extend", s2), { error: t.error });
    }), c2(this, "onSessionPingRequest", async (e, t) => {
      const { id: s2 } = t;
      try {
        this.isValidPing({ topic: e }), await this.sendResult({ id: s2, topic: e, result: true, throwOnFailedPublish: true }), this.client.events.emit("session_ping", { id: s2, topic: e });
      } catch (i3) {
        await this.sendError({ id: s2, topic: e, error: i3 }), this.client.logger.error(i3);
      }
    }), c2(this, "onSessionPingResponse", (e, t) => {
      const { id: s2 } = t, i3 = xi("session_ping", s2);
      setTimeout(() => {
        if (this.events.listenerCount(i3) === 0) throw new Error(`emitting ${i3} without any listeners 2176`);
        isJsonRpcResult(t) ? this.events.emit(xi("session_ping", s2), {}) : isJsonRpcError(t) && this.events.emit(xi("session_ping", s2), { error: t.error });
      }, 500);
    }), c2(this, "onSessionDeleteRequest", async (e, t) => {
      const { id: s2 } = t;
      try {
        this.isValidDisconnect({ topic: e, reason: t.params }), Promise.all([new Promise((i3) => {
          this.client.core.relayer.once(C3.publish, async () => {
            i3(await this.deleteSession({ topic: e, id: s2 }));
          });
        }), this.sendResult({ id: s2, topic: e, result: true, throwOnFailedPublish: true }), this.cleanupPendingSentRequestsForTopic({ topic: e, error: Nt("USER_DISCONNECTED") })]).catch((i3) => this.client.logger.error(i3));
      } catch (i3) {
        this.client.logger.error(i3);
      }
    }), c2(this, "onSessionRequest", async (e) => {
      var t, s2, i3;
      const { topic: r2, payload: o3, attestation: a2, encryptedId: l3, transportType: p4 } = e, { id: h4, params: u4 } = o3;
      try {
        await this.isValidRequest(v7({ topic: r2 }, u4));
        const d3 = this.client.session.get(r2), w4 = await this.getVerifyContext({ attestationId: a2, hash: kc(JSON.stringify(formatJsonRpcRequest("wc_sessionRequest", u4, h4))), encryptedId: l3, metadata: d3.peer.metadata, transportType: p4 }), m3 = { id: h4, topic: r2, params: u4, verifyContext: w4 };
        await this.setPendingSessionRequest(m3), p4 === Q.link_mode && (t = d3.peer.metadata.redirect) != null && t.universal && this.client.core.addLinkModeSupportedApp((s2 = d3.peer.metadata.redirect) == null ? void 0 : s2.universal), (i3 = this.client.signConfig) != null && i3.disableRequestQueue ? this.emitSessionRequest(m3) : (this.addSessionRequestToSessionRequestQueue(m3), this.processSessionRequestQueue());
      } catch (d3) {
        await this.sendError({ id: h4, topic: r2, error: d3 }), this.client.logger.error(d3);
      }
    }), c2(this, "onSessionRequestResponse", (e, t) => {
      const { id: s2 } = t, i3 = xi("session_request", s2);
      if (this.events.listenerCount(i3) === 0) throw new Error(`emitting ${i3} without any listeners`);
      isJsonRpcResult(t) ? this.events.emit(xi("session_request", s2), { result: t.result }) : isJsonRpcError(t) && this.events.emit(xi("session_request", s2), { error: t.error });
    }), c2(this, "onSessionEventRequest", async (e, t) => {
      const { id: s2, params: i3 } = t;
      try {
        const r2 = `${e}_session_event_${i3.event.name}`, o3 = Ua.get(r2);
        if (o3 && this.isRequestOutOfSync(o3, s2)) {
          this.client.logger.info(`Discarding out of sync request - ${s2}`);
          return;
        }
        this.isValidEmit(v7({ topic: e }, i3)), this.client.events.emit("session_event", { id: s2, topic: e, params: i3 }), Ua.set(r2, s2);
      } catch (r2) {
        await this.sendError({ id: s2, topic: e, error: r2 }), this.client.logger.error(r2);
      }
    }), c2(this, "onSessionAuthenticateResponse", (e, t) => {
      const { id: s2 } = t;
      this.client.logger.trace({ type: "method", method: "onSessionAuthenticateResponse", topic: e, payload: t }), isJsonRpcResult(t) ? this.events.emit(xi("session_request", s2), { result: t.result }) : isJsonRpcError(t) && this.events.emit(xi("session_request", s2), { error: t.error });
    }), c2(this, "onSessionAuthenticateRequest", async (e) => {
      var t;
      const { topic: s2, payload: i3, attestation: r2, encryptedId: o3, transportType: a2 } = e;
      try {
        const { requester: l3, authPayload: p4, expiryTimestamp: h4 } = i3.params, u4 = await this.getVerifyContext({ attestationId: r2, hash: kc(JSON.stringify(i3)), encryptedId: o3, metadata: l3.metadata, transportType: a2 }), d3 = { requester: l3, pairingTopic: s2, id: i3.id, authPayload: p4, verifyContext: u4, expiryTimestamp: h4 };
        await this.setAuthRequest(i3.id, { request: d3, pairingTopic: s2, transportType: a2 }), a2 === Q.link_mode && (t = l3.metadata.redirect) != null && t.universal && this.client.core.addLinkModeSupportedApp(l3.metadata.redirect.universal), this.client.events.emit("session_authenticate", { topic: s2, params: i3.params, id: i3.id, verifyContext: u4 });
      } catch (l3) {
        this.client.logger.error(l3);
        const p4 = i3.params.requester.publicKey, h4 = await this.client.core.crypto.generateKeyPair(), u4 = this.getAppLinkIfEnabled(i3.params.requester.metadata, a2), d3 = { type: Kt, receiverPublicKey: p4, senderPublicKey: h4 };
        await this.sendError({ id: i3.id, topic: s2, error: l3, encodeOpts: d3, rpcOpts: N.wc_sessionAuthenticate.autoReject, appLink: u4 });
      }
    }), c2(this, "addSessionRequestToSessionRequestQueue", (e) => {
      this.sessionRequestQueue.queue.push(e);
    }), c2(this, "cleanupAfterResponse", (e) => {
      this.deletePendingSessionRequest(e.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = $4.idle, this.processSessionRequestQueue();
      }, (0, import_time3.toMiliseconds)(this.requestQueueDelay));
    }), c2(this, "cleanupPendingSentRequestsForTopic", ({ topic: e, error: t }) => {
      const s2 = this.client.core.history.pending;
      s2.length > 0 && s2.filter((i3) => i3.topic === e && i3.request.method === "wc_sessionRequest").forEach((i3) => {
        const r2 = i3.request.id, o3 = xi("session_request", r2);
        if (this.events.listenerCount(o3) === 0) throw new Error(`emitting ${o3} without any listeners`);
        this.events.emit(xi("session_request", i3.request.id), { error: t });
      });
    }), c2(this, "processSessionRequestQueue", () => {
      if (this.sessionRequestQueue.state === $4.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const e = this.sessionRequestQueue.queue[0];
      if (!e) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        this.sessionRequestQueue.state = $4.active, this.emitSessionRequest(e);
      } catch (t) {
        this.client.logger.error(t);
      }
    }), c2(this, "emitSessionRequest", (e) => {
      this.client.events.emit("session_request", e);
    }), c2(this, "onPairingCreated", (e) => {
      if (e.methods && this.expectedPairingMethodMap.set(e.topic, e.methods), e.active) return;
      const t = this.client.proposal.getAll().find((s2) => s2.pairingTopic === e.topic);
      t && this.onSessionProposeRequest({ topic: e.topic, payload: formatJsonRpcRequest("wc_sessionPropose", b3(v7({}, t), { requiredNamespaces: t.requiredNamespaces, optionalNamespaces: t.optionalNamespaces, relays: t.relays, proposer: t.proposer, sessionProperties: t.sessionProperties, scopedProperties: t.scopedProperties }), t.id) });
    }), c2(this, "isValidConnect", async (e) => {
      if (!ya(e)) {
        const { message: l3 } = ht("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(e)}`);
        throw new Error(l3);
      }
      const { pairingTopic: t, requiredNamespaces: s2, optionalNamespaces: i3, sessionProperties: r2, scopedProperties: o3, relays: a2 } = e;
      if (Et(t) || await this.isValidPairingTopic(t), !pa(a2, true)) {
        const { message: l3 } = ht("MISSING_OR_INVALID", `connect() relays: ${a2}`);
        throw new Error(l3);
      }
      if (!Et(s2) && xe(s2) !== 0 && this.validateNamespaces(s2, "requiredNamespaces"), !Et(i3) && xe(i3) !== 0 && this.validateNamespaces(i3, "optionalNamespaces"), Et(r2) || this.validateSessionProps(r2, "sessionProperties"), !Et(o3)) {
        this.validateSessionProps(o3, "scopedProperties");
        const l3 = Object.keys(s2 || {}).concat(Object.keys(i3 || {}));
        if (!Object.keys(o3).every((p4) => l3.includes(p4))) throw new Error(`Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(o3)}, required/optional namespaces: ${JSON.stringify(l3)}`);
      }
    }), c2(this, "validateNamespaces", (e, t) => {
      const s2 = ha(e, "connect()", t);
      if (s2) throw new Error(s2.message);
    }), c2(this, "isValidApprove", async (e) => {
      if (!ya(e)) throw new Error(ht("MISSING_OR_INVALID", `approve() params: ${e}`).message);
      const { id: t, namespaces: s2, relayProtocol: i3, sessionProperties: r2, scopedProperties: o3 } = e;
      this.checkRecentlyDeleted(t), await this.isValidProposalId(t);
      const a2 = this.client.proposal.get(t), l3 = Bo(s2, "approve()");
      if (l3) throw new Error(l3.message);
      const p4 = No(a2.requiredNamespaces, s2, "approve()");
      if (p4) throw new Error(p4.message);
      if (!nt(i3, true)) {
        const { message: h4 } = ht("MISSING_OR_INVALID", `approve() relayProtocol: ${i3}`);
        throw new Error(h4);
      }
      if (Et(r2) || this.validateSessionProps(r2, "sessionProperties"), !Et(o3)) {
        this.validateSessionProps(o3, "scopedProperties");
        const h4 = new Set(Object.keys(s2));
        if (!Object.keys(o3).every((u4) => h4.has(u4))) throw new Error(`Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(o3)}, approved namespaces: ${Array.from(h4).join(", ")}`);
      }
    }), c2(this, "isValidReject", async (e) => {
      if (!ya(e)) {
        const { message: i3 } = ht("MISSING_OR_INVALID", `reject() params: ${e}`);
        throw new Error(i3);
      }
      const { id: t, reason: s2 } = e;
      if (this.checkRecentlyDeleted(t), await this.isValidProposalId(t), !ma(s2)) {
        const { message: i3 } = ht("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(s2)}`);
        throw new Error(i3);
      }
    }), c2(this, "isValidSessionSettleRequest", (e) => {
      if (!ya(e)) {
        const { message: l3 } = ht("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${e}`);
        throw new Error(l3);
      }
      const { relay: t, controller: s2, namespaces: i3, expiry: r2 } = e;
      if (!Io(t)) {
        const { message: l3 } = ht("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(l3);
      }
      const o3 = da(s2, "onSessionSettleRequest()");
      if (o3) throw new Error(o3.message);
      const a2 = Bo(i3, "onSessionSettleRequest()");
      if (a2) throw new Error(a2.message);
      if (vi(r2)) {
        const { message: l3 } = ht("EXPIRED", "onSessionSettleRequest()");
        throw new Error(l3);
      }
    }), c2(this, "isValidUpdate", async (e) => {
      if (!ya(e)) {
        const { message: a2 } = ht("MISSING_OR_INVALID", `update() params: ${e}`);
        throw new Error(a2);
      }
      const { topic: t, namespaces: s2 } = e;
      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
      const i3 = this.client.session.get(t), r2 = Bo(s2, "update()");
      if (r2) throw new Error(r2.message);
      const o3 = No(i3.requiredNamespaces, s2, "update()");
      if (o3) throw new Error(o3.message);
    }), c2(this, "isValidExtend", async (e) => {
      if (!ya(e)) {
        const { message: s2 } = ht("MISSING_OR_INVALID", `extend() params: ${e}`);
        throw new Error(s2);
      }
      const { topic: t } = e;
      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
    }), c2(this, "isValidRequest", async (e) => {
      if (!ya(e)) {
        const { message: a2 } = ht("MISSING_OR_INVALID", `request() params: ${e}`);
        throw new Error(a2);
      }
      const { topic: t, request: s2, chainId: i3, expiry: r2 } = e;
      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
      const { namespaces: o3 } = this.client.session.get(t);
      if (!va(o3, i3)) {
        const { message: a2 } = ht("MISSING_OR_INVALID", `request() chainId: ${i3}`);
        throw new Error(a2);
      }
      if (!wa(s2)) {
        const { message: a2 } = ht("MISSING_OR_INVALID", `request() ${JSON.stringify(s2)}`);
        throw new Error(a2);
      }
      if (!xa(o3, i3, s2.method)) {
        const { message: a2 } = ht("MISSING_OR_INVALID", `request() method: ${s2.method}`);
        throw new Error(a2);
      }
      if (r2 && !Ba(r2, _e3)) {
        const { message: a2 } = ht("MISSING_OR_INVALID", `request() expiry: ${r2}. Expiry must be a number (in seconds) between ${_e3.min} and ${_e3.max}`);
        throw new Error(a2);
      }
    }), c2(this, "isValidRespond", async (e) => {
      var t;
      if (!ya(e)) {
        const { message: r2 } = ht("MISSING_OR_INVALID", `respond() params: ${e}`);
        throw new Error(r2);
      }
      const { topic: s2, response: i3 } = e;
      try {
        await this.isValidSessionTopic(s2);
      } catch (r2) {
        throw (t = e?.response) != null && t.id && this.cleanupAfterResponse(e), r2;
      }
      if (!ba(i3)) {
        const { message: r2 } = ht("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(i3)}`);
        throw new Error(r2);
      }
    }), c2(this, "isValidPing", async (e) => {
      if (!ya(e)) {
        const { message: s2 } = ht("MISSING_OR_INVALID", `ping() params: ${e}`);
        throw new Error(s2);
      }
      const { topic: t } = e;
      await this.isValidSessionOrPairingTopic(t);
    }), c2(this, "isValidEmit", async (e) => {
      if (!ya(e)) {
        const { message: o3 } = ht("MISSING_OR_INVALID", `emit() params: ${e}`);
        throw new Error(o3);
      }
      const { topic: t, event: s2, chainId: i3 } = e;
      await this.isValidSessionTopic(t);
      const { namespaces: r2 } = this.client.session.get(t);
      if (!va(r2, i3)) {
        const { message: o3 } = ht("MISSING_OR_INVALID", `emit() chainId: ${i3}`);
        throw new Error(o3);
      }
      if (!Ea(s2)) {
        const { message: o3 } = ht("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s2)}`);
        throw new Error(o3);
      }
      if (!Sa(r2, i3, s2.name)) {
        const { message: o3 } = ht("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s2)}`);
        throw new Error(o3);
      }
    }), c2(this, "isValidDisconnect", async (e) => {
      if (!ya(e)) {
        const { message: s2 } = ht("MISSING_OR_INVALID", `disconnect() params: ${e}`);
        throw new Error(s2);
      }
      const { topic: t } = e;
      await this.isValidSessionOrPairingTopic(t);
    }), c2(this, "isValidAuthenticate", (e) => {
      const { chains: t, uri: s2, domain: i3, nonce: r2 } = e;
      if (!Array.isArray(t) || t.length === 0) throw new Error("chains is required and must be a non-empty array");
      if (!nt(s2, false)) throw new Error("uri is required parameter");
      if (!nt(i3, false)) throw new Error("domain is required parameter");
      if (!nt(r2, false)) throw new Error("nonce is required parameter");
      if ([...new Set(t.map((a2) => Ie(a2).namespace))].length > 1) throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");
      const { namespace: o3 } = Ie(t[0]);
      if (o3 !== "eip155") throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.");
    }), c2(this, "getVerifyContext", async (e) => {
      const { attestationId: t, hash: s2, encryptedId: i3, metadata: r2, transportType: o3 } = e, a2 = { verified: { verifyUrl: r2.verifyUrl || ue2, validation: "UNKNOWN", origin: r2.url || "" } };
      try {
        if (o3 === Q.link_mode) {
          const p4 = this.getAppLinkIfEnabled(r2, o3);
          return a2.verified.validation = p4 && new URL(p4).origin === new URL(r2.url).origin ? "VALID" : "INVALID", a2;
        }
        const l3 = await this.client.core.verify.resolve({ attestationId: t, hash: s2, encryptedId: i3, verifyUrl: r2.verifyUrl });
        l3 && (a2.verified.origin = l3.origin, a2.verified.isScam = l3.isScam, a2.verified.validation = l3.origin === new URL(r2.url).origin ? "VALID" : "INVALID");
      } catch (l3) {
        this.client.logger.warn(l3);
      }
      return this.client.logger.debug(`Verify context: ${JSON.stringify(a2)}`), a2;
    }), c2(this, "validateSessionProps", (e, t) => {
      Object.values(e).forEach((s2, i3) => {
        if (s2 == null) {
          const { message: r2 } = ht("MISSING_OR_INVALID", `${t} must contain an existing value for each key. Received: ${s2} for key ${Object.keys(e)[i3]}`);
          throw new Error(r2);
        }
      });
    }), c2(this, "getPendingAuthRequest", (e) => {
      const t = this.client.auth.requests.get(e);
      return typeof t == "object" ? t : void 0;
    }), c2(this, "addToRecentlyDeleted", (e, t) => {
      if (this.recentlyDeletedMap.set(e, t), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {
        let s2 = 0;
        const i3 = this.recentlyDeletedLimit / 2;
        for (const r2 of this.recentlyDeletedMap.keys()) {
          if (s2++ >= i3) break;
          this.recentlyDeletedMap.delete(r2);
        }
      }
    }), c2(this, "checkRecentlyDeleted", (e) => {
      const t = this.recentlyDeletedMap.get(e);
      if (t) {
        const { message: s2 } = ht("MISSING_OR_INVALID", `Record was recently deleted - ${t}: ${e}`);
        throw new Error(s2);
      }
    }), c2(this, "isLinkModeEnabled", (e, t) => {
      var s2, i3, r2, o3, a2, l3, p4, h4, u4;
      return !e || t !== Q.link_mode ? false : ((i3 = (s2 = this.client.metadata) == null ? void 0 : s2.redirect) == null ? void 0 : i3.linkMode) === true && ((o3 = (r2 = this.client.metadata) == null ? void 0 : r2.redirect) == null ? void 0 : o3.universal) !== void 0 && ((l3 = (a2 = this.client.metadata) == null ? void 0 : a2.redirect) == null ? void 0 : l3.universal) !== "" && ((p4 = e?.redirect) == null ? void 0 : p4.universal) !== void 0 && ((h4 = e?.redirect) == null ? void 0 : h4.universal) !== "" && ((u4 = e?.redirect) == null ? void 0 : u4.linkMode) === true && this.client.core.linkModeSupportedApps.includes(e.redirect.universal) && typeof (global == null ? void 0 : global.Linking) < "u";
    }), c2(this, "getAppLinkIfEnabled", (e, t) => {
      var s2;
      return this.isLinkModeEnabled(e, t) ? (s2 = e?.redirect) == null ? void 0 : s2.universal : void 0;
    }), c2(this, "handleLinkModeMessage", ({ url: e }) => {
      if (!e || !e.includes("wc_ev") || !e.includes("topic")) return;
      const t = Ai(e, "topic") || "", s2 = decodeURIComponent(Ai(e, "wc_ev") || ""), i3 = this.client.session.keys.includes(t);
      i3 && this.client.session.update(t, { transportType: Q.link_mode }), this.client.core.dispatchEnvelope({ topic: t, message: s2, sessionExists: i3 });
    }), c2(this, "registerLinkModeListeners", async () => {
      var e;
      if (Ii() || pt() && (e = this.client.metadata.redirect) != null && e.linkMode) {
        const t = global == null ? void 0 : global.Linking;
        if (typeof t < "u") {
          t.addEventListener("url", this.handleLinkModeMessage, this.client.name);
          const s2 = await t.getInitialURL();
          s2 && setTimeout(() => {
            this.handleLinkModeMessage({ url: s2 });
          }, 50);
        }
      }
    }), c2(this, "shouldSetTVF", (e, t) => {
      if (!t || e !== "wc_sessionRequest") return false;
      const { request: s2 } = t;
      return Object.keys(Ue2).includes(s2.method);
    }), c2(this, "getTVFParams", (e, t, s2) => {
      var i3, r2;
      try {
        const o3 = t.request.method, a2 = this.extractTxHashesFromResult(o3, s2);
        return b3(v7({ correlationId: e, rpcMethods: [o3], chainId: t.chainId }, this.isValidContractData(t.request.params) && { contractAddresses: [(r2 = (i3 = t.request.params) == null ? void 0 : i3[0]) == null ? void 0 : r2.to] }), { txHashes: a2 });
      } catch (o3) {
        this.client.logger.warn("Error getting TVF params", o3);
      }
      return {};
    }), c2(this, "isValidContractData", (e) => {
      var t;
      if (!e) return false;
      try {
        const s2 = e?.data || ((t = e?.[0]) == null ? void 0 : t.data);
        if (!s2.startsWith("0x")) return false;
        const i3 = s2.slice(2);
        return /^[0-9a-fA-F]*$/.test(i3) ? i3.length % 2 === 0 : false;
      } catch {
      }
      return false;
    }), c2(this, "extractTxHashesFromResult", (e, t) => {
      try {
        const s2 = Ue2[e];
        if (typeof t == "string") return [t];
        const i3 = t[s2.key];
        if (oe(i3)) return e === "solana_signAllTransactions" ? i3.map((r2) => Ji(r2)) : i3;
        if (typeof i3 == "string") return [i3];
      } catch (s2) {
        this.client.logger.warn("Error extracting tx hashes from result", s2);
      }
      return [];
    });
  }
  async processPendingMessageEvents() {
    try {
      const n2 = this.client.session.keys, e = this.client.core.relayer.messages.getWithoutAck(n2);
      for (const [t, s2] of Object.entries(e)) for (const i3 of s2) try {
        await this.onProviderMessageEvent({ topic: t, message: i3, publishedAt: Date.now() });
      } catch {
        this.client.logger.warn(`Error processing pending message event for topic: ${t}, message: ${i3}`);
      }
    } catch (n2) {
      this.client.logger.warn("processPendingMessageEvents failed", n2);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: n2 } = ht("NOT_INITIALIZED", this.name);
      throw new Error(n2);
    }
  }
  async confirmOnlineStateOrThrow() {
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(C3.message, (n2) => {
      this.onProviderMessageEvent(n2);
    });
  }
  async onRelayMessage(n2) {
    const { topic: e, message: t, attestation: s2, transportType: i3 } = n2, { publicKey: r2 } = this.client.auth.authKeys.keys.includes(ce2) ? this.client.auth.authKeys.get(ce2) : { responseTopic: void 0, publicKey: void 0 };
    try {
      const o3 = await this.client.core.crypto.decode(e, t, { receiverPublicKey: r2, encoding: i3 === Q.link_mode ? Ee : Ht });
      isJsonRpcRequest(o3) ? (this.client.core.history.set(e, o3), await this.onRelayEventRequest({ topic: e, payload: o3, attestation: s2, transportType: i3, encryptedId: kc(t) })) : isJsonRpcResponse(o3) ? (await this.client.core.history.resolve(o3), await this.onRelayEventResponse({ topic: e, payload: o3, transportType: i3 }), this.client.core.history.delete(e, o3.id)) : await this.onRelayEventUnknownPayload({ topic: e, payload: o3, transportType: i3 }), await this.client.core.relayer.messages.ack(e, t);
    } catch (o3) {
      this.client.logger.error(o3);
    }
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(M3.expired, async (n2) => {
      const { topic: e, id: t } = bi(n2.target);
      if (t && this.client.pendingRequest.keys.includes(t)) return await this.deletePendingSessionRequest(t, ht("EXPIRED"), true);
      if (t && this.client.auth.requests.keys.includes(t)) return await this.deletePendingAuthRequest(t, ht("EXPIRED"), true);
      e ? this.client.session.keys.includes(e) && (await this.deleteSession({ topic: e, expirerHasDeleted: true }), this.client.events.emit("session_expire", { topic: e })) : t && (await this.deleteProposal(t, true), this.client.events.emit("proposal_expire", { id: t }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(se2.create, (n2) => this.onPairingCreated(n2)), this.client.core.pairing.events.on(se2.delete, (n2) => {
      this.addToRecentlyDeleted(n2.topic, "pairing");
    });
  }
  isValidPairingTopic(n2) {
    if (!nt(n2, false)) {
      const { message: e } = ht("MISSING_OR_INVALID", `pairing topic should be a string: ${n2}`);
      throw new Error(e);
    }
    if (!this.client.core.pairing.pairings.keys.includes(n2)) {
      const { message: e } = ht("NO_MATCHING_KEY", `pairing topic doesn't exist: ${n2}`);
      throw new Error(e);
    }
    if (vi(this.client.core.pairing.pairings.get(n2).expiry)) {
      const { message: e } = ht("EXPIRED", `pairing topic: ${n2}`);
      throw new Error(e);
    }
  }
  async isValidSessionTopic(n2) {
    if (!nt(n2, false)) {
      const { message: e } = ht("MISSING_OR_INVALID", `session topic should be a string: ${n2}`);
      throw new Error(e);
    }
    if (this.checkRecentlyDeleted(n2), !this.client.session.keys.includes(n2)) {
      const { message: e } = ht("NO_MATCHING_KEY", `session topic doesn't exist: ${n2}`);
      throw new Error(e);
    }
    if (vi(this.client.session.get(n2).expiry)) {
      await this.deleteSession({ topic: n2 });
      const { message: e } = ht("EXPIRED", `session topic: ${n2}`);
      throw new Error(e);
    }
    if (!this.client.core.crypto.keychain.has(n2)) {
      const { message: e } = ht("MISSING_OR_INVALID", `session topic does not exist in keychain: ${n2}`);
      throw await this.deleteSession({ topic: n2 }), new Error(e);
    }
  }
  async isValidSessionOrPairingTopic(n2) {
    if (this.checkRecentlyDeleted(n2), this.client.session.keys.includes(n2)) await this.isValidSessionTopic(n2);
    else if (this.client.core.pairing.pairings.keys.includes(n2)) this.isValidPairingTopic(n2);
    else if (nt(n2, false)) {
      const { message: e } = ht("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${n2}`);
      throw new Error(e);
    } else {
      const { message: e } = ht("MISSING_OR_INVALID", `session or pairing topic should be a string: ${n2}`);
      throw new Error(e);
    }
  }
  async isValidProposalId(n2) {
    if (!ga(n2)) {
      const { message: e } = ht("MISSING_OR_INVALID", `proposal id should be a number: ${n2}`);
      throw new Error(e);
    }
    if (!this.client.proposal.keys.includes(n2)) {
      const { message: e } = ht("NO_MATCHING_KEY", `proposal id doesn't exist: ${n2}`);
      throw new Error(e);
    }
    if (vi(this.client.proposal.get(n2).expiryTimestamp)) {
      await this.deleteProposal(n2);
      const { message: e } = ht("EXPIRED", `proposal id: ${n2}`);
      throw new Error(e);
    }
  }
};
var Ns2 = class extends zi2 {
  constructor(n2, e) {
    super(n2, e, pt2, we2), this.core = n2, this.logger = e;
  }
};
var St3 = class extends zi2 {
  constructor(n2, e) {
    super(n2, e, ht2, we2), this.core = n2, this.logger = e;
  }
};
var Os2 = class extends zi2 {
  constructor(n2, e) {
    super(n2, e, ut2, we2, (t) => t.id), this.core = n2, this.logger = e;
  }
};
var bs2 = class extends zi2 {
  constructor(n2, e) {
    super(n2, e, mt2, ae, () => ce2), this.core = n2, this.logger = e;
  }
};
var As2 = class extends zi2 {
  constructor(n2, e) {
    super(n2, e, _t2, ae), this.core = n2, this.logger = e;
  }
};
var xs2 = class extends zi2 {
  constructor(n2, e) {
    super(n2, e, Et3, ae, (t) => t.id), this.core = n2, this.logger = e;
  }
};
var Cs2 = Object.defineProperty;
var Vs3 = (S3, n2, e) => n2 in S3 ? Cs2(S3, n2, { enumerable: true, configurable: true, writable: true, value: e }) : S3[n2] = e;
var Ge3 = (S3, n2, e) => Vs3(S3, typeof n2 != "symbol" ? n2 + "" : n2, e);
var Ds2 = class {
  constructor(n2, e) {
    this.core = n2, this.logger = e, Ge3(this, "authKeys"), Ge3(this, "pairingTopics"), Ge3(this, "requests"), this.authKeys = new bs2(this.core, this.logger), this.pairingTopics = new As2(this.core, this.logger), this.requests = new xs2(this.core, this.logger);
  }
  async init() {
    await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init();
  }
};
var Ls2 = Object.defineProperty;
var ks2 = (S3, n2, e) => n2 in S3 ? Ls2(S3, n2, { enumerable: true, configurable: true, writable: true, value: e }) : S3[n2] = e;
var E3 = (S3, n2, e) => ks2(S3, typeof n2 != "symbol" ? n2 + "" : n2, e);
var Ee3 = class _Ee extends J2 {
  constructor(n2) {
    super(n2), E3(this, "protocol", De2), E3(this, "version", Le3), E3(this, "name", me2.name), E3(this, "metadata"), E3(this, "core"), E3(this, "logger"), E3(this, "events", new import_events4.EventEmitter()), E3(this, "engine"), E3(this, "session"), E3(this, "proposal"), E3(this, "pendingRequest"), E3(this, "auth"), E3(this, "signConfig"), E3(this, "on", (t, s2) => this.events.on(t, s2)), E3(this, "once", (t, s2) => this.events.once(t, s2)), E3(this, "off", (t, s2) => this.events.off(t, s2)), E3(this, "removeListener", (t, s2) => this.events.removeListener(t, s2)), E3(this, "removeAllListeners", (t) => this.events.removeAllListeners(t)), E3(this, "connect", async (t) => {
      try {
        return await this.engine.connect(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), E3(this, "pair", async (t) => {
      try {
        return await this.engine.pair(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), E3(this, "approve", async (t) => {
      try {
        return await this.engine.approve(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), E3(this, "reject", async (t) => {
      try {
        return await this.engine.reject(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), E3(this, "update", async (t) => {
      try {
        return await this.engine.update(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), E3(this, "extend", async (t) => {
      try {
        return await this.engine.extend(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), E3(this, "request", async (t) => {
      try {
        return await this.engine.request(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), E3(this, "respond", async (t) => {
      try {
        return await this.engine.respond(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), E3(this, "ping", async (t) => {
      try {
        return await this.engine.ping(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), E3(this, "emit", async (t) => {
      try {
        return await this.engine.emit(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), E3(this, "disconnect", async (t) => {
      try {
        return await this.engine.disconnect(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), E3(this, "find", (t) => {
      try {
        return this.engine.find(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), E3(this, "getPendingSessionRequests", () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }), E3(this, "authenticate", async (t, s2) => {
      try {
        return await this.engine.authenticate(t, s2);
      } catch (i3) {
        throw this.logger.error(i3.message), i3;
      }
    }), E3(this, "formatAuthMessage", (t) => {
      try {
        return this.engine.formatAuthMessage(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), E3(this, "approveSessionAuthenticate", async (t) => {
      try {
        return await this.engine.approveSessionAuthenticate(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), E3(this, "rejectSessionAuthenticate", async (t) => {
      try {
        return await this.engine.rejectSessionAuthenticate(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }), this.name = n2?.name || me2.name, this.metadata = oi(n2?.metadata), this.signConfig = n2?.signConfig;
    const e = typeof n2?.logger < "u" && typeof n2?.logger != "string" ? n2.logger : (0, import_pino.default)(k({ level: n2?.logger || me2.logger }));
    this.core = n2?.core || new Jo2(n2), this.logger = E(e, this.name), this.session = new St3(this.core, this.logger), this.proposal = new Ns2(this.core, this.logger), this.pendingRequest = new Os2(this.core, this.logger), this.engine = new Ps2(this), this.auth = new Ds2(this.core, this.logger);
  }
  static async init(n2) {
    const e = new _Ee(n2);
    return await e.initialize(), e;
  }
  get context() {
    return y(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.auth.init(), await this.engine.init(), this.logger.info("SignClient Initialization Success"), setTimeout(() => {
        this.engine.processRelayMessageCache();
      }, (0, import_time3.toMiliseconds)(import_time3.ONE_SECOND));
    } catch (n2) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(n2.message), n2;
    }
  }
};
var $s2 = Ee3;

// node_modules/.pnpm/graz@0.4.2_@cosmjs+amino@0.37.0_@cosmjs+cosmwasm-stargate@0.37.0_bufferutil@4.0.9_utf-8_5d60c0582feff04f176a50b2e50a338d/node_modules/graz/dist/index.mjs
var import_react3 = __toESM(require_react(), 1);
var import_p_map = __toESM(require_p_map(), 1);
var import_cosmwasm_stargate = __toESM(require_build12(), 1);
var import_stargate = __toESM(require_build11(), 1);

// node_modules/.pnpm/zustand@5.0.4_@types+react@19.2.7_react@19.2.1_use-sync-external-store@1.4.0_react@19.2.1_/node_modules/zustand/esm/vanilla/shallow.mjs
var isIterable = (obj) => Symbol.iterator in obj;
var hasIterableEntries = (value) => (
  // HACK: avoid checking entries type
  "entries" in value
);
var compareEntries = (valueA, valueB) => {
  const mapA = valueA instanceof Map ? valueA : new Map(valueA.entries());
  const mapB = valueB instanceof Map ? valueB : new Map(valueB.entries());
  if (mapA.size !== mapB.size) {
    return false;
  }
  for (const [key, value] of mapA) {
    if (!Object.is(value, mapB.get(key))) {
      return false;
    }
  }
  return true;
};
var compareIterables = (valueA, valueB) => {
  const iteratorA = valueA[Symbol.iterator]();
  const iteratorB = valueB[Symbol.iterator]();
  let nextA = iteratorA.next();
  let nextB = iteratorB.next();
  while (!nextA.done && !nextB.done) {
    if (!Object.is(nextA.value, nextB.value)) {
      return false;
    }
    nextA = iteratorA.next();
    nextB = iteratorB.next();
  }
  return !!nextA.done && !!nextB.done;
};
function shallow(valueA, valueB) {
  if (Object.is(valueA, valueB)) {
    return true;
  }
  if (typeof valueA !== "object" || valueA === null || typeof valueB !== "object" || valueB === null) {
    return false;
  }
  if (!isIterable(valueA) || !isIterable(valueB)) {
    return compareEntries(
      { entries: () => Object.entries(valueA) },
      { entries: () => Object.entries(valueB) }
    );
  }
  if (hasIterableEntries(valueA) && hasIterableEntries(valueB)) {
    return compareEntries(valueA, valueB);
  }
  return compareIterables(valueA, valueB);
}

// node_modules/.pnpm/zustand@5.0.4_@types+react@19.2.7_react@19.2.1_use-sync-external-store@1.4.0_react@19.2.1_/node_modules/zustand/esm/react/shallow.mjs
var import_react2 = __toESM(require_react(), 1);
function useShallow(selector) {
  const prev = import_react2.default.useRef(void 0);
  return (state) => {
    const next = selector(state);
    return shallow(prev.current, next) ? prev.current : prev.current = next;
  };
}

// node_modules/.pnpm/graz@0.4.2_@cosmjs+amino@0.37.0_@cosmjs+cosmwasm-stargate@0.37.0_bufferutil@4.0.9_utf-8_5d60c0582feff04f176a50b2e50a338d/node_modules/graz/dist/index.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var R5;
var F5 = Object.defineProperty;
var U3 = (e, n2, t) => ((e2, n3, t2) => n3 in e2 ? F5(e2, n3, { enumerable: true, configurable: true, writable: true, value: t2 }) : e2[n3] = t2)(e, "symbol" != typeof n2 ? n2 + "" : n2, t);
var P4 = "connect-graz";
var M4 = { CONNECT: "connect", DISCONNECT: "disconnect", RECONNECT: "reconnect", GET_WALLET: "getWallet", CLEAR_RECENT_CHAIN: "clearRecentChain", GET_RECENT_CHAIN_IDS: "getRecentChainIds", GET_RECENT_CHAINS: "getRecentChains", GET_CHAIN_INFO: "getChainInfo", GET_CHAIN_INFOS: "getChainInfos", ADD_CHAIN: "addChain", SUGGEST_CHAIN: "suggestChain", SUGGEST_CHAIN_AND_CONNECT: "suggestChainAndConnect", SEND_TOKENS: "sendTokens", SEND_IBC_TOKENS: "sendIbcTokens", INSTANTIATE_CONTRACT: "instantiateContract", EXECUTE_CONTRACT: "executeContract", GET_QUERY_SMART: "getQuerySmart", GET_QUERY_RAW: "getQueryRaw", CREATE_MULTI_CHAIN_ASYNC_FUNCTION: "createMultiChainAsyncFunction", HANDLE_FOCUS: "handleFocus", AUTO_CONNECT_IFRAME: "autoConnectIframe", RECONNECT_EFFECT: "reconnectEffect", SUBSCRIPTION: "subscription" };
var x2 = ((e) => (e.KEPLR = "keplr", e.LEAP = "leap", e.VECTIS = "vectis", e.COSMOSTATION = "cosmostation", e.WALLETCONNECT = "walletconnect", e.WC_KEPLR_MOBILE = "wc_keplr_mobile", e.WC_LEAP_MOBILE = "wc_leap_mobile", e.WC_COSMOSTATION_MOBILE = "wc_cosmostation_mobile", e.WC_CLOT_MOBILE = "wc_clot_mobile", e.METAMASK_SNAP_LEAP = "metamask_snap_leap", e.METAMASK_SNAP_COSMOS = "metamask_snap_cosmos", e.STATION = "station", e.XDEFI = "xdefi", e.COSMIFRAME = "cosmiframe", e.COMPASS = "compass", e.INITIA = "initia", e.OKX = "okx", e.PARA = "para", e.CACTUSCOSMOS = "cactuscosmos", e))(x2 || {});
var K4 = ["keplr", "leap", "vectis", "cosmostation", "walletconnect", "wc_keplr_mobile", "wc_leap_mobile", "wc_cosmostation_mobile", "wc_clot_mobile", "metamask_snap_leap", "station", "xdefi", "metamask_snap_cosmos", "cosmiframe", "compass", "initia", "okx", "para", "cactuscosmos"];
var $5 = { iframeOptions: null, recentChainIds: null, chains: null, chainsConfig: null, paraConfig: null, multiChainFetchConcurrency: 3, walletType: "keplr", walletConnect: { options: null, walletConnectModal: null }, walletDefaultOptions: null, pingInterval: 36e5, loggerConfig: null, _notFoundFn: () => null, _onReconnectFailed: () => null, _reconnect: false, _reconnectConnector: null };
var j2 = { accounts: null, activeChainIds: null, status: "disconnected", lastPing: null, wcSignClients: /* @__PURE__ */ new Map(), paraConnector: null };
var G5 = create2(subscribeWithSelector(persist(() => j2, { name: "graz-session", version: 2, partialize: (e) => ({ accounts: e.accounts, activeChainIds: e.activeChainIds, lastPing: e.lastPing, status: e.status }), storage: createJSONStorage(() => sessionStorage) })));
var H2 = create2(subscribeWithSelector(persist(() => $5, { name: "graz-internal", partialize: (e) => ({ recentChainIds: e.recentChainIds, _reconnect: e._reconnect, _reconnectConnector: e._reconnectConnector, walletType: e.walletType, chains: e.chains }), version: 3 })));
var z3 = ((e) => (e[e.ERROR = 0] = "ERROR", e[e.WARN = 1] = "WARN", e[e.INFO = 2] = "INFO", e[e.DEBUG = 3] = "DEBUG", e[e.TRACE = 4] = "TRACE", e))(z3 || {});
var Q2 = ((e) => (e.WALLET = "wallet", e.TRANSACTION = "transaction", e.QUERY = "query", e.STORE = "store", e.MULTICHAIN = "multichain", e.EVENT = "event", e.PERFORMANCE = "performance", e))(Q2 || {});
var V4 = class {
  constructor(e) {
    U3(this, "level"), U3(this, "categories"), U3(this, "enabled"), U3(this, "timers"), U3(this, "errorReporter"), U3(this, "levelColors", { error: "color: #ff4444; font-weight: bold;", warn: "color: #ff9800; font-weight: bold;", info: "color: #2196f3; font-weight: bold;", debug: "color: #4caf50; font-weight: bold;", trace: "color: #9e9e9e; font-weight: bold;", reset: "color: inherit; font-weight: normal;" }), U3(this, "categoryColors", { wallet: "color: #9c27b0; font-weight: bold;", transaction: "color: #e91e63; font-weight: bold;", query: "color: #00bcd4; font-weight: bold;", store: "color: #ff5722; font-weight: bold;", multichain: "color: #3f51b5; font-weight: bold;", event: "color: #ffc107; font-weight: bold;", performance: "color: #4caf50; font-weight: bold;" }), U3(this, "functionColors", { connect: "color: #00e5ff; font-weight: bold;", disconnect: "color: #00e676; font-weight: bold;", reconnect: "color: #ff6d00; font-weight: bold;", getWallet: "color: #d500f9; font-weight: bold;", clearRecentChain: "color: #ff1744; font-weight: bold;", getRecentChainIds: "color: #f50057; font-weight: bold;", getRecentChains: "color: #ff4081; font-weight: bold;", getChainInfo: "color: #e040fb; font-weight: bold;", getChainInfos: "color: #b388ff; font-weight: bold;", addChain: "color: #8c9eff; font-weight: bold;", suggestChain: "color: #536dfe; font-weight: bold;", suggestChainAndConnect: "color: #448aff; font-weight: bold;", sendTokens: "color: #18ffff; font-weight: bold;", sendIbcTokens: "color: #40c4ff; font-weight: bold;", instantiateContract: "color: #69f0ae; font-weight: bold;", executeContract: "color: #b2ff59; font-weight: bold;", getQuerySmart: "color: #eeff41; font-weight: bold;", getQueryRaw: "color: #ffea00; font-weight: bold;", createMultiChainAsyncFunction: "color: #7c4dff; font-weight: bold;", handleFocus: "color: #ff9100; font-weight: bold;", autoConnectIframe: "color: #ff6e40; font-weight: bold;", reconnectEffect: "color: #a1887f; font-weight: bold;", subscription: "color: #90caf9; font-weight: bold;" }), U3(this, "hookColors", { useConnect: "color: #00e5ff; font-weight: bold;", useDisconnect: "color: #1de9b6; font-weight: bold;", useCheckWallet: "color: #d500f9; font-weight: bold;", useAddChain: "color: #aa00ff; font-weight: bold;", useSuggestChain: "color: #6200ea; font-weight: bold;", useSuggestChainAndConnect: "color: #651fff; font-weight: bold;", useStargateClient: "color: #2979ff; font-weight: bold;", useCosmWasmClient: "color: #2962ff; font-weight: bold;", useStargateSigningClient: "color: #448aff; font-weight: bold;", useCosmWasmSigningClient: "color: #536dfe; font-weight: bold;", useSendTokens: "color: #00e676; font-weight: bold;", useSendIbcTokens: "color: #76ff03; font-weight: bold;", useInstantiateContract: "color: #c6ff00; font-weight: bold;", useExecuteContract: "color: #aeea00; font-weight: bold;" });
    const n2 = "undefined" != typeof window && window.__GRAZ_DEBUG__;
    this.level = e?.level, this.categories = new Set(e?.categories ?? []), this.enabled = e?.enabled ?? n2 ?? false, this.timers = /* @__PURE__ */ new Map(), this.errorReporter = e?.errorReporter;
  }
  formatLog(e, n2, t, o3) {
    const r2 = o3 ? `%c[${o3}]%c ` : "";
    let i3 = "color: #00e5ff; font-weight: bold;";
    o3 && (i3 = this.hookColors[o3] || this.functionColors[o3] || i3);
    const a2 = o3 ? [i3, this.levelColors.reset] : [];
    return [`%c[graz]%c %c${e.toUpperCase()}%c %c[${n2}]%c ${r2}${t}`, "color: #673ab7; font-weight: bold;", this.levelColors.reset, this.levelColors[e] || this.levelColors.reset, this.levelColors.reset, this.categoryColors[n2] || this.levelColors.reset, this.levelColors.reset, ...a2];
  }
  error(e, n2, t) {
    if (!this.shouldLog(0, e)) return;
    const o3 = t?.function || t?.hook, [r2, ...i3] = this.formatLog("error", e, n2, o3), a2 = t ? { ...t } : void 0;
    a2 && (delete a2.function, delete a2.hook), console.error(r2, ...i3, Object.keys(a2 || {}).length > 0 ? a2 : "");
    const s2 = this.errorReporter || "undefined" != typeof window && window.grazErrorReporter;
    if (s2) {
      const o4 = new Error(n2);
      s2.captureException(o4, { category: e, context: t });
    }
  }
  warn(e, n2, t) {
    if (!this.shouldLog(1, e)) return;
    const o3 = t?.function || t?.hook, [r2, ...i3] = this.formatLog("warn", e, n2, o3), a2 = t ? { ...t } : void 0;
    a2 && (delete a2.function, delete a2.hook), console.warn(r2, ...i3, Object.keys(a2 || {}).length > 0 ? a2 : "");
  }
  info(e, n2, t) {
    if (!this.shouldLog(2, e)) return;
    const o3 = t?.function || t?.hook, [r2, ...i3] = this.formatLog("info", e, n2, o3), a2 = t ? { ...t } : void 0;
    a2 && (delete a2.function, delete a2.hook), console.info(r2, ...i3, Object.keys(a2 || {}).length > 0 ? a2 : "");
  }
  debug(e, n2, t) {
    if (!this.shouldLog(3, e)) return;
    const o3 = t?.function || t?.hook, [r2, ...i3] = this.formatLog("debug", e, n2, o3), a2 = t ? { ...t } : void 0;
    a2 && (delete a2.function, delete a2.hook), console.debug(r2, ...i3, Object.keys(a2 || {}).length > 0 ? a2 : "");
  }
  trace(e, n2, t) {
    if (!this.shouldLog(4, e)) return;
    const o3 = t?.function || t?.hook, [r2, ...i3] = this.formatLog("trace", e, n2, o3), a2 = t ? { ...t } : void 0;
    a2 && (delete a2.function, delete a2.hook), console.trace(r2, ...i3, Object.keys(a2 || {}).length > 0 ? a2 : "");
  }
  time(e) {
    this.enabled && "undefined" != typeof performance && this.timers.set(e, performance.now());
  }
  timeEnd(e) {
    if (!this.enabled) return;
    if ("undefined" == typeof performance) return;
    const n2 = this.timers.get(e);
    if (void 0 !== n2) {
      const t = performance.now() - n2, [o3, ...r2] = this.formatLog("debug", "performance", `⏱️  ${e}: ${t.toFixed(2)}ms`);
      console.debug(o3, ...r2), this.timers.delete(e);
    }
  }
  group(e) {
    this.enabled && void 0 !== console.group && console.group(`[graz] ${e}`);
  }
  groupEnd() {
    this.enabled && void 0 !== console.groupEnd && console.groupEnd();
  }
  shouldLog(e, n2) {
    if (!this.enabled) return false;
    if (void 0 !== this.level) {
      if (Array.isArray(this.level)) {
        if (!this.level.includes(e)) return false;
      } else if (e > this.level) return false;
    }
    return !(this.categories.size > 0 && !this.categories.has(n2));
  }
  setLevel(e) {
    this.level = e;
  }
  setCategories(e) {
    this.categories = new Set(e ?? []);
  }
  enable() {
    this.enabled = true;
  }
  disable() {
    this.enabled = false;
  }
};
var Y5 = () => (R5 || (R5 = new V4()), R5);
var X2 = (e) => {
  R5 = new V4(e);
};
var J4 = () => {
  if (void 0 !== window.cactuslink_cosmos) {
    const e = window.cactuslink_cosmos, n2 = (e2) => {
      const n3 = () => {
        be3(), e2();
      };
      return window.addEventListener("accountsChanged", n3), () => {
        window.removeEventListener("accountsChanged", n3);
      };
    };
    return { ...Object.assign(e, { subscription: n2 }), getOfflineSignerAuto: (n3) => Promise.resolve(e.getOfflineSigner(n3)), getOfflineSignerOnlyAmino: (n3) => e.getOfflineSigner(n3), experimentalSuggestChain: async () => {
      throw new Error("Cactus Cosmos does not support experimentalSuggestChain");
    } };
  }
  throw H2.getState()._notFoundFn(), new Error("window.cactuslink_cosmos is not defined");
};
var Z2 = () => {
  if (void 0 !== window.compass) {
    const e = window.compass, n2 = (e2) => {
      const n3 = () => {
        be3(), e2();
      };
      return window.addEventListener("leap_keystorechange", n3), () => {
        window.removeEventListener("leap_keystorechange", n3);
      };
    }, t = (n3) => {
      e.defaultOptions = n3;
    };
    return Object.assign(e, { subscription: n2, setDefaultOptions: t });
  }
  throw H2.getState()._notFoundFn(), new Error("window.leap is not defined");
};
var ee3 = () => {
  const e = H2.getState();
  if (!e.iframeOptions) throw e._notFoundFn(), new Error("no iframe options set");
  if (!B()) throw e._notFoundFn(), new Error("not in iframe");
  if (!e.iframeOptions.allowedIframeParentOrigins.length) throw e._notFoundFn(), new Error("no iframe allowed origins");
  const n2 = new J(e.iframeOptions.allowedIframeParentOrigins).getKeplrClient();
  return { enable: n2.enable.bind(n2), getKey: n2.getKey.bind(n2), getOfflineSigner: n2.getOfflineSigner.bind(n2), getOfflineSignerAuto: n2.getOfflineSignerAuto.bind(n2), getOfflineSignerOnlyAmino: n2.getOfflineSignerOnlyAmino.bind(n2), experimentalSuggestChain: n2.experimentalSuggestChain.bind(n2), signDirect: n2.signDirect.bind(n2), signAmino: n2.signAmino.bind(n2) };
};
var ne2 = {};
var te3 = () => {
  if (void 0 !== window.cosmostation?.providers.keplr) {
    const e = window.cosmostation.providers.keplr, n2 = (e2) => {
      const n3 = () => {
        be3(), e2();
      };
      return window.addEventListener("cosmostation_keystorechange", n3), () => {
        window.removeEventListener("cosmostation_keystorechange", n3);
      };
    }, t = (n3) => {
      e.defaultOptions = n3;
    };
    return Object.assign(e, { subscription: n2, setDefaultOptions: t });
  }
  throw H2.getState()._notFoundFn(), new Error("window.cosmostation.providers.keplr is not defined");
};
var oe2 = () => {
  if (void 0 !== window.initia) {
    const e = window.initia;
    return { enable: async () => {
      await e.getAddress();
    }, getKey: async (n2) => {
      const t = e.getOfflineSigner(n2), [o3] = await t.getAccounts();
      if (!o3) throw new Error("Wallet connection failed");
      const r2 = (() => {
        switch (o3.algo) {
          case "secp256k1":
            return (0, import_amino.rawSecp256k1PubkeyToRawAddress)(o3.pubkey);
          case "ed25519":
            return (0, import_amino.rawEd25519PubkeyToRawAddress)(o3.pubkey);
          default:
            throw new Error("sr25519 public key algorithm is not supported");
        }
      })();
      return { name: (i3 = o3.address, `${i3.slice(0, 6)}...${i3.slice(-6)}`), algo: o3.algo, pubKey: o3.pubkey, bech32Address: o3.address, address: r2, isNanoLedger: false, isKeystone: false };
      var i3;
    }, getOfflineSigner: (n2) => {
      const t = e.getOfflineSigner(n2), o3 = e.getOfflineSignerOnlyAmino(n2);
      return { getAccounts: t.getAccounts.bind(t), signDirect: t.signDirect.bind(t), signAmino: o3.signAmino.bind(o3) };
    }, getOfflineSignerAuto: (n2) => Promise.resolve(e.getOfflineSigner(n2)), getOfflineSignerOnlyAmino: (n2) => e.getOfflineSignerOnlyAmino(n2), experimentalSuggestChain: (n2) => e.requestAddInitiaLayer({ chain_id: n2.chainId, chain_name: n2.chainName, bech32_prefix: "init", bech32_config: n2.bech32Config, slip44: n2.bip44.coinType, logo_URIs: { png: n2.chainSymbolImageUrl }, fees: { fee_tokens: n2.feeCurrencies.map((e2) => ({ denom: e2.coinDenom, amount: e2.coinMinimalDenom, low_gas_price: e2.gasPriceStep?.low, average_gas_price: e2.gasPriceStep?.average, high_gas_price: e2.gasPriceStep?.high })) }, apis: { rpc: [{ address: n2.rpc }], rest: [{ address: n2.rest }] } }), signDirect: (...n2) => {
      const [t, o3, r2] = n2;
      return e.getOfflineSigner(t).signDirect(o3, ((e2) => {
        const { bodyBytes: n3, authInfoBytes: t2, chainId: o4, accountNumber: r3 } = e2;
        if (!(n3 && t2 && o4 && r3)) throw new Error("Invalid sign doc");
        return { bodyBytes: n3, authInfoBytes: t2, chainId: o4, accountNumber: r3 };
      })(r2));
    }, signAmino: (...n2) => {
      const [t, o3, r2] = n2;
      return e.getOfflineSignerOnlyAmino(t).signAmino(o3, r2);
    }, signArbitrary: async (n2, t, o3) => {
      const r2 = e.getOfflineSigner(n2), i3 = (await r2.getAccounts()).find((e2) => e2.address === t);
      if (!i3) throw new Error(`Wallet not connected to account ${t}`);
      const a2 = (() => {
        switch (i3.algo) {
          case "secp256k1":
            return (0, import_amino.encodeSecp256k1Pubkey)(i3.pubkey);
          case "ed25519":
            return (0, import_amino.encodeEd25519Pubkey)(i3.pubkey);
          default:
            throw new Error("sr25519 public key algorithm is not supported");
        }
      })();
      return { signature: await e.signArbitrary(o3), pub_key: { type: "secp256k1" === i3.algo ? import_amino.pubkeyType.secp256k1 : import_amino.pubkeyType.ed25519, value: a2.value } };
    }, subscription: (e2) => {
      const n2 = () => {
        be3(), e2();
      };
      return window.addEventListener("initia_keystorechange", n2), () => {
        window.removeEventListener("initia_keystorechange", n2);
      };
    } };
  }
  throw H2.getState()._notFoundFn(), new Error("window.initia is not defined");
};
var re3 = () => {
  if (void 0 !== window.keplr) {
    const e = window.keplr, n2 = (e2) => {
      const n3 = () => {
        be3(), e2();
      };
      return window.addEventListener("keplr_keystorechange", n3), () => {
        window.removeEventListener("keplr_keystorechange", n3);
      };
    }, t = (n3) => {
      e.defaultOptions = n3;
    };
    return Object.assign(e, { subscription: n2, setDefaultOptions: t });
  }
  throw H2.getState()._notFoundFn(), new Error("window.keplr is not defined");
};
var ie3 = () => {
  if (void 0 !== window.leap) {
    const e = window.leap, n2 = (e2) => {
      const n3 = () => {
        be3(), e2();
      };
      return window.addEventListener("leap_keystorechange", n3), () => {
        window.removeEventListener("leap_keystorechange", n3);
      };
    }, t = (n3) => {
      e.defaultOptions = n3;
    };
    return Object.assign(e, { subscription: n2, setDefaultOptions: t });
  }
  throw H2.getState()._notFoundFn(), new Error("window.leap is not defined");
};
var ae2 = {};
var se3 = () => ((e) => {
  const n2 = window.ethereum;
  if (n2 && e) {
    const t = async () => await n2.request({ method: "wallet_getSnaps" }), o3 = async (n3) => {
      try {
        const o4 = await t();
        return Object.values(o4).find((t2) => t2.id === e.id && (!n3 || t2.version === n3));
      } catch (e2) {
        return;
      }
    }, r2 = async () => {
      await n2.request({ method: "wallet_requestSnaps", params: { [e.id]: e.params || {} } });
    }, i3 = async () => {
      const e2 = await n2.request({ method: "web3_clientVersion" });
      if (!e2.includes("MetaMask")) throw new Error("Metamask is not installed");
      if (void 0 !== window.okxwallet && window.okxwallet.isOkxWallet) throw new Error("You have OKX Wallet installed. Please disable and reload the page to use Metamask Snap.");
      const t2 = e2.split("MetaMask/v")[1]?.split(".")[0];
      if (!(Number(t2) >= 11)) throw new Error("Metamask Snap is not supported in this version");
      return await o3() || await r2(), true;
    }, a2 = async (t2, o4, r3) => {
      const i4 = await n2.request({ method: "wallet_invokeSnap", params: { snapId: e.id, request: { method: "signDirect", params: { chainId: t2, signerAddress: o4, signDoc: r3 } } } }), a3 = r3.accountNumber, s3 = new import_long2.default(a3.low, a3.high, a3.unsigned);
      return { signature: i4.signature, signed: { ...i4.signed, accountNumber: s3.toString(), authInfoBytes: new Uint8Array(Object.values(i4.signed.authInfoBytes)), bodyBytes: new Uint8Array(Object.values(i4.signed.bodyBytes)) } };
    }, s2 = async (t2, o4, r3) => await n2.request({ method: "wallet_invokeSnap", params: { snapId: e.id, request: { method: "signAmino", params: { chainId: t2, signerAddress: o4, signDoc: r3 } } } }), c3 = async (t2) => {
      if (void 0 !== ae2[t2]) return ae2[t2];
      const o4 = await n2.request({ method: "wallet_invokeSnap", params: { snapId: e.id, request: { method: "getKey", params: { chainId: t2 } } } });
      if (!o4) throw new Error("No response from Metamask");
      return o4.pubKey = Uint8Array.from(Object.values(o4.pubkey)), delete o4.pubkey, ae2[t2] = o4, ae2[t2];
    }, l3 = async (e2) => {
      const n3 = await c3(e2);
      return { address: n3.bech32Address, algo: n3.algo, pubkey: n3.pubKey };
    }, d3 = async (...e2) => {
      const [n3, t2, o4, r3] = e2;
      return await s2(n3, t2, o4);
    }, u4 = async (...e2) => {
      const [n3, t2, o4] = e2, r3 = { ...o4, accountNumber: import_long2.default.fromString(o4.accountNumber?.toString() || "0"), authInfoBytes: o4.authInfoBytes, bodyBytes: o4.bodyBytes };
      return await a2(n3, t2, r3);
    }, g2 = (e2) => ({ getAccounts: async () => [await l3(e2)], signAmino: (n3, t2) => d3(e2, n3, t2) });
    return { enable: async (e2) => {
      await o3() || await r2();
    }, experimentalSuggestChain: async (...t2) => {
      await i3(), await n2.request({ method: "wallet_invokeSnap", params: { snapId: e.id, request: { method: "suggestChain", params: { chainInfo: t2[0] } } } });
    }, getKey: c3, getOfflineSigner: (e2) => ({ getAccounts: async () => [await l3(e2)], signDirect: (n3, t2) => u4(e2, n3, t2), signAmino: (n3, t2) => d3(e2, n3, t2) }), getOfflineSignerAuto: async (e2) => g2(e2), getOfflineSignerOnlyAmino: g2, init: i3, signAmino: d3, signDirect: u4 };
  }
  throw H2.getState()._notFoundFn(), new Error("window.ethereum is not defined");
})({ id: "npm:@leapwallet/metamask-cosmos-snap" });
var ce3 = () => {
  if (void 0 !== window.okxwallet?.keplr) {
    const e = window.okxwallet.keplr, n2 = (e2) => {
      const n3 = () => {
        be3(), e2();
      };
      return window.okxwallet?.on("accountsChanged", n3), () => {
        window.okxwallet?.removeListener("accountsChanged", n3);
      };
    }, t = (n3) => {
      e.defaultOptions = n3;
    };
    return Object.assign(e, { subscription: n2, setDefaultOptions: t });
  }
  throw H2.getState()._notFoundFn(), new Error("window.okxwallet.keplr is not defined");
};
var le3 = null;
var de3 = () => {
  const e = () => {
    const e2 = G5.getState().paraConnector;
    if (!e2) throw new Error("Para connector not initialized. Call connect() first or check paraConfig in GrazProvider.");
    return e2;
  }, n2 = H2.getState().paraConfig;
  if (!n2?.paraWeb) throw new Error("Missing Para config. Provide paraConfig with 'paraWeb' to GrazProvider.");
  return { enable: async (e2) => {
    const t = Array.isArray(e2) ? e2 : [e2];
    try {
      const e3 = await (le3 || (le3 = (async () => {
        const e4 = G5.getState().paraConnector;
        if (e4) return e4;
        if (!n2.connectorClass) throw new Error("Para connector class not provided. Provide 'connectorClass' in paraConfig to use Para wallet.");
        try {
          const e5 = H2.getState().chains, t2 = new n2.connectorClass(n2, e5);
          if (!t2) throw new Error("Para connector initialization failed. Check config and dependencies.");
          return G5.setState((e6) => ({ ...e6, paraConnector: t2 })), t2;
        } catch (e5) {
          throw le3 = null, new Error(`Para connector init failed: ${e5?.message || "Unknown error"}. Check ParaConfig and connectorClass.`);
        }
      })()));
      G5.setState({ paraConnector: e3, status: "connecting" }), await e3.enable(t);
      const o3 = Object.fromEntries(await Promise.all(t.map(async (n3) => [n3, await e3.getKey(n3)])));
      G5.setState((e4) => ({ accounts: { ...e4.accounts || {}, ...o3 }, activeChainIds: Array.from(/* @__PURE__ */ new Set([...e4.activeChainIds || [], ...t])), status: "connected" })), H2.setState((e4) => ({ recentChainIds: Array.from(/* @__PURE__ */ new Set([...e4.recentChainIds || [], ...t])), walletType: "para", _reconnect: false, _reconnectConnector: "para" }));
    } catch (e3) {
      throw G5.setState({ paraConnector: null, status: "disconnected" }), new Error("Para enable failed" + (e3 instanceof Error ? `: ${e3.message}` : ""));
    }
  }, disable: async () => {
    const e2 = G5.getState().paraConnector;
    if (e2) try {
      await e2.disconnect(), await e2.getParaWebClient().logout();
    } catch (e3) {
      throw new Error("Para disconnect failed" + (e3?.message ? `: ${e3.message}` : ". Wallet may already be disconnected."));
    } finally {
      G5.setState({ paraConnector: null, status: "disconnected" });
    }
    else G5.setState({ paraConnector: null, status: "disconnected" });
  }, getKey: async (n3) => {
    try {
      return await e().getKey(n3);
    } catch (e2) {
      throw new Error(`Failed to get key${e2?.message ? `: ${e2.message}` : ""}. Check chain connection and Cosmos API key settings at developer.getpara.com.`);
    }
  }, getOfflineSigner: (n3) => {
    try {
      return e().getOfflineSigner(n3);
    } catch (e2) {
      throw new Error(`Failed to get offline signer${e2?.message ? `: ${e2.message}` : ""}. Check Para auth and Cosmos support in developer portal.`);
    }
  }, getOfflineSignerOnlyAmino: (n3) => {
    try {
      return e().getOfflineSignerOnlyAmino(n3);
    } catch (e2) {
      throw new Error(`Failed to get Amino signer${e2?.message ? `: ${e2.message}` : ""}. Check Para auth and Cosmos support in developer portal.`);
    }
  }, getOfflineSignerAuto: (n3) => {
    try {
      return e().getOfflineSignerAuto(n3);
    } catch (e2) {
      throw new Error(`Failed to get auto signer${e2?.message ? `: ${e2.message}` : ""}. Check Para auth and Cosmos support in developer portal.`);
    }
  }, signAmino: async (n3, t, o3, r2) => {
    try {
      return await e().signAmino(n3, t, o3, r2);
    } catch (e2) {
      throw new Error(`Amino signing failed${e2?.message ? `: ${e2.message}` : ""}. User rejected or invalid transaction/signer.`);
    }
  }, signDirect: async (n3, t, o3, r2) => {
    try {
      return await e().signDirect(n3, t, o3, r2);
    } catch (e2) {
      throw new Error(`Direct signing failed${e2?.message ? `: ${e2.message}` : ""}. User rejected or invalid transaction/signer.`);
    }
  }, signArbitrary: async (n3, t, o3) => {
    try {
      return await e().signArbitrary(n3, t, o3);
    } catch (e2) {
      throw new Error(`Arbitrary signing failed${e2?.message ? `: ${e2.message}` : ""}. User rejected or feature not supported.`);
    }
  }, experimentalSuggestChain: async () => {
    throw new Error("Chain suggestion not supported. Configure chains in Para wallet settings.");
  } };
};
var ue3 = () => {
  if (void 0 !== window.station?.keplr) {
    const e = window.station.keplr;
    return { subscription: (e2) => {
      const n2 = () => {
        be3(), e2();
      };
      return window.addEventListener("station_wallet_change", n2), () => {
        window.removeEventListener("station_wallet_change", n2);
      };
    }, getKey: async (n2) => ({ isKeystone: false, ...await e.getKey(n2) }), getOfflineSigner: (n2) => {
      try {
        const t = e.getOfflineSignerOnlyAmino(n2), o3 = (e2, n3) => {
          throw new Error("signDirect not supported by Station");
        };
        return Object.assign(t, { signDirect: o3 });
      } catch (e2) {
        throw console.error(e2), e2;
      }
    }, experimentalSuggestChain: async (n2) => {
      try {
        if (!n2.bech32Config) throw new Error("Bech32Config is required");
        if (!n2.stakeCurrency) throw new Error("StakeCurrency is required");
        const t = Object.assign(n2, { bech32Config: n2.bech32Config, chainSymbolImageUrl: n2.chainSymbolImageUrl || "", stakeCurrency: { coinDecimals: n2.stakeCurrency.coinDecimals, coinDenom: n2.stakeCurrency.coinDenom, coinImageUrl: n2.stakeCurrency.coinImageUrl || "", coinMinimalDenom: n2.stakeCurrency.coinMinimalDenom }, currencies: n2.currencies.map((e2) => ({ coinDecimals: e2.coinDecimals, coinDenom: e2.coinDenom, coinImageUrl: e2.coinImageUrl || "", coinMinimalDenom: e2.coinMinimalDenom })), feeCurrencies: n2.feeCurrencies.map((e2) => ({ coinDecimals: e2.coinDecimals, coinDenom: e2.coinDenom, coinImageUrl: e2.coinImageUrl || "", coinMinimalDenom: e2.coinMinimalDenom, gasPriceStep: { average: e2.gasPriceStep?.average || 0, high: e2.gasPriceStep?.high || 0, low: e2.gasPriceStep?.low || 0 } })) });
        await e.experimentalSuggestChain(t);
      } catch (e2) {
        throw console.error(e2), e2;
      }
    }, enable: (n2) => e.enable(n2), disable: (n2) => e.disable(n2), getOfflineSignerAuto: (n2) => e.getOfflineSignerAuto(n2), getOfflineSignerOnlyAmino: (n2) => e.getOfflineSignerOnlyAmino(n2), signDirect: e.signDirect, signAmino: (n2, t, o3, r2) => e.signAmino(n2, t, o3) };
  }
  throw H2.getState()._notFoundFn(), new Error("window.station is not defined");
};
var ge3 = () => {
  if (void 0 !== window.vectis) {
    const e = window.vectis.cosmos;
    return { enable: (n2) => e.enable(n2), getOfflineSigner: (n2) => {
      const t = e.getOfflineSigner(n2);
      return { getAccounts: t.getAccounts, signAmino: t.signAmino, signDirect: async (e2, n3) => {
        const o3 = await t.signDirect(e2, { accountNumber: import_long2.default.fromString(n3.accountNumber.toString() || "", false), authInfoBytes: n3.authInfoBytes, bodyBytes: n3.bodyBytes, chainId: n3.chainId || "" });
        return { signature: o3.signature, signed: { authInfoBytes: o3.signed.authInfoBytes, bodyBytes: o3.signed.bodyBytes, chainId: o3.signed.chainId, accountNumber: BigInt(o3.signed.accountNumber.toString()) } };
      } };
    }, getOfflineSignerAuto: async (n2) => {
      const t = await e.getOfflineSignerAuto(n2);
      return "signAmino" in t ? t : "signDirect" in t ? { getAccounts: t.getAccounts, signDirect: async (e2, n3) => {
        const o3 = await t.signDirect(e2, { accountNumber: import_long2.default.fromString(n3.accountNumber.toString() || "", false), authInfoBytes: n3.authInfoBytes, bodyBytes: n3.bodyBytes, chainId: n3.chainId || "" });
        return { signature: o3.signature, signed: { authInfoBytes: o3.signed.authInfoBytes, bodyBytes: o3.signed.bodyBytes, chainId: o3.signed.chainId, accountNumber: BigInt(o3.signed.accountNumber.toString()) } };
      } } : t;
    }, getKey: async (n2) => {
      const t = await e.getKey(n2);
      return { address: (0, import_encoding.fromBech32)(t.address).data, algo: t.algo, bech32Address: t.address, name: t.name, pubKey: t.pubKey, isKeystone: false, isNanoLedger: t.isNanoLedger };
    }, subscription: (e2) => {
      const n2 = () => {
        be3(), e2();
      };
      return window.addEventListener("vectis_accountChanged", n2), () => {
        window.removeEventListener("vectis_accountChanged", n2);
      };
    }, getOfflineSignerOnlyAmino: (...n2) => {
      const t = n2[0];
      return e.getOfflineSignerAmino(t);
    }, experimentalSuggestChain: async (...n2) => {
      const [t] = n2;
      if (!t.bech32Config) throw new Error("Bech32Config is required");
      if (!t.stakeCurrency) throw new Error("StakeCurrency is required");
      const o3 = { rpcUrl: t.rpc, restUrl: t.rest, prettyName: t.chainName.replace(" ", ""), bech32Prefix: t.bech32Config.bech32PrefixAccAddr, currencies: t.currencies, feeCurrencies: t.feeCurrencies, chainId: t.chainId, chainName: t.chainName, bip44: t.bip44, stakeCurrency: t.stakeCurrency, features: t.features };
      return e.suggestChains([o3]);
    }, signDirect: async (...n2) => {
      const { 1: t, 2: o3 } = n2, r2 = await e.signDirect(t, { bodyBytes: o3.bodyBytes || Uint8Array.from([]), authInfoBytes: o3.authInfoBytes || Uint8Array.from([]), accountNumber: import_long2.default.fromString(o3.accountNumber?.toString() || "", false), chainId: o3.chainId || "" });
      return { signature: r2.signature, signed: { authInfoBytes: r2.signed.authInfoBytes, bodyBytes: r2.signed.bodyBytes, chainId: r2.signed.chainId, accountNumber: BigInt(r2.signed.accountNumber.toString()) } };
    }, signAmino: async (...n2) => {
      const { 1: t, 2: o3 } = n2;
      return e.signAmino(t, o3);
    } };
  }
  throw H2.getState()._notFoundFn(), new Error("window.vectis is not defined");
};
var he3 = () => {
  if ("undefined" != typeof window) {
    const e = navigator.userAgent;
    return !!/android/i.test(e) || !!/iPad|iPhone|iPod/.test(e);
  }
  return false;
};
var fe3 = (e, n2, t = new Error("Promise timed out")) => {
  const o3 = new Promise((e2, o4) => {
    setTimeout(() => {
      o4(t);
    }, n2);
  });
  return Promise.race([e, o3]);
};
var we3 = (e) => {
  if (!H2.getState().walletConnect?.options?.projectId?.trim()) throw new Error("walletConnect.options.projectId is not defined");
  const n2 = e?.walletType || "walletconnect", t = e?.encoding || "base64", o3 = (n3) => {
    if (!e) return;
    const { appUrl: t2, formatNativeUrl: o4 } = e;
    if (he3()) {
      if (he3() && navigator.userAgent.toLowerCase().includes("android")) {
        const e2 = o4(t2.mobile.android, n3, "android");
        window.open(e2, "_self", "noreferrer noopener");
      }
      if (he3() && (navigator.userAgent.toLowerCase().includes("iphone") || navigator.userAgent.toLowerCase().includes("ipad"))) {
        const e2 = o4(t2.mobile.ios, n3, "ios");
        window.open(e2, "_self", "noreferrer noopener");
      }
    }
  }, r2 = () => {
    const { wcSignClients: e2 } = G5.getState();
    if (!e2.get(n2)) throw new Error("walletConnect.signClient is not defined");
    e2.delete(n2), G5.setState({ wcSignClients: e2 }), H2.setState({ _reconnect: false, _reconnectConnector: null, recentChainIds: null });
  }, i3 = async (e2) => {
    const { wcSignClients: t2 } = G5.getState(), o4 = t2.get(n2);
    if (!o4) throw new Error("walletConnect.signClient is not defined");
    if (!e2) throw new Error("No wallet connect session");
    await o4.disconnect({ topic: e2, reason: Nt("USER_DISCONNECTED") }), await s2(o4);
  }, a2 = (e2) => {
    try {
      const { wcSignClients: t2 } = G5.getState(), o4 = t2.get(n2);
      if (!o4) throw new Error("walletConnect.signClient is not defined");
      const r3 = o4.session.getAll(), a3 = r3.at(-1);
      if (!a3) return;
      if (!(1e3 * a3.expiry > Date.now() + 1e3)) throw i3(a3.topic), new Error("invalid session");
      try {
        const n3 = r3.find((n4) => n4.requiredNamespaces.cosmos?.chains?.includes(`cosmos:${e2}`));
        if (!n3) throw new Error("no session");
        return n3;
      } catch (e3) {
        if (!e3.message.toLowerCase().includes("no matching key")) throw e3;
      }
      return a3;
    } catch (e3) {
      if (!e3.message.toLowerCase().includes("no matching key")) throw e3;
    }
  }, s2 = async (e2) => {
    try {
      const n3 = e2.core.pairing.pairings.getAll({ active: false });
      if (!n3.length) return;
      await Promise.all(n3.map(async (n4) => {
        await e2.core.pairing.pairings.delete(n4.topic, { code: 7001, message: "clear pairing" });
      }));
    } catch (e3) {
      if (!e3.message.toLowerCase().includes("no matching key")) throw e3;
    }
  }, c3 = async (t2) => {
    const r3 = "string" == typeof t2 ? [t2] : t2, { wcSignClients: s3, activeChainIds: c4 } = G5.getState(), l4 = s3.get(n2);
    if (!l4) throw new Error("enable walletConnect.signClient is not defined");
    const { walletConnect: u5 } = H2.getState();
    if (!u5?.options?.projectId) throw new Error("walletConnect.options.projectId is not defined");
    const g3 = new WalletConnectModal({ projectId: u5.options.projectId, enableExplorer: false, explorerRecommendedWalletIds: "NONE", ...u5.walletConnectModal }), h5 = ((e2) => {
      try {
        return a2(e2);
      } catch (e3) {
        return;
      }
    })(r3);
    if (!h5) {
      const { uri: n3, approval: t3 } = await fe3(l4.connect({ requiredNamespaces: { cosmos: { methods: ["cosmos_getAccounts", "cosmos_signAmino", "cosmos_signDirect"], chains: r3.map((e2) => `cosmos:${e2}`), events: ["chainChanged", "accountsChanged"] } } }), 15e3, new Error("Connection timeout"));
      if (!n3) throw new Error("No wallet connect uri");
      e ? o3(n3) : await g3.openModal({ uri: n3 });
      const i4 = async (e2) => e2.aborted ? Promise.reject(new Error("User closed wallet connect")) : new Promise((n4, o4) => {
        t3().then((e3) => {
          const t4 = e3.sessionProperties;
          if (!t4) return o4(new Error("No session properties"));
          const r4 = JSON.parse(String(t4.keys));
          if (0 === r4.length) return o4(new Error("No accounts"));
          if (!r4[0]) return o4(new Error("No accounts"));
          const i5 = {};
          return r4.forEach((e4) => {
            i5[e4.chainId] = { address: e4.address, algo: e4.algo, bech32Address: e4.bech32Address, isNanoLedger: e4.isNanoLedger, isKeystone: e4.isKeystone, name: e4.name, pubKey: e4.pubKey };
          }), G5.setState((e4) => ({ accounts: { ...e4.accounts || {}, ...i5 } })), n4(e3);
        }).catch(o4), e2.addEventListener("abort", () => {
          o4(new Error("User closed wallet connect"));
        }, { once: true });
      });
      try {
        const e2 = new AbortController(), n4 = e2.signal;
        g3.subscribeModal((n5) => {
          n5.open || e2.abort();
        }), await i4(n4);
      } catch (e2) {
        if (g3.closeModal(), !e2.message.toLowerCase().includes("no matching key")) return Promise.reject(e2);
      }
      return e || g3.closeModal(), Promise.resolve();
    }
    try {
      await fe3((async () => {
        const e2 = Object.fromEntries(await Promise.all((c4 || r3).map(async (e3) => [e3, await d3(e3)])));
        G5.setState({ accounts: e2 });
      })(), 15e3, new Error("Connection timeout"));
    } catch (e2) {
      if (i3(h5.topic), !e2.message.toLowerCase().includes("no matching key")) throw e2;
    }
  }, l3 = async (e2) => {
    const n3 = await d3(e2);
    return { address: n3.bech32Address, algo: n3.algo, pubkey: n3.pubKey };
  }, d3 = async (e2) => {
    const n3 = a2([e2]);
    if (!n3?.topic) throw new Error("No wallet connect session");
    const o4 = n3.sessionProperties && JSON.parse(String(n3.sessionProperties.keys));
    if (!o4) throw new Error("No wallet connect key");
    if (0 === o4.length) throw new Error("No wallet connect session");
    const r3 = o4.find((n4) => n4.chainId === e2);
    if (!r3) throw new Error(`No wallet connect key for chainId ${e2}`);
    return { ...r3, pubKey: Buffer.from(String(r3.pubKey), t) };
  }, u4 = async (...e2) => {
    const [r3, i4, s3] = e2, { signature: c4, signed: l4 } = await (async (...e3) => {
      const [r4, i5, s4] = e3, { accounts: c5, wcSignClients: l5 } = G5.getState(), d4 = l5.get(n2);
      if (!d4) throw new Error("walletConnect.signClient is not defined");
      if (!c5) throw new Error("account is not defined");
      const u5 = a2([r4])?.topic;
      if (!u5) throw new Error("No wallet connect session");
      if (!s4.bodyBytes) throw new Error("No bodyBytes");
      if (!s4.authInfoBytes) throw new Error("No authInfoBytes");
      return o3(), await d4.request({ topic: u5, chainId: `cosmos:${r4}`, request: { method: "cosmos_signDirect", params: { signerAddress: i5, signDoc: { chainId: s4.chainId, accountNumber: s4.accountNumber?.toString(), bodyBytes: s4.bodyBytes ? Buffer.from(s4.bodyBytes).toString(t) : null, authInfoBytes: s4.authInfoBytes ? Buffer.from(s4.authInfoBytes).toString(t) : null } } } });
    })(r3, i4, s3);
    return { signed: { chainId: l4.chainId ?? "", accountNumber: l4.accountNumber ? BigInt(l4.accountNumber) : BigInt(0), authInfoBytes: l4.authInfoBytes ? new Uint8Array(Buffer.from(l4.authInfoBytes, t)) : new Uint8Array([]), bodyBytes: l4.bodyBytes ? new Uint8Array(Buffer.from(l4.bodyBytes, t)) : new Uint8Array([]) }, signature: c4 };
  }, g2 = async (...e2) => {
    const [t2, r3, i4, s3] = e2, c4 = await (async (...e3) => {
      const [t3, r4, i5, s4] = e3, { wcSignClients: c5 } = G5.getState(), l4 = c5.get(n2), { accounts: d4 } = G5.getState();
      if (!l4) throw new Error("walletConnect.signClient is not defined");
      if (!d4) throw new Error("account is not defined");
      const u5 = a2([t3])?.topic;
      if (!u5) throw new Error("No wallet connect session");
      return o3(), await l4.request({ topic: u5, chainId: `cosmos:${t3}`, request: { method: "cosmos_signDirect", params: { signerAddress: r4, signDoc: i5 } } });
    })(t2, r3, i4);
    return c4;
  }, h4 = (e2) => ({ getAccounts: async () => [await l3(e2)], signAmino: (n3, t2) => g2(e2, n3, t2) });
  return { enable: c3, disable: async (e2) => {
    const { wcSignClients: t2 } = G5.getState(), o4 = t2.get(n2);
    if (void 0 === e2) {
      const e3 = o4?.session.getAll();
      void 0 !== e3 && await Promise.all(e3.map((e4) => i3(e4.topic)));
    } else "string" == typeof e2 ? await i3(a2([e2])?.topic) : await Promise.all(e2.map((e3) => i3(a2([e3])?.topic)));
    0 === o4?.session.getAll().length && r2();
  }, experimentalSuggestChain: async (...e2) => {
    await Promise.reject(new Error("WalletConnect does not support experimentalSuggestChain"));
  }, getKey: d3, getOfflineSigner: (e2) => ({ getAccounts: async () => [await l3(e2)], signDirect: (n3, t2) => u4(e2, n3, t2), signAmino: (n3, t2) => g2(e2, n3, t2) }), getOfflineSignerAuto: async (e2) => (await d3(e2)).isNanoLedger ? h4(e2) : /* @__PURE__ */ ((e3) => ({ getAccounts: async () => [await l3(e3)], signDirect: (n3, t2) => u4(e3, n3, t2) }))(e2), getOfflineSignerOnlyAmino: h4, signAmino: g2, signDirect: u4, subscription: (e2) => {
    const { wcSignClients: t2 } = G5.getState(), o4 = t2.get(n2);
    if (!o4) return () => {
    };
    const i4 = (n3) => {
      const t3 = G5.getState().accounts;
      if ("accountsChanged" === n3.params.event.name && t3 && !Object.values(t3).map((e3) => e3.bech32Address).includes(n3.params.event.data[0])) {
        const e3 = n3.params.chainId.split(":")[1];
        e3 && c3([e3]);
      } else e2();
    };
    return o4.events.on("session_delete", r2), o4.events.on("session_expire", r2), o4.events.on("session_event", i4), () => {
      o4.events.off("session_delete", r2), o4.events.off("session_expire", r2), o4.events.off("session_event", i4);
    };
  }, init: async () => {
    const { walletConnect: e2 } = H2.getState();
    if (!e2?.options) throw new Error("walletConnect.options is not defined");
    const { wcSignClients: t2 } = G5.getState(), o4 = t2.get(n2);
    if (o4) return o4;
    const r3 = await $s2.init(e2.options);
    return t2.set(n2, r3), G5.setState({ wcSignClients: t2 }), r3;
  } };
};
var me3 = () => {
  if (!H2.getState().walletConnect?.options?.projectId?.trim()) throw new Error("walletConnect.options.projectId is not defined");
  if (!he3()) throw new Error("WalletConnect Cosmostation mobile is only supported in mobile");
  return we3({ encoding: "hex", appUrl: { mobile: { ios: "cosmostation://", android: "cosmostation://" } }, walletType: "wc_cosmostation_mobile", formatNativeUrl: (e, n2, t) => {
    const o3 = e.replace(/\//g, "").replace(/:/g, "");
    return n2 ? `${o3}://wc?${n2}` : `${o3}://wc`;
  } });
};
var pe3 = () => {
  if (!H2.getState().walletConnect?.options?.projectId?.trim()) throw new Error("walletConnect.options.projectId is not defined");
  if (!he3()) throw new Error("WalletConnect Keplr mobile is only supported in mobile");
  return we3({ encoding: "base64", appUrl: { mobile: { ios: "keplrwallet://", android: "intent://" } }, walletType: "wc_keplr_mobile", formatNativeUrl: (e, n2, t) => {
    const o3 = e.replace(/\//g, "").replace(/:/g, ""), r2 = n2 && encodeURIComponent(n2);
    switch (t) {
      case "ios":
        return r2 ? `${o3}://wcV2?${r2}` : `${o3}://wcV2`;
      case "android":
        return r2 ? `${o3}://wcV2?${r2}#Intent;package=com.chainapsis.keplr;scheme=keplrwallet;end;` : `${o3}://wcV2#Intent;package=com.chainapsis.keplr;scheme=keplrwallet;end;`;
      default:
        return r2 ? `${o3}://wc?uri=${r2}` : `${o3}://wc`;
    }
  } });
};
var Ce3 = () => {
  if (!H2.getState().walletConnect?.options?.projectId?.trim()) throw new Error("walletConnect.options.projectId is not defined");
  if (!he3()) throw new Error("WalletConnect Leap mobile is only supported in mobile");
  return we3({ encoding: "base64", appUrl: { mobile: { ios: "leapcosmos://", android: "intent://" } }, walletType: "wc_leap_mobile", formatNativeUrl: (e, n2, t) => {
    const o3 = e.replace(/\//g, "").replace(/:/g, ""), r2 = n2 && encodeURIComponent(n2);
    switch (t) {
      case "ios":
        return r2 ? `${o3}://wcV2?${r2}` : `${o3}://wcV2`;
      case "android":
        return r2 ? `${o3}://wcV2?${r2}#Intent;package=io.leapwallet.cosmos;scheme=leapwallet;end;` : `${o3}://wcV2#Intent;package=io.leapwallet.cosmos;scheme=leapwallet;end;`;
      default:
        return r2 ? `${o3}://wc?uri=${r2}` : `${o3}://wc`;
    }
  } });
};
var ye3 = () => {
  if (void 0 !== window.xfi?.keplr) {
    const e = window.xfi.keplr, n2 = (e2) => {
      const n3 = () => {
        be3(), e2();
      };
      return window.addEventListener("keplr_keystorechange", n3), () => {
        window.removeEventListener("keplr_keystorechange", n3);
      };
    };
    return Object.assign(e, { subscription: n2 });
  }
  throw H2.getState()._notFoundFn(), new Error("window.xfi.keplr is not defined");
};
var Se3 = (e = H2.getState().walletType) => {
  try {
    return Ie3(e), true;
  } catch (e2) {
    return false;
  }
};
var be3 = () => {
  window.sessionStorage.removeItem(P4), G5.setState(j2);
};
var Ie3 = (e = H2.getState().walletType) => {
  const n2 = Y5();
  n2.debug("wallet", "Getting wallet adapter", { function: "getWallet", walletType: e });
  const t = (() => {
    switch (e) {
      case "keplr":
        return re3();
      case "leap":
        return ie3();
      case "cosmostation":
        return te3();
      case "vectis":
        return ge3();
      case "walletconnect":
        return we3();
      case "wc_keplr_mobile":
        return pe3();
      case "wc_leap_mobile":
        return Ce3();
      case "wc_cosmostation_mobile":
        return me3();
      case "wc_clot_mobile":
        return (() => {
          if (!H2.getState().walletConnect?.options?.projectId?.trim()) throw new Error("walletConnect.options.projectId is not defined");
          if (!he3()) throw new Error("WalletConnect Clot mobile is only supported in mobile");
          return we3({ encoding: "base64", appUrl: { mobile: { android: "clot://", ios: "clot://" } }, walletType: "wc_clot_mobile", formatNativeUrl: (e2, n3, t2) => {
            const o4 = e2.replace(/\//g, "").replace(/:/g, ""), r2 = n3 && encodeURIComponent(n3);
            return "ios" === t2 ? r2 ? `${o4}://wcV2?${r2}` : `${o4}://wcV2` : r2 ? `${o4}://wc?uri=${r2}` : `${o4}://wc`;
          } });
        })();
      case "metamask_snap_leap":
        return se3();
      case "metamask_snap_cosmos":
        return (() => {
          const e2 = window.ethereum;
          let n3 = window.cosmos;
          if (e2) return { init: async () => {
            const t2 = await e2.request({ method: "web3_clientVersion" });
            if (!t2.includes("MetaMask")) throw new Error("Metamask is not installed");
            if (void 0 !== window.okxwallet && window.okxwallet.isOkxWallet) throw new Error("You have OKX Wallet installed. Please disable and reload the page to use Metamask Snap.");
            const o4 = t2.split("MetaMask/v")[1]?.split(".")[0];
            if (!(Number(o4) >= 11)) throw new Error("Metamask Snap is not supported in this version");
            return await isSnapInstalled() || await installSnap(), window.cosmos = new CosmosSnap(), n3 = window.cosmos, true;
          }, enable: async (e3) => {
            await isSnapInstalled() || await installSnap();
          }, getOfflineSigner: (e3) => n3.getOfflineSigner(e3), experimentalSuggestChain: async (e3) => {
            if (!e3.bech32Config) throw new Error("Bech32Config is required");
            if (!e3.stakeCurrency) throw new Error("StakeCurrency is required");
            await n3.experimentalSuggestChain({ ...e3, stakeCurrency: e3.stakeCurrency, bech32Config: e3.bech32Config });
          }, signAmino: async (e3, t2, o4) => n3.signAmino(e3, t2, o4), getKey: async (e3) => void 0 !== ne2[e3] ? ne2[e3] : n3.getKey(e3), getOfflineSignerAuto: async (e3) => (await n3.getKey(e3)).isNanoLedger ? n3.getOfflineSignerOnlyAmino(e3) : n3.getOfflineSigner(e3), getOfflineSignerOnlyAmino: (e3) => n3.getOfflineSignerOnlyAmino(e3), signDirect: async (e3, t2, o4) => n3.signDirect(e3, t2, o4), signArbitrary: async (e3, t2, o4) => n3.signArbitrary(e3, t2, o4), disable: async (e3) => {
            e3 && await n3.deleteChain(e3);
          } };
          throw H2.getState()._notFoundFn(), new Error("window.ethereum is not defined");
        })();
      case "station":
        return ue3();
      case "xdefi":
        return ye3();
      case "cosmiframe":
        return ee3();
      case "compass":
        return Z2();
      case "initia":
        return oe2();
      case "okx":
        return ce3();
      case "para":
        return de3();
      case "cactuscosmos":
        return J4();
      default:
        throw n2.warn("wallet", "Unknown wallet type", { function: "getWallet", walletType: e }), new Error("Unknown wallet type");
    }
  })(), o3 = H2.getState().walletDefaultOptions;
  return o3 && t.setDefaultOptions?.(o3), t;
};
var Ae2 = (e) => "metamask_snap_leap" === e;
var _e4 = () => Boolean(navigator?.userAgent) && /LeapCosmos/i.test(navigator.userAgent);
var ve2 = (e) => "walletconnect" === e || "wc_keplr_mobile" === e || "wc_leap_mobile" === e || "wc_cosmostation_mobile" === e;
var Oe2 = (e) => "para" === e;
var Te2 = async (e) => {
  const n2 = Y5();
  n2.time("connect"), n2.group("Connect Wallet");
  try {
    const { recentChainIds: t, chains: o3, walletType: r2 } = H2.getState(), i3 = e?.walletType || r2;
    if (n2.debug("wallet", "Starting connection", { function: "connect", walletType: i3, chainId: e?.chainId, timestamp: Date.now() }), ve2(i3)) {
      const e2 = Ie3("walletconnect"), { disable: n3 } = e2;
      n3 && n3();
    }
    if (!Se3(i3)) throw n2.warn("wallet", "Wallet not available", { function: M4.CONNECT, walletType: i3 }), new Error(`${i3} is not available`);
    n2.debug("wallet", "Wallet adapter retrieved", { function: M4.CONNECT, walletType: i3 });
    const a2 = Ie3(i3), s2 = "string" == typeof e?.chainId ? [e.chainId] : e?.chainId || t;
    if (!s2) throw new Error("No last known connected chain, connect action requires chain ids");
    const c3 = o3?.map((e2) => e2.chainId);
    if (s2.forEach((e2) => {
      if (!c3?.includes(e2)) throw new Error(`Chain ${e2} is not provided in GrazProvider`);
    }), G5.setState((e2) => {
      const n3 = H2.getState()._reconnect || Boolean(H2.getState()._reconnectConnector) || Boolean(s2);
      return e2.activeChainIds && s2.filter((n4) => !e2.activeChainIds?.includes(n4)).length > 0 ? { status: "connecting" } : n3 ? { status: "reconnecting" } : { status: "connecting" };
    }), n2.debug("wallet", "Initializing wallet", { function: M4.CONNECT }), await a2.init?.(), n2.debug("wallet", "Enabling chains", { function: M4.CONNECT, chainIds: s2, chainCount: s2.length }), await a2.enable(s2), n2.debug("wallet", "Fetching accounts", { function: M4.CONNECT }), !ve2(i3)) {
      let e2 = {};
      if (Ae2(i3)) {
        const n3 = {};
        for await (const e3 of s2) n3[e3] = await a2.getKey(e3);
        e2 = n3;
      } else if (_e4() && a2.getKeys) {
        const n3 = await a2.getKeys(s2);
        s2.forEach((t2, o4) => {
          const r3 = n3[o4];
          r3 && (e2[t2] = r3);
        });
      } else e2 = Object.fromEntries(await Promise.all(s2.map(async (e3) => [e3, await a2.getKey(e3)])));
      G5.setState((n3) => ({ accounts: { ...n3.accounts || {}, ...e2 } }));
    }
    H2.setState((e2) => ({ recentChainIds: [...e2.recentChainIds || [], ...s2].filter((e3, n3, t2) => t2.indexOf(e3) === n3) })), G5.setState((e2) => ({ activeChainIds: [...e2.activeChainIds || [], ...s2].filter((e3, n3, t2) => t2.indexOf(e3) === n3) })), H2.setState({ walletType: i3, _reconnect: Boolean(e?.autoReconnect), _reconnectConnector: i3 }), G5.setState({ status: "connected" }), "undefined" != typeof window && window.sessionStorage.setItem(P4, "Active");
    const l3 = s2.map((e2) => o3.find((n3) => n3.chainId === e2)), d3 = G5.getState().accounts;
    return n2.info("wallet", "Connection successful", { function: M4.CONNECT, walletType: i3, chainCount: s2.length, chainIds: s2, addresses: d3 ? Object.values(d3).map((e2) => e2.bech32Address) : [] }), n2.debug("store", "Session store updated", { function: M4.CONNECT, accountCount: Object.keys(d3 || {}).length }), n2.timeEnd("connect"), n2.groupEnd(), { accounts: d3, walletType: i3, chains: l3 };
  } catch (t) {
    throw n2.error("wallet", "Connection failed", { function: M4.CONNECT, error: t instanceof Error ? t.message : String(t), stack: t instanceof Error ? t.stack : void 0, walletType: e?.walletType, chainId: e?.chainId }), null === G5.getState().accounts && G5.setState({ status: "disconnected" }), G5.getState().accounts && G5.getState().activeChainIds && G5.setState({ status: "connected" }), n2.timeEnd("connect"), n2.groupEnd(), t;
  }
};
var ke4 = (e) => {
  const n2 = Y5(), t = "string" == typeof e?.chainId ? [e.chainId] : e?.chainId;
  n2.info("wallet", "Disconnecting", { function: M4.DISCONNECT, chainId: t || "all chains" }), "undefined" != typeof window && window.sessionStorage.removeItem(P4);
  const o3 = () => {
    if (ve2(H2.getState().walletType)) {
      const e2 = Ie3("walletconnect"), { disable: n3 } = e2;
      n3 && n3();
    }
    if (Oe2(H2.getState().walletType)) {
      const e2 = Ie3("para"), { disable: n3 } = e2;
      n3 && n3();
    }
  };
  if (t) {
    const e2 = G5.getState().accounts;
    t.forEach((n3) => {
      delete e2?.[n3];
    });
    0 === Object.values(e2 || {}).length ? (o3(), G5.setState(j2), H2.setState({ _reconnect: false, _reconnectConnector: null, recentChainIds: null }), n2.debug("store", "Session cleared - all chains disconnected", { function: M4.DISCONNECT })) : (G5.setState((n3) => ({ activeChainIds: n3.activeChainIds?.filter((e3) => !t.includes(e3)), accounts: e2 })), H2.setState((e3) => ({ recentChainIds: e3.recentChainIds?.filter((e4) => !t.includes(e4)) })), n2.debug("store", "Partial disconnect - some chains remain connected", { function: M4.DISCONNECT }));
  } else o3(), G5.setState(j2), H2.setState({ _reconnect: false, _reconnectConnector: null, recentChainIds: null }), n2.debug("store", "Session cleared - disconnected from all chains", { function: M4.DISCONNECT });
  return n2.info("wallet", "Disconnected successfully", { function: M4.DISCONNECT, chainId: t || "all chains" }), Promise.resolve();
};
var Ne = async (e) => {
  const n2 = Y5(), { recentChainIds: t, _reconnectConnector: o3, _reconnect: r2 } = H2.getState();
  n2.debug("wallet", "Attempting reconnection", { function: M4.RECONNECT, recentChains: t, walletType: o3 });
  try {
    const e2 = Se3(o3 || void 0);
    if (t && e2 && o3) {
      if (ve2(o3)) return;
      const e3 = await Te2({ chainId: t, walletType: o3, autoReconnect: r2 });
      return n2.info("wallet", "Reconnection successful", { function: M4.RECONNECT }), e3;
    }
    n2.warn("wallet", "Reconnection skipped", { function: M4.RECONNECT, hasRecentChains: Boolean(t), isWalletReady: e2, hasConnector: Boolean(o3) });
  } catch (t2) {
    n2.warn("wallet", "Reconnection failed", { function: M4.RECONNECT, error: t2 instanceof Error ? t2.message : String(t2) }), e?.onError?.(t2), ke4();
  }
};
var Fe3 = ({ chainId: e } = {}) => {
  const n2 = Y5(), t = H2.getState().chains?.find((n3) => n3.chainId === e);
  return n2.debug("store", "Getting chain info", { function: "getChainInfo", chainId: e, found: Boolean(t) }), t;
};
var qe3 = async ({ chainInfo: e, walletType: n2 }) => {
  const t = Y5();
  t.debug("wallet", "Suggesting chain to wallet", { function: "suggestChain", chainId: e.chainId, chainName: e.chainName, walletType: n2 });
  try {
    const o3 = Ie3(n2);
    await o3.experimentalSuggestChain(e);
    const { chains: r2 } = H2.getState(), i3 = r2?.find((n3) => n3.chainId === e.chainId);
    return i3 || (H2.setState((n3) => ({ chains: [...n3.chains || [], e] })), t.debug("store", "Chain added to store after suggestion", { function: "suggestChain", chainId: e.chainId })), t.info("wallet", "Chain suggested successfully", { function: "suggestChain", chainId: e.chainId, chainName: e.chainName, walletType: n2 }), e;
  } catch (o3) {
    throw t.error("wallet", "Failed to suggest chain", { function: "suggestChain", error: o3 instanceof Error ? o3.message : String(o3), chainId: e.chainId, walletType: n2 }), o3;
  }
};
var Me4 = async (e) => {
  const n2 = Y5(), t = H2.getState().walletType, o3 = e.walletType ?? t;
  n2.info("wallet", "Suggesting chain and connecting", { function: "suggestChainAndConnect", chainId: e.chainInfo.chainId, chainName: e.chainInfo.chainName, walletType: o3 }), n2.time("suggest-chain-and-connect");
  try {
    await qe3({ chainInfo: e.chainInfo, walletType: o3 });
    const t2 = await Te2({ chainId: e.chainInfo.chainId, walletType: e.walletType, autoReconnect: e.autoReconnect });
    return n2.timeEnd("suggest-chain-and-connect"), n2.info("wallet", "Chain suggested and connected successfully", { function: "suggestChainAndConnect", chainId: e.chainInfo.chainId, walletType: t2.walletType }), t2;
  } catch (t2) {
    throw n2.timeEnd("suggest-chain-and-connect"), n2.error("wallet", "Failed to suggest chain and connect", { function: "suggestChainAndConnect", error: t2 instanceof Error ? t2.message : String(t2), chainId: e.chainInfo.chainId }), t2;
  }
};
var We4 = (e) => (X2({ enabled: e.logger?.enabled ?? false, level: e.logger?.level, categories: e.logger?.categories }), H2.setState((n2) => {
  const t = n2.chains ?? [], o3 = e.chains, r2 = /* @__PURE__ */ new Map();
  o3.forEach((e2) => r2.set(e2.chainId, e2)), t.forEach((e2) => {
    r2.has(e2.chainId) || r2.set(e2.chainId, e2);
  });
  const i3 = Array.from(r2.values());
  return { iframeOptions: e.iframeOptions || n2.iframeOptions, walletConnect: e.walletConnect || n2.walletConnect, walletType: e.defaultWallet || n2.walletType, paraConfig: e.paraConfig || n2.paraConfig, walletDefaultOptions: e.walletDefaultOptions || n2.walletDefaultOptions, chains: i3, chainsConfig: e.chainsConfig || n2.chainsConfig, multiChainFetchConcurrency: e.multiChainFetchConcurrency || n2.multiChainFetchConcurrency, pingInterval: e.pingInteval || n2.pingInterval, loggerConfig: e.logger ? { enabled: e.logger.enabled ?? n2.loggerConfig?.enabled ?? false, level: e.logger.level ?? n2.loggerConfig?.level ?? 1, categories: e.logger.categories ?? n2.loggerConfig?.categories ?? [] } : n2.loggerConfig, _notFoundFn: e.onNotFound || n2._notFoundFn, _onReconnectFailed: e.onReconnectFailed || n2._onReconnectFailed, _reconnect: void 0 === e.autoReconnect || (e.autoReconnect || n2._reconnect) };
}), e);
var Ve3 = ({ chainId: e }) => {
  const n2 = H2((e2) => e2.chains);
  if (!n2) throw new Error("No chains found in GrazProvider");
  return e && e.length > 0 ? e.map((e2) => n2.find((n3) => n3.chainId === e2)).filter(Boolean) : n2;
};
var Ze4 = () => H2(useShallow((e) => ({ walletType: e.walletType, isCosmostation: "cosmostation" === e.walletType, isCosmostationMobile: "wc_cosmostation_mobile" === e.walletType, isKeplr: "keplr" === e.walletType, isKeplrMobile: "wc_keplr_mobile" === e.walletType, isLeap: "leap" === e.walletType, isLeapMobile: "wc_leap_mobile" === e.walletType, isVectis: "vectis" === e.walletType, isWalletConnect: "walletconnect" === e.walletType, isMetamaskSnapLeap: "metamask_snap_leap" === e.walletType, isStation: "station" === e.walletType, isCosmiframe: "cosmiframe" === e.walletType })));
var en3 = (e) => {
  const n2 = H2((n3) => e || n3.walletType);
  return useQuery({ queryKey: ["USE_CHECK_WALLET", n2], queryFn: () => {
    const e2 = Y5();
    if (e2.debug("wallet", "Checking wallet availability", { hook: "useCheckWallet", walletType: n2 }), !n2) return e2.debug("wallet", "No wallet type provided", { hook: "useCheckWallet" }), false;
    const t = Se3(n2);
    return e2.debug("wallet", "Wallet check completed", { hook: "useCheckWallet", walletType: n2, isAvailable: t }), t;
  } });
};
function nn3(e) {
  const n2 = H2((e2) => e2.walletType), t = G5((e2) => e2.activeChainIds), o3 = Ve3({ chainId: e?.chainId ? e.chainId : t || void 0 }), r2 = G5((e2) => e2.accounts), i3 = G5((e2) => e2.status);
  (0, import_react3.useEffect)(() => G5.subscribe((e2) => e2.status, (n3, t2) => {
    if ("connected" === n3) {
      const { accounts: n4, activeChainIds: o4 } = G5.getState(), { chains: r3 } = H2.getState(), { walletType: i4 } = H2.getState();
      if (!n4 || !o4 || !r3) return e?.onDisconnect?.();
      e?.onConnect?.({ accounts: n4, chains: o4.map((e2) => r3.find((n5) => n5.chainId === e2)), walletType: i4, isReconnect: "reconnecting" === t2 });
    }
    "disconnected" === n3 && e?.onDisconnect?.();
  }), [e]);
  return { data: (0, import_react3.useMemo)(() => r2 ? ((e2, n3) => {
    const t2 = e2.map(n3);
    return Object.fromEntries(t2.map((n4, t3) => [e2[t3].chainId, n4]));
  })(o3, (e2) => r2[e2.chainId]) : void 0, [r2, o3]), isConnected: "connected" === i3, isConnecting: "connecting" === i3, isDisconnected: "disconnected" === i3, isReconnecting: "reconnecting" === i3, isLoading: "connecting" === i3 || "reconnecting" === i3, walletType: "connected" === i3 ? n2 : void 0, reconnect: Ne, status: i3 };
}
var rn3 = ({ onError: e, onLoading: n2, onSuccess: t } = {}) => {
  const o3 = Y5(), r2 = useMutation({ mutationKey: ["USE_CONNECT", e, n2, t], mutationFn: Te2, onError: (n3, t2) => {
    o3.error("wallet", "useConnect mutation failed", { error: n3 instanceof Error ? n3.message : String(n3), chainId: t2?.chainId }), e?.(n3, t2);
  }, onMutate: n2, onSuccess: (e2) => (o3.info("wallet", "useConnect mutation successful", { hook: "useConnect", walletType: e2.walletType, chainCount: e2.chains.length }), Promise.resolve(t?.(e2))) }), { data: i3 } = en3();
  return { connect: (e2) => r2.mutate(e2), connectAsync: (e2) => r2.mutateAsync(e2), error: r2.error, isLoading: r2.isPending, isSuccess: r2.isSuccess, isSupported: Boolean(i3), status: r2.status };
};
var an3 = ({ onError: e, onLoading: n2, onSuccess: t } = {}) => {
  const o3 = Y5(), r2 = useMutation({ mutationKey: ["USE_DISCONNECT", e, n2, t], mutationFn: ke4, onError: (n3) => (o3.error("wallet", "useDisconnect mutation failed", { hook: "useDisconnect", error: n3 instanceof Error ? n3.message : String(n3) }), Promise.resolve(e?.(n3, void 0))), onMutate: n2, onSuccess: () => (o3.info("wallet", "useDisconnect mutation successful", { hook: "useDisconnect" }), Promise.resolve(t?.(void 0))) });
  return { disconnect: (e2) => r2.mutate(e2), disconnectAsync: (e2) => r2.mutateAsync(e2), error: r2.error, isLoading: r2.isPending, isSuccess: r2.isSuccess, status: r2.status };
};
var yn2 = ({ onError: e, onLoading: n2, onSuccess: t } = {}) => {
  const o3 = Y5(), r2 = useMutation({ mutationKey: ["USE_SUGGEST_CHAIN_AND_CONNECT", e, n2, t], mutationFn: Me4, onError: (n3, t2) => (o3.error("wallet", "useSuggestChainAndConnect mutation failed", { error: n3 instanceof Error ? n3.message : String(n3), chainId: t2.chainInfo.chainId }), Promise.resolve(e?.(n3, t2))), onMutate: (e2) => n2?.(e2), onSuccess: (e2) => (o3.info("wallet", "useSuggestChainAndConnect mutation successful", { hook: "useSuggestChainAndConnect", walletType: e2.walletType, chainCount: e2.chains.length }), Promise.resolve(t?.(e2))) }), { data: i3 } = en3();
  return { error: r2.error, isLoading: r2.isPending, isSuccess: r2.isSuccess, isSupported: Boolean(i3), status: r2.status, suggestAndConnect: r2.mutate, suggestAndConnectAsync: r2.mutateAsync };
};
var Tn3 = ({ children: e }) => {
  const [n2, t] = (0, import_react3.useState)(false);
  return (0, import_react3.useEffect)(() => {
    t(true);
  }, []), (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: n2 ? e : null });
};
var kn3 = () => {
  const e = Y5(), n2 = "undefined" != typeof window && "Active" === window.sessionStorage.getItem(P4), { _reconnect: t, _onReconnectFailed: o3, _reconnectConnector: i3, iframeOptions: a2, chains: s2, pingInterval: c3 } = H2(), { activeChainIds: l3, wcSignClients: d3 } = G5(), u4 = Se3(i3 || void 0);
  return (0, import_react3.useEffect)(() => {
    const t2 = async () => {
      if (n2 && u4 && i3 && l3?.[0]) {
        const n3 = G5.getState().lastPing;
        if (n3 && Date.now() - n3 < c3) return;
        const t3 = Ie3(i3);
        try {
          if (!await t3.getKey(l3[0])) throw new Error("No account found");
          G5.setState({ lastPing: Date.now() }), e.debug("event", "Wallet ping successful", { function: "handleFocus" });
        } catch (n4) {
          e.debug("event", "Wallet ping failed, triggering reconnect", { function: "handleFocus", error: n4 instanceof Error ? n4.message : String(n4), walletType: i3 }), Ne({ onError: o3 });
        }
      }
    };
    return window.addEventListener("focus", t2), () => {
      window.removeEventListener("focus", t2);
    };
  }, [n2, u4, i3, s2, l3, c3]), (0, import_react3.useEffect)(() => {
    if (!a2 || false === a2.autoConnect || !a2.allowedIframeParentOrigins.length || !s2) return;
    new J(a2.allowedIframeParentOrigins).isReady().then((n3) => {
      if (n3) return e.info("event", "Auto-connecting to iframe wallet", { function: "autoConnectIframe" }), Te2({ chainId: s2.map((e2) => e2.chainId), walletType: "cosmiframe" });
    });
  }, [a2]), (0, import_react3.useEffect)(() => {
    if (i3) {
      if (!u4) return;
      n2 && Boolean(l3) ? (e.info("event", "Reconnection triggered", { function: "reconnectEffect", reason: "session active" }), Ne({ onError: o3 })) : !n2 && t && (e.info("event", "Reconnection triggered", { function: "reconnectEffect", reason: "auto-reconnect enabled" }), Ne({ onError: o3 }));
    }
  }, [u4]), (0, import_react3.useEffect)(() => {
    if (i3) {
      if (!u4) return;
      "cosmostation" === i3 && te3().subscription?.(() => {
        e.debug("event", "Account changed", { function: "subscription", walletType: "cosmostation" }), Ne({ onError: o3 });
      }), "keplr" === i3 && re3().subscription?.(() => {
        e.debug("event", "Account changed", { function: "subscription", walletType: "keplr" }), Ne({ onError: o3 });
      }), "leap" === i3 && ie3().subscription?.(() => {
        e.debug("event", "Account changed", { function: "subscription", walletType: "leap" }), Ne({ onError: o3 });
      }), "compass" === i3 && Z2().subscription?.(() => {
        Ne({ onError: o3 });
      }), "vectis" === i3 && ge3().subscription?.(() => {
        Ne({ onError: o3 });
      }), "walletconnect" === i3 && d3.has("walletconnect") && we3().subscription?.(() => {
        Ne({ onError: o3 });
      }), "station" === i3 && ue3().subscription?.(() => {
        Ne({ onError: o3 });
      }), "xdefi" === i3 && ye3().subscription?.(() => {
        Ne({ onError: o3 });
      }), "cosmiframe" === i3 && ee3().subscription?.(() => {
        Ne({ onError: o3 });
      }), "okx" === i3 && ce3().subscription?.(() => {
        Ne({ onError: o3 });
      });
    }
  }, [i3, d3, u4]), null;
};
var Nn2 = () => (kn3(), null);
var Bn2 = ({ children: e, grazOptions: n2 }) => ((0, import_react3.useEffect)(() => {
  We4(n2);
}, [n2]), (0, import_jsx_runtime.jsxs)(Tn3, { children: [e, (0, import_jsx_runtime.jsx)(Nn2, {})] }));

// node_modules/.pnpm/@getpara+cosmos-wallet-connectors@2.0.0-alpha.73_@cosmjs+amino@0.37.0_@cosmjs+encoding@_105e61b7335e19f95087e11f175d09d3/node_modules/@getpara/cosmos-wallet-connectors/dist/stores/useStore.js
var import_zustand_sync_tabs = __toESM(require_zustand_sync_tabs(), 1);
var useExternalWalletStore = create(
  (0, import_zustand_sync_tabs.syncTabs)(
    (set) => ({
      isConnecting: false,
      updateState: (state) => {
        set(__spreadValues({}, state));
      }
    }),
    {
      name: "para-cosmos-external-wallet-state"
    }
  )
);

// node_modules/.pnpm/@getpara+cosmos-wallet-connectors@2.0.0-alpha.73_@cosmjs+amino@0.37.0_@cosmjs+encoding@_105e61b7335e19f95087e11f175d09d3/node_modules/@getpara/cosmos-wallet-connectors/dist/utils/formatEthHexAddress.js
function formatEthHexAddress(address) {
  return `0x${Buffer.from(address).toString("hex")}`.toLowerCase();
}

// node_modules/.pnpm/@getpara+cosmos-wallet-connectors@2.0.0-alpha.73_@cosmjs+amino@0.37.0_@cosmjs+encoding@_105e61b7335e19f95087e11f175d09d3/node_modules/@getpara/cosmos-wallet-connectors/dist/providers/externalHooks.js
var externalHooks = { useAccount: nn3 };

// node_modules/.pnpm/@getpara+cosmos-wallet-connectors@2.0.0-alpha.73_@cosmjs+amino@0.37.0_@cosmjs+encoding@_105e61b7335e19f95087e11f175d09d3/node_modules/@getpara/cosmos-wallet-connectors/dist/providers/CosmosExternalWalletContext.js
var CosmosExternalWalletContext = (0, import_react4.createContext)(
  defaultCosmosExternalWallet
);
function CosmosExternalWalletProvider({
  children,
  onSwitchWallet,
  selectedChainId,
  wallets: incompleteWallets,
  chains,
  multiChain,
  shouldUseSuggestChainAndConnect,
  onSwitchChain,
  para,
  walletsWithFullAuth,
  connectedWallet: connectedWalletProp,
  includeWalletVerification,
  connectionOnly
}) {
  var _a2, _b, _c2;
  const { suggestAndConnectAsync } = yn2();
  const {
    data: account,
    isConnecting,
    isReconnecting,
    isConnected
  } = nn3(
    multiChain ? {
      chainId: chains.map((c3) => c3.chainId)
    } : selectedChainId ? {
      chainId: [selectedChainId]
    } : void 0
  );
  const { connectAsync } = rn3();
  const { disconnectAsync, status: disconnectStatus } = an3();
  const { walletType } = Ze4();
  const isLocalConnecting = useExternalWalletStore((state) => state.isConnecting);
  const updateExternalWalletState = useExternalWalletStore((state) => state.updateState);
  const isConnectError = (0, import_react4.useRef)(false);
  const connectedWallet = connectedWalletProp ? para.findWallet(connectedWalletProp.id, connectedWalletProp.type) : null;
  const ethAddress = (_b = (_a2 = account == null ? void 0 : account[selectedChainId]) == null ? void 0 : _a2.ethereumHexAddress) == null ? void 0 : _b.toLowerCase();
  const address = (_c2 = account == null ? void 0 : account[selectedChainId]) == null ? void 0 : _c2.bech32Address;
  const disconnectTypeRef = (0, import_react4.useRef)();
  const verificationMessage = (0, import_react4.useRef)();
  const reset = () => __async(this, null, function* () {
    yield disconnectAsync();
    yield para.logout();
  });
  const switchChain = (chainId) => __async(this, null, function* () {
    var _a22;
    let error;
    let changeResp = {};
    try {
      let chainInfo;
      if (shouldUseSuggestChainAndConnect) {
        chainInfo = Fe3({ chainId });
        if (!chainInfo) {
          console.error("Chain not found.");
          return;
        }
      }
      const connectedWallet2 = yield shouldUseSuggestChainAndConnect ? suggestAndConnectAsync({ walletType, chainInfo }) : connectAsync({ walletType, chainId });
      changeResp.address = connectedWallet2.accounts[chainId].bech32Address;
      changeResp.ethAddress = formatEthHexAddress(connectedWallet2.accounts[chainId].address);
    } catch (err) {
      if (err.message === "No wallet exists") {
        changeResp.error = err.message;
      } else {
        console.error("Graz connection error:", err);
        changeResp.error = "An unknown error occurred.";
      }
    }
    onSwitchWallet(changeResp);
    if (!changeResp.error) {
      onSwitchChain(chainId);
      const storedExternalWallet = para.externalWallets[(_a22 = changeResp.ethAddress) != null ? _a22 : ""];
      const { provider, providerId } = getProvider(walletType);
      para.setExternalWallet({
        partnerId: para.partnerId,
        address: changeResp.ethAddress,
        type: "COSMOS",
        provider,
        providerId,
        addressBech32: changeResp.address,
        withFullParaAuth: storedExternalWallet.isExternalWithParaAuth,
        withVerification: includeWalletVerification,
        isConnectionOnly: connectionOnly
      });
    }
    return { error };
  });
  const login = (_0) => __async(this, [_0], function* ({
    address: address2,
    addressBech32,
    withFullParaAuth,
    providerId,
    provider
  }) {
    try {
      return yield para.loginExternalWallet({
        externalWallet: {
          partnerId: para.partnerId,
          address: address2,
          type: "COSMOS",
          provider,
          providerId,
          addressBech32,
          withFullParaAuth,
          withVerification: includeWalletVerification,
          isConnectionOnly: connectionOnly
        },
        uri: window == null ? void 0 : window.location.origin,
        chainId: selectedChainId
      });
    } catch (e) {
      yield reset();
      throw "Error logging you in. Please try again.";
    }
  });
  (0, import_react4.useEffect)(() => {
    const storedExternalWallet = para.externalWallets[ethAddress != null ? ethAddress : ""];
    if (isConnected && !isConnecting && !isReconnecting && !isLocalConnecting && !!ethAddress && !storedExternalWallet && walletType !== x2.PARA && !disconnectTypeRef.current) {
      reset();
    }
  }, [isConnecting, isLocalConnecting, isReconnecting, isConnected]);
  (0, import_react4.useEffect)(() => {
    const connect2 = () => __async(this, null, function* () {
      var _a22;
      if (!isLocalConnecting && !isConnecting && !isReconnecting && connectedWallet && connectedWallet.type === "COSMOS" && (connectedWallet.isExternal ? walletType !== ((_a22 = connectedWallet.name) == null ? void 0 : _a22.toLowerCase()) : walletType !== "para") && !disconnectTypeRef.current && !isConnectError.current) {
        const isLoggedIn = yield para.isFullyLoggedIn();
        if (!isLoggedIn) {
          return;
        }
        const chainId = multiChain ? chains.map((c3) => c3.chainId) : selectedChainId;
        const targetWalletType = connectedWallet.isExternal ? connectedWallet.name.toLowerCase() : x2.PARA;
        try {
          yield connectAsync({
            walletType: targetWalletType,
            chainId
          });
        } catch (e) {
          isConnectError.current = true;
        }
      }
    });
    connect2();
  }, [isLocalConnecting, isConnecting, isReconnecting, walletType, connectedWallet]);
  const signMessage = (_0) => __async(this, [_0], function* ({ message, externalWallet }) {
    let wallet, signAddress, signEthAddress;
    if (externalWallet) {
      const commonWallet = wallets.find((w4) => w4.id === externalWallet.providerId);
      wallet = Ie3(commonWallet == null ? void 0 : commonWallet.grazType);
      signAddress = externalWallet.addressBech32;
      signEthAddress = externalWallet.address;
    } else {
      wallet = Ie3(walletType);
      signAddress = address;
      signEthAddress = ethAddress;
    }
    if (!wallet) {
      return { error: "Connected wallet not found" };
    }
    try {
      const publicKey = (yield wallet.getKey(selectedChainId)).pubKey;
      const signature = yield wallet.signArbitrary(selectedChainId, signAddress, message);
      return {
        address: signEthAddress,
        addressBech32: signAddress,
        signature: signature.signature,
        cosmosPublicKeyHex: Buffer.from(publicKey).toString("hex"),
        cosmosSigner: signAddress
      };
    } catch (e) {
      if (e.message.includes("Request rejected")) {
        return { error: "Signature request rejected" };
      }
      return { error: "An unknown error occurred" };
    }
  });
  const signVerificationMessage = () => __async(this, null, function* () {
    const signature = yield signMessage({ message: verificationMessage.current });
    return signature;
  });
  const connectBase = (walletType2, chainId) => __async(this, null, function* () {
    var _a22;
    if (!chainId) {
      yield disconnectAsync();
    }
    const _chainId = chainId != null ? chainId : multiChain ? chains.map((c3) => c3.chainId) : selectedChainId;
    if (!_chainId) {
      throw new Error("Chain id not provided.");
    }
    if (!walletType2) {
      throw new Error("Graz wallet type not provided.");
    }
    try {
      let chainInfo;
      if (shouldUseSuggestChainAndConnect) {
        if (typeof _chainId !== "string") {
          console.error("multiChain is not compatible with shouldUseSuggestChainAndConnect.");
          return;
        }
        chainInfo = Fe3({ chainId: _chainId });
        if (!chainInfo) {
          console.error("Chain not found.");
          return;
        }
      }
      const connectedWallet2 = yield shouldUseSuggestChainAndConnect ? suggestAndConnectAsync({ walletType: walletType2, chainInfo }) : connectAsync({ walletType: walletType2, chainId: _chainId });
      const firstChain = !chainId ? selectedChainId : typeof _chainId === "string" ? _chainId : _chainId[0];
      const addressBech32 = connectedWallet2.accounts[firstChain].bech32Address;
      let rawAddress;
      const accountAddress = connectedWallet2.accounts[firstChain].address;
      if (!accountAddress || accountAddress.length === 0 || accountAddress.byteLength === 0) {
        const pubKey = connectedWallet2.accounts[firstChain].pubKey;
        rawAddress = rawSecp256k1PubkeyToRawAddress(pubKey);
      } else {
        rawAddress = accountAddress;
      }
      const address2 = formatEthHexAddress(rawAddress);
      const { provider, providerId } = getProvider(walletType2);
      return {
        partnerId: para.partnerId,
        type: "COSMOS",
        address: address2,
        addressBech32,
        provider,
        providerId
      };
    } catch (e) {
      let error;
      if (e.message === "No wallet exists") {
        error = e.message;
      } else {
        error = `Graz connection error: ${(_a22 = e == null ? void 0 : e.message) != null ? _a22 : e}`;
      }
      throw error;
    }
  });
  const connect = (walletType2, chainId) => __async(this, null, function* () {
    var _a22, _b2;
    updateExternalWalletState({ isConnecting: true });
    const walletId = (_a22 = getWallet(walletType2)) == null ? void 0 : _a22.id;
    const isFullAuthWallet = walletsWithFullAuth === "ALL" || walletsWithFullAuth.includes(walletId.toUpperCase());
    try {
      const externalWallet = yield connectBase(walletType2, chainId);
      const authState = yield login(__spreadProps(__spreadValues({}, externalWallet), {
        withFullParaAuth: isFullAuthWallet
      }));
      verificationMessage.current = authState.stage === "verify" ? authState.signatureVerificationMessage : void 0;
      return {
        address: externalWallet.address,
        authState
      };
    } catch (e) {
      return {
        error: (_b2 = e == null ? void 0 : e.message) != null ? _b2 : e
      };
    } finally {
      updateExternalWalletState({ isConnecting: false });
    }
  });
  const injectedWallets = K4.filter((w4) => !incompleteWallets.some((iw) => iw.grazType === w4) && Se3(w4)).map((w4) => {
    const wallet = Ie3(w4);
    if (!wallet.eip6963ProviderInfo) {
      return void 0;
    }
    const eipInfo = wallet.eip6963ProviderInfo;
    return __spreadValues({
      grazType: w4,
      // Using name here for the injected connector since that's the only common id across the networks
      id: eipInfo.name,
      internalId: eipInfo.name,
      iconUrl: eipInfo.icon
    }, eipInfo);
  }).filter((w4) => !!w4);
  const allWallets2 = [...incompleteWallets, ...injectedWallets];
  const getWallet = (walletType2) => allWallets2.find((w4) => w4.grazType === walletType2 || w4.grazMobileType === walletType2);
  const getProvider = (walletType2) => {
    const wallet = getWallet(walletType2);
    return {
      provider: wallet == null ? void 0 : wallet.name,
      providerId: wallet == null ? void 0 : wallet.id
    };
  };
  const wallets = allWallets2.map((wallet) => {
    return __spreadProps(__spreadValues({
      connect: () => connect(wallet.grazType),
      connectMobile: () => connect(wallet.grazType),
      type: "COSMOS"
    }, wallet), {
      // Using name here since that's the only common id across the networks
      id: wallet.name,
      installed: Se3(wallet.grazType)
    });
  }).filter((w4) => !!w4);
  const formattedChains = chains.map((c3) => {
    return {
      id: c3.chainId,
      name: c3.chainName
    };
  });
  const connectParaEmbedded = (0, import_react4.useCallback)(() => __async(this, null, function* () {
    if (!para) {
      return { error: "No para instance available" };
    }
    try {
      const chainId = multiChain ? chains.map((c3) => c3.chainId) : selectedChainId;
      const result = yield connectAsync({ walletType: x2.PARA, chainId });
      return { result };
    } catch (err) {
      const error = err instanceof Error ? err.message : "Unknown error";
      return { error };
    }
  }), [para, multiChain, chains, selectedChainId]);
  const requestInfo = (providerId) => __async(this, null, function* () {
    var _a22;
    const wallet = wallets.find((w4) => w4.id === providerId);
    if (!wallet) {
      throw new Error(`Wallet for provider ${providerId} not found`);
    }
    disconnectTypeRef.current = "ACCOUNT_LINKING";
    try {
      const externalWallet = yield connectBase(
        wallet.grazType,
        multiChain ? chains.map((c3) => c3.chainId) : selectedChainId
      );
      return externalWallet;
    } catch (e) {
      console.error("Error linking account:", e);
      throw new Error((_a22 = e == null ? void 0 : e.message) != null ? _a22 : e);
    }
  });
  const disconnectBase = (_0, ..._1) => __async(this, [_0, ..._1], function* (_2, { disconnectType } = {}) {
    var _a22;
    if (disconnectType) {
      disconnectTypeRef.current = disconnectType;
    }
    try {
      yield disconnectAsync();
    } catch (e) {
      console.error("Error linking account:", e);
      throw new Error((_a22 = e == null ? void 0 : e.message) != null ? _a22 : e);
    } finally {
      disconnectTypeRef.current = void 0;
    }
  });
  return (0, import_jsx_runtime2.jsx)(
    CosmosExternalWalletContext.Provider,
    {
      value: (0, import_react4.useMemo)(
        () => __spreadValues({
          wallets,
          chains: formattedChains,
          chainId: selectedChainId,
          disconnect: disconnectAsync,
          disconnectStatus,
          switchChain,
          connectParaEmbedded,
          signMessage,
          signVerificationMessage,
          requestInfo,
          disconnectBase
        }, externalHooks),
        [
          wallets,
          formattedChains,
          selectedChainId,
          disconnectAsync,
          switchChain,
          connectParaEmbedded,
          signMessage,
          signVerificationMessage,
          requestInfo,
          disconnectBase
        ]
      ),
      children
    }
  );
}

// node_modules/.pnpm/@getpara+cosmos-wallet-connectors@2.0.0-alpha.73_@cosmjs+amino@0.37.0_@cosmjs+encoding@_105e61b7335e19f95087e11f175d09d3/node_modules/@getpara/cosmos-wallet-connectors/dist/providers/ParaCosmosContext.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_react5 = __toESM(require_react(), 1);

// node_modules/.pnpm/@getpara+graz-connector@2.0.0-alpha.73_@cosmjs+amino@0.37.0_@cosmjs+encoding@0.37.0_@co_ef4f93aef2c79767000a991873208296/node_modules/@getpara/graz-connector/dist/esm/chunk-M66XENHI.js
var __async2 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x3) => x3.done ? resolve(x3.value) : Promise.resolve(x3.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/.pnpm/@getpara+graz-connector@2.0.0-alpha.73_@cosmjs+amino@0.37.0_@cosmjs+encoding@0.37.0_@co_ef4f93aef2c79767000a991873208296/node_modules/@getpara/graz-connector/dist/esm/connector.js
var import_encoding2 = __toESM(require_build2(), 1);

// node_modules/.pnpm/@getpara+cosmjs-v0-integration@2.0.0-alpha.73_@cosmjs+amino@0.37.0_@cosmjs+encoding@0.3_c1d4bce2412478dbaccba42229ead2d8/node_modules/@getpara/cosmjs-v0-integration/dist/esm/chunk-4AFQP74Z.js
var __async3 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x3) => x3.done ? resolve(x3.value) : Promise.resolve(x3.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/.pnpm/@getpara+cosmjs-v0-integration@2.0.0-alpha.73_@cosmjs+amino@0.37.0_@cosmjs+encoding@0.3_c1d4bce2412478dbaccba42229ead2d8/node_modules/@getpara/cosmjs-v0-integration/dist/esm/cosmosSigners.js
var import_amino2 = __toESM(require_build5(), 1);
var import_crypto = __toESM(require_build4(), 1);
var import_proto_signing = __toESM(require_build6(), 1);
var import_tx = __toESM(require_tx(), 1);
var ParaCosmosSigner = class {
  /**
   * Signs a message.
   *
   * @param para - the ParaCore instance
   * @param prefix - the cosmos address prefix, defaults to 'cosmos'
   * @param walletId - optional wallet ID to use. If not present, will use the first wallet found.
   * @param messageSigningTimeoutMs - optional timeout in milliseconds. If not present, defaults to 30 seconds.
   **/
  constructor(para, prefix = "cosmos", walletId, messageSigningTimeoutMs) {
    this.currentWalletId = para.findWalletId(walletId, { type: ["COSMOS"] });
    this.para = para;
    this.prefix = prefix;
    this.messageSigningTimeoutMs = messageSigningTimeoutMs;
  }
  get currentWallet() {
    var _a2;
    return (_a2 = this.para.wallets[this.currentWalletId]) != null ? _a2 : (() => {
      throw new Error(`no valid Para wallet found`);
    })();
  }
  get publicKey() {
    const uncompressedPublicKey = hexToUint8Array(this.currentWallet.publicKey);
    const compressedPublicKey = import_crypto.Secp256k1.compressPubkey(uncompressedPublicKey);
    return compressedPublicKey;
  }
  get address() {
    return getCosmosAddress(this.currentWallet.publicKey, this.prefix);
  }
  getAccounts() {
    return __async3(this, null, function* () {
      return [
        {
          algo: "secp256k1",
          address: this.address,
          pubkey: this.publicKey
        }
      ];
    });
  }
};
var ParaProtoSigner = class extends ParaCosmosSigner {
  signDirect(address, signDoc) {
    return __async3(this, null, function* () {
      const signBytes = (0, import_proto_signing.makeSignBytes)(signDoc);
      if (address !== this.address) {
        throw new Error(`Address ${address} not found in wallet`);
      }
      const hashedMessage = (0, import_crypto.sha256)(signBytes);
      const signDocJson = import_tx.SignDoc.toJSON(signDoc);
      const signDocJsonStringified = JSON.stringify(signDocJson);
      const signDocJsonStringEncoded = btoa(signDocJsonStringified);
      const res = yield this.para.signMessage({
        walletId: this.currentWallet.id,
        messageBase64: Buffer.from(hashedMessage.buffer).toString("base64"),
        timeoutMs: this.messageSigningTimeoutMs,
        cosmosSignDocBase64: signDocJsonStringEncoded
      });
      const signature = hexToSignature(`0x${res.signature}`);
      const extendedSignature = new import_crypto.ExtendedSecp256k1Signature(
        hexToUint8Array(signature.r),
        hexToUint8Array(signature.s),
        Number(signature.v)
      );
      const signatureBytes = new Uint8Array([...extendedSignature.r(32), ...extendedSignature.s(32)]);
      return {
        signed: signDoc,
        signature: (0, import_amino2.encodeSecp256k1Signature)(this.publicKey, signatureBytes)
      };
    });
  }
};
var ParaAminoSigner = class extends ParaCosmosSigner {
  signAmino(signerAddress, signDoc) {
    return __async3(this, null, function* () {
      if (signerAddress !== this.address) {
        throw new Error(`Address ${signerAddress} not found in wallet`);
      }
      const hashedMessage = new import_crypto.Sha256((0, import_amino2.serializeSignDoc)(signDoc)).digest();
      const res = yield this.para.signMessage({
        walletId: this.currentWallet.id,
        messageBase64: Buffer.from(hashedMessage.buffer).toString("base64")
      });
      const signature = hexToSignature(`0x${res.signature}`);
      const extendedSignature = new import_crypto.ExtendedSecp256k1Signature(
        hexToUint8Array(signature.r),
        hexToUint8Array(signature.s),
        Number(signature.v)
      );
      const signatureBytes = new Uint8Array([...extendedSignature.r(32), ...extendedSignature.s(32)]);
      return {
        signed: signDoc,
        signature: (0, import_amino2.encodeSecp256k1Signature)(this.publicKey, signatureBytes)
      };
    });
  }
};

// node_modules/.pnpm/@getpara+cosmjs-v0-integration@2.0.0-alpha.73_@cosmjs+amino@0.37.0_@cosmjs+encoding@0.3_c1d4bce2412478dbaccba42229ead2d8/node_modules/@getpara/cosmjs-v0-integration/dist/esm/utils.js
var import_stargate2 = __toESM(require_build11(), 1);
var import_tx2 = __toESM(require_tx2(), 1);
var import_tx3 = __toESM(require_tx(), 1);

// node_modules/.pnpm/@getpara+graz-connector@2.0.0-alpha.73_@cosmjs+amino@0.37.0_@cosmjs+encoding@0.37.0_@co_ef4f93aef2c79767000a991873208296/node_modules/@getpara/graz-connector/dist/esm/connector.js
function toArray(v9) {
  return Array.isArray(v9) ? v9 : [v9];
}
var ParaOfflineSigner = class {
  constructor(chainId, connector) {
    this.chainId = chainId;
    this.connector = connector;
  }
  get para() {
    return this.connector.getParaWebClient();
  }
  get prefix() {
    return this.connector.getBech32Prefix(this.chainId);
  }
  wallet() {
    return __async2(this, null, function* () {
      return this.connector.getFirstWallet();
    });
  }
  getAccounts() {
    return __async2(this, null, function* () {
      const key = yield this.connector.getKey(this.chainId);
      return [
        {
          address: key.bech32Address,
          algo: key.algo,
          pubkey: key.pubKey
        }
      ];
    });
  }
  signDirect(signerAddress, signDoc) {
    return __async2(this, null, function* () {
      if (this.chainId !== signDoc.chainId) {
        throw new Error(`Chain ID mismatch: expected ${this.chainId}, got ${signDoc.chainId}`);
      }
      const accounts = yield this.getAccounts();
      if (accounts.every((a2) => a2.address !== signerAddress)) {
        throw new Error(`Signer address ${signerAddress} not found in wallet`);
      }
      const signer = new ParaProtoSigner(this.para, this.prefix, (yield this.wallet()).id);
      try {
        const result = yield signer.signDirect(signerAddress, signDoc);
        return {
          signed: {
            bodyBytes: result.signed.bodyBytes,
            authInfoBytes: result.signed.authInfoBytes,
            chainId: result.signed.chainId,
            accountNumber: result.signed.accountNumber
          },
          signature: result.signature
        };
      } catch (err) {
        throw new Error(`Direct signing failed: ${err instanceof Error ? err.message : "Unknown error"}`);
      }
    });
  }
};
var ParaGrazConnector = class {
  constructor(config, chains = null) {
    this.config = config;
    this.chains = chains;
    this.enabledChainIds = /* @__PURE__ */ new Set();
    if (!(config == null ? void 0 : config.paraWeb)) {
      throw new Error("ParaWeb instance required in config");
    }
    this.events = config.events;
    this.paraWebClient = config.paraWeb;
  }
  ensureChainEnabled(chainId) {
    return __async2(this, null, function* () {
      if (!this.enabledChainIds.has(chainId)) {
        throw new Error(`Chain ${chainId} not enabled. Call enable() first`);
      }
      if (!(yield this.paraWebClient.isFullyLoggedIn())) {
        throw new Error("Para wallet not authenticated");
      }
    });
  }
  waitForLogin(timeoutMs = 6e4) {
    return __async2(this, null, function* () {
      const deadline = Date.now() + timeoutMs;
      let delay = 500;
      const MAX_DELAY = 5e3;
      while (true) {
        if (yield this.paraWebClient.isFullyLoggedIn()) {
          return;
        }
        if (Date.now() >= deadline) {
          throw new Error(`Login timeout after ${timeoutMs / 1e3}s`);
        }
        yield new Promise((r2) => setTimeout(r2, delay));
        delay = Math.min(delay * 1.5, MAX_DELAY);
      }
    });
  }
  waitForAccounts(timeoutMs = 5e3) {
    return __async2(this, null, function* () {
      const deadline = Date.now() + timeoutMs;
      let delay = 250;
      const MAX_DELAY = 1e3;
      while (true) {
        const wallets = this.paraWebClient.getWalletsByType("COSMOS");
        if (wallets.length) {
          return wallets;
        }
        if (Date.now() >= deadline) {
          throw new Error("No Cosmos wallets found");
        }
        yield new Promise((r2) => setTimeout(r2, delay));
        delay = Math.min(delay * 1.5, MAX_DELAY);
      }
    });
  }
  hasCosmosWallet() {
    return __async2(this, null, function* () {
      const isLoggedIn = yield this.paraWebClient.isFullyLoggedIn();
      const wallets = this.paraWebClient.getWalletsByType("COSMOS");
      return isLoggedIn && wallets.length > 0;
    });
  }
  enable(chainIdsInput) {
    return __async2(this, null, function* () {
      var _a2, _b, _c2, _d;
      const chainIds = toArray(chainIdsInput);
      const previousEnabled = new Set(this.enabledChainIds);
      try {
        chainIds.forEach((id) => this.enabledChainIds.add(id));
        if (yield this.hasCosmosWallet()) {
          (_b = (_a2 = this.events) == null ? void 0 : _a2.onEnabled) == null ? void 0 : _b.call(_a2, chainIds, this);
          return;
        }
        yield this.waitForLogin();
        yield this.waitForAccounts();
        (_d = (_c2 = this.events) == null ? void 0 : _c2.onEnabled) == null ? void 0 : _d.call(_c2, chainIds, this);
      } catch (err) {
        this.enabledChainIds = previousEnabled;
        if (err instanceof Error) {
          throw err;
        }
        throw new Error("Failed to enable Para wallet");
      }
    });
  }
  disconnect() {
    return __async2(this, null, function* () {
      try {
        yield this.paraWebClient.logout();
      } catch (e) {
        throw new Error("Disconnect failed");
      } finally {
        this.enabledChainIds.clear();
      }
    });
  }
  getFirstWallet() {
    return __async2(this, null, function* () {
      try {
        const [wallet] = yield this.waitForAccounts();
        return wallet;
      } catch (e) {
        throw new Error("No Para wallet available");
      }
    });
  }
  getBech32Prefix(chainId) {
    var _a2, _b, _c2;
    const prefix = ((_c2 = (_b = (_a2 = this.chains) == null ? void 0 : _a2.find((c3) => c3.chainId === chainId)) == null ? void 0 : _b.bech32Config) == null ? void 0 : _c2.bech32PrefixAccAddr) || "cosmos";
    return prefix;
  }
  getParaWebClient() {
    return this.paraWebClient;
  }
  getConfig() {
    return this.config;
  }
  buildHybridSigner(chainId) {
    const aminoSigner = this.getOfflineSignerOnlyAmino(chainId);
    const directSigner = new ParaOfflineSigner(chainId, this);
    return {
      getAccounts: () => directSigner.getAccounts(),
      signAmino: (signer, signDoc) => aminoSigner.signAmino(signer, signDoc),
      signDirect: (signer, signDoc) => directSigner.signDirect(signer, signDoc)
    };
  }
  getKey(chainId) {
    return __async2(this, null, function* () {
      try {
        yield this.ensureChainEnabled(chainId);
        const wallet = yield this.getFirstWallet();
        const signer = new ParaProtoSigner(this.paraWebClient, this.getBech32Prefix(chainId), wallet.id);
        const [account] = yield signer.getAccounts();
        if (!account) {
          throw new Error(`No Cosmos accounts for chain ${chainId}`);
        }
        return {
          name: "Para Wallet",
          algo: account.algo,
          pubKey: account.pubkey,
          address: (0, import_encoding2.fromBech32)(account.address).data,
          bech32Address: account.address,
          isKeystone: false,
          isNanoLedger: false
        };
      } catch (err) {
        if (err instanceof Error) {
          throw err;
        }
        throw new Error(`Failed to get key for chain ${chainId}`);
      }
    });
  }
  getOfflineSignerOnlyAmino(chainId) {
    void this.ensureChainEnabled(chainId);
    const wallet = this.paraWebClient.getWalletsByType("COSMOS")[0];
    if (!wallet) {
      throw new Error("No Cosmos wallet for Amino signing");
    }
    return new ParaAminoSigner(this.paraWebClient, this.getBech32Prefix(chainId), wallet.id);
  }
  getOfflineSigner(chainId) {
    void this.ensureChainEnabled(chainId);
    return this.buildHybridSigner(chainId);
  }
  getOfflineSignerAuto(chainId) {
    return __async2(this, null, function* () {
      void this.ensureChainEnabled(chainId);
      return this.buildHybridSigner(chainId);
    });
  }
  signAmino(chainId, signer, signDoc, _signOptions) {
    return __async2(this, null, function* () {
      yield this.ensureChainEnabled(chainId);
      try {
        const wallet = yield this.getFirstWallet();
        const signerImpl = new ParaAminoSigner(this.paraWebClient, this.getBech32Prefix(chainId), wallet.id);
        const response = yield signerImpl.signAmino(signer, signDoc);
        return response;
      } catch (err) {
        throw new Error(`Amino signing failed: ${err instanceof Error ? err.message : "Unknown error"}`);
      }
    });
  }
  signDirect(chainId, signer, signDoc, _signOptions) {
    return __async2(this, null, function* () {
      var _a2, _b;
      yield this.ensureChainEnabled(chainId);
      try {
        const wallet = yield this.getFirstWallet();
        const signerImpl = new ParaProtoSigner(this.paraWebClient, this.getBech32Prefix(chainId), wallet.id);
        const convertedSignDoc = {
          bodyBytes: (_a2 = signDoc.bodyBytes) != null ? _a2 : new Uint8Array(),
          authInfoBytes: (_b = signDoc.authInfoBytes) != null ? _b : new Uint8Array(),
          chainId: signDoc.chainId,
          accountNumber: typeof signDoc.accountNumber === "bigint" ? signDoc.accountNumber : BigInt(signDoc.accountNumber)
        };
        const result = yield signerImpl.signDirect(signer, convertedSignDoc);
        return {
          signed: {
            bodyBytes: result.signed.bodyBytes,
            authInfoBytes: result.signed.authInfoBytes,
            chainId: result.signed.chainId,
            accountNumber: result.signed.accountNumber
          },
          signature: result.signature
        };
      } catch (err) {
        throw new Error(`Direct signing failed: ${err instanceof Error ? err.message : "Unknown error"}`);
      }
    });
  }
  signArbitrary(chainId, signer, data2) {
    return __async2(this, null, function* () {
      yield this.ensureChainEnabled(chainId);
      const encodedData = typeof data2 === "string" ? Buffer.from(data2, "utf-8").toString("base64") : Buffer.from(data2).toString("base64");
      const signDoc = {
        chain_id: "",
        account_number: "0",
        sequence: "0",
        fee: { gas: "0", amount: [] },
        msgs: [
          {
            type: "sign/MsgSignData",
            value: { signer, data: encodedData }
          }
        ],
        memo: ""
      };
      try {
        const response = yield this.signAmino(chainId, signer, signDoc);
        return response.signature;
      } catch (err) {
        throw new Error(`Arbitrary signing failed: ${err instanceof Error ? err.message : "Unknown error"}`);
      }
    });
  }
};

// node_modules/.pnpm/@getpara+cosmos-wallet-connectors@2.0.0-alpha.73_@cosmjs+amino@0.37.0_@cosmjs+encoding@_105e61b7335e19f95087e11f175d09d3/node_modules/@getpara/cosmos-wallet-connectors/dist/providers/ParaCosmosContext.js
function ParaCosmosProvider({
  children,
  config,
  internalConfig,
  grazProviderProps
}) {
  const para = internalConfig.para;
  const { chains, wallets } = config;
  const walletsWithType = [];
  wallets.forEach((w4) => {
    const wallet = w4();
    walletsWithType.push(wallet);
  });
  const cosmosExternalWalletProviderProps = (0, import_react5.useMemo)(
    () => __spreadProps(__spreadValues(__spreadValues({}, config), internalConfig), {
      wallets: walletsWithType
    }),
    [walletsWithType, config, internalConfig]
  );
  const paraConfig = (0, import_react5.useMemo)(
    () => ({
      paraWeb: para
    }),
    [para]
  );
  return (
    // Casting Para as any here to avoid ts errors due to the graz version being behind.
    // TODO: update graz para sdk to current version
    (0, import_jsx_runtime3.jsx)(
      Bn2,
      {
        grazOptions: __spreadValues({
          chains,
          autoReconnect: true,
          paraConfig: __spreadProps(__spreadValues({}, paraConfig), { connectorClass: ParaGrazConnector })
        }, grazProviderProps),
        children: (0, import_jsx_runtime3.jsx)(CosmosExternalWalletProvider, __spreadProps(__spreadValues({}, cosmosExternalWalletProviderProps), { children }))
      }
    )
  );
}

// node_modules/.pnpm/@getpara+cosmos-wallet-connectors@2.0.0-alpha.73_@cosmjs+amino@0.37.0_@cosmjs+encoding@_105e61b7335e19f95087e11f175d09d3/node_modules/@getpara/cosmos-wallet-connectors/dist/wallets/connectors/keplr/keplrIcon.js
var icon = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIj4KICA8ZyBjbGlwLXBhdGg9InVybCgjY2xpcDBfMTAzNl8xMTU0KSI+CiAgICA8cGF0aCBkPSJNMCAxMC4yQzAgNi4yNzE4NiA3LjE1MjU2ZS0wOCA0LjMwNzg0IDAuODg0MTYgMi44NjUwMUMxLjM3ODkgMi4wNTc2OCAyLjA1NzY3IDEuMzc4OSAyLjg2NTAxIDAuODg0MTU0QzQuMzA3ODMgLTEuNDMwNTFlLTA3IDYuMjcxODYgMCAxMC4yIDBIMTMuOEMxNy43MjgxIDAgMTkuNjkyMiAtMS40MzA1MWUtMDcgMjEuMTM1IDAuODg0MTU0QzIxLjk0MjMgMS4zNzg5IDIyLjYyMTEgMi4wNTc2OCAyMy4xMTU4IDIuODY1MDFDMjQgNC4zMDc4NCAyNCA2LjI3MTg2IDI0IDEwLjJWMTMuOEMyNCAxNy43MjgxIDI0IDE5LjY5MjIgMjMuMTE1OCAyMS4xMzVDMjIuNjIxMSAyMS45NDI0IDIxLjk0MjMgMjIuNjIxMSAyMS4xMzUgMjMuMTE1OEMxOS42OTIyIDI0IDE3LjcyODEgMjQgMTMuOCAyNEgxMC4yQzYuMjcxODYgMjQgNC4zMDc4MyAyNCAyLjg2NTAxIDIzLjExNThDMi4wNTc2NyAyMi42MjExIDEuMzc4OSAyMS45NDI0IDAuODg0MTYgMjEuMTM1QzcuMTUyNTZlLTA4IDE5LjY5MjIgMCAxNy43MjgxIDAgMTMuOFYxMC4yWiIgZmlsbD0idXJsKCNwYWludDBfbGluZWFyXzEwMzZfMTE1NCkiLz4KICAgIDxwYXRoIGQ9Ik0wIDEwLjJDMCA2LjI3MTg2IDcuMTUyNTZlLTA4IDQuMzA3ODQgMC44ODQxNiAyLjg2NTAxQzEuMzc4OSAyLjA1NzY4IDIuMDU3NjcgMS4zNzg5IDIuODY1MDEgMC44ODQxNTRDNC4zMDc4MyAtMS40MzA1MWUtMDcgNi4yNzE4NiAwIDEwLjIgMEgxMy44QzE3LjcyODEgMCAxOS42OTIyIC0xLjQzMDUxZS0wNyAyMS4xMzUgMC44ODQxNTRDMjEuOTQyMyAxLjM3ODkgMjIuNjIxMSAyLjA1NzY4IDIzLjExNTggMi44NjUwMUMyNCA0LjMwNzg0IDI0IDYuMjcxODYgMjQgMTAuMlYxMy44QzI0IDE3LjcyODEgMjQgMTkuNjkyMiAyMy4xMTU4IDIxLjEzNUMyMi42MjExIDIxLjk0MjQgMjEuOTQyMyAyMi42MjExIDIxLjEzNSAyMy4xMTU4QzE5LjY5MjIgMjQgMTcuNzI4MSAyNCAxMy44IDI0SDEwLjJDNi4yNzE4NiAyNCA0LjMwNzgzIDI0IDIuODY1MDEgMjMuMTE1OEMyLjA1NzY3IDIyLjYyMTEgMS4zNzg5IDIxLjk0MjQgMC44ODQxNiAyMS4xMzVDNy4xNTI1NmUtMDggMTkuNjkyMiAwIDE3LjcyODEgMCAxMy44VjEwLjJaIiBmaWxsPSJ1cmwoI3BhaW50MV9yYWRpYWxfMTAzNl8xMTU0KSIvPgogICAgPHBhdGggZD0iTTAgMTAuMkMwIDYuMjcxODYgNy4xNTI1NmUtMDggNC4zMDc4NCAwLjg4NDE2IDIuODY1MDFDMS4zNzg5IDIuMDU3NjggMi4wNTc2NyAxLjM3ODkgMi44NjUwMSAwLjg4NDE1NEM0LjMwNzgzIC0xLjQzMDUxZS0wNyA2LjI3MTg2IDAgMTAuMiAwSDEzLjhDMTcuNzI4MSAwIDE5LjY5MjIgLTEuNDMwNTFlLTA3IDIxLjEzNSAwLjg4NDE1NEMyMS45NDIzIDEuMzc4OSAyMi42MjExIDIuMDU3NjggMjMuMTE1OCAyLjg2NTAxQzI0IDQuMzA3ODQgMjQgNi4yNzE4NiAyNCAxMC4yVjEzLjhDMjQgMTcuNzI4MSAyNCAxOS42OTIyIDIzLjExNTggMjEuMTM1QzIyLjYyMTEgMjEuOTQyNCAyMS45NDIzIDIyLjYyMTEgMjEuMTM1IDIzLjExNThDMTkuNjkyMiAyNCAxNy43MjgxIDI0IDEzLjggMjRIMTAuMkM2LjI3MTg2IDI0IDQuMzA3ODMgMjQgMi44NjUwMSAyMy4xMTU4QzIuMDU3NjcgMjIuNjIxMSAxLjM3ODkgMjEuOTQyNCAwLjg4NDE2IDIxLjEzNUM3LjE1MjU2ZS0wOCAxOS42OTIyIDAgMTcuNzI4MSAwIDEzLjhWMTAuMloiIGZpbGw9InVybCgjcGFpbnQyX3JhZGlhbF8xMDM2XzExNTQpIi8+CiAgICA8cGF0aCBkPSJNMCAxMC4yQzAgNi4yNzE4NiA3LjE1MjU2ZS0wOCA0LjMwNzg0IDAuODg0MTYgMi44NjUwMUMxLjM3ODkgMi4wNTc2OCAyLjA1NzY3IDEuMzc4OSAyLjg2NTAxIDAuODg0MTU0QzQuMzA3ODMgLTEuNDMwNTFlLTA3IDYuMjcxODYgMCAxMC4yIDBIMTMuOEMxNy43MjgxIDAgMTkuNjkyMiAtMS40MzA1MWUtMDcgMjEuMTM1IDAuODg0MTU0QzIxLjk0MjMgMS4zNzg5IDIyLjYyMTEgMi4wNTc2OCAyMy4xMTU4IDIuODY1MDFDMjQgNC4zMDc4NCAyNCA2LjI3MTg2IDI0IDEwLjJWMTMuOEMyNCAxNy43MjgxIDI0IDE5LjY5MjIgMjMuMTE1OCAyMS4xMzVDMjIuNjIxMSAyMS45NDI0IDIxLjk0MjMgMjIuNjIxMSAyMS4xMzUgMjMuMTE1OEMxOS42OTIyIDI0IDE3LjcyODEgMjQgMTMuOCAyNEgxMC4yQzYuMjcxODYgMjQgNC4zMDc4MyAyNCAyLjg2NTAxIDIzLjExNThDMi4wNTc2NyAyMi42MjExIDEuMzc4OSAyMS45NDI0IDAuODg0MTYgMjEuMTM1QzcuMTUyNTZlLTA4IDE5LjY5MjIgMCAxNy43MjgxIDAgMTMuOFYxMC4yWiIgZmlsbD0idXJsKCNwYWludDNfcmFkaWFsXzEwMzZfMTE1NCkiLz4KICAgIDxwYXRoIGQ9Ik05LjE1OTM0IDE4LjZWMTIuNzUzN0wxNC44NDAyIDE4LjZIMTguMDAwMVYxOC40NDgzTDExLjQ2NjYgMTEuNzkyM0wxNy40OTYxIDUuNDc1ODlWNS40MDAwMkgxNC4zMTU5TDkuMTU5MzQgMTAuOTgxNVY1LjQwMDAySDYuNjAwMVYxOC42SDkuMTU5MzRaIiBmaWxsPSJ3aGl0ZSIvPgogIDwvZz4KICA8ZGVmcz4KICAgIDxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQwX2xpbmVhcl8xMDM2XzExNTQiIHgxPSIxMiIgeTE9IjAiIHgyPSIxMiIgeTI9IjI0IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CiAgICAgIDxzdG9wIHN0b3AtY29sb3I9IiMxRkQxRkYiLz4KICAgICAgPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjMUJCOEZGIi8+CiAgICA8L2xpbmVhckdyYWRpZW50PgogICAgPHJhZGlhbEdyYWRpZW50IGlkPSJwYWludDFfcmFkaWFsXzEwMzZfMTE1NCIgY3g9IjAiIGN5PSIwIiByPSIxIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgZ3JhZGllbnRUcmFuc2Zvcm09InRyYW5zbGF0ZSgxLjE0NjQyIDIzLjA5MDYpIHJvdGF0ZSgtNDUuMTU1Nikgc2NhbGUoMzguNDg4NCAzOS4wNjQyKSI+CiAgICAgIDxzdG9wIHN0b3AtY29sb3I9IiMyMzJERTMiLz4KICAgICAgPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjMjMyREUzIiBzdG9wLW9wYWNpdHk9IjAiLz4KICAgIDwvcmFkaWFsR3JhZGllbnQ+CiAgICA8cmFkaWFsR3JhZGllbnQgaWQ9InBhaW50Ml9yYWRpYWxfMTAzNl8xMTU0IiBjeD0iMCIgY3k9IjAiIHI9IjEiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBncmFkaWVudFRyYW5zZm9ybT0idHJhbnNsYXRlKDIyLjcwNzQgMjMuODYzKSByb3RhdGUoLTEzOC40NSkgc2NhbGUoMjQuMDY1IDM2LjY5MjMpIj4KICAgICAgPHN0b3Agc3RvcC1jb2xvcj0iIzhCNERGRiIvPgogICAgICA8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiM4QjRERkYiIHN0b3Atb3BhY2l0eT0iMCIvPgogICAgPC9yYWRpYWxHcmFkaWVudD4KICAgIDxyYWRpYWxHcmFkaWVudCBpZD0icGFpbnQzX3JhZGlhbF8xMDM2XzExNTQiIGN4PSIwIiBjeT0iMCIgcj0iMSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIGdyYWRpZW50VHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTEuODAwMSAwLjE3Nzk5OSkgcm90YXRlKDkwKSBzY2FsZSgxOC45MjIgNDUuOTA5OCkiPgogICAgICA8c3RvcCBzdG9wLWNvbG9yPSIjMjRENUZGIi8+CiAgICAgIDxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzFCQjhGRiIgc3RvcC1vcGFjaXR5PSIwIi8+CiAgICA8L3JhZGlhbEdyYWRpZW50PgogICAgPGNsaXBQYXRoIGlkPSJjbGlwMF8xMDM2XzExNTQiPgogICAgICA8cmVjdCB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIGZpbGw9IndoaXRlIi8+CiAgICA8L2NsaXBQYXRoPgogIDwvZGVmcz4KPC9zdmc+";

// node_modules/.pnpm/@getpara+cosmos-wallet-connectors@2.0.0-alpha.73_@cosmjs+amino@0.37.0_@cosmjs+encoding@_105e61b7335e19f95087e11f175d09d3/node_modules/@getpara/cosmos-wallet-connectors/dist/wallets/connectors/keplr/keplr.js
var keplrWallet = () => {
  return {
    id: "keplr",
    internalId: "KEPLR",
    name: "Keplr",
    iconUrl: icon,
    isExtension: true,
    isMobile: isMobile() && true,
    downloadUrl: "https://www.keplr.app/get",
    grazType: x2.KEPLR,
    grazMobileType: x2.WC_KEPLR_MOBILE
  };
};

// node_modules/.pnpm/@getpara+cosmos-wallet-connectors@2.0.0-alpha.73_@cosmjs+amino@0.37.0_@cosmjs+encoding@_105e61b7335e19f95087e11f175d09d3/node_modules/@getpara/cosmos-wallet-connectors/dist/wallets/connectors/leap/leapIcon.js
var icon2 = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIj4KICA8ZyBjbGlwLXBhdGg9InVybCgjY2xpcDBfMTAzN18xMTY5KSI+CiAgICA8cGF0aCBkPSJNMjEuNjE4NyAxNC43NTAzQzIxLjYxODcgMTYuNDYyNiAyMC41NzQyIDE3LjY2NzIgMTguODc4MyAxOC40NDQzQzE3LjE4MjEgMTkuMjIxNCAxNC44MzU0IDE5LjU3MDIgMTIuMjM0OCAxOS41NzAyQzkuNjM0MjcgMTkuNTcwMiA3LjI3MjM0IDE5LjIyMTUgNS41NjA4NyAxOC40NDQzQzMuODQ5NjggMTcuNjY3MiAyLjc5MDA0IDE2LjQ2MjUgMi43OTAwNCAxNC43NTAzQzIuNzkwMDQgMTMuMDM3NCAzLjg0Mjg3IDExLjQ4NjkgNS41NDY3NSAxMC4zNjQyQzcuMjUwNiA5LjI0MTYzIDkuNjA0NjEgOC41NDc0OSAxMi4yMDQ0IDguNTQ3NDlDMTQuODA0MSA4LjU0NzQ5IDE3LjE1ODEgOS4yNDMxMyAxOC44NjE5IDEwLjM2NjVDMjAuNTY1OCAxMS40OSAyMS42MTg3IDEzLjA0MDUgMjEuNjE4NyAxNC43NTAzWiIgZmlsbD0iIzI0QTk1QSIgc3Ryb2tlPSIjMTM4RDNFIiBzdHJva2Utd2lkdGg9IjAuMDE2NTY3Ii8+CiAgICA8cGF0aCBkPSJNMTQuODMxNyA1LjE5NDcyTDE0LjgzNjYgNS4xOTU4MUwxNC44Mzk4IDUuMTkxOTJDMTUuNDQyMSA0LjQ2NTg2IDE2LjM1NDYgNCAxNy4zNzY2IDRDMTkuMTg5NSA0IDIwLjY2MTcgNS40NjQxOSAyMC42NjE3IDcuMjY3MTFDMjAuNjYxNyA3Ljg2MDAzIDIwLjUwMzUgOC40MTA2IDIwLjIyOTggOC44ODg1N0wyMC4yMjc2IDguODkyM0wyMC4yMjk1IDguODk2MTlDMjAuNDkxMiA5LjQ1MzE3IDIwLjYzMTIgMTAuMDQ2NCAyMC42MzEyIDEwLjY2MzhDMjAuNjMxMiAxMi4yNTI1IDE5LjY5MSAxMy42OTA4IDE4LjE2OTQgMTQuNzMyM0MxNi42NDc4IDE1Ljc3MzcgMTQuNTQ1MyAxNi40MTc4IDEyLjIyMzIgMTYuNDE3OEM5LjkwMTAyIDE2LjQxNzggNy43OTg2MyAxNS43NzM3IDYuMjc2OTcgMTQuNzMyM0M0Ljc1NTMxIDEzLjY5MDggMy44MTUxNiAxMi4yNTI1IDMuODE1MTYgMTAuNjYzOEMzLjgxNTE2IDEwLjA0NjQgMy45NTUxNCA5LjQ1MzE3IDQuMjE2ODkgOC44OTYxOUw0LjIxODczIDguODkyM0w0LjIxNjU5IDguODg4NTdDMy45NDI4MyA4LjQxMDYgMy43ODQ2NyA3Ljg2MDAzIDMuNzg0NjcgNy4yNjcxMUMzLjc4NDY3IDUuNDY0MTkgNS4yNTY4MiA0IDcuMDY5NzIgNEM4LjA4NTYzIDQgOC45OTgxOCA0LjQ2NTg1IDkuNjA2NTYgNS4xOTE5NUw5LjYwOTgyIDUuMTk1ODNMOS42MTQ3NCA1LjE5NDdDMTAuNDM3NSA1LjAwNjgyIDExLjMxNSA0LjkwOTgzIDEyLjIyMzIgNC45MDk4M0MxMy4xMzEzIDQuOTA5ODMgMTQuMDA4OSA1LjAxMjg4IDE0LjgzMTcgNS4xOTQ3MloiIGZpbGw9IiMzMkRBNkQiIHN0cm9rZT0iIzEzOEQzRSIgc3Ryb2tlLXdpZHRoPSIwLjAxNjU2NyIvPgogICAgPHBhdGggZD0iTTYuODAxMTcgOS4wODQzOEM3LjkxMjY5IDkuMDg0MzggOC44MTM3MyA4LjE4ODIyIDguODEzNzMgNy4wODI3NUM4LjgxMzczIDUuOTc3MjggNy45MTI2OSA1LjA4MTEyIDYuODAxMTcgNS4wODExMkM1LjY4OTYxIDUuMDgxMTIgNC43ODg1NyA1Ljk3NzI4IDQuNzg4NTcgNy4wODI3NUM0Ljc4ODU3IDguMTg4MjIgNS42ODk2MSA5LjA4NDM4IDYuODAxMTcgOS4wODQzOFoiIGZpbGw9IndoaXRlIi8+CiAgICA8cGF0aCBkPSJNMTcuNTM3NyA5LjA4NDM4QzE4LjY0OTMgOS4wODQzOCAxOS41NTAzIDguMTg4MjIgMTkuNTUwMyA3LjA4Mjc1QzE5LjU1MDMgNS45NzcyOCAxOC42NDkzIDUuMDgxMTIgMTcuNTM3NyA1LjA4MTEyQzE2LjQyNjIgNS4wODExMiAxNS41MjUxIDUuOTc3MjggMTUuNTI1MSA3LjA4Mjc1QzE1LjUyNTEgOC4xODgyMiAxNi40MjYyIDkuMDg0MzggMTcuNTM3NyA5LjA4NDM4WiIgZmlsbD0id2hpdGUiLz4KICAgIDxwYXRoIGQ9Ik0xLjMxNzM3IDE4LjE3ODhDMS4zMjUwOSAxOC4xNzU4IDEuMzI1MDcgMTguMTc1OCAxLjMyNTA1IDE4LjE3NThMMS4zMjQ0NiAxOC4xNzQyTDEuMzIyNTkgMTguMTY5NEwxLjMxNTI2IDE4LjE1MDJDMS4zMDg4MyAxOC4xMzMzIDEuMjk5MzQgMTguMTA4MyAxLjI4NzE1IDE4LjA3NTdDMS4yNjI3OCAxOC4wMTA3IDEuMjI3NTkgMTcuOTE1NSAxLjE4NDM2IDE3Ljc5NTRDMS4wOTc5MSAxNy41NTUxIDAuOTc5MzAxIDE3LjIxNDcgMC44NTA2OTEgMTYuODE0NEMwLjU5MzQ0NiAxNi4wMTM3IDAuMjk2MjcxIDE0Ljk3MzUgMC4xMzYyNzUgMTQuMDE1QzAuMDU2Mjc1OCAxMy41MzU3IDAuMDEwNjE3OCAxMy4wNzcxIDAuMDIxMzE4NiAxMi42NzkyQzAuMDMyMDI0NiAxMi4yODExIDAuMDk5MTI3NCAxMS45NDQ3IDAuMjQzNzk3IDExLjcwOTJDMC4zODgwNjkgMTEuNDc0MiAwLjYwOTc2MSAxMS4zMzkgMC45MzIwMzQgMTEuMzQzMUMxLjI1NTA3IDExLjM0NzMgMS42Nzk1MiAxMS40OTE0IDIuMjI3OTUgMTEuODE3MUM1LjUyNDA4IDEzLjc3NDQgNi4yNzM2NiAxNy4wMjgzIDYuNDUwNDEgMTguNTMxNkM2LjQ5ODYxIDE4Ljk1MTEgNi4xNjExIDE5LjMyMyA1LjczMjg1IDE5LjMyM0gwLjU3OTQxM0MwLjIzOTk2MiAxOS4zMjMgMC4xMTU0NDkgMTguODc5MiAwLjQxMjc4NyAxOC43MDc3TDEuMzIxNDkgMTguMTg2TDEuMzI3NjYgMTguMTgyNUwxLjMyNTA1IDE4LjE3NThMMS4zMTczNyAxOC4xNzg4WiIgZmlsbD0iIzMyREE2RCIvPgogICAgPHBhdGggZD0iTTEuMzI1MDUgMTguMTc1OEMxLjMyNTA3IDE4LjE3NTggMS4zMjUwOSAxOC4xNzU4IDEuMzE3MzcgMTguMTc4OEwxLjMyNTA1IDE4LjE3NThaTTEuMzI1MDUgMTguMTc1OEwxLjMyNDQ2IDE4LjE3NDJMMS4zMjI1OSAxOC4xNjk0TDEuMzE1MjYgMTguMTUwMkMxLjMwODgzIDE4LjEzMzMgMS4yOTkzNCAxOC4xMDgzIDEuMjg3MTUgMTguMDc1N0MxLjI2Mjc4IDE4LjAxMDcgMS4yMjc1OSAxNy45MTU1IDEuMTg0MzYgMTcuNzk1NEMxLjA5NzkxIDE3LjU1NTEgMC45NzkzMDEgMTcuMjE0NyAwLjg1MDY5MSAxNi44MTQ0QzAuNTkzNDQ2IDE2LjAxMzcgMC4yOTYyNzEgMTQuOTczNSAwLjEzNjI3NSAxNC4wMTVDMC4wNTYyNzU4IDEzLjUzNTcgMC4wMTA2MTc4IDEzLjA3NzEgMC4wMjEzMTg2IDEyLjY3OTJDMC4wMzIwMjQ2IDEyLjI4MTEgMC4wOTkxMjc0IDExLjk0NDcgMC4yNDM3OTcgMTEuNzA5MkMwLjM4ODA2OSAxMS40NzQyIDAuNjA5NzYxIDExLjMzOSAwLjkzMjAzNCAxMS4zNDMxQzEuMjU1MDcgMTEuMzQ3MyAxLjY3OTUyIDExLjQ5MTQgMi4yMjc5NSAxMS44MTcxQzUuNTI0MDggMTMuNzc0NCA2LjI3MzY2IDE3LjAyODMgNi40NTA0MSAxOC41MzE2QzYuNDk4NjEgMTguOTUxMSA2LjE2MTEgMTkuMzIzIDUuNzMyODUgMTkuMzIzSDAuNTc5NDEzQzAuMjM5OTYyIDE5LjMyMyAwLjExNTQ0OSAxOC44NzkyIDAuNDEyNzg3IDE4LjcwNzdMMS4zMjE0OSAxOC4xODZMMS4zMjc2NiAxOC4xODI1TDEuMzI1MDUgMTguMTc1OFoiIHN0cm9rZT0iIzEzOEQzRSIgc3Ryb2tlLXdpZHRoPSIwLjAxNjU2NyIvPgogICAgPHBhdGggZD0iTTIyLjgyMTIgMTguMTc2MUwyMi44MjkgMTguMTc4OEMyMi44MjQzIDE4LjE3NzIgMjIuODIyNCAxOC4xNzY1IDIyLjgyMTcgMTguMTc2MkMyMi44MjEyIDE4LjE3NjEgMjIuODIxMiAxOC4xNzYxIDIyLjgyMTIgMTguMTc2MUwyMi44MjEzIDE4LjE3NTdMMjIuODIxOCAxOC4xNzQ1TDIyLjgyMzQgMTguMTY5NkwyMi44MzAxIDE4LjE1MDVDMjIuODM1OSAxOC4xMzM2IDIyLjg0NDQgMTguMTA4NSAyMi44NTU1IDE4LjA3NkMyMi44Nzc1IDE4LjAxMDkgMjIuOTA5MyAxNy45MTU4IDIyLjk0ODMgMTcuNzk1NkMyMy4wMjY0IDE3LjU1NTQgMjMuMTMzNiAxNy4yMTQ5IDIzLjI0OTggMTYuODE0NkMyMy40ODIxIDE2LjAxMzkgMjMuNzUwNiAxNC45NzM3IDIzLjg5NSAxNC4wMTUxQzIzLjk2NzIgMTMuNTM1OCAyNC4wMDgzIDEzLjA3NzIgMjMuOTk4NSAxMi42NzkyQzIzLjk4ODcgMTIuMjgxIDIzLjkyNzggMTEuOTQ0NSAyMy43OTY5IDExLjcwODlDMjMuNzMxNSAxMS41OTExIDIzLjY0ODcgMTEuNDk4OCAyMy41NDYxIDExLjQzNjNDMjMuNDQzNiAxMS4zNzM5IDIzLjMyMDkgMTEuMzQxMSAyMy4xNzUyIDExLjM0MzFDMjIuODgzNSAxMS4zNDczIDIyLjUgMTEuNDkxMiAyMi4wMDQxIDExLjgxNjlDMTkuMDMxMSAxMy43NzQgMTguMzQ4NSAxNy4wMzQxIDE4LjE5NjEgMTguNTMxNUMxOC4xNTM4IDE4Ljk1MiAxOC40NTU4IDE5LjMyMyAxOC44NDA0IDE5LjMyM0gyMy40OTk5QzIzLjY1MDYgMTkuMzIzIDIzLjc1NDggMTkuMjEyOSAyMy43ODc2IDE5LjA3OThDMjMuODIwNSAxOC45NDY5IDIzLjc4MTYgMTguNzkzMSAyMy42NDc5IDE4LjcwNzVMMjIuODIxMiAxOC4xNzYxWk0yMi44MjEyIDE4LjE3NjFMMjIuODE5IDE4LjE4MjNMMjIuODI0NiAxOC4xODU4TDIzLjY0NzkgMTguNzA3NUwyMi44MjEyIDE4LjE3NjFaIiBmaWxsPSIjMzJEQTZEIi8+CiAgICA8cGF0aCBkPSJNMjIuODIxMiAxOC4xNzYxTDIyLjgyOSAxOC4xNzg4QzIyLjgyNDMgMTguMTc3MiAyMi44MjI0IDE4LjE3NjUgMjIuODIxNyAxOC4xNzYyQzIyLjgyMTIgMTguMTc2MSAyMi44MjEyIDE4LjE3NjEgMjIuODIxMiAxOC4xNzYxWk0yMi44MjEyIDE4LjE3NjFMMjIuODIxMyAxOC4xNzU3TDIyLjgyMTggMTguMTc0NUwyMi44MjM0IDE4LjE2OTZMMjIuODMwMSAxOC4xNTA1QzIyLjgzNTkgMTguMTMzNiAyMi44NDQ0IDE4LjEwODUgMjIuODU1NSAxOC4wNzZDMjIuODc3NSAxOC4wMTA5IDIyLjkwOTMgMTcuOTE1OCAyMi45NDgzIDE3Ljc5NTZDMjMuMDI2NCAxNy41NTU0IDIzLjEzMzYgMTcuMjE0OSAyMy4yNDk4IDE2LjgxNDZDMjMuNDgyMSAxNi4wMTM5IDIzLjc1MDYgMTQuOTczNyAyMy44OTUgMTQuMDE1MUMyMy45NjcyIDEzLjUzNTggMjQuMDA4MyAxMy4wNzcyIDIzLjk5ODUgMTIuNjc5MkMyMy45ODg3IDEyLjI4MSAyMy45Mjc4IDExLjk0NDUgMjMuNzk2OSAxMS43MDg5QzIzLjczMTUgMTEuNTkxMSAyMy42NDg3IDExLjQ5ODggMjMuNTQ2MSAxMS40MzYzQzIzLjQ0MzYgMTEuMzczOSAyMy4zMjA5IDExLjM0MTEgMjMuMTc1MiAxMS4zNDMxQzIyLjg4MzUgMTEuMzQ3MyAyMi41IDExLjQ5MTIgMjIuMDA0MSAxMS44MTY5QzE5LjAzMTEgMTMuNzc0IDE4LjM0ODUgMTcuMDM0MSAxOC4xOTYxIDE4LjUzMTVDMTguMTUzOCAxOC45NTIgMTguNDU1OCAxOS4zMjMgMTguODQwNCAxOS4zMjNIMjMuNDk5OUMyMy42NTA2IDE5LjMyMyAyMy43NTQ4IDE5LjIxMjkgMjMuNzg3NiAxOS4wNzk4QzIzLjgyMDUgMTguOTQ2OSAyMy43ODE2IDE4Ljc5MzEgMjMuNjQ3OSAxOC43MDc1TTIyLjgyMTIgMTguMTc2MUwyMy42NDc5IDE4LjcwNzVNMjIuODIxMiAxOC4xNzYxTDIyLjgxOSAxOC4xODIzTDIyLjgyNDYgMTguMTg1OEwyMy42NDc5IDE4LjcwNzUiIHN0cm9rZT0iIzEzOEQzRSIgc3Ryb2tlLXdpZHRoPSIwLjAxNjU2NyIvPgogICAgPHBhdGggZD0iTTYuODIxNzIgOC4yODg4MUM3LjQ4NDggOC4yODg4MSA4LjAyMjM1IDcuNzUxMjkgOC4wMjIzNSA3LjA4ODJDOC4wMjIzNSA2LjQyNTExIDcuNDg0OCA1Ljg4NzU3IDYuODIxNzIgNS44ODc1N0M2LjE1ODY0IDUuODg3NTcgNS42MjEwOSA2LjQyNTExIDUuNjIxMDkgNy4wODgyQzUuNjIxMDkgNy43NTEyOSA2LjE1ODY0IDguMjg4ODEgNi44MjE3MiA4LjI4ODgxWiIgZmlsbD0iIzA5MjUxMSIvPgogICAgPHBhdGggZD0iTTE3LjU1ODMgOC4yODg4MUMxOC4yMjE0IDguMjg4ODEgMTguNzU4OSA3Ljc1MTI5IDE4Ljc1ODkgNy4wODgyQzE4Ljc1ODkgNi40MjUxMSAxOC4yMjE0IDUuODg3NTcgMTcuNTU4MyA1Ljg4NzU3QzE2Ljg5NTIgNS44ODc1NyAxNi4zNTc3IDYuNDI1MTEgMTYuMzU3NyA3LjA4ODJDMTYuMzU3NyA3Ljc1MTI5IDE2Ljg5NTIgOC4yODg4MSAxNy41NTgzIDguMjg4ODFaIiBmaWxsPSIjMDkyNTExIi8+CiAgICA8cGF0aCBkPSJNMTUuNDI2MiAxMS45MTI1QzE1LjM4OTkgMTIuMzM0NSAxNS4yNzA5IDEyLjc0NTEgMTUuMDc1OSAxMy4xMjFDMTQuODgwOSAxMy40OTY5IDE0LjYxMzggMTMuODMwNiAxNC4yODk4IDE0LjEwMzNDMTMuOTY1OCAxNC4zNzYgMTMuNTkxMyAxNC41ODIxIDEzLjE4NzYgMTQuNzEwMUMxMi43ODQgMTQuODM4IDEyLjM1OTEgMTQuODg1MiAxMS45MzcyIDE0Ljg0ODlDMTEuNTE1MyAxNC44MTI2IDExLjEwNDYgMTQuNjkzNSAxMC43Mjg3IDE0LjQ5ODVDMTAuMzUyOSAxNC4zMDM2IDEwLjAxOTEgMTQuMDM2NCA5Ljc0NjM5IDEzLjcxMjRDOS40NzM3NiAxMy4zODg1IDkuMjY3NTYgMTMuMDEzOSA5LjEzOTY0IDEyLjYxMDNDOS4wMTE3MSAxMi4yMDY2IDguOTY0NTkgMTEuNzgxNyA5LjAwMDg4IDExLjM1OThMMTIuMjEzNiAxMS42MzYyTDE1LjQyNjIgMTEuOTEyNVoiIGZpbGw9IiMwOTI1MTEiLz4KICA8L2c+CiAgPGRlZnM+CiAgICA8Y2xpcFBhdGggaWQ9ImNsaXAwXzEwMzdfMTE2OSI+CiAgICAgIDxyZWN0IHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgZmlsbD0id2hpdGUiLz4KICAgIDwvY2xpcFBhdGg+CiAgPC9kZWZzPgo8L3N2Zz4=";

// node_modules/.pnpm/@getpara+cosmos-wallet-connectors@2.0.0-alpha.73_@cosmjs+amino@0.37.0_@cosmjs+encoding@_105e61b7335e19f95087e11f175d09d3/node_modules/@getpara/cosmos-wallet-connectors/dist/wallets/connectors/leap/leap.js
var leapWallet = () => {
  return {
    id: "leap",
    internalId: "LEAP",
    name: "Leap",
    iconUrl: icon2,
    isExtension: true,
    isMobile: isMobile() && true,
    downloadUrl: "https://www.leapwallet.io/download",
    grazType: x2.LEAP,
    grazMobileType: x2.WC_LEAP_MOBILE
  };
};

// node_modules/.pnpm/@getpara+cosmos-wallet-connectors@2.0.0-alpha.73_@cosmjs+amino@0.37.0_@cosmjs+encoding@_105e61b7335e19f95087e11f175d09d3/node_modules/@getpara/cosmos-wallet-connectors/dist/wallets/connectors/cosmostation/cosmostationIcon.js
var icon3 = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzMwNV8yKSI+CjxwYXRoIGQ9Ik0xNy4zNDI5IDIuNzE1ODJIOS42NDc3QzkuNDU1OTggMi43MTYgOS4yNjc2NyAyLjc2NjU0IDkuMTAxNjIgMi44NjIzOEM4LjkzNTU2IDIuOTU4MjIgOC43OTc2IDMuMDk1OTkgOC43MDE1MyAzLjI2MTkxTDQuODUzODkgOS45MjU2NkM0Ljc1NzY5IDEwLjA5MTYgNC43MDcwMyAxMC4yOCA0LjcwNzAzIDEwLjQ3MThDNC43MDcwMyAxMC42NjM1IDQuNzU3NjkgMTAuODUxOSA0Ljg1Mzg5IDExLjAxNzlMOC43MDE1MyAxNy42ODE2TDEwLjU5MzYgMTYuNTg5NUw3LjA2MzE4IDEwLjQ3MThMMTAuMjc5MiA0LjkwMDJIMTYuNzE0MUwyMC4yNDczIDExLjAxNzhMMjIuMTM5NCA5LjkyNTYyTDE4LjI4ODkgMy4yNjE5MUMxOC4xOTMxIDMuMDk1NzkgMTguMDU1MiAyLjk1Nzg1IDE3Ljg4OTIgMi44NjE5OEMxNy43MjMxIDIuNzY2MTEgMTcuNTM0NyAyLjcxNTcgMTcuMzQyOSAyLjcxNTgyWiIgZmlsbD0iIzlDNkNGRiIvPgo8cGF0aCBkPSJNMTUuMjc0OSA2LjMzNjkxTDEzLjM4MjggNy40MjkxTDE2LjkxNiAxMy41NDY4TDEzLjcgMTkuMTE4M0g3LjI2NTE2TDMuNzMxOTUgMTMuMDAwNkwxLjgzOTg0IDE0LjA5MjlMNS42ODc0OCAyMC43NTY2QzUuNzgzMzYgMjAuOTIyNyA1LjkyMTI3IDIxLjA2MDYgNi4wODczNCAyMS4xNTY0QzYuMjUzNDEgMjEuMjUyMyA2LjQ0MTc5IDIxLjMwMjggNi42MzM1NCAyMS4zMDI3SDE0LjMyODhDMTQuNTIwNSAyMS4zMDI1IDE0LjcwODggMjEuMjUyIDE0Ljg3NDkgMjEuMTU2MUMxNS4wNDA5IDIxLjA2MDMgMTUuMTc4OCAyMC45MjI1IDE1LjI3NDkgMjAuNzU2NkwxOS4xMjI1IDE0LjA5MjlDMTkuMjE4NyAxMy45MjcgMTkuMjY5NCAxMy43Mzg2IDE5LjI2OTQgMTMuNTQ2OEMxOS4yNjk0IDEzLjM1NSAxOS4yMTg3IDEzLjE2NjYgMTkuMTIyNSAxMy4wMDA3TDE1LjI3NDkgNi4zMzY5MVoiIGZpbGw9IiMwNUQyREQiLz4KPC9nPgo8ZGVmcz4KPGNsaXBQYXRoIGlkPSJjbGlwMF8zMDVfMiI+CjxyZWN0IHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgZmlsbD0id2hpdGUiLz4KPC9jbGlwUGF0aD4KPC9kZWZzPgo8L3N2Zz4K";

// node_modules/.pnpm/@getpara+cosmos-wallet-connectors@2.0.0-alpha.73_@cosmjs+amino@0.37.0_@cosmjs+encoding@_105e61b7335e19f95087e11f175d09d3/node_modules/@getpara/cosmos-wallet-connectors/dist/wallets/connectors/cosmostation/cosmostation.js
var cosmostationWallet = () => {
  return {
    id: "cosmostation",
    internalId: "COSMOSTATION",
    name: "Cosmostation",
    iconUrl: icon3,
    isExtension: true,
    isMobile: isMobile() && true,
    downloadUrl: "https://www.cosmostation.io/products/cosmostation_extension",
    grazType: x2.COSMOSTATION,
    grazMobileType: x2.WC_COSMOSTATION_MOBILE
  };
};

// node_modules/.pnpm/@getpara+cosmos-wallet-connectors@2.0.0-alpha.73_@cosmjs+amino@0.37.0_@cosmjs+encoding@_105e61b7335e19f95087e11f175d09d3/node_modules/@getpara/cosmos-wallet-connectors/dist/wallets/connectors/index.js
var allWallets = [keplrWallet, leapWallet, cosmostationWallet];
export {
  CosmosExternalWalletContext,
  ParaCosmosProvider,
  allWallets,
  cosmostationWallet,
  keplrWallet,
  leapWallet
};
//# sourceMappingURL=dist-ROQTMC4O.js.map
